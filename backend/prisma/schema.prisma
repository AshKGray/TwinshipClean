// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

// ============================================
// User Model
// ============================================
model User {
  id                       String    @id @default(uuid())
  email                    String    @unique
  emailNormalized          String    @unique @map("email_normalized")
  passwordHash             String    @map("password_hash")
  emailVerified            Boolean   @default(false) @map("email_verified")
  emailVerificationToken   String?   @unique @map("email_verification_token")
  emailVerificationExpires DateTime? @map("email_verification_expires")

  // Profile fields
  displayName String? @map("display_name")
  avatarUrl   String? @map("avatar_url")

  // Security fields
  failedLoginAttempts Int       @default(0) @map("failed_login_attempts")
  accountLockedUntil  DateTime? @map("account_locked_until")
  lastLoginAt         DateTime? @map("last_login_at")
  lastLoginIp         String?   @map("last_login_ip")

  // Timestamps
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  deletedAt DateTime? @map("deleted_at")

  // Relations
  refreshTokens      RefreshToken[]
  passwordResets     PasswordReset[]
  loginHistory       LoginHistory[]
  twinPairs1         TwinPair[]         @relation("TwinPair_User1")
  twinPairs2         TwinPair[]         @relation("TwinPair_User2")
  sentMessages       Message[]          @relation("MessageSender")
  receivedMessages   Message[]          @relation("MessageRecipient")
  messageReactions   MessageReaction[]  @relation("MessageReactions")
  presence           UserPresence?      @relation("UserPresence")

  @@index([emailNormalized])
  @@index([emailVerificationToken])
  @@index([deletedAt])
  @@map("users")
}

// ============================================
// Refresh Token Model
// ============================================
model RefreshToken {
  id              String    @id @default(uuid())
  token           String    @unique
  userId          String    @map("user_id")
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Token metadata
  deviceId        String?   @map("device_id")
  userAgent       String?   @map("user_agent")
  ipAddress       String?   @map("ip_address")
  
  // Security
  expiresAt       DateTime  @map("expires_at")
  revokedAt       DateTime? @map("revoked_at")
  revokedReason   String?   @map("revoked_reason") // logout, security, expired, replaced
  replacedByToken String?   @map("replaced_by_token")
  
  // Timestamps
  createdAt       DateTime  @default(now()) @map("created_at")
  lastUsedAt      DateTime? @map("last_used_at")

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@index([revokedAt])
  @@map("refresh_tokens")
}

// ============================================
// Password Reset Model
// ============================================
model PasswordReset {
  id        String    @id @default(uuid())
  userId    String    @map("user_id")
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String    @unique
  
  // Security
  expiresAt DateTime  @map("expires_at")
  usedAt    DateTime? @map("used_at")
  ipAddress String?   @map("ip_address")
  userAgent String?   @map("user_agent")  
  // Timestamps
  createdAt DateTime  @default(now()) @map("created_at")

  @@index([token])
  @@index([userId])
  @@index([expiresAt])
  @@map("password_resets")
}

// ============================================
// Login History Model
// ============================================
model LoginHistory {
  id               String   @id @default(uuid())
  userId           String?  @map("user_id")
  user             User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  email            String
  
  // Event details
  eventType        String   @map("event_type") // login_success, login_failed, logout, etc.
  success          Boolean
  failureReason    String?  @map("failure_reason") // invalid_password, account_locked, etc.
  
  // Metadata
  ipAddress        String?  @map("ip_address")
  userAgent        String?  @map("user_agent")
  deviceFingerprint String? @map("device_fingerprint")
  
  // Timestamp
  createdAt        DateTime @default(now()) @map("created_at")

  @@index([userId])
  @@index([email])
  @@index([createdAt])
  @@index([eventType])
  @@map("login_history")
}

// ============================================
// Twin Pair Model
// ============================================
model TwinPair {
  id          String    @id @default(uuid())
  user1Id     String    @map("user1_id")
  user1       User      @relation("TwinPair_User1", fields: [user1Id], references: [id], onDelete: Cascade)
  user2Id     String    @map("user2_id")
  user2       User      @relation("TwinPair_User2", fields: [user2Id], references: [id], onDelete: Cascade)
  
  // Pairing details
  pairingCode String?   @map("pairing_code")
  pairedAt    DateTime? @map("paired_at")
  pairType    String?   @map("pair_type") // identical, fraternal, other
  
  // Status
  status      String    @default("pending") // pending, active, inactive
  
  // Timestamps
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  messages    Message[]

  @@unique([user1Id, user2Id])
  @@index([user1Id])
  @@index([user2Id])
  @@index([pairingCode])
  @@index([status])
  @@map("twin_pairs")
}

// ============================================
// Message Model
// ============================================
model Message {
  id             String    @id @default(uuid())
  twinPairId     String    @map("twin_pair_id")
  twinPair       TwinPair  @relation(fields: [twinPairId], references: [id], onDelete: Cascade)

  // Message content
  senderId       String    @map("sender_id")
  sender         User      @relation("MessageSender", fields: [senderId], references: [id], onDelete: Cascade)
  recipientId    String    @map("recipient_id")
  recipient      User      @relation("MessageRecipient", fields: [recipientId], references: [id], onDelete: Cascade)

  content        String
  messageType    String    @default("text") @map("message_type") // text, image, voice, reaction
  accentColor    String?   @map("accent_color")

  // Message metadata
  originalMessageId String? @map("original_message_id") // For reactions/replies

  // Delivery status
  deliveredAt    DateTime? @map("delivered_at")
  readAt         DateTime? @map("read_at")

  // Offline queue support
  queuedAt       DateTime? @map("queued_at") // When message was queued offline
  syncedAt       DateTime? @map("synced_at") // When message was synced from offline queue

  // Timestamps
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")
  deletedAt      DateTime? @map("deleted_at") // Soft delete for retention policy

  // Relations
  reactions      MessageReaction[]

  @@index([twinPairId])
  @@index([senderId])
  @@index([recipientId])
  @@index([createdAt])
  @@index([deliveredAt])
  @@index([readAt])
  @@index([deletedAt])
  @@index([queuedAt])
  @@map("messages")
}

// ============================================
// Message Reaction Model
// ============================================
model MessageReaction {
  id        String   @id @default(uuid())
  messageId String   @map("message_id")
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  userId    String   @map("user_id")
  user      User     @relation("MessageReactions", fields: [userId], references: [id], onDelete: Cascade)

  emoji     String

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")

  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
  @@map("message_reactions")
}

// ============================================
// Message Queue Model (for offline support)
// ============================================
model MessageQueue {
  id             String    @id @default(uuid())
  twinPairId     String    @map("twin_pair_id")
  senderId       String    @map("sender_id")
  recipientId    String    @map("recipient_id")

  // Message data (JSON serialized)
  messageData    String    @map("message_data")
  messageType    String    @map("message_type") // send_message, typing_start, etc.

  // Queue metadata
  attempts       Int       @default(0)
  maxAttempts    Int       @default(3) @map("max_attempts")
  nextAttemptAt  DateTime? @map("next_attempt_at")

  // Status
  status         String    @default("pending") // pending, processing, delivered, failed, expired
  errorMessage   String?   @map("error_message")

  // Timestamps
  createdAt      DateTime  @default(now()) @map("created_at")
  processedAt    DateTime? @map("processed_at")
  expiresAt      DateTime  @map("expires_at")

  @@index([twinPairId])
  @@index([recipientId])
  @@index([status])
  @@index([nextAttemptAt])
  @@index([expiresAt])
  @@map("message_queue")
}

// ============================================
// User Presence Model
// ============================================
model UserPresence {
  id           String    @id @default(uuid())
  userId       String    @unique @map("user_id")
  user         User      @relation("UserPresence", fields: [userId], references: [id], onDelete: Cascade)

  status       String    @default("offline") // online, offline, away
  lastSeenAt   DateTime? @map("last_seen_at")
  deviceInfo   String?   @map("device_info") // JSON with device details

  // Timestamps
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")

  @@index([status])
  @@index([lastSeenAt])
  @@map("user_presence")
}

// ============================================
// Twin Profile Model (extended user profile)
// ============================================
model TwinProfile {
  id                       String    @id @default(uuid())
  userId                   String    @unique @map("user_id")

  // Personal details
  name                     String
  age                      Int
  gender                   String
  sexualOrientation        String?   @map("sexual_orientation")
  showSexualOrientation    Boolean   @default(false) @map("show_sexual_orientation")
  twinType                 String    @map("twin_type") // identical, fraternal, other
  otherTwinTypeDescription String?   @map("other_twin_type_description")
  twinDeceased             Boolean   @default(false) @map("twin_deceased")

  // Birth info
  birthDate                String    @map("birth_date")
  zodiacSign               String?   @map("zodiac_sign")
  placeOfBirth             String?   @map("place_of_birth")
  timeOfBirth              String?   @map("time_of_birth")

  // Profile customization
  profilePicture           String?   @map("profile_picture")
  accentColor              String    @default("neon-purple") @map("accent_color")

  // Timestamps
  createdAt                DateTime  @default(now()) @map("created_at")
  updatedAt                DateTime  @updatedAt @map("updated_at")

  @@index([userId])
  @@map("twin_profiles")
}

// ============================================
// Game Result Model
// ============================================
model GameResult {
  id           String    @id @default(uuid())
  userId       String    @map("user_id")
  twinPairId   String?   @map("twin_pair_id")

  // Game details
  gameType     String    @map("game_type") // cognitive_sync_maze, emotional_resonance, etc.
  score        Int
  twinScore    Int?      @map("twin_score")

  // Game-specific data (JSON)
  cognitiveData   String? @map("cognitive_data")
  emotionalData   String? @map("emotional_data")
  decisionData    String? @map("decision_data")
  duoData         String? @map("duo_data")
  insights        String? // JSON array of insights

  // Timestamps
  createdAt    DateTime  @default(now()) @map("created_at")

  @@index([userId])
  @@index([twinPairId])
  @@index([gameType])
  @@index([createdAt])
  @@map("game_results")
}

// ============================================
// Twincidence Model (Twin Moments/Synchronicities)
// ============================================
model Twincidence {
  id          String    @id @default(uuid())
  twinPairId  String    @map("twin_pair_id")
  createdBy   String?   @map("created_by") // userId who created it, null for auto-detected

  // Twincidence content
  title       String
  description String
  photos      String?   // JSON array of photo URLs (optional)

  // Event type and detection
  eventType   String    @map("event_type") // manual, simultaneous_twintuition, hr_sync, sleep_sync, etc.
  detectionMethod String? @map("detection_method") // on_device, server_side, user_reported

  // For simultaneous events (e.g., twintuition button)
  user1EventTime  DateTime? @map("user1_event_time")
  user2EventTime  DateTime? @map("user2_event_time")
  timeDifference  Int?      @map("time_difference") // Milliseconds between events

  // Event-specific data (JSON for flexibility)
  eventData       String?   @map("event_data") // JSON with event-specific details

  // Consent and sharing status
  sharedWithTwin  Boolean   @default(false) @map("shared_with_twin") // Whether visible to twin
  user1Consented  Boolean   @default(false) @map("user1_consented") // User1's share consent
  user2Consented  Boolean   @default(false) @map("user2_consented") // User2's share consent

  // Research data
  includedInResearch Boolean @default(false) @map("included_in_research")
  anonymizedData     String? @map("anonymized_data") // JSON with anonymized metrics

  // Metadata
  isSpecial   Boolean   @default(false) @map("is_special") // Highlight special moments
  severity    String?   // low, medium, high - for how significant the moment was

  // Timestamps
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  deletedAt   DateTime? @map("deleted_at") // Soft delete support

  @@index([twinPairId])
  @@index([eventType])
  @@index([createdAt])
  @@index([isSpecial])
  @@index([sharedWithTwin])
  @@index([deletedAt])
  @@map("twincidences")
}

// ============================================
// Twincidence Consent Model (Per-Event-Type Consent)
// ============================================
model TwincidenceConsent {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  eventType   String    @map("event_type") // simultaneous_twintuition, hr_sync, sleep_sync, etc.

  // Consent level: A, B, or C
  // A = anonymous_research_only
  // B = share_with_twin (requires dual consent)
  // C = no_collection
  consentLevel String   @map("consent_level") // A, B, C

  // Timestamps
  consentedAt DateTime  @default(now()) @map("consented_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")
  revokedAt   DateTime? @map("revoked_at")

  // Audit trail
  previousConsent String? @map("previous_consent") // Track consent changes

  @@unique([userId, eventType])
  @@index([userId])
  @@index([eventType])
  @@index([consentLevel])
  @@map("twincidence_consents")
}

// ============================================
// Event Type Catalog (Configuration for detectable events)
// ============================================
model EventTypeCatalog {
  id                String    @id @default(uuid())
  eventType         String    @unique @map("event_type")

  // Display information
  displayName       String    @map("display_name")
  description       String
  icon              String?   // Icon identifier
  category          String    // twintuition, health, activity, media, location, etc.

  // Technical configuration
  detectionEnabled  Boolean   @default(true) @map("detection_enabled")
  requiresHealthKit Boolean   @default(false) @map("requires_healthkit")
  requiresLocation  Boolean   @default(false) @map("requires_location")

  // Detection thresholds (JSON)
  thresholds        String?   // JSON with configurable thresholds

  // Research configuration
  researchEnabled   Boolean   @default(true) @map("research_enabled")
  minimumDataPoints Int       @default(1) @map("minimum_data_points")

  // Metadata
  isActive          Boolean   @default(true) @map("is_active")
  sortOrder         Int       @default(0) @map("sort_order")

  // Timestamps
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")

  @@index([category])
  @@index([isActive])
  @@index([sortOrder])
  @@map("event_type_catalog")
}

// ============================================
// Assessment Model
// ============================================
model Assessment {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")
  twinPairId      String?   @map("twin_pair_id")

  // Assessment details
  assessmentType  String    @map("assessment_type") // twin_connection, emotional_intelligence, etc.
  responses       String    // JSON with question IDs and responses
  results         String    // JSON with scores and insights

  // Metadata
  completedAt     DateTime? @map("completed_at")
  status          String    @default("in_progress") // in_progress, completed, abandoned

  // Timestamps
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  @@index([userId])
  @@index([twinPairId])
  @@index([assessmentType])
  @@index([createdAt])
  @@map("assessments")
}

// ============================================
// Twintuition Alert Model
// ============================================
model TwintuitionAlert {
  id          String    @id @default(uuid())
  userId      String    @map("user_id")
  twinPairId  String?   @map("twin_pair_id")

  // Alert content
  message     String
  type        String    // feeling, thought, action
  isRead      Boolean   @default(false) @map("is_read")

  // Timestamps
  createdAt   DateTime  @default(now()) @map("created_at")

  @@index([userId])
  @@index([twinPairId])
  @@index([isRead])
  @@index([createdAt])
  @@map("twintuition_alerts")
}

// ============================================
// Research Participation Model
// ============================================
model ResearchParticipation {
  id                      String    @id @default(uuid())
  userId                  String    @unique @map("user_id")

  // Consent details
  hasConsented            Boolean   @default(false) @map("has_consented")
  consentedAt             DateTime? @map("consented_at")
  consentVersion          String?   @map("consent_version")

  // Participation details
  hasActiveStudies        Boolean   @default(false) @map("has_active_studies")
  contributionsCount      Int       @default(0) @map("contributions_count")

  // Timestamps
  createdAt               DateTime  @default(now()) @map("created_at")
  updatedAt               DateTime  @updatedAt @map("updated_at")

  @@index([userId])
  @@map("research_participation")
}

// ============================================
// Invitation Model
// ============================================
model Invitation {
  id            String    @id @default(uuid())
  senderId      String    @map("sender_id")

  // Invitation details
  invitationCode String   @unique @map("invitation_code")
  recipientEmail String?  @map("recipient_email")
  recipientPhone String?  @map("recipient_phone")
  recipientName  String?  @map("recipient_name")

  // Status
  status        String    @default("pending") // pending, accepted, declined, expired
  acceptedAt    DateTime? @map("accepted_at")
  acceptedBy    String?   @map("accepted_by") // userId who accepted

  // Expiry
  expiresAt     DateTime  @map("expires_at")

  // Timestamps
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  @@index([senderId])
  @@index([invitationCode])
  @@index([recipientEmail])
  @@index([status])
  @@index([expiresAt])
  @@map("invitations")
}

// ============================================
// Stripe Customer Model
// ============================================
model StripeCustomer {
  id                  String    @id @default(uuid())
  userId              String    @unique @map("user_id")
  stripeCustomerId    String    @unique @map("stripe_customer_id")

  // Customer details
  email               String
  paymentMethodId     String?   @map("payment_method_id")

  // Timestamps
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  // Relations
  subscriptions       Subscription[]
  paymentIntents      PaymentIntent[]
  invoices            Invoice[]

  @@index([userId])
  @@index([stripeCustomerId])
  @@map("stripe_customers")
}

// ============================================
// Subscription Model
// ============================================
model Subscription {
  id                    String    @id @default(uuid())
  stripeCustomerId      String    @map("stripe_customer_id")
  customer              StripeCustomer @relation(fields: [stripeCustomerId], references: [stripeCustomerId], onDelete: Cascade)

  stripeSubscriptionId  String    @unique @map("stripe_subscription_id")
  stripePriceId         String    @map("stripe_price_id")
  stripeProductId       String    @map("stripe_product_id")

  // Subscription details
  status                String    // active, canceled, past_due, unpaid, trialing
  tier                  String    // basic, premium, etc.

  // Billing
  currentPeriodStart    DateTime  @map("current_period_start")
  currentPeriodEnd      DateTime  @map("current_period_end")
  cancelAtPeriodEnd     Boolean   @default(false) @map("cancel_at_period_end")
  canceledAt            DateTime? @map("canceled_at")
  trialStart            DateTime? @map("trial_start")
  trialEnd              DateTime? @map("trial_end")

  // RevenueCat sync
  revenueCatId          String?   @unique @map("revenuecat_id")
  lastSyncedAt          DateTime? @map("last_synced_at")

  // Timestamps
  createdAt             DateTime  @default(now()) @map("created_at")
  updatedAt             DateTime  @updatedAt @map("updated_at")

  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@index([status])
  @@map("subscriptions")
}

// ============================================
// Payment Intent Model
// ============================================
model PaymentIntent {
  id                      String    @id @default(uuid())
  stripeCustomerId        String    @map("stripe_customer_id")
  customer                StripeCustomer @relation(fields: [stripeCustomerId], references: [stripeCustomerId], onDelete: Cascade)

  stripePaymentIntentId   String    @unique @map("stripe_payment_intent_id")

  // Payment details
  amount                  Int       // Amount in cents
  currency                String    @default("usd")
  status                  String    // succeeded, processing, requires_payment_method, etc.

  // Metadata
  description             String?
  metadata                String?   // JSON

  // 3D Secure / SCA
  requiresAction          Boolean   @default(false) @map("requires_action")
  clientSecret            String?   @map("client_secret")

  // Timestamps
  createdAt               DateTime  @default(now()) @map("created_at")
  updatedAt               DateTime  @updatedAt @map("updated_at")

  @@index([stripeCustomerId])
  @@index([stripePaymentIntentId])
  @@index([status])
  @@map("payment_intents")
}

// ============================================
// Invoice Model
// ============================================
model Invoice {
  id                  String    @id @default(uuid())
  stripeCustomerId    String    @map("stripe_customer_id")
  customer            StripeCustomer @relation(fields: [stripeCustomerId], references: [stripeCustomerId], onDelete: Cascade)

  stripeInvoiceId     String    @unique @map("stripe_invoice_id")

  // Invoice details
  amount              Int       // Total in cents
  currency            String    @default("usd")
  status              String    // draft, open, paid, void, uncollectible

  // Billing period
  periodStart         DateTime  @map("period_start")
  periodEnd           DateTime  @map("period_end")

  // Payment
  paidAt              DateTime? @map("paid_at")
  dueDate             DateTime? @map("due_date")
  attemptCount        Int       @default(0) @map("attempt_count")

  // URLs
  hostedInvoiceUrl    String?   @map("hosted_invoice_url")
  invoicePdfUrl       String?   @map("invoice_pdf_url")

  // Timestamps
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  @@index([stripeCustomerId])
  @@index([stripeInvoiceId])
  @@index([status])
  @@map("invoices")
}

// ============================================
// Webhook Event Model
// ============================================
model WebhookEvent {
  id                String    @id @default(uuid())
  stripeEventId     String    @unique @map("stripe_event_id")

  // Event details
  eventType         String    @map("event_type")
  eventData         String    @map("event_data") // JSON

  // Processing
  processed         Boolean   @default(false)
  processedAt       DateTime? @map("processed_at")
  errorMessage      String?   @map("error_message")
  retryCount        Int       @default(0) @map("retry_count")

  // Timestamps
  createdAt         DateTime  @default(now()) @map("created_at")

  @@index([stripeEventId])
  @@index([eventType])
  @@index([processed])
  @@index([createdAt])
  @@map("webhook_events")
}

// SQLite doesn't support enums, so we'll use String constraints in the application layer