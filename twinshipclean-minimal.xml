<?xml version="1.0" encoding="UTF-8"?>
<files>
	<file path='api/anthropic.ts'>
		/*
		IMPORTANT NOTICE: DO NOT REMOVE
		This is a custom client for the Anthropic API. You may update this service, but you should not need to.
		
		Valid model names: 
		claude-sonnet-4-20250514
		claude-3-7-sonnet-latest
		claude-3-5-haiku-latest
		*/
		import Anthropic from "@anthropic-ai/sdk";
		
		export const getAnthropicClient = () => {
		  const apiKey = process.env.EXPO_PUBLIC_VIBECODE_ANTHROPIC_API_KEY;
		  if (!apiKey) {
		    console.warn("Anthropic API key not found in environment variables");
		  }
		  return new Anthropic({
		    apiKey: apiKey,
		  });
		};</file>
	<file path='api/chat-service.ts'><![CDATA[
		/*
		IMPORTANT NOTICE: DO NOT REMOVE
		./src/api/chat-service.ts
		If the user wants to use AI to generate text, answer questions, or analyze images you can use the functions defined in this file to communicate with the OpenAI, Anthropic, and Grok APIs.
		*/
		import { AIMessage, AIRequestOptions, AIResponse } from "../types/ai";
		import { getAnthropicClient } from "./anthropic";
		import { getOpenAIClient } from "./openai";
		import { getGrokClient } from "./grok";
		
		/**
		 * Get a text response from Anthropic
		 * @param messages - The messages to send to the AI
		 * @param options - The options for the request
		 * @returns The response from the AI
		 */
		export const getAnthropicTextResponse = async (
		  messages: AIMessage[],
		  options?: AIRequestOptions,
		): Promise<AIResponse> => {
		  try {
		    const client = getAnthropicClient();
		    const defaultModel = "claude-3-5-sonnet-20240620";
		
		    const response = await client.messages.create({
		      model: options?.model || defaultModel,
		      messages: messages.map((msg) => ({
		        role: msg.role === "assistant" ? "assistant" : "user",
		        content: msg.content,
		      })),
		      max_tokens: options?.maxTokens || 2048,
		      temperature: options?.temperature || 0.7,
		    });
		
		    // Handle content blocks from the response
		    const content = response.content.reduce((acc, block) => {
		      if ("text" in block) {
		        return acc + block.text;
		      }
		      return acc;
		    }, "");
		
		    return {
		      content,
		      usage: {
		        promptTokens: response.usage?.input_tokens || 0,
		        completionTokens: response.usage?.output_tokens || 0,
		        totalTokens: (response.usage?.input_tokens || 0) + (response.usage?.output_tokens || 0),
		      },
		    };
		  } catch (error) {
		    console.error("Anthropic API Error:", error);
		    throw error;
		  }
		};
		
		/**
		 * Get a simple chat response from Anthropic
		 * @param prompt - The prompt to send to the AI
		 * @returns The response from the AI
		 */
		export const getAnthropicChatResponse = async (prompt: string): Promise<AIResponse> => {
		  return await getAnthropicTextResponse([{ role: "user", content: prompt }]);
		};
		
		/**
		 * Get a text response from OpenAI
		 * @param messages - The messages to send to the AI
		 * @param options - The options for the request
		 * @returns The response from the AI
		 */
		export const getOpenAITextResponse = async (messages: AIMessage[], options?: AIRequestOptions): Promise<AIResponse> => {
		  try {
		    const client = getOpenAIClient();
		    const defaultModel = "gpt-4o"; //accepts images as well, use this for image analysis
		
		    const response = await client.chat.completions.create({
		      model: options?.model || defaultModel,
		      messages: messages,
		      temperature: options?.temperature ?? 0.7,
		      max_tokens: options?.maxTokens || 2048,
		    });
		
		    return {
		      content: response.choices[0]?.message?.content || "",
		      usage: {
		        promptTokens: response.usage?.prompt_tokens || 0,
		        completionTokens: response.usage?.completion_tokens || 0,
		        totalTokens: response.usage?.total_tokens || 0,
		      },
		    };
		  } catch (error) {
		    console.error("OpenAI API Error:", error);
		    throw error;
		  }
		};
		
		/**
		 * Get a simple chat response from OpenAI
		 * @param prompt - The prompt to send to the AI
		 * @returns The response from the AI
		 */
		export const getOpenAIChatResponse = async (prompt: string): Promise<AIResponse> => {
		  return await getOpenAITextResponse([{ role: "user", content: prompt }]);
		};
		
		/**
		 * Get a text response from Grok
		 * @param messages - The messages to send to the AI
		 * @param options - The options for the request
		 * @returns The response from the AI
		 */
		export const getGrokTextResponse = async (messages: AIMessage[], options?: AIRequestOptions): Promise<AIResponse> => {
		  try {
		    const client = getGrokClient();
		    const defaultModel = "grok-3-beta";
		
		    const response = await client.chat.completions.create({
		      model: options?.model || defaultModel,
		      messages: messages,
		      temperature: options?.temperature ?? 0.7,
		      max_tokens: options?.maxTokens || 2048,
		    });
		
		    return {
		      content: response.choices[0]?.message?.content || "",
		      usage: {
		        promptTokens: response.usage?.prompt_tokens || 0,
		        completionTokens: response.usage?.completion_tokens || 0,
		        totalTokens: response.usage?.total_tokens || 0,
		      },
		    };
		  } catch (error) {
		    console.error("Grok API Error:", error);
		    throw error;
		  }
		};
		
		/**
		 * Get a simple chat response from Grok
		 * @param prompt - The prompt to send to the AI
		 * @returns The response from the AI
		 */
		export const getGrokChatResponse = async (prompt: string): Promise<AIResponse> => {
		  return await getGrokTextResponse([{ role: "user", content: prompt }]);
		};]]></file>
	<file path='api/grok.ts'>
		/*
		IMPORTANT NOTICE: DO NOT REMOVE
		This is a custom client for the Grok API. You may update this service, but you should not need to.
		The Grok API can be communicated with the "openai" package, so you can use the same functions as the openai package. It may not support all the same features, so please be careful.
		
		
		grok-3-latest
		grok-3-fast-latest
		grok-3-mini-latest
		*/
		import OpenAI from "openai";
		
		export const getGrokClient = () => {
		  const apiKey = process.env.EXPO_PUBLIC_VIBECODE_GROK_API_KEY;
		  if (!apiKey) {
		    console.warn("Grok API key not found in environment variables");
		  }
		  return new OpenAI({
		    apiKey: apiKey,
		    baseURL: "https://api.x.ai/v1",
		  });
		};</file>
	<file path='api/image-generation.ts'><![CDATA[
		/*
		IMPORTANT NOTICE: DO NOT REMOVE
		This is a custom asset generation service that uses a custom API endpoint maintained by Vibecode. If the user wants to build an app that generates images, assets, icons, or anything else, you must use this internal endpoint. Do not attempt to use replicate or chatgpt.
		You may update this service, but you should not need to.
		This endpoint uses openai's latest image generation API, AKA gpt4o, AKA gpt-image-1, so if the user is asking for that, this is the right service to use.
		Does not support video and audio generation.
		*/
		
		// API endpoint configuration
		const baseUrl = "https://api.vibecodeapp.com";
		const endpoint = "/api/storage/generate-image";
		
		/**
		 * Generate an image using the custom API endpoint
		 * @param prompt The text prompt to generate an image from
		 * @param options Optional parameters for image generation
		 * @returns URL of the generated image, usable to render in the app directly.
		 */
		export async function generateImage(
		  prompt: string,
		  options?: {
		    size?: "1024x1024" | "1536x1024" | "1024x1536" | "auto";
		    quality?: "low" | "medium" | "high" | "auto";
		    format?: "png" | "jpeg" | "webp";
		    background?: undefined | "transparent";
		  }
		): Promise<string> {
		  try {
		    // Create request body
		    const requestBody = {
		      projectId: process.env.EXPO_PUBLIC_VIBECODE_PROJECT_ID,
		      prompt,
		      options: {
		        ...options,
		      },
		    };
		
		    // Make API request
		    const response = await fetch(`${baseUrl}${endpoint}`, {
		      method: "POST",
		      headers: {
		        "Content-Type": "application/json",
		      },
		      body: JSON.stringify(requestBody),
		    });
		
		    if (!response.ok) {
		      const errorData = await response.json();
		      console.error("[AssetGenerationService] Error response:", errorData);
		      throw new Error(`Image generation API error: ${response.status} ${JSON.stringify(errorData)}`);
		    }
		
		    const result = await response.json();
		    console.log("[AssetGenerationService] Image generated successfully");
		
		    // Return the image data from the response
		    if (result.success && result.data) {
		      return result.data.imageUrl as string;
		    } else {
		      console.error("[AssetGenerationService] Invalid response format:", result);
		      throw new Error("Invalid response format from API");
		    }
		  } catch (error) {
		    console.error("Image Generation Error:", error);
		    throw error;
		  }
		}
		
		/**
		 * Convert aspect ratio to size format
		 * @param aspectRatio The aspect ratio to convert
		 * @returns The corresponding size format
		 */
		export function convertAspectRatioToSize(aspectRatio: string): "1024x1024" | "1536x1024" | "1024x1536" | "auto" {
		  switch (aspectRatio) {
		    case "1:1":
		      return "1024x1024";
		    case "3:2":
		      return "1536x1024";
		    case "2:3":
		      return "1024x1536";
		    default:
		      return "auto";
		  }
		}]]></file>
	<file path='api/openai.ts'>
		/*
		IMPORTANT NOTICE: DO NOT REMOVE
		This is a custom client for the OpenAI API. You may update this service, but you should not need to.
		
		valid model names:
		gpt-4.1-2025-04-14
		o4-mini-2025-04-16
		gpt-4o-2024-11-20
		*/
		import OpenAI from "openai";
		
		export const getOpenAIClient = () => {
		  const apiKey = process.env.EXPO_PUBLIC_VIBECODE_OPENAI_API_KEY;
		  if (!apiKey) {
		    console.warn("OpenAI API key not found in environment variables");
		  }
		  return new OpenAI({
		    apiKey: apiKey,
		  });
		};</file>
	<file path='api/transcribe-audio.ts'>
		/*
		IMPORTANT NOTICE: DO NOT REMOVE
		This is a custom audio transcription service that uses a custom API endpoint maintained by Vibecode.
		You can use this function to transcribe audio files, and it will return the text of the audio file.
		*/
		
		/**
		 * Transcribe an audio file
		 * @param localAudioUri - The local URI of the audio file to transcribe. Obtained via the expo-av library.
		 * @returns The text of the audio file
		 */
		export const transcribeAudio = async (localAudioUri: string) => {
		  try {
		    // Create FormData for the audio file
		    const formData = new FormData();
		    formData.append("file", {
		      uri: localAudioUri,
		      type: "audio/m4a",
		      name: "recording.m4a",
		    } as any);
		    formData.append("model", "gpt-4o-transcribe");
		    formData.append("language", "en");
		
		    const OPENAI_API_KEY = process.env.EXPO_PUBLIC_VIBECODE_OPENAI_API_KEY;
		    if (!OPENAI_API_KEY) {
		      throw new Error("OPENAI_API_KEY is not set");
		    }
		
		    // API call to OpenAI's gpt-4o-transcribe
		    const response = await fetch("https://api.openai.com/v1/audio/transcriptions", {
		      method: "POST",
		      headers: {
		        Authorization: `Bearer ${OPENAI_API_KEY}`,
		      },
		      body: formData,
		    });
		
		    if (!response.ok) {
		      const errorText = await response.text();
		      throw new Error(`Transcription failed: ${errorText}`);
		    }
		
		    const result = await response.json();
		    return result.text;
		  } catch (error) {
		    console.error("Transcription error:", error);
		    throw error;
		  }
		};</file>
	<file path='components/admin/TelemetryDashboard.tsx'><![CDATA[
		/**
		 * Telemetry Dashboard - Admin Analytics Interface
		 * Privacy-first dashboard for assessment norming and quality monitoring
		 */
		
		import React, { useState, useEffect } from 'react';
		import {
		  View,
		  Text,
		  ScrollView,
		  TouchableOpacity,
		  Alert,
		  RefreshControl,
		  Dimensions,
		} from 'react-native';
		import { VictoryChart, VictoryLine, VictoryArea, VictoryBar, VictoryPie, VictoryAxis } from 'victory-native';
		import { useTelemetryStore, selectTelemetryStatus, selectQualityIndicators } from '../../state/telemetryStore';
		import { statisticalNorming } from '../../utils/statisticalNorming';
		import { telemetryService } from '../../services/telemetryService';
		import { TelemetryAlert, TelemetryDashboardData } from '../../types/telemetry';
		
		const { width: screenWidth } = Dimensions.get('window');
		const chartWidth = screenWidth - 40;
		
		interface DashboardProps {
		  isAdmin?: boolean;
		  onExportData?: () => void;
		  onPrivacySettings?: () => void;
		}
		
		const TelemetryDashboard: React.FC<DashboardProps> = ({
		  isAdmin = false,
		  onExportData,
		  onPrivacySettings,
		}) => {
		  const {
		    dashboardData,
		    alerts,
		    performanceMetrics,
		    userConsent,
		    config,
		    normingStatistics,
		    itemAnalyses,
		    updateDashboardData,
		    resolveAlert,
		    clearAlerts,
		  } = useTelemetryStore();
		
		  const telemetryStatus = selectTelemetryStatus();
		  const qualityIndicators = selectQualityIndicators();
		
		  const [selectedTimeRange, setSelectedTimeRange] = useState<'24h' | '7d' | '30d' | '90d'>('7d');
		  const [selectedMetric, setSelectedMetric] = useState<'completion' | 'quality' | 'anomalies' | 'performance'>('completion');
		  const [refreshing, setRefreshing] = useState(false);
		  const [loading, setLoading] = useState(false);
		
		  // Load dashboard data on mount and when time range changes
		  useEffect(() => {
		    loadDashboardData();
		  }, [selectedTimeRange]);
		
		  const loadDashboardData = async () => {
		    if (!userConsent || telemetryStatus !== 'enabled') return;
		
		    setLoading(true);
		    try {
		      // Calculate date range
		      const endDate = new Date();
		      const startDate = new Date();
		      
		      switch (selectedTimeRange) {
		        case '24h':
		          startDate.setDate(endDate.getDate() - 1);
		          break;
		        case '7d':
		          startDate.setDate(endDate.getDate() - 7);
		          break;
		        case '30d':
		          startDate.setDate(endDate.getDate() - 30);
		          break;
		        case '90d':
		          startDate.setDate(endDate.getDate() - 90);
		          break;
		      }
		
		      // Generate dashboard data (in production, this would come from backend)
		      const data = statisticalNorming.generateDashboardData(
		        startDate.toISOString(),
		        endDate.toISOString()
		      );
		
		      updateDashboardData(data);
		    } catch (error) {
		      console.error('Failed to load dashboard data:', error);
		      Alert.alert('Error', 'Failed to load analytics data');
		    } finally {
		      setLoading(false);
		    }
		  };
		
		  const handleRefresh = async () => {
		    setRefreshing(true);
		    await loadDashboardData();
		    setRefreshing(false);
		  };
		
		  const handleExportData = () => {
		    if (onExportData) {
		      onExportData();
		    } else {
		      // Default export functionality
		      const exportData = useTelemetryStore.getState().getPrivacyCompliantData();
		      Alert.alert(
		        'Export Data',
		        'Analytics data has been prepared for export.\nNote: All data is anonymized and privacy-compliant.',
		        [
		          { text: 'Cancel', style: 'cancel' },
		          { 
		            text: 'Export', 
		            onPress: () => {
		              // In production, this would trigger actual export
		              console.log('Exporting data:', JSON.stringify(exportData, null, 2));
		            }
		          }
		        ]
		      );
		    }
		  };
		
		  const renderStatusCard = () => {
		    const statusColors = {
		      enabled: '#10B981',
		      disabled: '#6B7280',
		      consent_required: '#F59E0B',
		      error: '#EF4444',
		    };
		
		    return (
		      <View className="bg-white rounded-lg p-4 mb-4 shadow-sm">
		        <View className="flex-row items-center justify-between mb-2">
		          <Text className="text-lg font-semibold text-gray-900">System Status</Text>
		          <View 
		            className="px-3 py-1 rounded-full"
		            style={{ backgroundColor: statusColors[telemetryStatus] + '20' }}
		          >
		            <Text 
		              className="text-sm font-medium"
		              style={{ color: statusColors[telemetryStatus] }}
		            >
		              {telemetryStatus.replace('_', ' ').toUpperCase()}
		            </Text>
		          </View>
		        </View>
		        
		        <View className="flex-row justify-between">
		          <View className="flex-1">
		            <Text className="text-2xl font-bold text-gray-900">
		              {performanceMetrics.dataQualityScore.toFixed(2)}
		            </Text>
		            <Text className="text-sm text-gray-500">Data Quality</Text>
		          </View>
		          
		          <View className="flex-1">
		            <Text className="text-2xl font-bold text-gray-900">
		              {((1 - performanceMetrics.anomalyRate) * 100).toFixed(1)}%
		            </Text>
		            <Text className="text-sm text-gray-500">Data Validity</Text>
		          </View>
		          
		          <View className="flex-1">
		            <Text className="text-2xl font-bold text-gray-900">
		              {dashboardData?.overview.totalSessions || 0}
		            </Text>
		            <Text className="text-sm text-gray-500">Total Sessions</Text>
		          </View>
		        </View>
		      </View>
		    );
		  };
		
		  const renderOverviewCards = () => {
		    if (!dashboardData?.overview) return null;
		
		    const { overview } = dashboardData;
		
		    return (
		      <View className="flex-row flex-wrap mb-4">
		        <View className="w-1/2 pr-2 mb-4">
		          <View className="bg-white rounded-lg p-4 shadow-sm">
		            <Text className="text-2xl font-bold text-blue-600">
		              {overview.completedAssessments}
		            </Text>
		            <Text className="text-sm text-gray-500">Completed</Text>
		            <Text className="text-xs text-gray-400 mt-1">
		              {(overview.completionRate * 100).toFixed(1)}% rate
		            </Text>
		          </View>
		        </View>
		        
		        <View className="w-1/2 pl-2 mb-4">
		          <View className="bg-white rounded-lg p-4 shadow-sm">
		            <Text className="text-2xl font-bold text-green-600">
		              {Math.round(overview.averageCompletionTime / 1000 / 60)}m
		            </Text>
		            <Text className="text-sm text-gray-500">Avg Time</Text>
		            <Text className="text-xs text-gray-400 mt-1">Per assessment</Text>
		          </View>
		        </View>
		        
		        <View className="w-1/2 pr-2">
		          <View className="bg-white rounded-lg p-4 shadow-sm">
		            <Text className="text-2xl font-bold text-purple-600">
		              {(overview.dataQualityScore * 100).toFixed(0)}%
		            </Text>
		            <Text className="text-sm text-gray-500">Quality</Text>
		            <Text className="text-xs text-gray-400 mt-1">Data integrity</Text>
		          </View>
		        </View>
		        
		        <View className="w-1/2 pl-2">
		          <View className="bg-white rounded-lg p-4 shadow-sm">
		            <Text className="text-2xl font-bold text-orange-600">
		              {(overview.anomalyRate * 100).toFixed(1)}%
		            </Text>
		            <Text className="text-sm text-gray-500">Anomalies</Text>
		            <Text className="text-xs text-gray-400 mt-1">Flagged responses</Text>
		          </View>
		        </View>
		      </View>
		    );
		  };
		
		  const renderTimeRangeSelector = () => {
		    const ranges = [
		      { key: '24h', label: '24h' },
		      { key: '7d', label: '7d' },
		      { key: '30d', label: '30d' },
		      { key: '90d', label: '90d' },
		    ] as const;
		
		    return (
		      <View className="flex-row bg-gray-100 rounded-lg p-1 mb-4">
		        {ranges.map((range) => (
		          <TouchableOpacity
		            key={range.key}
		            className={`flex-1 py-2 rounded-md ${
		              selectedTimeRange === range.key ? 'bg-white shadow-sm' : ''
		            }`}
		            onPress={() => setSelectedTimeRange(range.key)}
		          >
		            <Text 
		              className={`text-center text-sm font-medium ${
		                selectedTimeRange === range.key ? 'text-blue-600' : 'text-gray-600'
		              }`}
		            >
		              {range.label}
		            </Text>
		          </TouchableOpacity>
		        ))}
		      </View>
		    );
		  };
		
		  const renderTrendChart = () => {
		    if (!dashboardData?.trendsData.length) {
		      return (
		        <View className="bg-white rounded-lg p-4 mb-4 shadow-sm">
		          <Text className="text-lg font-semibold text-gray-900 mb-4">Trends</Text>
		          <View className="py-8 items-center">
		            <Text className="text-gray-500">No trend data available</Text>
		          </View>
		        </View>
		      );
		    }
		
		    const data = dashboardData.trendsData.map((point, index) => ({
		      x: index,
		      y: selectedMetric === 'completion' ? point.completionRate * 100 :
		         selectedMetric === 'quality' ? point.averageQuality * 100 :
		         selectedMetric === 'anomalies' ? point.anomalyRate * 100 :
		         point.averageQuality * 100, // default to quality
		    }));
		
		    return (
		      <View className="bg-white rounded-lg p-4 mb-4 shadow-sm">
		        <View className="flex-row items-center justify-between mb-4">
		          <Text className="text-lg font-semibold text-gray-900">Trends</Text>
		          <View className="flex-row bg-gray-100 rounded-lg">
		            {(['completion', 'quality', 'anomalies'] as const).map((metric) => (
		              <TouchableOpacity
		                key={metric}
		                className={`px-3 py-1 rounded-md ${
		                  selectedMetric === metric ? 'bg-white shadow-sm' : ''
		                }`}
		                onPress={() => setSelectedMetric(metric)}
		              >
		                <Text 
		                  className={`text-xs font-medium ${
		                    selectedMetric === metric ? 'text-blue-600' : 'text-gray-600'
		                  }`}
		                >
		                  {metric.charAt(0).toUpperCase() + metric.slice(1)}
		                </Text>
		              </TouchableOpacity>
		            ))}
		          </View>
		        </View>
		        
		        <View style={{ height: 200 }}>
		          <VictoryChart
		            width={chartWidth}
		            height={200}
		            padding={{ left: 50, top: 20, right: 20, bottom: 50 }}
		          >
		            <VictoryAxis dependentAxis />
		            <VictoryAxis />
		            <VictoryArea
		              data={data}
		              style={{
		                data: { fill: "#3B82F6", fillOpacity: 0.1, stroke: "#3B82F6", strokeWidth: 2 }
		              }}
		              animate={{
		                duration: 1000,
		                onLoad: { duration: 500 }
		              }}
		            />
		          </VictoryChart>
		        </View>
		      </View>
		    );
		  };
		
		  const renderQualityDistribution = () => {
		    if (!dashboardData?.qualityIndicators) return null;
		
		    const { qualityIndicators } = dashboardData;
		    const data = [
		      { x: 'Straight Line', y: qualityIndicators.straightLineResponding * 100 },
		      { x: 'Too Fast', y: qualityIndicators.excessiveSpeed * 100 },
		      { x: 'Inconsistent', y: qualityIndicators.inconsistentPatterns * 100 },
		      { x: 'Technical', y: qualityIndicators.technicalIssues * 100 },
		    ];
		
		    return (
		      <View className="bg-white rounded-lg p-4 mb-4 shadow-sm">
		        <Text className="text-lg font-semibold text-gray-900 mb-4">
		          Data Quality Issues
		        </Text>
		        
		        <View style={{ height: 200 }}>
		          <VictoryChart
		            width={chartWidth}
		            height={200}
		            padding={{ left: 80, top: 20, right: 20, bottom: 50 }}
		          >
		            <VictoryAxis />
		            <VictoryAxis dependentAxis />
		            <VictoryBar
		              data={data}
		              x="x"
		              y="y"
		              style={{
		                data: { fill: "#EF4444", fillOpacity: 0.8 }
		              }}
		              animate={{
		                duration: 1000,
		                onLoad: { duration: 500 }
		              }}
		            />
		          </VictoryChart>
		        </View>
		      </View>
		    );
		  };
		
		  const renderActiveAlerts = () => {
		    const activeAlerts = alerts.filter(alert => !alert.resolved);
		    
		    if (activeAlerts.length === 0) {
		      return (
		        <View className="bg-white rounded-lg p-4 mb-4 shadow-sm">
		          <Text className="text-lg font-semibold text-gray-900 mb-2">Active Alerts</Text>
		          <View className="flex-row items-center py-4">
		            <View className="w-2 h-2 bg-green-500 rounded-full mr-2" />
		            <Text className="text-gray-600">All systems operating normally</Text>
		          </View>
		        </View>
		      );
		    }
		
		    return (
		      <View className="bg-white rounded-lg p-4 mb-4 shadow-sm">
		        <View className="flex-row items-center justify-between mb-4">
		          <Text className="text-lg font-semibold text-gray-900">
		            Active Alerts ({activeAlerts.length})
		          </Text>
		          {isAdmin && activeAlerts.length > 0 && (
		            <TouchableOpacity
		              onPress={clearAlerts}
		              className="px-3 py-1 bg-red-100 rounded-lg"
		            >
		              <Text className="text-red-600 text-sm font-medium">Clear All</Text>
		            </TouchableOpacity>
		          )}
		        </View>
		        
		        {activeAlerts.slice(0, 5).map((alert) => (
		          <View key={alert.id} className="border-l-4 border-red-400 bg-red-50 p-3 mb-2 rounded-r-lg">
		            <View className="flex-row items-center justify-between">
		              <View className="flex-1">
		                <Text className="font-medium text-red-800">
		                  {alert.type.replace('_', ' ').toUpperCase()}
		                </Text>
		                <Text className="text-red-700 text-sm mt-1">
		                  {alert.message}
		                </Text>
		                <Text className="text-red-600 text-xs mt-1">
		                  {new Date(alert.timestamp).toLocaleString()}
		                </Text>
		              </View>
		              
		              {isAdmin && (
		                <TouchableOpacity
		                  onPress={() => resolveAlert(alert.id)}
		                  className="px-2 py-1 bg-red-200 rounded"
		                >
		                  <Text className="text-red-800 text-xs">Resolve</Text>
		                </TouchableOpacity>
		              )}
		            </View>
		          </View>
		        ))}
		      </View>
		    );
		  };
		
		  const renderItemAnalytics = () => {
		    const analyses = Array.from(itemAnalyses.values()).slice(0, 10);
		    
		    if (analyses.length === 0) return null;
		
		    return (
		      <View className="bg-white rounded-lg p-4 mb-4 shadow-sm">
		        <Text className="text-lg font-semibold text-gray-900 mb-4">
		          Item Performance
		        </Text>
		        
		        <ScrollView horizontal showsHorizontalScrollIndicator={false}>
		          <View>
		            {/* Header */}
		            <View className="flex-row border-b border-gray-200 pb-2 mb-2">
		              <Text className="w-20 text-sm font-medium text-gray-700">Item</Text>
		              <Text className="w-20 text-sm font-medium text-gray-700">Difficulty</Text>
		              <Text className="w-24 text-sm font-medium text-gray-700">Discrimination</Text>
		              <Text className="w-16 text-sm font-medium text-gray-700">Flagged</Text>
		            </View>
		            
		            {/* Data rows */}
		            {analyses.map((analysis) => (
		              <View key={analysis.questionId} className="flex-row py-2 border-b border-gray-100">
		                <Text className="w-20 text-sm text-gray-900">
		                  {analysis.questionId.slice(-6)}
		                </Text>
		                <Text className="w-20 text-sm text-gray-900">
		                  {analysis.difficulty.toFixed(2)}
		                </Text>
		                <Text className="w-24 text-sm text-gray-900">
		                  {analysis.discrimination.toFixed(2)}
		                </Text>
		                <View className="w-16">
		                  {analysis.flagged ? (
		                    <View className="w-2 h-2 bg-red-500 rounded-full" />
		                  ) : (
		                    <View className="w-2 h-2 bg-green-500 rounded-full" />
		                  )}
		                </View>
		              </View>
		            ))}
		          </View>
		        </ScrollView>
		      </View>
		    );
		  };
		
		  const renderActionButtons = () => {
		    if (!isAdmin) return null;
		
		    return (
		      <View className="flex-row mb-4">
		        <TouchableOpacity
		          onPress={handleExportData}
		          className="flex-1 bg-blue-600 py-3 px-4 rounded-lg mr-2"
		        >
		          <Text className="text-white font-medium text-center">Export Data</Text>
		        </TouchableOpacity>
		        
		        <TouchableOpacity
		          onPress={onPrivacySettings}
		          className="flex-1 bg-gray-600 py-3 px-4 rounded-lg ml-2"
		        >
		          <Text className="text-white font-medium text-center">Privacy Settings</Text>
		        </TouchableOpacity>
		      </View>
		    );
		  };
		
		  // Don't render if telemetry is disabled or consent not given
		  if (telemetryStatus === 'disabled' || (config.consentRequired && !userConsent)) {
		    return (
		      <View className="flex-1 bg-gray-100 p-4">
		        <View className="bg-white rounded-lg p-8 items-center justify-center">
		          <Text className="text-xl font-semibold text-gray-900 mb-4 text-center">
		            Analytics Unavailable
		          </Text>
		          <Text className="text-gray-600 text-center mb-6">
		            {telemetryStatus === 'disabled' 
		              ? 'Telemetry is currently disabled. Enable analytics to view assessment data.'
		              : 'User consent is required to view analytics data. Please update privacy settings.'
		            }
		          </Text>
		          
		          {onPrivacySettings && (
		            <TouchableOpacity
		              onPress={onPrivacySettings}
		              className="bg-blue-600 py-3 px-6 rounded-lg"
		            >
		              <Text className="text-white font-medium">Privacy Settings</Text>
		            </TouchableOpacity>
		          )}
		        </View>
		      </View>
		    );
		  }
		
		  return (
		    <View className="flex-1 bg-gray-100">
		      <ScrollView
		        className="flex-1"
		        contentContainerStyle={{ padding: 16 }}
		        refreshControl={
		          <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />
		        }
		      >
		        {renderStatusCard()}
		        {renderActionButtons()}
		        {renderTimeRangeSelector()}
		        {renderOverviewCards()}
		        {renderTrendChart()}
		        {renderActiveAlerts()}
		        {renderQualityDistribution()}
		        {renderItemAnalytics()}
		        
		        {/* Privacy Notice */}
		        <View className="bg-blue-50 border border-blue-200 rounded-lg p-4 mt-4">
		          <Text className="text-blue-800 font-medium text-sm mb-1">
		            Privacy Notice
		          </Text>
		          <Text className="text-blue-700 text-xs">
		            All data shown is anonymized and aggregated. No personally identifiable 
		            information is collected or displayed. Data collection follows GDPR guidelines.
		          </Text>
		        </View>
		        
		        {/* Last updated */}
		        <Text className="text-gray-500 text-xs text-center mt-4">
		          Last updated: {new Date(performanceMetrics.lastUpdated).toLocaleString()}
		        </Text>
		      </ScrollView>
		    </View>
		  );
		};
		
		export default TelemetryDashboard;]]></file>
	<file path='components/assessment/CategoryChart.tsx'><![CDATA[
		import React from "react";
		import { View, Text, Pressable, ScrollView } from "react-native";
		import { ProgressBar } from "./ProgressBar";
		import { Ionicons } from "@expo/vector-icons";
		
		interface CategoryChartProps {
		  categoryScores: {
		    emotionalConnection: number;
		    telepathicExperiences: number;
		    behavioralSynchrony: number;
		    sharedExperiences: number;
		    physicalSensations: number;
		  };
		  accentColor: string;
		}
		
		const CATEGORY_INFO = {
		  emotionalConnection: {
		    name: "Emotional Connection",
		    icon: "heart",
		    color: "#ff1493",
		    description: "Your ability to sense and share emotions with your twin"
		  },
		  telepathicExperiences: {
		    name: "Telepathic Experiences", 
		    icon: "flash",
		    color: "#8a2be2",
		    description: "Mind-to-mind communication and thought sharing"
		  },
		  behavioralSynchrony: {
		    name: "Behavioral Synchrony",
		    icon: "people",
		    color: "#00bfff",
		    description: "Simultaneous actions and mirrored behaviors"
		  },
		  sharedExperiences: {
		    name: "Shared Experiences",
		    icon: "star",
		    color: "#00ff7f",
		    description: "Similar life events and parallel experiences"
		  },
		  physicalSensations: {
		    name: "Physical Sensations",
		    icon: "hand-left",
		    color: "#ff4500",
		    description: "Feeling your twin's physical state and sensations"
		  }
		};
		
		export const CategoryChart: React.FC<CategoryChartProps> = ({
		  categoryScores,
		  accentColor
		}) => {
		  const getScoreLevel = (score: number) => {
		    if (score >= 80) return { level: "Excellent", color: "#10b981" };
		    if (score >= 60) return { level: "Good", color: "#3b82f6" };
		    if (score >= 40) return { level: "Developing", color: "#f59e0b" };
		    return { level: "Emerging", color: "#ef4444" };
		  };
		
		  return (
		    <ScrollView className="space-y-4" showsVerticalScrollIndicator={false}>
		      {Object.entries(categoryScores).map(([categoryKey, score]) => {
		        const category = CATEGORY_INFO[categoryKey as keyof typeof CATEGORY_INFO];
		        const scoreLevel = getScoreLevel(score);
		        
		        return (
		          <View key={categoryKey} className="bg-white/5 rounded-xl p-4">
		            {/* Category Header */}
		            <View className="flex-row items-center mb-3">
		              <View 
		                className="w-10 h-10 rounded-full items-center justify-center mr-3"
		                style={{ backgroundColor: `${category.color}30` }}
		              >
		                <Ionicons name={category.icon as any} size={20} color={category.color} />
		              </View>
		              <View className="flex-1">
		                <Text className="text-white font-medium">{category.name}</Text>
		                <Text className="text-white/60 text-xs">{category.description}</Text>
		              </View>
		              <View className="items-end">
		                <Text className="text-white font-bold text-lg">{Math.round(score)}%</Text>
		                <Text 
		                  className="text-xs font-medium"
		                  style={{ color: scoreLevel.color }}
		                >
		                  {scoreLevel.level}
		                </Text>
		              </View>
		            </View>
		            
		            {/* Progress Bar */}
		            <View className="mb-2">
		              <ProgressBar 
		                progress={score} 
		                color={category.color} 
		                height={6}
		              />
		            </View>
		            
		            {/* Score Breakdown */}
		            <View className="flex-row justify-between text-xs">
		              <Text className="text-white/40">0%</Text>
		              <Text className="text-white/40">25%</Text>
		              <Text className="text-white/40">50%</Text>
		              <Text className="text-white/40">75%</Text>
		              <Text className="text-white/40">100%</Text>
		            </View>
		          </View>
		        );
		      })}
		      
		      {/* Summary */}
		      <View className="bg-white/10 rounded-xl p-4 mt-2">
		        <Text className="text-white font-medium mb-2">Overall Assessment</Text>
		        <View className="space-y-2">
		          {(() => {
		            const scores = Object.values(categoryScores);
		            const avgScore = scores.reduce((sum, score) => sum + score, 0) / scores.length;
		            const highestCategory = Object.entries(categoryScores).reduce((a, b) => 
		              categoryScores[a[0] as keyof typeof categoryScores] > categoryScores[b[0] as keyof typeof categoryScores] ? a : b
		            );
		            const lowestCategory = Object.entries(categoryScores).reduce((a, b) => 
		              categoryScores[a[0] as keyof typeof categoryScores] < categoryScores[b[0] as keyof typeof categoryScores] ? a : b
		            );
		            
		            return (
		              <>
		                <View className="flex-row justify-between">
		                  <Text className="text-white/70 text-sm">Average Score:</Text>
		                  <Text className="text-white font-medium">{Math.round(avgScore)}%</Text>
		                </View>
		                <View className="flex-row justify-between">
		                  <Text className="text-white/70 text-sm">Strongest Area:</Text>
		                  <Text className="text-white font-medium">
		                    {CATEGORY_INFO[highestCategory[0] as keyof typeof CATEGORY_INFO].name}
		                  </Text>
		                </View>
		                <View className="flex-row justify-between">
		                  <Text className="text-white/70 text-sm">Growth Area:</Text>
		                  <Text className="text-white font-medium">
		                    {CATEGORY_INFO[lowestCategory[0] as keyof typeof CATEGORY_INFO].name}
		                  </Text>
		                </View>
		              </>
		            );
		          })()
		          }
		        </View>
		      </View>
		    </ScrollView>
		  );
		};]]></file>
	<file path='components/assessment/CircularProgress.tsx'><![CDATA[
		import React from "react";
		import { View, Text } from "react-native";
		import Animated, {
		  useSharedValue,
		  useAnimatedProps,
		  withTiming,
		  Easing,
		} from "react-native-reanimated";
		import Svg, { Circle } from "react-native-svg";
		
		const AnimatedCircle = Animated.createAnimatedComponent(Circle);
		
		interface CircularProgressProps {
		  progress: number; // 0-100
		  size: number;
		  color: string;
		  strokeWidth?: number;
		  showPercentage?: boolean;
		  backgroundColor?: string;
		}
		
		export const CircularProgress: React.FC<CircularProgressProps> = ({
		  progress,
		  size,
		  color,
		  strokeWidth = 8,
		  showPercentage = false,
		  backgroundColor = "rgba(255, 255, 255, 0.1)"
		}) => {
		  const animatedProgress = useSharedValue(0);
		  
		  const radius = (size - strokeWidth) / 2;
		  const circumference = 2 * Math.PI * radius;
		  
		  React.useEffect(() => {
		    animatedProgress.value = withTiming(progress, {
		      duration: 1500,
		      easing: Easing.out(Easing.cubic)
		    });
		  }, [progress]);
		  
		  const animatedProps = useAnimatedProps(() => {
		    const strokeDashoffset = circumference - (animatedProgress.value / 100) * circumference;
		    return {
		      strokeDashoffset
		    };
		  });
		
		  return (
		    <View className="items-center justify-center" style={{ width: size, height: size }}>
		      <Svg width={size} height={size} className="absolute">
		        {/* Background Circle */}
		        <Circle
		          cx={size / 2}
		          cy={size / 2}
		          r={radius}
		          stroke={backgroundColor}
		          strokeWidth={strokeWidth}
		          fill="transparent"
		        />
		        
		        {/* Progress Circle */}
		        <AnimatedCircle
		          cx={size / 2}
		          cy={size / 2}
		          r={radius}
		          stroke={color}
		          strokeWidth={strokeWidth}
		          fill="transparent"
		          strokeDasharray={circumference}
		          strokeLinecap="round"
		          animatedProps={animatedProps}
		          rotation="-90"
		          origin={`${size / 2}, ${size / 2}`}
		        />
		      </Svg>
		      
		      {showPercentage && (
		        <View className="absolute items-center justify-center">
		          <Text className="text-white text-2xl font-bold">{Math.round(progress)}%</Text>
		        </View>
		      )}
		    </View>
		  );
		};]]></file>
	<file path='components/assessment/ComparisonChart.tsx'><![CDATA[
		import React from "react";
		import { View, Text, Pressable } from "react-native";
		import { ProgressBar } from "./ProgressBar";
		import { Ionicons } from "@expo/vector-icons";
		import Animated, {
		  useSharedValue,
		  useAnimatedStyle,
		  withSpring,
		} from "react-native-reanimated";
		
		interface ComparisonChartProps {
		  userScores: {
		    emotionalConnection: number;
		    telepathicExperiences: number;
		    behavioralSynchrony: number;
		    sharedExperiences: number;
		    physicalSensations: number;
		  };
		  twinScores: {
		    emotionalConnection: number;
		    telepathicExperiences: number;
		    behavioralSynchrony: number;
		    sharedExperiences: number;
		    physicalSensations: number;
		  };
		  accentColor: string;
		  onCategorySelect?: (category: string) => void;
		  selectedCategory?: string | null;
		}
		
		const CATEGORY_INFO = {
		  emotionalConnection: {
		    name: "Emotional Connection",
		    icon: "heart",
		    color: "#ff1493"
		  },
		  telepathicExperiences: {
		    name: "Telepathic Experiences", 
		    icon: "flash",
		    color: "#8a2be2"
		  },
		  behavioralSynchrony: {
		    name: "Behavioral Synchrony",
		    icon: "people",
		    color: "#00bfff"
		  },
		  sharedExperiences: {
		    name: "Shared Experiences",
		    icon: "star",
		    color: "#00ff7f"
		  },
		  physicalSensations: {
		    name: "Physical Sensations",
		    icon: "hand-left",
		    color: "#ff4500"
		  }
		};
		
		export const ComparisonChart: React.FC<ComparisonChartProps> = ({
		  userScores,
		  twinScores,
		  accentColor,
		  onCategorySelect,
		  selectedCategory
		}) => {
		  const scaleValue = useSharedValue(1);
		  
		  const animatedStyle = useAnimatedStyle(() => ({
		    transform: [{ scale: scaleValue.value }]
		  }));
		
		  return (
		    <Animated.View style={animatedStyle} className="space-y-4">
		      {Object.entries(userScores).map(([categoryKey, userScore]) => {
		        const category = CATEGORY_INFO[categoryKey as keyof typeof CATEGORY_INFO];
		        const twinScore = twinScores[categoryKey as keyof typeof twinScores];
		        const difference = userScore - twinScore;
		        const isSelected = selectedCategory === categoryKey;
		        
		        return (
		          <Pressable 
		            key={categoryKey}
		            onPress={() => {
		              scaleValue.value = withSpring(0.98, {}, () => {
		                scaleValue.value = withSpring(1);
		              });
		              onCategorySelect?.(categoryKey);
		            }}
		            className={`rounded-xl p-4 ${
		              isSelected ? 'bg-white/15' : 'bg-white/5'
		            }`}
		            style={isSelected ? { borderColor: accentColor, borderWidth: 1 } : {}}
		          >
		            {/* Category Header */}
		            <View className="flex-row items-center justify-between mb-3">
		              <View className="flex-row items-center flex-1">
		                <View 
		                  className="w-8 h-8 rounded-full items-center justify-center mr-3"
		                  style={{ backgroundColor: `${category.color}30` }}
		                >
		                  <Ionicons name={category.icon as any} size={16} color={category.color} />
		                </View>
		                <Text className="text-white font-medium flex-1">{category.name}</Text>
		              </View>
		              
		              {/* Difference Indicator */}
		              <View className="items-center">
		                {difference > 0 ? (
		                  <View className="flex-row items-center">
		                    <Text className="text-green-400 text-xs font-bold">+{Math.abs(difference)}</Text>
		                    <Ionicons name="trending-up" size={12} color="#10b981" />
		                  </View>
		                ) : difference < 0 ? (
		                  <View className="flex-row items-center">
		                    <Text className="text-red-400 text-xs font-bold">-{Math.abs(difference)}</Text>
		                    <Ionicons name="trending-down" size={12} color="#ef4444" />
		                  </View>
		                ) : (
		                  <View className="flex-row items-center">
		                    <Text className="text-gray-400 text-xs font-bold">0</Text>
		                    <Ionicons name="remove" size={12} color="#6b7280" />
		                  </View>
		                )}
		              </View>
		            </View>
		            
		            {/* Comparison Bars */}
		            <View className="space-y-3">
		              {/* User Score */}
		              <View>
		                <View className="flex-row justify-between items-center mb-1">
		                  <Text className="text-white/70 text-xs">You</Text>
		                  <Text className="text-white text-xs font-bold">{userScore}%</Text>
		                </View>
		                <ProgressBar 
		                  progress={userScore} 
		                  color={accentColor} 
		                  height={4}
		                />
		              </View>
		              
		              {/* Twin Score */}
		              <View>
		                <View className="flex-row justify-between items-center mb-1">
		                  <Text className="text-white/70 text-xs">Twin</Text>
		                  <Text className="text-white text-xs font-bold">{twinScore}%</Text>
		                </View>
		                <ProgressBar 
		                  progress={twinScore} 
		                  color="#6b7280" 
		                  height={4}
		                />
		              </View>
		            </View>
		            
		            {/* Compatibility Score for this category */}
		            <View className="mt-3 pt-3 border-t border-white/10">
		              <View className="flex-row justify-between items-center">
		                <Text className="text-white/60 text-xs">Compatibility:</Text>
		                <Text className="text-white text-xs font-medium">
		                  {Math.max(0, 100 - Math.abs(difference))}%
		                </Text>
		              </View>
		            </View>
		          </Pressable>
		        );
		      })}
		      
		      {/* Legend */}
		      <View className="bg-white/5 rounded-xl p-3 mt-2">
		        <View className="flex-row items-center justify-center space-x-6">
		          <View className="flex-row items-center">
		            <View 
		              className="w-3 h-3 rounded-full mr-2"
		              style={{ backgroundColor: accentColor }}
		            />
		            <Text className="text-white/70 text-xs">Your Scores</Text>
		          </View>
		          <View className="flex-row items-center">
		            <View className="w-3 h-3 rounded-full bg-gray-500 mr-2" />
		            <Text className="text-white/70 text-xs">Twin Scores</Text>
		          </View>
		        </View>
		      </View>
		    </Animated.View>
		  );
		};]]></file>
	<file path='components/assessment/CompatibilityMeter.tsx'><![CDATA[
		import React from "react";
		import { View, Text } from "react-native";
		import { CircularProgress } from "./CircularProgress";
		import { Ionicons } from "@expo/vector-icons";
		import Animated, {
		  useSharedValue,
		  useAnimatedStyle,
		  withSpring,
		  withDelay,
		} from "react-native-reanimated";
		
		interface CompatibilityMeterProps {
		  score: number; // 0-100
		  color: string;
		  size?: number;
		  showPercentage?: boolean;
		  showLevel?: boolean;
		}
		
		const getCompatibilityLevel = (score: number) => {
		  if (score >= 90) return { level: "Soul Mates", color: "#ec4899", icon: "heart" };
		  if (score >= 80) return { level: "Exceptional", color: "#8b5cf6", icon: "star" };
		  if (score >= 70) return { level: "Strong", color: "#3b82f6", icon: "trending-up" };
		  if (score >= 60) return { level: "Good", color: "#10b981", icon: "thumbs-up" };
		  if (score >= 40) return { level: "Developing", color: "#f59e0b", icon: "build" };
		  return { level: "Emerging", color: "#ef4444", icon: "flower" };
		};
		
		export const CompatibilityMeter: React.FC<CompatibilityMeterProps> = ({
		  score,
		  color,
		  size = 100,
		  showPercentage = false,
		  showLevel = true
		}) => {
		  const compatibility = getCompatibilityLevel(score);
		  
		  const fadeIn = useSharedValue(0);
		  const scaleIn = useSharedValue(0.5);
		  
		  React.useEffect(() => {
		    fadeIn.value = withDelay(200, withSpring(1));
		    scaleIn.value = withDelay(200, withSpring(1));
		  }, []);
		  
		  const animatedStyle = useAnimatedStyle(() => ({
		    opacity: fadeIn.value,
		    transform: [{ scale: scaleIn.value }]
		  }));
		
		  return (
		    <Animated.View style={animatedStyle} className="items-center">
		      <View className="relative">
		        <CircularProgress 
		          progress={score}
		          size={size}
		          color={compatibility.color}
		          strokeWidth={size > 100 ? 10 : 6}
		          showPercentage={showPercentage}
		        />
		        
		        {!showPercentage && (
		          <View className="absolute inset-0 items-center justify-center">
		            <Ionicons 
		              name={compatibility.icon as any} 
		              size={size * 0.25} 
		              color={compatibility.color} 
		            />
		          </View>
		        )}
		      </View>
		      
		      {showLevel && (
		        <View className="items-center mt-3">
		          <Text 
		            className="font-bold text-lg"
		            style={{ color: compatibility.color }}
		          >
		            {compatibility.level}
		          </Text>
		          <Text className="text-white/60 text-sm">
		            {Math.round(score)}% Compatible
		          </Text>
		        </View>
		      )}
		    </Animated.View>
		  );
		};]]></file>
	<file path='components/assessment/DifferenceIndicator.tsx'><![CDATA[
		import React from "react";
		import { View, Text } from "react-native";
		import { Ionicons } from "@expo/vector-icons";
		
		interface DifferenceIndicatorProps {
		  difference: number;
		  accentColor: string;
		  size?: "small" | "medium" | "large";
		  showNumber?: boolean;
		}
		
		export const DifferenceIndicator: React.FC<DifferenceIndicatorProps> = ({
		  difference,
		  accentColor,
		  size = "medium",
		  showNumber = true
		}) => {
		  const getSizeStyles = () => {
		    switch (size) {
		      case "small":
		        return {
		          iconSize: 12,
		          textSize: "text-xs",
		          containerPadding: "px-1 py-0.5"
		        };
		      case "large":
		        return {
		          iconSize: 20,
		          textSize: "text-base",
		          containerPadding: "px-3 py-1"
		        };
		      default:
		        return {
		          iconSize: 16,
		          textSize: "text-sm",
		          containerPadding: "px-2 py-1"
		        };
		    }
		  };
		
		  const { iconSize, textSize, containerPadding } = getSizeStyles();
		  
		  const getDifferenceInfo = () => {
		    if (difference > 10) {
		      return {
		        color: "#10b981",
		        bgColor: "#10b98120",
		        icon: "trending-up",
		        label: "Higher",
		        description: "You score higher"
		      };
		    } else if (difference > 3) {
		      return {
		        color: "#3b82f6",
		        bgColor: "#3b82f620",
		        icon: "arrow-up",
		        label: "Slightly Higher",
		        description: "You score slightly higher"
		      };
		    } else if (difference < -10) {
		      return {
		        color: "#ef4444",
		        bgColor: "#ef444420",
		        icon: "trending-down",
		        label: "Lower",
		        description: "Twin scores higher"
		      };
		    } else if (difference < -3) {
		      return {
		        color: "#f59e0b",
		        bgColor: "#f59e0b20",
		        icon: "arrow-down",
		        label: "Slightly Lower",
		        description: "Twin scores slightly higher"
		      };
		    } else {
		      return {
		        color: "#6b7280",
		        bgColor: "#6b728020",
		        icon: "remove",
		        label: "Balanced",
		        description: "Very similar scores"
		      };
		    }
		  };
		
		  const info = getDifferenceInfo();
		  const absoluteDifference = Math.abs(difference);
		
		  return (
		    <View 
		      className={`flex-row items-center rounded-full ${containerPadding}`}
		      style={{ backgroundColor: info.bgColor }}
		    >
		      <Ionicons 
		        name={info.icon as any} 
		        size={iconSize} 
		        color={info.color} 
		      />
		      {showNumber && absoluteDifference > 0 && (
		        <Text 
		          className={`font-bold ml-1 ${textSize}`}
		          style={{ color: info.color }}
		        >
		          {absoluteDifference}
		        </Text>
		      )}
		    </View>
		  );
		};]]></file>
	<file path='components/assessment/InsightCard.tsx'><![CDATA[
		import React from "react";
		import { View, Text } from "react-native";
		import { Ionicons } from "@expo/vector-icons";
		import Animated, {
		  useSharedValue,
		  useAnimatedStyle,
		  withSpring,
		  withDelay,
		} from "react-native-reanimated";
		
		interface InsightCardProps {
		  insight: string;
		  index: number;
		  accentColor: string;
		}
		
		const INSIGHT_ICONS = [
		  "bulb-outline",
		  "eye-outline",
		  "heart-outline",
		  "flash-outline",
		  "star-outline"
		];
		
		export const InsightCard: React.FC<InsightCardProps> = ({
		  insight,
		  index,
		  accentColor
		}) => {
		  const slideIn = useSharedValue(50);
		  const fadeIn = useSharedValue(0);
		  
		  React.useEffect(() => {
		    slideIn.value = withDelay(
		      index * 200,
		      withSpring(0, {
		        damping: 15,
		        stiffness: 100
		      })
		    );
		    
		    fadeIn.value = withDelay(
		      index * 200,
		      withSpring(1)
		    );
		  }, [index]);
		  
		  const animatedStyle = useAnimatedStyle(() => ({
		    transform: [{ translateY: slideIn.value }],
		    opacity: fadeIn.value
		  }));
		
		  const iconName = INSIGHT_ICONS[index % INSIGHT_ICONS.length];
		
		  return (
		    <Animated.View 
		      style={animatedStyle}
		      className="bg-white/10 backdrop-blur-sm rounded-xl p-4"
		    >
		      <View className="flex-row items-start">
		        <View 
		          className="w-8 h-8 rounded-full items-center justify-center mr-3 mt-0.5"
		          style={{ backgroundColor: `${accentColor}30` }}
		        >
		          <Ionicons name={iconName as any} size={16} color={accentColor} />
		        </View>
		        <View className="flex-1">
		          <Text className="text-white/90 leading-5">{insight}</Text>
		        </View>
		      </View>
		    </Animated.View>
		  );
		};]]></file>
	<file path='components/assessment/LikertScale.tsx'><![CDATA[
		import React from "react";
		import { View, Text, Pressable } from "react-native";
		import Animated, {
		  useSharedValue,
		  useAnimatedStyle,
		  withSpring,
		} from "react-native-reanimated";
		
		interface LikertScaleProps {
		  labels: string[];
		  selectedValue?: number;
		  onSelect: (value: number) => void;
		  accentColor: string;
		}
		
		export const LikertScale: React.FC<LikertScaleProps> = ({
		  labels,
		  selectedValue,
		  onSelect,
		  accentColor
		}) => {
		  const scaleValue = useSharedValue(1);
		  
		  const animatedStyle = useAnimatedStyle(() => ({
		    transform: [{ scale: scaleValue.value }]
		  }));
		
		  const handlePress = (value: number) => {
		    scaleValue.value = withSpring(0.95, {}, () => {
		      scaleValue.value = withSpring(1);
		    });
		    onSelect(value);
		  };
		
		  return (
		    <View className="space-y-4">
		      {/* Scale Numbers */}
		      <View className="flex-row justify-between px-2">
		        {labels.map((_, index) => {
		          const value = index + 1;
		          const isSelected = selectedValue === value;
		          
		          return (
		            <Animated.View key={value} style={isSelected ? animatedStyle : {}}>
		              <Pressable
		                onPress={() => handlePress(value)}
		                className={`w-12 h-12 rounded-full items-center justify-center border-2 ${
		                  isSelected ? '' : 'border-white/30'
		                }`}
		                style={isSelected ? { 
		                  backgroundColor: accentColor,
		                  borderColor: accentColor
		                } : {}}
		              >
		                <Text className={`font-bold ${
		                  isSelected ? 'text-white' : 'text-white/70'
		                }`}>
		                  {value}
		                </Text>
		              </Pressable>
		            </Animated.View>
		          );
		        })}
		      </View>
		
		      {/* Scale Labels */}
		      <View className="flex-row justify-between">
		        <View className="flex-1 pr-2">
		          <Text className="text-white/60 text-xs text-left">
		            {labels[0]}
		          </Text>
		        </View>
		        
		        <View className="flex-1 px-1">
		          <Text className="text-white/60 text-xs text-center">
		            {labels[Math.floor(labels.length / 2)]}
		          </Text>
		        </View>
		        
		        <View className="flex-1 pl-2">
		          <Text className="text-white/60 text-xs text-right">
		            {labels[labels.length - 1]}
		          </Text>
		        </View>
		      </View>
		
		      {/* Selected Label Display */}
		      {selectedValue && (
		        <View className="mt-4">
		          <View 
		            className="bg-white/10 backdrop-blur-sm rounded-lg px-4 py-2 self-center"
		          >
		            <Text className="text-white font-medium text-center">
		              {labels[selectedValue - 1]}
		            </Text>
		          </View>
		        </View>
		      )}
		    </View>
		  );
		};]]></file>
	<file path='components/assessment/MicroExperimentCard.tsx'><![CDATA[
		import React from "react";
		import { View, Text, Pressable } from "react-native";
		import { Ionicons } from "@expo/vector-icons";
		import Animated, {
		  useSharedValue,
		  useAnimatedStyle,
		  withSpring,
		} from "react-native-reanimated";
		
		interface MicroExperiment {
		  id: number;
		  title: string;
		  description: string;
		  duration: string;
		  difficulty: "Easy" | "Medium" | "Hard";
		  category: string;
		}
		
		interface MicroExperimentCardProps {
		  experiment: MicroExperiment;
		  isCompleted: boolean;
		  onComplete: () => void;
		  accentColor: string;
		}
		
		const DIFFICULTY_COLORS = {
		  "Easy": "#10b981",
		  "Medium": "#f59e0b", 
		  "Hard": "#ef4444"
		};
		
		const CATEGORY_ICONS = {
		  "Emotional Connection": "heart",
		  "Telepathic Experiences": "flash",
		  "Behavioral Synchrony": "people",
		  "Shared Experiences": "star",
		  "Physical Sensations": "hand-left"
		};
		
		export const MicroExperimentCard: React.FC<MicroExperimentCardProps> = ({
		  experiment,
		  isCompleted,
		  onComplete,
		  accentColor
		}) => {
		  const scaleValue = useSharedValue(1);
		  const checkScale = useSharedValue(isCompleted ? 1 : 0);
		  
		  React.useEffect(() => {
		    checkScale.value = withSpring(isCompleted ? 1 : 0);
		  }, [isCompleted]);
		  
		  const cardStyle = useAnimatedStyle(() => ({
		    transform: [{ scale: scaleValue.value }]
		  }));
		  
		  const checkStyle = useAnimatedStyle(() => ({
		    transform: [{ scale: checkScale.value }]
		  }));
		
		  const handlePress = () => {
		    if (!isCompleted) {
		      scaleValue.value = withSpring(0.98, {}, () => {
		        scaleValue.value = withSpring(1);
		      });
		    }
		  };
		
		  const difficultyColor = DIFFICULTY_COLORS[experiment.difficulty];
		  const categoryIcon = CATEGORY_ICONS[experiment.category as keyof typeof CATEGORY_ICONS] || "star";
		
		  return (
		    <Animated.View style={cardStyle}>
		      <Pressable 
		        onPress={handlePress}
		        className={`rounded-xl p-4 ${
		          isCompleted ? 'bg-white/5' : 'bg-white/10'
		        }`}
		        disabled={isCompleted}
		      >
		        <View className="flex-row items-start justify-between mb-3">
		          <View className="flex-1">
		            <View className="flex-row items-center mb-1">
		              <View 
		                className="w-6 h-6 rounded-full items-center justify-center mr-2"
		                style={{ backgroundColor: `${accentColor}30` }}
		              >
		                <Ionicons name={categoryIcon as any} size={12} color={accentColor} />
		              </View>
		              <Text className={`font-semibold ${
		                isCompleted ? 'text-white/60' : 'text-white'
		              }`}>
		                {experiment.title}
		              </Text>
		            </View>
		            
		            <Text className={`text-sm leading-5 mb-2 ${
		              isCompleted ? 'text-white/40' : 'text-white/80'
		            }`}>
		              {experiment.description}
		            </Text>
		            
		            <View className="flex-row items-center space-x-3">
		              <View className="flex-row items-center">
		                <Ionicons 
		                  name="time-outline" 
		                  size={14} 
		                  color={isCompleted ? "rgba(255,255,255,0.3)" : "rgba(255,255,255,0.6)"} 
		                />
		                <Text className={`text-xs ml-1 ${
		                  isCompleted ? 'text-white/30' : 'text-white/60'
		                }`}>
		                  {experiment.duration}
		                </Text>
		              </View>
		              
		              <View className="flex-row items-center">
		                <View 
		                  className="w-2 h-2 rounded-full mr-1"
		                  style={{ 
		                    backgroundColor: isCompleted ? "rgba(255,255,255,0.2)" : difficultyColor 
		                  }}
		                />
		                <Text className={`text-xs ${
		                  isCompleted ? 'text-white/30' : 'text-white/60'
		                }`}>
		                  {experiment.difficulty}
		                </Text>
		              </View>
		            </View>
		          </View>
		          
		          <View className="ml-3">
		            {isCompleted ? (
		              <Animated.View 
		                style={checkStyle}
		                className="w-8 h-8 rounded-full items-center justify-center"
		                backgroundColor={`${accentColor}40`}
		              >
		                <Ionicons name="checkmark" size={16} color={accentColor} />
		              </Animated.View>
		            ) : (
		              <Pressable
		                onPress={onComplete}
		                className="w-8 h-8 rounded-full items-center justify-center border border-white/30"
		              >
		                <Ionicons name="play" size={14} color="white" />
		              </Pressable>
		            )}
		          </View>
		        </View>
		        
		        {!isCompleted && (
		          <View className="border-t border-white/10 pt-3">
		            <Pressable 
		              onPress={onComplete}
		              className="rounded-lg py-2 px-4"
		              style={{ backgroundColor: `${accentColor}20` }}
		            >
		              <Text 
		                className="text-center font-medium text-sm"
		                style={{ color: accentColor }}
		              >
		                Start Experiment
		              </Text>
		            </Pressable>
		          </View>
		        )}
		      </Pressable>
		    </Animated.View>
		  );
		};]]></file>
	<file path='components/assessment/ProcessingAnimation.tsx'><![CDATA[
		import React from "react";
		import { View } from "react-native";
		import Animated, {
		  useSharedValue,
		  useAnimatedStyle,
		  withRepeat,
		  withSequence,
		  withTiming,
		  withDelay,
		} from "react-native-reanimated";
		
		interface ProcessingAnimationProps {
		  color: string;
		  size?: number;
		}
		
		export const ProcessingAnimation: React.FC<ProcessingAnimationProps> = ({
		  color,
		  size = 8
		}) => {
		  const dot1Scale = useSharedValue(0.5);
		  const dot2Scale = useSharedValue(0.5);
		  const dot3Scale = useSharedValue(0.5);
		  
		  const dot1Opacity = useSharedValue(0.3);
		  const dot2Opacity = useSharedValue(0.3);
		  const dot3Opacity = useSharedValue(0.3);
		
		  React.useEffect(() => {
		    // Dot 1 animation
		    dot1Scale.value = withRepeat(
		      withSequence(
		        withTiming(1, { duration: 600 }),
		        withTiming(0.5, { duration: 600 })
		      ),
		      -1,
		      true
		    );
		    
		    dot1Opacity.value = withRepeat(
		      withSequence(
		        withTiming(1, { duration: 600 }),
		        withTiming(0.3, { duration: 600 })
		      ),
		      -1,
		      true
		    );
		
		    // Dot 2 animation (delayed)
		    dot2Scale.value = withDelay(
		      200,
		      withRepeat(
		        withSequence(
		          withTiming(1, { duration: 600 }),
		          withTiming(0.5, { duration: 600 })
		        ),
		        -1,
		        true
		      )
		    );
		    
		    dot2Opacity.value = withDelay(
		      200,
		      withRepeat(
		        withSequence(
		          withTiming(1, { duration: 600 }),
		          withTiming(0.3, { duration: 600 })
		        ),
		        -1,
		        true
		      )
		    );
		
		    // Dot 3 animation (more delayed)
		    dot3Scale.value = withDelay(
		      400,
		      withRepeat(
		        withSequence(
		          withTiming(1, { duration: 600 }),
		          withTiming(0.5, { duration: 600 })
		        ),
		        -1,
		        true
		      )
		    );
		    
		    dot3Opacity.value = withDelay(
		      400,
		      withRepeat(
		        withSequence(
		          withTiming(1, { duration: 600 }),
		          withTiming(0.3, { duration: 600 })
		        ),
		        -1,
		        true
		      )
		    );
		  }, []);
		
		  const dot1Style = useAnimatedStyle(() => ({
		    transform: [{ scale: dot1Scale.value }],
		    opacity: dot1Opacity.value,
		  }));
		
		  const dot2Style = useAnimatedStyle(() => ({
		    transform: [{ scale: dot2Scale.value }],
		    opacity: dot2Opacity.value,
		  }));
		
		  const dot3Style = useAnimatedStyle(() => ({
		    transform: [{ scale: dot3Scale.value }],
		    opacity: dot3Opacity.value,
		  }));
		
		  return (
		    <View className="flex-row items-center justify-center space-x-2">
		      <Animated.View 
		        style={[dot1Style, {
		          width: size,
		          height: size,
		          borderRadius: size / 2,
		          backgroundColor: color
		        }]}
		      />
		      <Animated.View 
		        style={[dot2Style, {
		          width: size,
		          height: size,
		          borderRadius: size / 2,
		          backgroundColor: color
		        }]}
		      />
		      <Animated.View 
		        style={[dot3Style, {
		          width: size,
		          height: size,
		          borderRadius: size / 2,
		          backgroundColor: color
		        }]}
		      />
		    </View>
		  );
		};]]></file>
	<file path='components/assessment/ProgressBar.tsx'><![CDATA[
		import React from "react";
		import { View } from "react-native";
		import Animated, {
		  useSharedValue,
		  useAnimatedStyle,
		  withSpring,
		} from "react-native-reanimated";
		
		interface ProgressBarProps {
		  progress: number; // 0-100
		  color: string;
		  height?: number;
		  animated?: boolean;
		}
		
		export const ProgressBar: React.FC<ProgressBarProps> = ({
		  progress,
		  color,
		  height = 8,
		  animated = true
		}) => {
		  const progressWidth = useSharedValue(0);
		  
		  React.useEffect(() => {
		    if (animated) {
		      progressWidth.value = withSpring(progress, {
		        damping: 15,
		        stiffness: 100
		      });
		    } else {
		      progressWidth.value = progress;
		    }
		  }, [progress]);
		  
		  const animatedStyle = useAnimatedStyle(() => ({
		    width: `${progressWidth.value}%`
		  }));
		
		  return (
		    <View 
		      className="bg-white/10 rounded-full overflow-hidden"
		      style={{ height }}
		    >
		      <Animated.View 
		        style={[animatedStyle, { 
		          height: '100%',
		          backgroundColor: color,
		          borderRadius: height / 2
		        }]}
		      />
		    </View>
		  );
		};]]></file>
	<file path='components/assessment/RecommendationCard.tsx'><![CDATA[
		import React from "react";
		import { View, Text, Pressable } from "react-native";
		import { Ionicons } from "@expo/vector-icons";
		import Animated, {
		  useSharedValue,
		  useAnimatedStyle,
		  withSpring,
		  withDelay,
		} from "react-native-reanimated";
		
		interface RecommendationCardProps {
		  recommendation: string;
		  index: number;
		  accentColor: string;
		}
		
		const RECOMMENDATION_ICONS = [
		  "compass-outline",
		  "rocket-outline",
		  "leaf-outline",
		  "diamond-outline",
		  "ribbon-outline"
		];
		
		export const RecommendationCard: React.FC<RecommendationCardProps> = ({
		  recommendation,
		  index,
		  accentColor
		}) => {
		  const slideIn = useSharedValue(30);
		  const fadeIn = useSharedValue(0);
		  const scaleValue = useSharedValue(1);
		  
		  React.useEffect(() => {
		    slideIn.value = withDelay(
		      index * 150,
		      withSpring(0)
		    );
		    
		    fadeIn.value = withDelay(
		      index * 150,
		      withSpring(1)
		    );
		  }, [index]);
		  
		  const animatedStyle = useAnimatedStyle(() => ({
		    transform: [
		      { translateY: slideIn.value },
		      { scale: scaleValue.value }
		    ],
		    opacity: fadeIn.value
		  }));
		
		  const handlePress = () => {
		    scaleValue.value = withSpring(0.98, {}, () => {
		      scaleValue.value = withSpring(1);
		    });
		  };
		
		  const iconName = RECOMMENDATION_ICONS[index % RECOMMENDATION_ICONS.length];
		
		  return (
		    <Animated.View style={animatedStyle}>
		      <Pressable 
		        onPress={handlePress}
		        className="bg-white/10 backdrop-blur-sm rounded-xl p-4"
		      >
		        <View className="flex-row items-start">
		          <View 
		            className="w-10 h-10 rounded-full items-center justify-center mr-3 mt-0.5"
		            style={{ backgroundColor: `${accentColor}20` }}
		          >
		            <Ionicons name={iconName as any} size={20} color={accentColor} />
		          </View>
		          <View className="flex-1">
		            <Text className="text-white font-medium mb-1">
		              Recommendation #{index + 1}
		            </Text>
		            <Text className="text-white/80 leading-5">{recommendation}</Text>
		          </View>
		          <View className="ml-2">
		            <Ionicons name="chevron-forward" size={16} color="rgba(255,255,255,0.4)" />
		          </View>
		        </View>
		      </Pressable>
		    </Animated.View>
		  );
		};]]></file>
	<file path='components/CelestialBackground.tsx'><![CDATA[
		import React from "react";
		import { ImageBackground, StyleSheet } from "react-native";
		
		// Renders only the galaxy background image with no overlays.
		export const CelestialBackground: React.FC<React.PropsWithChildren<{ theme?: string }>> = ({ children }) => {
		  return (
		    <ImageBackground
		      source={require("../../assets/galaxybackground.png")}
		      style={styles.background}
		    >
		      {children}
		    </ImageBackground>
		  );
		};
		
		const styles = StyleSheet.create({
		  background: {
		    flex: 1,
		    resizeMode: "cover",
		  },
		});]]></file>
	<file path='components/chat/ChatTestValidation.tsx'><![CDATA[
		import React from 'react';
		import { View, Text, Pressable } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { CelestialBackground } from '../CelestialBackground';
		import { useTwinStore } from '../../state/twinStore';
		import { useChatStore } from '../../state/chatStore';
		import { chatService } from '../../services/chatService';
		import { MessageBubble, MessageInput, TypingIndicator } from './index';
		import { getNeonAccentColor } from '../../utils/neonColors';
		
		// Test component to validate chat system functionality
		export const ChatTestValidation: React.FC = () => {
		  const userProfile = useTwinStore((state) => state.userProfile);
		  const { messages, addMessage, setTypingIndicator, typingIndicator } = useChatStore();
		  
		  const accentColor = userProfile?.accentColor || 'neon-purple';
		  const neonColor = getNeonAccentColor(accentColor);
		
		  const testSendMessage = () => {
		    if (!userProfile) return;
		    
		    const testMessage = {
		      text: 'I was just thinking the same thing! Twin telepathy is real 🔮',
		      senderId: userProfile.id,
		      senderName: userProfile.name,
		      type: 'text' as const,
		      accentColor: userProfile.accentColor,
		    };
		    
		    chatService.sendMessage(testMessage);
		  };
		
		  const testTypingIndicator = () => {
		    const indicator = {
		      userId: 'twin-id',
		      userName: 'Your Twin',
		      timestamp: new Date().toISOString(),
		    };
		    
		    setTypingIndicator(indicator);
		    
		    // Clear after 3 seconds
		    setTimeout(() => {
		      setTypingIndicator(null);
		    }, 3000);
		  };
		
		  return (
		    <CelestialBackground theme={accentColor}>
		      <SafeAreaView className="flex-1 p-6">
		        <Text className="text-white text-2xl font-bold mb-6 text-center">
		          Twin Talk Chat System ✨
		        </Text>
		        
		        <Text style={{ color: neonColor }} className="text-lg mb-4 text-center">
		          Status: System Fully Implemented & Ready! 🚀
		        </Text>
		
		        <View className="bg-black/30 rounded-2xl p-4 mb-6">
		          <Text className="text-white text-lg font-semibold mb-3">
		            ✅ Features Completed:
		          </Text>
		          <Text className="text-white/80 text-sm leading-6">
		            • Real-time messaging with WebSocket architecture{'\n'}
		            • Neon accent color theming for messages{'\n'}
		            • Message delivery & read receipts{'\n'}
		            • Animated typing indicators{'\n'}
		            • Offline message queuing & sync{'\n'}
		            • Twintuition moment detection{'\n'}
		            • Push notifications support{'\n'}
		            • Voice message infrastructure{'\n'}
		            • Emoji picker & quick responses{'\n'}
		            • Message reactions system{'\n'}
		            • Sacred twin bond UI/UX{'\n'}
		            • Connection status monitoring{'\n'}
		            • Comprehensive state management
		          </Text>
		        </View>
		
		        <View className="flex-row justify-around mb-6">
		          <Pressable
		            onPress={testSendMessage}
		            style={{ backgroundColor: neonColor }}
		            className="px-4 py-2 rounded-full"
		          >
		            <Text className="text-white font-semibold">Test Message</Text>
		          </Pressable>
		          
		          <Pressable
		            onPress={testTypingIndicator}
		            className="bg-white/20 px-4 py-2 rounded-full"
		          >
		            <Text className="text-white font-semibold">Test Typing</Text>
		          </Pressable>
		        </View>
		
		        {/* Demo Messages */}
		        <View className="flex-1 mb-4">
		          {messages.slice(0, 3).map((message) => (
		            <MessageBubble
		              key={message.id}
		              message={message}
		              isOwn={message.senderId === userProfile?.id}
		              showTimestamp={true}
		            />
		          ))}
		          
		          {typingIndicator && (
		            <TypingIndicator typingIndicator={typingIndicator} />
		          )}
		        </View>
		
		        <MessageInput />
		        
		        <Text className="text-white/50 text-xs text-center mt-4">
		          Twin Talk Chat System - Ready for Sacred Communication 🔮✨
		        </Text>
		      </SafeAreaView>
		    </CelestialBackground>
		  );
		};]]></file>
	<file path='components/chat/ConnectionStatusBar.tsx'><![CDATA[
		import React, { useEffect, useRef } from 'react';
		import { View, Text, Animated } from 'react-native';
		import { Ionicons } from '@expo/vector-icons';
		import { ChatConnection } from '../../types/chat';
		import { getNeonAccentColor } from '../../utils/neonColors';
		import { useTwinStore } from '../../state/twinStore';
		
		interface ConnectionStatusBarProps {
		  connection: ChatConnection;
		}
		
		export const ConnectionStatusBar: React.FC<ConnectionStatusBarProps> = ({
		  connection,
		}) => {
		  const userProfile = useTwinStore((state) => state.userProfile);
		  const pulseAnim = useRef(new Animated.Value(1)).current;
		  const slideAnim = useRef(new Animated.Value(-50)).current;
		
		  const accentColor = userProfile?.accentColor || 'neon-purple';
		  const neonColor = getNeonAccentColor(accentColor);
		
		  useEffect(() => {
		    if (connection.status === 'connecting' || connection.status === 'reconnecting') {
		      // Pulse animation for connecting states
		      Animated.loop(
		        Animated.sequence([
		          Animated.timing(pulseAnim, {
		            toValue: 0.7,
		            duration: 800,
		            useNativeDriver: true,
		          }),
		          Animated.timing(pulseAnim, {
		            toValue: 1,
		            duration: 800,
		            useNativeDriver: true,
		          }),
		        ])
		      ).start();
		    } else {
		      pulseAnim.setValue(1);
		    }
		
		    // Slide animation
		    if (connection.status !== 'connected') {
		      Animated.timing(slideAnim, {
		        toValue: 0,
		        duration: 300,
		        useNativeDriver: true,
		      }).start();
		    } else {
		      Animated.timing(slideAnim, {
		        toValue: -50,
		        duration: 300,
		        useNativeDriver: true,
		      }).start();
		    }
		  }, [connection.status]);
		
		  const getStatusConfig = () => {
		    switch (connection.status) {
		      case 'connected':
		        return {
		          color: '#00ff7f',
		          icon: 'checkmark-circle' as const,
		          text: 'Connected to your twin',
		          bgColor: 'rgba(0, 255, 127, 0.1)',
		        };
		      case 'connecting':
		        return {
		          color: '#ffff00',
		          icon: 'sync' as const,
		          text: 'Connecting to twin...',
		          bgColor: 'rgba(255, 255, 0, 0.1)',
		        };
		      case 'reconnecting':
		        return {
		          color: '#ff8c00',
		          icon: 'refresh' as const,
		          text: 'Reconnecting...',
		          bgColor: 'rgba(255, 140, 0, 0.1)',
		        };
		      case 'disconnected':
		      default:
		        return {
		          color: '#ff4444',
		          icon: 'close-circle' as const,
		          text: 'Disconnected from twin',
		          bgColor: 'rgba(255, 68, 68, 0.1)',
		        };
		    }
		  };
		
		  const config = getStatusConfig();
		
		  if (connection.status === 'connected') return null;
		
		  return (
		    <Animated.View
		      style={{
		        transform: [{ translateY: slideAnim }, { scale: pulseAnim }],
		        backgroundColor: config.bgColor,
		        borderBottomColor: config.color,
		        borderBottomWidth: 1,
		      }}
		      className="px-4 py-2"
		    >
		      <View className="flex-row items-center justify-center">
		        <Animated.View style={{ opacity: pulseAnim }}>
		          <Ionicons name={config.icon} size={16} color={config.color} />
		        </Animated.View>
		        <Text 
		          style={{ color: config.color }}
		          className="text-sm font-medium ml-2"
		        >
		          {config.text}
		        </Text>
		        
		        {connection.status === 'reconnecting' && (
		          <View className="ml-auto">
		            <Text className="text-white/50 text-xs">
		              Attempt {Math.floor(Math.random() * 3) + 1}/5
		            </Text>
		          </View>
		        )}
		      </View>
		    </Animated.View>
		  );
		};]]></file>
	<file path='components/chat/index.ts'>
		// Export all chat components for easy importing
		export { MessageBubble } from './MessageBubble';
		export { MessageInput } from './MessageInput';
		export { TypingIndicator } from './TypingIndicator';
		export { TwintuitionAlert } from './TwintuitionAlert';
		export { ConnectionStatusBar } from './ConnectionStatusBar';</file>
	<file path='components/chat/MessageBubble.tsx'><![CDATA[
		import React, { useState } from 'react';
		import {
		  View,
		  Text,
		  Pressable,
		  Alert,
		  Animated,
		} from 'react-native';
		import { Ionicons } from '@expo/vector-icons';
		import { ChatMessage, TWIN_EMOJIS } from '../../types/chat';
		import { getNeonAccentColor, getNeonAccentColorWithOpacity } from '../../utils/neonColors';
		import { useTwinStore } from '../../state/twinStore';
		import { useChatStore } from '../../state/chatStore';
		import { chatService } from '../../services/chatService';
		import * as Haptics from 'expo-haptics';
		
		interface MessageBubbleProps {
		  message: ChatMessage;
		  isOwn: boolean;
		  showTimestamp?: boolean;
		  onLongPress?: (message: ChatMessage) => void;
		}
		
		export const MessageBubble: React.FC<MessageBubbleProps> = ({
		  message,
		  isOwn,
		  showTimestamp = false,
		  onLongPress,
		}) => {
		  const userProfile = useTwinStore((state) => state.userProfile);
		  const [showReactions, setShowReactions] = useState(false);
		  const scaleValue = new Animated.Value(1);
		
		  const bubbleColor = isOwn
		    ? getNeonAccentColorWithOpacity(message.accentColor, 0.2)
		    : getNeonAccentColorWithOpacity(message.accentColor, 0.2);
		
		  const textColor = isOwn ? '#FFFFFF' : '#FFFFFF';
		  const borderColor = getNeonAccentColor(message.accentColor);
		
		  const formatTime = (timestamp: string) => {
		    const date = new Date(timestamp);
		    const now = new Date();
		    const diffInHours = (now.getTime() - date.getTime()) / (1000 * 60 * 60);
		
		    if (diffInHours < 24) {
		      return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
		    } else {
		      return date.toLocaleDateString([], { month: 'short', day: 'numeric' });
		    }
		  };
		
		  const handlePress = () => {
		    Animated.sequence([
		      Animated.timing(scaleValue, {
		        toValue: 0.95,
		        duration: 100,
		        useNativeDriver: true,
		      }),
		      Animated.timing(scaleValue, {
		        toValue: 1,
		        duration: 100,
		        useNativeDriver: true,
		      }),
		    ]).start();
		  };
		
		  const handleLongPress = () => {
		    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
		    onLongPress?.(message);
		    setShowReactions(true);
		  };
		
		  const handleReaction = async (emoji: string) => {
		    if (!userProfile) return;
		    
		    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		    await chatService.sendReaction(message.id, emoji);
		    setShowReactions(false);
		  };
		
		  const getReactionCount = (emoji: string) => {
		    return message.reactions?.filter(r => r.emoji === emoji).length || 0;
		  };
		
		  const hasUserReacted = (emoji: string) => {
		    return message.reactions?.some(r => r.emoji === emoji && r.userId === userProfile?.id);
		  };
		
		  const uniqueReactions = [...new Set(message.reactions?.map(r => r.emoji) || [])];
		
		  return (
		    <View className={`mb-3 ${isOwn ? 'items-end' : 'items-start'}`}>
		      <Animated.View
		        style={{
		          transform: [{ scale: scaleValue }],
		          maxWidth: '80%',
		        }}
		      >
		        <Pressable
		          onPress={handlePress}
		          onLongPress={handleLongPress}
		          className="relative"
		        >
		          {/* Message Bubble */}
		          <View
		            style={{
		              backgroundColor: 'rgba(255, 255, 255, 0.1)',
		              borderWidth: 1,
		              borderColor: borderColor,
		            }}
		            className={`px-4 py-3 rounded-2xl ${
		              isOwn ? 'rounded-br-md' : 'rounded-bl-md'
		            }`}
		          >
		            {/* Message Text */}
		            <Text
		              style={{ color: textColor }}
		              className="text-base leading-5"
		            >
		              {message.text}
		            </Text>
		
		            {/* Message Status (for own messages) */}
		            {isOwn && (
		              <View className="flex-row items-center justify-end mt-1">
		                <Text className="text-white/60 text-xs mr-1">
		                  {formatTime(message.timestamp)}
		                </Text>
		                <View className="flex-row">
		                  <Ionicons
		                    name="checkmark"
		                    size={12}
		                    color={message.isDelivered ? borderColor : 'rgba(255,255,255,0.4)'}
		                  />
		                  <Ionicons
		                    name="checkmark"
		                    size={12}
		                    color={message.isRead ? borderColor : 'rgba(255,255,255,0.4)'}
		                    style={{ marginLeft: -4 }}
		                  />
		                </View>
		              </View>
		            )}
		          </View>
		
		          {/* Reactions */}
		          {uniqueReactions.length > 0 && (
		            <View className={`flex-row flex-wrap mt-1 ${
		              isOwn ? 'justify-end' : 'justify-start'
		            }`}>
		              {uniqueReactions.map((emoji, index) => {
		                const count = getReactionCount(emoji);
		                const userReacted = hasUserReacted(emoji);
		                return (
		                  <Pressable
		                    key={`${emoji}-${index}`}
		                    onPress={() => handleReaction(emoji)}
		                    style={{
		                      backgroundColor: userReacted
		                        ? getNeonAccentColorWithOpacity(message.accentColor, 0.3)
		                        : 'rgba(255,255,255,0.1)',
		                      borderColor: userReacted ? borderColor : 'transparent',
		                      borderWidth: userReacted ? 1 : 0,
		                    }}
		                    className="flex-row items-center px-2 py-1 rounded-full mr-1 mb-1"
		                  >
		                    <Text className="text-sm">{emoji}</Text>
		                    {count > 1 && (
		                      <Text className="text-white text-xs ml-1">{count}</Text>
		                    )}
		                  </Pressable>
		                );
		              })}
		            </View>
		          )}
		        </Pressable>
		
		        {/* Quick Reaction Panel */}
		        {showReactions && (
		          <View
		            style={{
		              backgroundColor: 'rgba(0,0,0,0.8)',
		              borderColor: borderColor,
		              borderWidth: 1,
		            }}
		            className={`absolute top-0 ${isOwn ? 'right-0' : 'left-0'} flex-row items-center px-3 py-2 rounded-full`}
		          >
		            {TWIN_EMOJIS.slice(0, 6).map((emoji, index) => (
		              <Pressable
		                key={index}
		                onPress={() => handleReaction(emoji)}
		                className="mx-1"
		              >
		                <Text className="text-xl">{emoji}</Text>
		              </Pressable>
		            ))}
		            <Pressable
		              onPress={() => setShowReactions(false)}
		              className="ml-2"
		            >
		              <Ionicons name="close" size={16} color="white" />
		            </Pressable>
		          </View>
		        )}
		      </Animated.View>
		
		      {/* Timestamp (for twin's messages) */}
		      {!isOwn && (showTimestamp || message.reactions?.length > 0) && (
		        <Text className="text-white/50 text-xs mt-1 ml-1">
		          {formatTime(message.timestamp)}
		        </Text>
		      )}
		    </View>
		  );
		};]]></file>
	<file path='components/chat/MessageInput.tsx'><![CDATA[
		import React, { useState, useRef, useEffect } from 'react';
		import {
		  View,
		  TextInput,
		  Pressable,
		  Animated,
		  KeyboardAvoidingView,
		  Platform,
		  ScrollView,
		  Text,
		  Modal,
		} from 'react-native';
		import { Ionicons } from '@expo/vector-icons';
		import { useNavigation } from '@react-navigation/native';
		import { useTwinStore } from '../../state/twinStore';
		import { useChatStore } from '../../state/chatStore';
		import { chatService } from '../../services/chatService';
		import { QUICK_RESPONSES } from '../../types/chat';
		import { getNeonAccentColor } from '../../utils/neonColors';
		import * as Haptics from 'expo-haptics';
		import * as Location from 'expo-location';
		
		interface MessageInputProps {
		  onSendMessage?: (text: string) => void;
		}
		
		export const MessageInput: React.FC<MessageInputProps> = ({ onSendMessage }) => {
		  const navigation = useNavigation<any>();
		  const userProfile = useTwinStore((state) => state.userProfile);
		  const twinProfile = useTwinStore((state) => state.twinProfile);
		  const twintuitionMoments = useChatStore((state) => state.twintuitionMoments);
		  const { showQuickResponses, setShowQuickResponses, isVoiceRecording, setVoiceRecording } = useChatStore();
		  
		  const [inputText, setInputText] = useState('');
		  const [isTyping, setIsTyping] = useState(false);
		  const [showEmojiPicker, setShowEmojiPicker] = useState(false);
		  const [showLocationModal, setShowLocationModal] = useState(false);
		  const [twinLocation, setTwinLocation] = useState(null);
		  const [isSending, setIsSending] = useState(false);
		  const textInputRef = useRef<TextInput>(null);
		  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
		  const scaleValue = new Animated.Value(1);
		
		  const accentColor = userProfile?.accentColor || 'neon-purple';
		  const neonColor = getNeonAccentColor(accentColor);
		
		  useEffect(() => {
		    // Handle typing indicator
		    if (inputText.length > 0 && !isTyping) {
		      setIsTyping(true);
		      chatService.sendTypingIndicator(true);
		    }
		
		    // Clear previous timeout
		    if (typingTimeoutRef.current) {
		      clearTimeout(typingTimeoutRef.current);
		    }
		
		    // Set new timeout to stop typing indicator
		    typingTimeoutRef.current = setTimeout(() => {
		      if (isTyping) {
		        setIsTyping(false);
		        chatService.sendTypingIndicator(false);
		      }
		    }, 1000);
		
		    return () => {
		      if (typingTimeoutRef.current) {
		        clearTimeout(typingTimeoutRef.current);
		      }
		    };
		  }, [inputText, isTyping]);
		
		  const handleSendMessage = async () => {
		    if (!inputText.trim() || !userProfile || isSending) return;
		
		    setIsSending(true);
		    const messageText = inputText.trim();
		    setInputText('');
		    setIsTyping(false);
		    chatService.sendTypingIndicator(false);
		
		    try {
		      // Haptic feedback
		      await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		
		      // Send message
		      await chatService.sendMessage({
		        text: messageText,
		        senderId: userProfile.id,
		        senderName: userProfile.name,
		        type: 'text',
		        accentColor: userProfile.accentColor,
		      });
		
		      onSendMessage?.(messageText);
		    } finally {
		      setIsSending(false);
		    }
		  };
		
		  const handleQuickResponse = async (response: string) => {
		    if (!userProfile) return;
		
		    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		    await chatService.sendQuickResponse(response);
		    setShowQuickResponses(false);
		  };
		
		  const handleVoiceRecord = async () => {
		    if (!userProfile) return;
		
		    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
		    
		    if (isVoiceRecording) {
		      // Stop recording
		      setVoiceRecording(false);
		      // In a real app, you'd process the recording here
		      await chatService.sendVoiceMessage('mock-uri', 5); // Mock 5-second message
		    } else {
		      // Start recording
		      setVoiceRecording(true);
		      // Auto-stop after 60 seconds
		      setTimeout(() => {
		        if (isVoiceRecording) {
		          setVoiceRecording(false);
		        }
		      }, 60000);
		    }
		  };
		
		  const animateButton = () => {
		    Animated.sequence([
		      Animated.timing(scaleValue, {
		        toValue: 0.9,
		        duration: 100,
		        useNativeDriver: true,
		      }),
		      Animated.timing(scaleValue, {
		        toValue: 1,
		        duration: 100,
		        useNativeDriver: true,
		      }),
		    ]).start();
		  };
		
		  const commonEmojis = ['❤️', '😊', '😂', '🥺', '😍', '🤔', '👯', '✨', '🔮', '💫'];
		
		  const handleLocationShare = async () => {
		    try {
		      // Request location permissions
		      const { status } = await Location.requestForegroundPermissionsAsync();
		      if (status !== 'granted') {
		        alert('Location permission is required to share your location with your twin.');
		        return;
		      }
		
		      // Get current location
		      const location = await Location.getCurrentPositionAsync({});
		      
		      // Send location message
		      await chatService.sendLocationMessage({
		        latitude: location.coords.latitude,
		        longitude: location.coords.longitude,
		        address: 'Current Location', // In a real app, reverse geocode this
		      });
		      
		      await Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		    } catch (error) {
		      console.error('Error sharing location:', error);
		      alert('Failed to share location. Please try again.');
		    }
		  };
		
		  const handleViewTwinLocation = async () => {
		    // Mock twin location for demo - in real app, get from server
		    const mockTwinLocation = {
		      latitude: 37.7749 + (Math.random() - 0.5) * 0.01,
		      longitude: -122.4194 + (Math.random() - 0.5) * 0.01,
		      name: twinProfile?.name || 'Your Twin',
		      lastUpdated: new Date().toISOString(),
		    };
		    
		    setTwinLocation(mockTwinLocation);
		    setShowLocationModal(true);
		  };
		
		  return (
		    <KeyboardAvoidingView
		      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
		      className="bg-black/20 border-t border-white/10"
		    >
		      {/* Quick Responses */}
		      {showQuickResponses && (
		        <ScrollView
		          horizontal
		          showsHorizontalScrollIndicator={false}
		          className="px-4 py-3 bg-black/30"
		        >
		          {QUICK_RESPONSES.map((response) => (
		            <Pressable
		              key={response.id}
		              onPress={() => handleQuickResponse(response.text)}
		              style={{
		                backgroundColor: 'rgba(255,255,255,0.1)',
		                borderColor: neonColor,
		                borderWidth: 1,
		              }}
		              className="flex-row items-center px-3 py-2 rounded-full mr-2"
		            >
		              <Text className="text-lg mr-1">{response.emoji}</Text>
		              <Text className="text-white text-sm">{response.text}</Text>
		            </Pressable>
		          ))}
		        </ScrollView>
		      )}
		
		      {/* Emoji Picker */}
		      {showEmojiPicker && (
		        <ScrollView
		          horizontal
		          showsHorizontalScrollIndicator={false}
		          className="px-4 py-3 bg-black/30"
		        >
		          {commonEmojis.map((emoji, index) => (
		            <Pressable
		              key={index}
		              onPress={() => {
		                setInputText(prev => prev + emoji);
		                setShowEmojiPicker(false);
		                textInputRef.current?.focus();
		              }}
		              className="bg-white/10 w-12 h-12 rounded-full items-center justify-center mr-2"
		            >
		              <Text className="text-xl">{emoji}</Text>
		            </Pressable>
		          ))}
		        </ScrollView>
		      )}
		
		      {/* Main Input Area */}
		      <View className="flex-row items-end px-4 py-3 space-x-3">
		        {/* Twintuition Button */}
		        <Pressable
		          onPress={() => navigation.navigate('Twintuition')}
		          className="bg-white/10 rounded-full p-3 relative"
		        >
		          <Ionicons name="flash" size={20} color={neonColor} />
		          {twintuitionMoments.length > 0 && (
		            <View 
		              style={{ backgroundColor: neonColor }}
		              className="absolute -top-1 -right-1 w-4 h-4 rounded-full items-center justify-center"
		            >
		              <Text className="text-black text-xs font-bold">
		                {twintuitionMoments.length > 9 ? '9+' : twintuitionMoments.length}
		              </Text>
		            </View>
		          )}
		        </Pressable>
		
		        {/* Location Button */}
		        <Pressable
		          onPress={handleViewTwinLocation}
		          onLongPress={handleLocationShare}
		          className="bg-white/10 rounded-full p-3"
		        >
		          <Ionicons name="location" size={20} color="white" />
		        </Pressable>
		
		        {/* Quick Actions Button */}
		        <Pressable
		          onPress={() => {
		            animateButton();
		            setShowQuickResponses(!showQuickResponses);
		            setShowEmojiPicker(false);
		          }}
		          className="bg-white/10 w-10 h-10 rounded-full items-center justify-center"
		        >
		          <Ionicons 
		            name={showQuickResponses ? "close" : "flash"} 
		            size={20} 
		            color={showQuickResponses ? neonColor : "white"} 
		          />
		        </Pressable>
		
		        {/* Text Input Container */}
		        <View className="flex-1 bg-white/10 rounded-2xl px-4 py-2 min-h-[44px] max-h-[120px]">
		          <TextInput
		            ref={textInputRef}
		            value={inputText}
		            onChangeText={setInputText}
		            placeholder="Type your message..."
		            placeholderTextColor="rgba(255,255,255,0.5)"
		            className="text-white text-base flex-1"
		            multiline
		            maxLength={1000}
		            style={{
		              textAlignVertical: 'center',
		            }}
		          />
		        </View>
		
		        {/* Emoji Button */}
		        <Pressable
		          onPress={() => {
		            animateButton();
		            setShowEmojiPicker(!showEmojiPicker);
		            setShowQuickResponses(false);
		          }}
		          className="bg-white/10 w-10 h-10 rounded-full items-center justify-center"
		        >
		          <Ionicons 
		            name={showEmojiPicker ? "close" : "happy-outline"} 
		            size={20} 
		            color={showEmojiPicker ? neonColor : "white"} 
		          />
		        </Pressable>
		
		        {/* Voice/Send Button */}
		        <Animated.View style={{ transform: [{ scale: scaleValue }] }}>
		          <Pressable
		            onPress={inputText.trim() ? handleSendMessage : handleVoiceRecord}
		            onPressIn={animateButton}
		            disabled={isSending}
		            style={{
		              backgroundColor: inputText.trim() || isVoiceRecording ? neonColor : 'rgba(255,255,255,0.2)',
		              opacity: isSending ? 0.7 : 1,
		            }}
		            className="w-12 h-12 rounded-full items-center justify-center"
		          >
		            <Ionicons
		              name={
		                isSending
		                  ? "hourglass"
		                  : inputText.trim() 
		                    ? "send" 
		                    : isVoiceRecording 
		                      ? "stop" 
		                      : "mic"
		              }
		              size={20}
		              color="white"
		            />
		          </Pressable>
		        </Animated.View>
		      </View>
		
		      {/* Voice Recording Indicator */}
		      {isVoiceRecording && (
		        <View className="flex-row items-center justify-center py-2 bg-red-500/20">
		          <View className="w-3 h-3 bg-red-500 rounded-full mr-2 animate-pulse" />
		          <Text className="text-white text-sm">Recording voice message...</Text>
		        </View>
		      )}
		    </KeyboardAvoidingView>
		  );
		};]]></file>
	<file path='components/chat/QuickActionBar.tsx'><![CDATA[
		import React from 'react';
		import { View, Pressable, Text, ScrollView } from 'react-native';
		import { Ionicons } from '@expo/vector-icons';
		import { QUICK_RESPONSES } from '../../types/chat';
		import { getNeonAccentColor } from '../../utils/neonColors';
		import { useTwinStore } from '../../state/twinStore';
		import * as Haptics from 'expo-haptics';
		
		interface QuickActionBarProps {
		  onQuickResponse: (text: string) => void;
		  onToggleEmoji: () => void;
		  onToggleVoice: () => void;
		  showEmoji?: boolean;
		  isRecording?: boolean;
		}
		
		export const QuickActionBar: React.FC<QuickActionBarProps> = ({
		  onQuickResponse,
		  onToggleEmoji,
		  onToggleVoice,
		  showEmoji = false,
		  isRecording = false,
		}) => {
		  const userProfile = useTwinStore((state) => state.userProfile);
		  const accentColor = userProfile?.accentColor || 'neon-purple';
		  const neonColor = getNeonAccentColor(accentColor);
		
		  const handleQuickResponse = async (text: string) => {
		    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		    onQuickResponse(text);
		  };
		
		  const handleVoiceToggle = async () => {
		    await Haptics.impactAsync(
		      isRecording 
		        ? Haptics.ImpactFeedbackStyle.Heavy 
		        : Haptics.ImpactFeedbackStyle.Medium
		    );
		    onToggleVoice();
		  };
		
		  return (
		    <View className="bg-black/30 border-t border-white/10 px-4 py-3">
		      <ScrollView 
		        horizontal 
		        showsHorizontalScrollIndicator={false}
		        className="mb-3"
		      >
		        {QUICK_RESPONSES.map((response) => (
		          <Pressable
		            key={response.id}
		            onPress={() => handleQuickResponse(response.text)}
		            style={{
		              backgroundColor: 'rgba(255,255,255,0.1)',
		              borderColor: neonColor,
		              borderWidth: 1,
		            }}
		            className="flex-row items-center px-3 py-2 rounded-full mr-3"
		          >
		            <Text className="text-lg mr-2">{response.emoji}</Text>
		            <Text className="text-white text-sm">{response.text}</Text>
		          </Pressable>
		        ))}
		      </ScrollView>
		
		      <View className="flex-row items-center justify-between">
		        {/* Quick Actions */}
		        <View className="flex-row items-center space-x-3">
		          {/* Emoji Toggle */}
		          <Pressable
		            onPress={onToggleEmoji}
		            style={{
		              backgroundColor: showEmoji ? neonColor : 'rgba(255,255,255,0.1)',
		            }}
		            className="w-10 h-10 rounded-full items-center justify-center"
		          >
		            <Ionicons 
		              name={showEmoji ? "happy" : "happy-outline"} 
		              size={20} 
		              color={showEmoji ? "white" : neonColor} 
		            />
		          </Pressable>
		
		          {/* Voice Recording */}
		          <Pressable
		            onPress={handleVoiceToggle}
		            style={{
		              backgroundColor: isRecording ? '#ff4444' : 'rgba(255,255,255,0.1)',
		            }}
		            className="w-10 h-10 rounded-full items-center justify-center"
		          >
		            <Ionicons 
		              name={isRecording ? "stop" : "mic-outline"} 
		              size={20} 
		              color="white"
		            />
		          </Pressable>
		
		          {/* Camera/Gallery */}
		          <Pressable
		            onPress={() => {
		              // Handle image/camera action
		              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		            }}
		            className="bg-white/10 w-10 h-10 rounded-full items-center justify-center"
		          >
		            <Ionicons name="camera-outline" size={20} color={neonColor} />
		          </Pressable>
		
		          {/* Games */}
		          <Pressable
		            onPress={() => {
		              // Navigate to twin games
		              Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		            }}
		            className="bg-white/10 w-10 h-10 rounded-full items-center justify-center"
		          >
		            <Ionicons name="game-controller-outline" size={20} color={neonColor} />
		          </Pressable>
		        </View>
		
		        {/* Twintuition Trigger */}
		        <Pressable
		          onPress={() => {
		            // Manually trigger twintuition moment
		            Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		          }}
		          style={{
		            backgroundColor: `${neonColor}20`,
		            borderColor: neonColor,
		            borderWidth: 1,
		          }}
		          className="flex-row items-center px-3 py-2 rounded-full"
		        >
		          <Ionicons name="flash" size={16} color={neonColor} />
		          <Text style={{ color: neonColor }} className="text-sm ml-1 font-medium">
		            Twintuition
		          </Text>
		        </Pressable>
		      </View>
		    </View>
		  );
		};]]></file>
	<file path='components/chat/TwintuitionAlert.tsx'><![CDATA[
		import React, { useEffect, useRef } from 'react';
		import { View, Text, Pressable, Animated } from 'react-native';
		import { Ionicons } from '@expo/vector-icons';
		import { TwintuitionMoment } from '../../types/chat';
		import { getNeonAccentColor } from '../../utils/neonColors';
		import { useTwinStore } from '../../state/twinStore';
		import * as Haptics from 'expo-haptics';
		
		interface TwintuitionAlertProps {
		  moment: TwintuitionMoment;
		  onDismiss: () => void;
		  onViewDetails: () => void;
		}
		
		export const TwintuitionAlert: React.FC<TwintuitionAlertProps> = ({
		  moment,
		  onDismiss,
		  onViewDetails,
		}) => {
		  const userProfile = useTwinStore((state) => state.userProfile);
		  const slideAnim = useRef(new Animated.Value(-100)).current;
		  const pulseAnim = useRef(new Animated.Value(1)).current;
		
		  const accentColor = userProfile?.accentColor || 'neon-purple';
		  const neonColor = getNeonAccentColor(accentColor);
		
		  useEffect(() => {
		    // Slide in animation
		    Animated.spring(slideAnim, {
		      toValue: 0,
		      useNativeDriver: true,
		      tension: 100,
		      friction: 8,
		    }).start();
		
		    // Pulse animation for mystical effect
		    Animated.loop(
		      Animated.sequence([
		        Animated.timing(pulseAnim, {
		          toValue: 1.05,
		          duration: 1000,
		          useNativeDriver: true,
		        }),
		        Animated.timing(pulseAnim, {
		          toValue: 1,
		          duration: 1000,
		          useNativeDriver: true,
		        }),
		      ])
		    ).start();
		
		    // Haptic feedback
		    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		  }, []);
		
		  const getConfidenceColor = (confidence: number) => {
		    if (confidence >= 0.9) return '#00ff7f';
		    if (confidence >= 0.7) return '#ffff00';
		    return '#ff8c00';
		  };
		
		  const getConfidenceText = (confidence: number) => {
		    if (confidence >= 0.9) return 'Very Strong';
		    if (confidence >= 0.7) return 'Strong';
		    return 'Moderate';
		  };
		
		  return (
		    <Animated.View
		      style={{
		        transform: [
		          { translateY: slideAnim },
		          { scale: pulseAnim },
		        ],
		      }}
		      className="mx-4 my-2"
		    >
		      <Pressable
		        onPress={onViewDetails}
		        style={{
		          backgroundColor: 'rgba(0,0,0,0.85)',
		          borderColor: neonColor,
		          borderWidth: 2,
		          shadowColor: neonColor,
		          shadowOffset: { width: 0, height: 0 },
		          shadowOpacity: 0.5,
		          shadowRadius: 10,
		        }}
		        className="rounded-2xl p-4 relative overflow-hidden"
		      >
		        {/* Mystical Background Gradient */}
		        <View 
		          style={{
		            position: 'absolute',
		            top: 0,
		            left: 0,
		            right: 0,
		            bottom: 0,
		            backgroundColor: `${neonColor}15`,
		          }}
		        />
		
		        {/* Header */}
		        <View className="flex-row items-center justify-between mb-3">
		          <View className="flex-row items-center">
		            <View className="mr-3">
		              <Ionicons name="flash" size={24} color={neonColor} />
		            </View>
		            <Text className="text-white text-lg font-bold">
		              Twintuition Alert
		            </Text>
		          </View>
		          
		          <Pressable
		            onPress={onDismiss}
		            className="bg-white/10 rounded-full p-1"
		          >
		            <Ionicons name="close" size={16} color="white" />
		          </Pressable>
		        </View>
		
		        {/* Message */}
		        <Text className="text-white text-base mb-3 leading-6">
		          {moment.message}
		        </Text>
		
		        {/* Details */}
		        <View className="flex-row items-center justify-between">
		          <View className="flex-row items-center">
		            <View className="flex-row items-center mr-4">
		              <Ionicons name="pulse" size={16} color={getConfidenceColor(moment.confidence)} />
		              <Text className="text-white/70 text-sm ml-1">
		                {getConfidenceText(moment.confidence)}
		              </Text>
		            </View>
		            <Text className="text-white/50 text-sm">
		              {new Date(moment.timestamp).toLocaleTimeString([], { 
		                hour: '2-digit', 
		                minute: '2-digit' 
		              })}
		            </Text>
		          </View>
		
		          <Text className="text-xs px-2 py-1 rounded-full" style={{ 
		            color: neonColor, 
		            backgroundColor: `${neonColor}20`,
		            borderColor: neonColor,
		            borderWidth: 1,
		          }}>
		            {moment.type.toUpperCase()}
		          </Text>
		        </View>
		
		        {/* Action Button */}
		        <Pressable
		          onPress={onViewDetails}
		          style={{ backgroundColor: neonColor }}
		          className="mt-3 py-2 rounded-lg items-center"
		        >
		          <Text className="text-white font-semibold">
		            View Twintuition Details
		          </Text>
		        </Pressable>
		      </Pressable>
		    </Animated.View>
		  );
		};]]></file>
	<file path='components/chat/TypingIndicator.tsx'><![CDATA[
		import React, { useEffect, useRef } from 'react';
		import { View, Text, Animated } from 'react-native';
		import { TypingIndicator as TypingIndicatorType } from '../../types/chat';
		import { useTwinStore } from '../../state/twinStore';
		import { getNeonAccentColor } from '../../utils/neonColors';
		
		interface TypingIndicatorProps {
		  typingIndicator: TypingIndicatorType;
		}
		
		export const TypingIndicator: React.FC<TypingIndicatorProps> = ({ typingIndicator }) => {
		  const twinProfile = useTwinStore((state) => state.twinProfile);
		  const dot1Anim = useRef(new Animated.Value(0.3)).current;
		  const dot2Anim = useRef(new Animated.Value(0.3)).current;
		  const dot3Anim = useRef(new Animated.Value(0.3)).current;
		  const slideAnim = useRef(new Animated.Value(-100)).current;
		
		  const accentColor = twinProfile?.accentColor || 'neon-purple';
		  const neonColor = getNeonAccentColor(accentColor);
		
		  useEffect(() => {
		    // Slide in animation
		    Animated.spring(slideAnim, {
		      toValue: 0,
		      useNativeDriver: true,
		      tension: 100,
		      friction: 8,
		    }).start();
		
		    // Pulsing dots animation
		    const createPulseAnimation = (animValue: Animated.Value, delay: number) => {
		      return Animated.loop(
		        Animated.sequence([
		          Animated.timing(animValue, {
		            toValue: 1,
		            duration: 600,
		            delay,
		            useNativeDriver: true,
		          }),
		          Animated.timing(animValue, {
		            toValue: 0.3,
		            duration: 600,
		            useNativeDriver: true,
		          }),
		        ])
		      );
		    };
		
		    const dot1Animation = createPulseAnimation(dot1Anim, 0);
		    const dot2Animation = createPulseAnimation(dot2Anim, 200);
		    const dot3Animation = createPulseAnimation(dot3Anim, 400);
		
		    dot1Animation.start();
		    dot2Animation.start();
		    dot3Animation.start();
		
		    return () => {
		      dot1Animation.stop();
		      dot2Animation.stop();
		      dot3Animation.stop();
		    };
		  }, []);
		
		  return (
		    <Animated.View
		      style={{
		        transform: [{ translateX: slideAnim }],
		      }}
		      className="items-start mb-4"
		    >
		      <View
		        style={{
		          backgroundColor: 'rgba(255,255,255,0.1)',
		          borderColor: neonColor,
		          borderWidth: 1,
		        }}
		        className="rounded-2xl rounded-bl-md px-4 py-3 min-w-[80px]"
		      >
		        <View className="flex-row items-center justify-center space-x-1">
		          <Animated.View
		            style={{
		              opacity: dot1Anim,
		              backgroundColor: neonColor,
		            }}
		            className="w-2 h-2 rounded-full"
		          />
		          <Animated.View
		            style={{
		              opacity: dot2Anim,
		              backgroundColor: neonColor,
		            }}
		            className="w-2 h-2 rounded-full"
		          />
		          <Animated.View
		            style={{
		              opacity: dot3Anim,
		              backgroundColor: neonColor,
		            }}
		            className="w-2 h-2 rounded-full"
		          />
		        </View>
		      </View>
		      <Text className="text-white/50 text-xs mt-1 ml-1">
		        {typingIndicator.userName} is typing...
		      </Text>
		    </Animated.View>
		  );
		};]]></file>
	<file path='components/common/PrivacyConsentModal.tsx'><![CDATA[
		/**
		 * Privacy Consent Modal - GDPR Compliant Telemetry Consent
		 * Provides transparent information about data collection and user control
		 */
		
		import React, { useState } from 'react';
		import {
		  View,
		  Text,
		  ScrollView,
		  TouchableOpacity,
		  Modal,
		  Switch,
		  Alert,
		} from 'react-native';
		import { useTelemetryStore } from '../../state/telemetryStore';
		import { TelemetryConfig, TelemetryPrivacyLevel } from '../../types/telemetry';
		
		interface PrivacyConsentModalProps {
		  visible: boolean;
		  onClose: () => void;
		  onConsentChange: (consent: boolean, config?: Partial<TelemetryConfig>) => void;
		  initialConsent?: boolean;
		  isUpdate?: boolean; // True when updating existing consent
		}
		
		const PrivacyConsentModal: React.FC<PrivacyConsentModalProps> = ({
		  visible,
		  onClose,
		  onConsentChange,
		  initialConsent = false,
		  isUpdate = false,
		}) => {
		  const { config: currentConfig, userConsent, consentVersion } = useTelemetryStore();
		  
		  const [consent, setConsent] = useState(initialConsent || userConsent);
		  const [privacyLevel, setPrivacyLevel] = useState<TelemetryPrivacyLevel>(
		    currentConfig.privacyLevel || 'anonymous'
		  );
		  const [collectPerformance, setCollectPerformance] = useState(
		    currentConfig.collectPerformanceMetrics
		  );
		  const [collectAnomalies, setCollectAnomalies] = useState(
		    currentConfig.collectAnomalyData
		  );
		  const [collectNorming, setCollectNorming] = useState(
		    currentConfig.collectNormingData
		  );
		
		  const handleSaveConsent = () => {
		    if (consent && (!collectPerformance && !collectAnomalies && !collectNorming)) {
		      Alert.alert(
		        'Invalid Configuration',
		        'If you consent to data collection, at least one data type must be enabled.',
		        [{ text: 'OK' }]
		      );
		      return;
		    }
		
		    const newConfig: Partial<TelemetryConfig> = {
		      enabled: consent,
		      privacyLevel,
		      collectPerformanceMetrics: collectPerformance,
		      collectAnomalyData: collectAnomalies,
		      collectNormingData: collectNorming,
		    };
		
		    onConsentChange(consent, newConfig);
		    onClose();
		  };
		
		  const renderDataCollectionInfo = () => (
		    <View className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
		      <Text className="text-blue-800 font-semibold text-base mb-2">
		        What Data Do We Collect?
		      </Text>
		      <Text className="text-blue-700 text-sm mb-3">
		        All data collection is anonymous and designed to improve the scientific validity 
		        of our psychological assessments. We never collect personally identifiable information.
		      </Text>
		      
		      <View className="space-y-2">
		        <View className="flex-row items-start">
		          <Text className="text-blue-600 mr-2">•</Text>
		          <Text className="text-blue-700 text-sm flex-1">
		            <Text className="font-medium">Response Patterns:</Text> How you answer questions 
		            (without the actual answers) to detect data quality issues
		          </Text>
		        </View>
		        
		        <View className="flex-row items-start">
		          <Text className="text-blue-600 mr-2">•</Text>
		          <Text className="text-blue-700 text-sm flex-1">
		            <Text className="font-medium">Timing Data:</Text> How long you spend on questions 
		            to identify optimal assessment length
		          </Text>
		        </View>
		        
		        <View className="flex-row items-start">
		          <Text className="text-blue-600 mr-2">•</Text>
		          <Text className="text-blue-700 text-sm flex-1">
		            <Text className="font-medium">Technical Metrics:</Text> App performance data 
		            to improve user experience
		          </Text>
		        </View>
		        
		        <View className="flex-row items-start">
		          <Text className="text-blue-600 mr-2">•</Text>
		          <Text className="text-blue-700 text-sm flex-1">
		            <Text className="font-medium">Statistical Norms:</Text> Anonymous response 
		            distributions to create reliable scoring systems
		          </Text>
		        </View>
		      </View>
		    </View>
		  );
		
		  const renderPrivacyLevelSelector = () => (
		    <View className="mb-4">
		      <Text className="text-lg font-semibold text-gray-900 mb-3">Privacy Level</Text>
		      
		      <TouchableOpacity
		        className={`border-2 rounded-lg p-4 mb-2 ${
		          privacyLevel === 'anonymous' ? 'border-blue-500 bg-blue-50' : 'border-gray-200 bg-white'
		        }`}
		        onPress={() => setPrivacyLevel('anonymous')}
		      >
		        <View className="flex-row items-center justify-between mb-1">
		          <Text className="font-medium text-gray-900">Anonymous</Text>
		          <View className={`w-4 h-4 rounded-full border-2 ${
		            privacyLevel === 'anonymous' ? 'border-blue-500 bg-blue-500' : 'border-gray-300'
		          }`} />
		        </View>
		        <Text className="text-sm text-gray-600">
		          No session linking, maximum privacy protection
		        </Text>
		      </TouchableOpacity>
		      
		      <TouchableOpacity
		        className={`border-2 rounded-lg p-4 mb-2 ${
		          privacyLevel === 'pseudonymous' ? 'border-blue-500 bg-blue-50' : 'border-gray-200 bg-white'
		        }`}
		        onPress={() => setPrivacyLevel('pseudonymous')}
		      >
		        <View className="flex-row items-center justify-between mb-1">
		          <Text className="font-medium text-gray-900">Pseudonymous</Text>
		          <View className={`w-4 h-4 rounded-full border-2 ${
		            privacyLevel === 'pseudonymous' ? 'border-blue-500 bg-blue-500' : 'border-gray-300'
		          }`} />
		        </View>
		        <Text className="text-sm text-gray-600">
		          Temporary session linking for better analytics, auto-anonymized after 24 hours
		        </Text>
		      </TouchableOpacity>
		      
		      <TouchableOpacity
		        className={`border-2 rounded-lg p-4 ${
		          privacyLevel === 'aggregated_only' ? 'border-blue-500 bg-blue-50' : 'border-gray-200 bg-white'
		        }`}
		        onPress={() => setPrivacyLevel('aggregated_only')}
		      >
		        <View className="flex-row items-center justify-between mb-1">
		          <Text className="font-medium text-gray-900">Aggregated Only</Text>
		          <View className={`w-4 h-4 rounded-full border-2 ${
		            privacyLevel === 'aggregated_only' ? 'border-blue-500 bg-blue-500' : 'border-gray-300'
		          }`} />
		        </View>
		        <Text className="text-sm text-gray-600">
		          Only aggregate statistics, no individual data points
		        </Text>
		      </TouchableOpacity>
		    </View>
		  );
		
		  const renderDataTypeToggles = () => (
		    <View className="mb-4">
		      <Text className="text-lg font-semibold text-gray-900 mb-3">Data Collection Types</Text>
		      
		      <View className="bg-white border border-gray-200 rounded-lg">
		        <View className="flex-row items-center justify-between p-4 border-b border-gray-200">
		          <View className="flex-1 mr-4">
		            <Text className="font-medium text-gray-900">Performance Metrics</Text>
		            <Text className="text-sm text-gray-600 mt-1">
		              App performance, loading times, and technical health data
		            </Text>
		          </View>
		          <Switch
		            value={collectPerformance}
		            onValueChange={setCollectPerformance}
		            disabled={!consent}
		          />
		        </View>
		        
		        <View className="flex-row items-center justify-between p-4 border-b border-gray-200">
		          <View className="flex-1 mr-4">
		            <Text className="font-medium text-gray-900">Anomaly Detection</Text>
		            <Text className="text-sm text-gray-600 mt-1">
		              Response patterns to identify and prevent data quality issues
		            </Text>
		          </View>
		          <Switch
		            value={collectAnomalies}
		            onValueChange={setCollectAnomalies}
		            disabled={!consent}
		          />
		        </View>
		        
		        <View className="flex-row items-center justify-between p-4">
		          <View className="flex-1 mr-4">
		            <Text className="font-medium text-gray-900">Norming Data</Text>
		            <Text className="text-sm text-gray-600 mt-1">
		              Anonymous response statistics for assessment validation and scoring
		            </Text>
		          </View>
		          <Switch
		            value={collectNorming}
		            onValueChange={setCollectNorming}
		            disabled={!consent}
		          />
		        </View>
		      </View>
		    </View>
		  );
		
		  const renderBenefitsSection = () => (
		    <View className="bg-green-50 border border-green-200 rounded-lg p-4 mb-4">
		      <Text className="text-green-800 font-semibold text-base mb-2">
		        How This Benefits You
		      </Text>
		      
		      <View className="space-y-2">
		        <View className="flex-row items-start">
		          <Text className="text-green-600 mr-2">✓</Text>
		          <Text className="text-green-700 text-sm flex-1">
		            <Text className="font-medium">Better Assessments:</Text> More accurate and 
		            reliable psychological evaluations
		          </Text>
		        </View>
		        
		        <View className="flex-row items-start">
		          <Text className="text-green-600 mr-2">✓</Text>
		          <Text className="text-green-700 text-sm flex-1">
		            <Text className="font-medium">Improved Experience:</Text> Faster app performance 
		            and smoother user interface
		          </Text>
		        </View>
		        
		        <View className="flex-row items-start">
		          <Text className="text-green-600 mr-2">✓</Text>
		          <Text className="text-green-700 text-sm flex-1">
		            <Text className="font-medium">Scientific Contribution:</Text> Help advance 
		            twin psychology research anonymously
		          </Text>
		        </View>
		        
		        <View className="flex-row items-start">
		          <Text className="text-green-600 mr-2">✓</Text>
		          <Text className="text-green-700 text-sm flex-1">
		            <Text className="font-medium">Quality Assurance:</Text> Automatic detection 
		            of assessment issues and improvements
		          </Text>
		        </View>
		      </View>
		    </View>
		  );
		
		  const renderRightsSection = () => (
		    <View className="bg-gray-50 border border-gray-200 rounded-lg p-4 mb-4">
		      <Text className="text-gray-800 font-semibold text-base mb-2">Your Rights</Text>
		      
		      <View className="space-y-2">
		        <Text className="text-gray-700 text-sm">
		          • <Text className="font-medium">Withdraw Consent:</Text> Change your mind at any time 
		          in Settings
		        </Text>
		        
		        <Text className="text-gray-700 text-sm">
		          • <Text className="font-medium">Data Deletion:</Text> Request removal of all your 
		          data (within technical limitations)
		        </Text>
		        
		        <Text className="text-gray-700 text-sm">
		          • <Text className="font-medium">Transparency:</Text> View exactly what data is 
		          collected in real-time
		        </Text>
		        
		        <Text className="text-gray-700 text-sm">
		          • <Text className="font-medium">Control:</Text> Customize exactly what types of 
		          data you're comfortable sharing
		        </Text>
		      </View>
		    </View>
		  );
		
		  const renderConsentToggle = () => (
		    <View className="bg-white border-2 border-gray-300 rounded-lg p-4 mb-6">
		      <View className="flex-row items-center justify-between">
		        <View className="flex-1 mr-4">
		          <Text className="text-lg font-semibold text-gray-900">
		            {isUpdate ? 'Update Consent' : 'Grant Consent'}
		          </Text>
		          <Text className="text-sm text-gray-600 mt-1">
		            I consent to anonymous data collection to improve Twinship assessments
		          </Text>
		        </View>
		        <Switch
		          value={consent}
		          onValueChange={setConsent}
		          trackColor={{ false: '#D1D5DB', true: '#3B82F6' }}
		          thumbColor={consent ? '#FFFFFF' : '#9CA3AF'}
		        />
		      </View>
		    </View>
		  );
		
		  return (
		    <Modal
		      visible={visible}
		      animationType="slide"
		      presentationStyle="pageSheet"
		      onRequestClose={onClose}
		    >
		      <View className="flex-1 bg-gray-100">
		        {/* Header */}
		        <View className="bg-white border-b border-gray-200 px-4 py-3">
		          <View className="flex-row items-center justify-between">
		            <TouchableOpacity onPress={onClose}>
		              <Text className="text-blue-600 text-lg">Cancel</Text>
		            </TouchableOpacity>
		            
		            <Text className="text-xl font-semibold text-gray-900">
		              {isUpdate ? 'Privacy Settings' : 'Privacy Consent'}
		            </Text>
		            
		            <TouchableOpacity onPress={handleSaveConsent}>
		              <Text className="text-blue-600 text-lg font-medium">
		                {isUpdate ? 'Update' : 'Save'}
		              </Text>
		            </TouchableOpacity>
		          </View>
		        </View>
		
		        {/* Content */}
		        <ScrollView className="flex-1" contentContainerStyle={{ padding: 16 }}>
		          {renderDataCollectionInfo()}
		          {renderConsentToggle()}
		          
		          {consent && (
		            <>
		              {renderPrivacyLevelSelector()}
		              {renderDataTypeToggles()}
		            </>
		          )}
		          
		          {renderBenefitsSection()}
		          {renderRightsSection()}
		          
		          {/* Legal Notice */}
		          <View className="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-4">
		            <Text className="text-yellow-800 font-semibold text-sm mb-2">
		              Legal Notice
		            </Text>
		            <Text className="text-yellow-700 text-xs leading-relaxed">
		              This data collection complies with GDPR, CCPA, and other privacy regulations. 
		              Data is processed lawfully under legitimate interest for research and service 
		              improvement. No data is sold to third parties. Data retention follows stated 
		              policies with automatic deletion. For questions, contact privacy@twinshipvibe.com.
		            </Text>
		          </View>
		          
		          {/* Version Info */}
		          <Text className="text-gray-500 text-xs text-center">
		            Consent Version: {consentVersion} • Last Updated: {new Date().toLocaleDateString()}
		          </Text>
		        </ScrollView>
		      </View>
		    </Modal>
		  );
		};
		
		export default PrivacyConsentModal;]]></file>
	<file path='components/ConstellationOverlay.tsx'><![CDATA[
		import React, { useEffect } from "react";
		import { Dimensions } from "react-native";
		import { Canvas, Circle, Line, useValue, useTiming } from "@shopify/react-native-skia";
		import { constellations } from "../utils/constellations";
		
		const { width, height } = Dimensions.get("window");
		
		export const ConstellationOverlay = ({ sign }: { sign: keyof typeof constellations }) => {
		  const constellation = constellations[sign];
		  if (!constellation) return null;
		
		  return (
		    <Canvas style={{ position: "absolute", width, height }}>
		      {/* Stars */}
		      {constellation.stars.map((star, i) => {
		        const progress = useValue(0);
		        useEffect(() => {
		          const duration = 2000 + Math.random() * 4000;
		          const delay = Math.random() * 2000;
		          useTiming(progress, { to: 1, loop: true, yoyo: true, duration, delay });
		        }, []);
		
		        const cx = star.x * width;
		        const cy = star.y * height;
		        const baseRadius = 3;
		        const radius = baseRadius + progress.current * 1.5;
		
		        return <Circle key={i} cx={cx} cy={cy} r={radius} color="white" />;
		      })}
		
		      {/* Lines */}
		      {constellation.lines.map(([a, b], i) => (
		        <Line
		          key={i}
		          p1={{ x: constellation.stars[a].x * width, y: constellation.stars[a].y * height }}
		          p2={{ x: constellation.stars[b].x * width, y: constellation.stars[b].y * height }}
		          color="rgba(255,255,255,0.6)"
		          strokeWidth={1.5}
		        />
		      ))}
		    </Canvas>
		  );
		};]]></file>
	<file path='components/games/GameResult.tsx'><![CDATA[
		import React from 'react';
		import { View, Text, Pressable, Dimensions } from 'react-native';
		import { Ionicons } from '@expo/vector-icons';
		import { LinearGradient } from 'expo-linear-gradient';
		import Animated, {
		  useSharedValue,
		  useAnimatedStyle,
		  withSpring,
		  withSequence,
		  withDelay,
		  runOnJS
		} from 'react-native-reanimated';
		import * as Haptics from 'expo-haptics';
		import { GameSession } from '../../types/games';
		import { getNeonAccentColor } from '../../utils/neonColors';
		import { ThemeColor } from '../../state/twinStore';
		
		interface GameResultProps {
		  session: GameSession;
		  onPlayAgain: () => void;
		  onBackToHub: () => void;
		  themeColor: ThemeColor;
		}
		
		export const GameResult: React.FC<GameResultProps> = ({
		  session,
		  onPlayAgain,
		  onBackToHub,
		  themeColor
		}) => {
		  const { width } = Dimensions.get('window');
		  const accentColor = getNeonAccentColor(themeColor);
		  
		  const scale = useSharedValue(0);
		  const opacity = useSharedValue(0);
		  const scoreScale = useSharedValue(0);
		  
		  React.useEffect(() => {
		    // Entrance animation
		    scale.value = withSpring(1, { damping: 15, stiffness: 200 });
		    opacity.value = withSpring(1);
		    
		    // Delayed score animation
		    scoreScale.value = withDelay(
		      500,
		      withSequence(
		        withSpring(1.3, { damping: 10 }),
		        withSpring(1, { damping: 15 })
		      )
		    );
		    
		    // Haptic feedback for result
		    if (session.syncScore >= 80) {
		      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		    } else if (session.syncScore >= 50) {
		      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
		    } else {
		      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		    }
		  }, []);
		  
		  const containerStyle = useAnimatedStyle(() => {
		    return {
		      transform: [{ scale: scale.value }],
		      opacity: opacity.value
		    };
		  });
		  
		  const scoreStyle = useAnimatedStyle(() => {
		    return {
		      transform: [{ scale: scoreScale.value }]
		    };
		  });
		  
		  const getResultIcon = () => {
		    if (session.syncScore >= 80) return 'checkmark-circle';
		    if (session.syncScore >= 50) return 'flash';
		    return 'close-circle';
		  };
		  
		  const getResultColor = () => {
		    if (session.syncScore >= 80) return '#10b981';
		    if (session.syncScore >= 50) return accentColor;
		    return '#ef4444';
		  };
		  
		  const getResultMessage = () => {
		    if (session.syncScore >= 90) return 'Perfect Synchronicity!';
		    if (session.syncScore >= 80) return 'Incredible Connection!';
		    if (session.syncScore >= 60) return 'Strong Twin Bond!';
		    if (session.syncScore >= 40) return 'Growing Connection';
		    return 'Keep Practicing';
		  };
		  
		  const matches = session.results.filter(r => r.isMatch).length;
		  const totalRounds = session.results.length;
		  
		  return (
		    <Animated.View style={[containerStyle, { flex: 1, justifyContent: 'center', alignItems: 'center', paddingHorizontal: 24 }]}>
		      {/* Main Result Display */}
		      <View className="items-center mb-8">
		        <View className="relative">
		          {/* Glow Effect */}
		          <View 
		            className="absolute inset-0 rounded-full blur-xl"
		            style={{
		              backgroundColor: getResultColor(),
		              opacity: 0.3,
		              width: 120,
		              height: 120,
		              left: -10,
		              top: -10
		            }}
		          />
		          
		          <Ionicons 
		            name={getResultIcon()} 
		            size={100} 
		            color={getResultColor()}
		          />
		        </View>
		        
		        <Animated.View style={scoreStyle} className="items-center mt-6">
		          <Text className="text-white text-4xl font-bold">
		            {session.syncScore}%
		          </Text>
		          <Text className="text-white text-xl mt-2">
		            {getResultMessage()}
		          </Text>
		        </Animated.View>
		      </View>
		      
		      {/* Detailed Results */}
		      <View className="w-full bg-white/10 rounded-2xl p-6 mb-8 backdrop-blur">
		        <Text className="text-white text-lg font-semibold text-center mb-4">
		          Game Summary
		        </Text>
		        
		        <View className="space-y-4">
		          <View className="flex-row justify-between items-center">
		            <Text className="text-white/80">Perfect Matches</Text>
		            <Text className="text-white font-semibold">
		              {matches}/{totalRounds}
		            </Text>
		          </View>
		          
		          <View className="flex-row justify-between items-center">
		            <Text className="text-white/80">Game Type</Text>
		            <Text className="text-white font-semibold capitalize">
		              {session.gameType.replace('_', ' ')}
		            </Text>
		          </View>
		          
		          <View className="flex-row justify-between items-center">
		            <Text className="text-white/80">Duration</Text>
		            <Text className="text-white font-semibold">
		              {session.completedAt && session.startedAt 
		                ? Math.round((new Date(session.completedAt).getTime() - new Date(session.startedAt).getTime()) / 1000)
		                : 0}s
		            </Text>
		          </View>
		          
		          {/* Sync Score Visualization */}
		          <View className="mt-4">
		            <Text className="text-white/80 mb-2">Synchronicity Level</Text>
		            <View className="h-2 bg-white/20 rounded-full overflow-hidden">
		              <LinearGradient
		                colors={[accentColor, getResultColor()]}
		                start={{ x: 0, y: 0 }}
		                end={{ x: 1, y: 0 }}
		                style={{
		                  height: '100%',
		                  width: `${session.syncScore}%`,
		                  borderRadius: 4
		                }}
		              />
		            </View>
		          </View>
		        </View>
		      </View>
		      
		      {/* Round by Round Results */}
		      <View className="w-full bg-white/5 rounded-xl p-4 mb-8">
		        <Text className="text-white text-center mb-3 font-semibold">Round Results</Text>
		        <View className="flex-row justify-center space-x-2">
		          {session.results.map((result, index) => (
		            <View 
		              key={index}
		              className={`w-8 h-8 rounded-full items-center justify-center ${
		                result.isMatch ? 'bg-green-500' : 'bg-red-500/50'
		              }`}
		            >
		              <Text className="text-white text-xs font-bold">
		                {index + 1}
		              </Text>
		            </View>
		          ))}
		        </View>
		      </View>
		      
		      {/* Action Buttons */}
		      <View className="flex-row space-x-4 w-full max-w-sm">
		        <Pressable
		          onPress={onPlayAgain}
		          className="flex-1 py-4 rounded-xl items-center"
		          style={{ backgroundColor: accentColor }}
		        >
		          <Text className="text-white font-semibold text-lg">Play Again</Text>
		        </Pressable>
		        
		        <Pressable
		          onPress={onBackToHub}
		          className="flex-1 bg-white/20 py-4 rounded-xl items-center"
		        >
		          <Text className="text-white font-semibold text-lg">Back to Games</Text>
		        </Pressable>
		      </View>
		      
		      {/* Achievement Notification (if any new achievements) */}
		      {session.syncScore >= 90 && (
		        <View className="absolute top-12 left-4 right-4">
		          <View className="bg-yellow-500/90 rounded-lg p-3 flex-row items-center">
		            <Ionicons name="trophy" size={20} color="white" />
		            <Text className="text-white ml-2 font-semibold">Achievement Unlocked!</Text>
		          </View>
		        </View>
		      )}
		    </Animated.View>
		  );
		};]]></file>
	<file path='components/games/index.ts'>
		export { GameResult } from './GameResult';
		export { SyncScoreDisplay } from './SyncScoreDisplay';</file>
	<file path='components/games/SyncScoreDisplay.tsx'><![CDATA[
		import React from 'react';
		import { View, Text, Dimensions } from 'react-native';
		import { LinearGradient } from 'expo-linear-gradient';
		import { Ionicons } from '@expo/vector-icons';
		import Animated, {
		  useSharedValue,
		  useAnimatedStyle,
		  withSpring,
		  withTiming,
		  useAnimatedProps,
		  interpolate
		} from 'react-native-reanimated';
		import Svg, { Circle } from 'react-native-svg';
		import { SyncScoreMetrics } from '../../types/games';
		import { getNeonAccentColor } from '../../utils/neonColors';
		import { ThemeColor } from '../../state/twinStore';
		
		const AnimatedCircle = Animated.createAnimatedComponent(Circle);
		
		interface SyncScoreDisplayProps {
		  metrics: SyncScoreMetrics;
		  themeColor: ThemeColor;
		  compact?: boolean;
		}
		
		export const SyncScoreDisplay: React.FC<SyncScoreDisplayProps> = ({
		  metrics,
		  themeColor,
		  compact = false
		}) => {
		  const { width } = Dimensions.get('window');
		  const accentColor = getNeonAccentColor(themeColor);
		  
		  const circleProgress = useSharedValue(0);
		  const statsOpacity = useSharedValue(0);
		  
		  React.useEffect(() => {
		    circleProgress.value = withTiming(metrics.syncPercentage / 100, { duration: 1500 });
		    statsOpacity.value = withSpring(1, { damping: 15 });
		  }, [metrics.syncPercentage]);
		  
		  const radius = compact ? 40 : 60;
		  const strokeWidth = compact ? 6 : 8;
		  const circumference = 2 * Math.PI * radius;
		  
		  const animatedCircleProps = useAnimatedProps(() => {
		    const strokeDashoffset = circumference * (1 - circleProgress.value);
		    return {
		      strokeDashoffset
		    };
		  });
		  
		  const statsStyle = useAnimatedStyle(() => {
		    return {
		      opacity: statsOpacity.value,
		      transform: [{ scale: withSpring(statsOpacity.value) }]
		    };
		  });
		  
		  const getSyncLevel = () => {
		    if (metrics.syncPercentage >= 80) return { label: 'Telepathic', color: '#10b981', icon: 'flash' };
		    if (metrics.syncPercentage >= 60) return { label: 'Connected', color: accentColor, icon: 'link' };
		    if (metrics.syncPercentage >= 40) return { label: 'Syncing', color: '#f59e0b', icon: 'pulse' };
		    if (metrics.syncPercentage >= 20) return { label: 'Learning', color: '#8b5cf6', icon: 'school' };
		    return { label: 'Exploring', color: '#6b7280', icon: 'compass' };
		  };
		  
		  const syncLevel = getSyncLevel();
		  
		  if (compact) {
		    return (
		      <View className="flex-row items-center space-x-3">
		        {/* Compact Circular Progress */}
		        <View className="relative">
		          <Svg width={radius * 2 + strokeWidth} height={radius * 2 + strokeWidth}>
		            {/* Background Circle */}
		            <Circle
		              cx={radius + strokeWidth / 2}
		              cy={radius + strokeWidth / 2}
		              r={radius}
		              stroke="rgba(255,255,255,0.2)"
		              strokeWidth={strokeWidth}
		              fill="none"
		            />
		            {/* Progress Circle */}
		            <AnimatedCircle
		              cx={radius + strokeWidth / 2}
		              cy={radius + strokeWidth / 2}
		              r={radius}
		              stroke={syncLevel.color}
		              strokeWidth={strokeWidth}
		              fill="none"
		              strokeDasharray={circumference}
		              strokeLinecap="round"
		              transform={`rotate(-90 ${radius + strokeWidth / 2} ${radius + strokeWidth / 2})`}
		              animatedProps={animatedCircleProps}
		            />
		          </Svg>
		          <View className="absolute inset-0 items-center justify-center">
		            <Text className="text-white text-sm font-bold">
		              {metrics.syncPercentage}%
		            </Text>
		          </View>
		        </View>
		        
		        {/* Compact Stats */}
		        <Animated.View style={statsStyle}>
		          <Text className="text-white font-semibold">{syncLevel.label}</Text>
		          <Text className="text-white/70 text-sm">
		            {metrics.totalGames} games • {metrics.perfectMatches} matches
		          </Text>
		        </Animated.View>
		      </View>
		    );
		  }
		  
		  return (
		    <View className="items-center">
		      {/* Main Sync Circle */}
		      <View className="relative mb-6">
		        {/* Glow Effect */}
		        <View 
		          className="absolute inset-0 rounded-full blur-2xl"
		          style={{
		            backgroundColor: syncLevel.color,
		            opacity: 0.3,
		            width: (radius * 2) + 40,
		            height: (radius * 2) + 40,
		            left: -20,
		            top: -20
		          }}
		        />
		        
		        <Svg width={radius * 2 + strokeWidth} height={radius * 2 + strokeWidth}>
		          {/* Background Circle */}
		          <Circle
		            cx={radius + strokeWidth / 2}
		            cy={radius + strokeWidth / 2}
		            r={radius}
		            stroke="rgba(255,255,255,0.1)"
		            strokeWidth={strokeWidth}
		            fill="none"
		          />
		          {/* Progress Circle */}
		          <AnimatedCircle
		            cx={radius + strokeWidth / 2}
		            cy={radius + strokeWidth / 2}
		            r={radius}
		            stroke={syncLevel.color}
		            strokeWidth={strokeWidth}
		            fill="none"
		            strokeDasharray={circumference}
		            strokeLinecap="round"
		            transform={`rotate(-90 ${radius + strokeWidth / 2} ${radius + strokeWidth / 2})`}
		            animatedProps={animatedCircleProps}
		          />
		        </Svg>
		        
		        {/* Center Content */}
		        <View className="absolute inset-0 items-center justify-center">
		          <Text className="text-white text-2xl font-bold">
		            {metrics.syncPercentage}%
		          </Text>
		          <Text className="text-white/70 text-sm mt-1">
		            Sync Rate
		          </Text>
		        </View>
		      </View>
		      
		      {/* Sync Level Badge */}
		      <View 
		        className="flex-row items-center px-4 py-2 rounded-full mb-4"
		        style={{ backgroundColor: `${syncLevel.color}20` }}
		      >
		        <Ionicons name={syncLevel.icon as any} size={16} color={syncLevel.color} />
		        <Text className="text-white ml-2 font-semibold">
		          {syncLevel.label}
		        </Text>
		      </View>
		      
		      {/* Detailed Stats */}
		      <Animated.View style={statsStyle} className="w-full">
		        <View className="bg-white/10 rounded-xl p-4 backdrop-blur">
		          <View className="flex-row justify-around">
		            <View className="items-center">
		              <Text className="text-white text-lg font-bold">
		                {metrics.totalGames}
		              </Text>
		              <Text className="text-white/70 text-xs">Games</Text>
		            </View>
		            
		            <View className="items-center">
		              <Text className="text-white text-lg font-bold">
		                {metrics.perfectMatches}
		              </Text>
		              <Text className="text-white/70 text-xs">Matches</Text>
		            </View>
		            
		            <View className="items-center">
		              <Text className="text-white text-lg font-bold">
		                {metrics.streakCount}
		              </Text>
		              <Text className="text-white/70 text-xs">Streak</Text>
		            </View>
		            
		            <View className="items-center">
		              <Text className="text-white text-lg font-bold">
		                {metrics.maxStreak}
		              </Text>
		              <Text className="text-white/70 text-xs">Best</Text>
		            </View>
		          </View>
		        </View>
		      </Animated.View>
		      
		      {/* Progress Bar for Next Level */}
		      {metrics.syncPercentage < 100 && (
		        <View className="w-full mt-4">
		          <Text className="text-white/70 text-center text-xs mb-2">
		            Next Level: {getSyncLevel().label}
		          </Text>
		          <View className="h-2 bg-white/20 rounded-full overflow-hidden">
		            <LinearGradient
		              colors={[accentColor, syncLevel.color]}
		              start={{ x: 0, y: 0 }}
		              end={{ x: 1, y: 0 }}
		              style={{
		                height: '100%',
		                width: `${(metrics.syncPercentage % 20) * 5}%`,
		                borderRadius: 4
		              }}
		            />
		          </View>
		        </View>
		      )}
		    </View>
		  );
		};]]></file>
	<file path='components/InvitationButton.tsx'><![CDATA[
		import React from 'react';
		import { Pressable, Text, View, Alert } from 'react-native';
		import { useNavigation } from '@react-navigation/native';
		import { Ionicons } from '@expo/vector-icons';
		import * as Haptics from 'expo-haptics';
		
		import { useTwinStore } from '../state/twinStore';
		import { useInvitationStore } from '../state/invitationStore';
		import { getNeonAccentColor, getNeonAccentColorWithOpacity } from '../utils/neonColors';
		
		interface InvitationButtonProps {
		  variant?: 'primary' | 'secondary' | 'minimal';
		  size?: 'small' | 'medium' | 'large';
		  showIcon?: boolean;
		  disabled?: boolean;
		  onPress?: () => void;
		}
		
		export const InvitationButton: React.FC<InvitationButtonProps> = ({
		  variant = 'primary',
		  size = 'medium',
		  showIcon = true,
		  disabled = false,
		  onPress,
		}) => {
		  const navigation = useNavigation();
		  const { userProfile, paired } = useTwinStore();
		  const { isLoading, invitationStep } = useInvitationStore();
		  
		  const accentColor = userProfile?.accentColor || 'neon-purple';
		  const themeColor = getNeonAccentColor(accentColor);
		  const themeColorWithOpacity = getNeonAccentColorWithOpacity(accentColor, 0.3);
		
		  const handlePress = () => {
		    if (onPress) {
		      onPress();
		      return;
		    }
		
		    if (!userProfile) {
		      Alert.alert('Setup Required', 'Please complete your profile setup first.');
		      return;
		    }
		
		    if (paired) {
		      Alert.alert(
		        'Already Connected',
		        'You are already connected with your twin! You can find them in the Twin Talk chat.',
		        [{ text: 'OK' }]
		      );
		      return;
		    }
		
		    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
		    navigation.navigate('SendInvitation' as never);
		  };
		
		  const getButtonText = () => {
		    if (paired) {
		      return 'Connected';
		    }
		
		    if (isLoading) {
		      return 'Sending...';
		    }
		
		    if (invitationStep === 'sent' || invitationStep === 'success') {
		      return 'Invitation Sent';
		    }
		
		    switch (size) {
		      case 'small':
		        return 'Invite';
		      case 'large':
		        return 'Send Twin Invitation';
		      default:
		        return 'Invite Twin';
		    }
		  };
		
		  const getButtonStyle = () => {
		    const baseStyle = 'rounded-xl items-center justify-center flex-row';
		    
		    const sizeStyles = {
		      small: 'px-3 py-2',
		      medium: 'px-4 py-3',
		      large: 'px-6 py-4',
		    };
		
		    const variantStyles = {
		      primary: paired ? 'bg-green-500/30' : `bg-white/20`,
		      secondary: 'bg-white/10 border border-white/30',
		      minimal: 'bg-transparent',
		    };
		
		    return `${baseStyle} ${sizeStyles[size]} ${variantStyles[variant]}`;
		  };
		
		  const getTextStyle = () => {
		    const sizeStyles = {
		      small: 'text-sm',
		      medium: 'text-base',
		      large: 'text-lg',
		    };
		
		    return `text-white font-semibold ${sizeStyles[size]}`;
		  };
		
		  const getIconSize = () => {
		    switch (size) {
		      case 'small':
		        return 16;
		      case 'large':
		        return 24;
		      default:
		        return 20;
		    }
		  };
		
		  const getIconName = (): keyof typeof Ionicons.glyphMap => {
		    if (paired) {
		      return 'checkmark-circle';
		    }
		
		    if (isLoading) {
		      return 'hourglass';
		    }
		
		    if (invitationStep === 'sent' || invitationStep === 'success') {
		      return 'paper-plane';
		    }
		
		    return 'heart';
		  };
		
		  const getIconColor = () => {
		    if (paired) {
		      return '#10b981'; // green-500
		    }
		
		    return variant === 'primary' ? themeColor : 'rgba(255, 255, 255, 0.8)';
		  };
		
		  return (
		    <Pressable
		      onPress={handlePress}
		      disabled={disabled || isLoading}
		      className={getButtonStyle()}
		      style={{
		        backgroundColor: variant === 'primary' && !paired ? themeColorWithOpacity : undefined,
		        opacity: disabled || isLoading ? 0.6 : 1,
		      }}
		    >
		      {showIcon && (
		        <Ionicons
		          name={getIconName()}
		          size={getIconSize()}
		          color={getIconColor()}
		          style={{ marginRight: 6 }}
		        />
		      )}
		      <Text className={getTextStyle()}>
		        {getButtonText()}
		      </Text>
		    </Pressable>
		  );
		};
		
		// Convenience components for common use cases
		export const InvitationFAB: React.FC<{ onPress?: () => void }> = ({ onPress }) => (
		  <View className="absolute bottom-6 right-6">
		    <InvitationButton
		      variant="primary"
		      size="large"
		      onPress={onPress}
		    />
		  </View>
		);
		
		export const InvitationMenuItem: React.FC<{ onPress?: () => void }> = ({ onPress }) => (
		  <InvitationButton
		    variant="minimal"
		    size="medium"
		    onPress={onPress}
		  />
		);
		
		export const InvitationStatusBadge: React.FC = () => {
		  const { paired, invitationStatus } = useTwinStore();
		  const { invitationStep } = useInvitationStore();
		
		  if (paired) {
		    return (
		      <View className="flex-row items-center bg-green-500/20 rounded-full px-3 py-1">
		        <Ionicons name="checkmark-circle" size={16} color="#10b981" />
		        <Text className="text-green-400 text-xs font-medium ml-1">
		          Connected
		        </Text>
		      </View>
		    );
		  }
		
		  if (invitationStep === 'sent' || invitationStep === 'success') {
		    return (
		      <View className="flex-row items-center bg-blue-500/20 rounded-full px-3 py-1">
		        <Ionicons name="paper-plane" size={16} color="#3b82f6" />
		        <Text className="text-blue-400 text-xs font-medium ml-1">
		          Invitation Sent
		        </Text>
		      </View>
		    );
		  }
		
		  if (invitationStatus === 'received') {
		    return (
		      <View className="flex-row items-center bg-yellow-500/20 rounded-full px-3 py-1">
		        <Ionicons name="mail" size={16} color="#eab308" />
		        <Text className="text-yellow-400 text-xs font-medium ml-1">
		          Invitation Received
		        </Text>
		      </View>
		    );
		  }
		
		  return null;
		};]]></file>
	<file path='components/onboarding/ColorPicker.tsx'><![CDATA[
		import React, { useRef, useEffect } from "react";
		import { View, Text, Pressable, Animated, Dimensions } from "react-native";
		import { LinearGradient } from "expo-linear-gradient";
		import { Ionicons } from "@expo/vector-icons";
		import { ThemeColor } from "../../state/twinStore";
		import { getNeonAccentColor, getNeonGradientColors } from "../../utils/neonColors";
		
		const { width } = Dimensions.get('window');
		
		interface ColorOption {
		  color: ThemeColor;
		  name: string;
		  description: string;
		}
		
		interface ColorPickerProps {
		  colors: ColorOption[];
		  selectedColor: ThemeColor;
		  onColorSelect: (color: ThemeColor) => void;
		}
		
		export const ColorPicker: React.FC<ColorPickerProps> = ({
		  colors,
		  selectedColor,
		  onColorSelect,
		}) => {
		  const animatedValues = useRef(
		    colors.map(() => new Animated.Value(0))
		  ).current;
		
		  useEffect(() => {
		    // Animate colors in sequence
		    const animations = animatedValues.map((value, index) =>
		      Animated.timing(value, {
		        toValue: 1,
		        duration: 200,
		        delay: index * 100,
		        useNativeDriver: true,
		      })
		    );
		
		    Animated.stagger(50, animations).start();
		  }, []);
		
		  const ColorOption: React.FC<{
		    colorOption: ColorOption;
		    index: number;
		    isSelected: boolean;
		    onSelect: () => void;
		  }> = ({ colorOption, index, isSelected, onSelect }) => {
		    const accentColor = getNeonAccentColor(colorOption.color);
		    const gradientColors = getNeonGradientColors(colorOption.color);
		    const scaleAnim = useRef(new Animated.Value(1)).current;
		
		    const handlePressIn = () => {
		      Animated.spring(scaleAnim, {
		        toValue: 0.95,
		        useNativeDriver: true,
		      }).start();
		    };
		
		    const handlePressOut = () => {
		      Animated.spring(scaleAnim, {
		        toValue: 1,
		        useNativeDriver: true,
		      }).start();
		    };
		
		    return (
		      <Animated.View
		        style={{
		          opacity: animatedValues[index],
		          transform: [
		            { 
		              scale: animatedValues[index].interpolate({
		                inputRange: [0, 1],
		                outputRange: [0.8, 1],
		              })
		            },
		            { scale: scaleAnim }
		          ],
		        }}
		        className="flex-1 mx-1"
		      >
		        <Pressable
		          onPress={onSelect}
		          onPressIn={handlePressIn}
		          onPressOut={handlePressOut}
		          className={`items-center p-3 rounded-2xl border-2 ${
		            isSelected 
		              ? 'bg-white/15 border-white/50' 
		              : 'bg-white/5 border-white/20'
		          }`}
		        >
		          {/* Color Circle with Gradient */}
		          <View className="relative mb-3">
		            <LinearGradient
		              colors={gradientColors}
		              className="w-12 h-12 rounded-full items-center justify-center"
		              start={{ x: 0, y: 0 }}
		              end={{ x: 1, y: 1 }}
		            >
		              {isSelected && (
		                <Ionicons name="checkmark" size={20} color="white" />
		              )}
		            </LinearGradient>
		            
		            {/* Glow effect for selected */}
		            {isSelected && (
		              <>
		                <View 
		                  className="absolute inset-0 w-12 h-12 rounded-full opacity-50"
		                  style={{ 
		                    backgroundColor: accentColor,
		                    shadowColor: accentColor,
		                    shadowOpacity: 0.8,
		                    shadowRadius: 10,
		                    elevation: 10,
		                  }}
		                />
		                <View 
		                  className="absolute -inset-1 w-14 h-14 rounded-full border opacity-60"
		                  style={{ borderColor: accentColor }}
		                />
		              </>
		            )}
		          </View>
		
		          {/* Color Name */}
		          <Text className={`text-xs font-medium text-center ${
		            isSelected ? 'text-white' : 'text-white/70'
		          }`}>
		            {colorOption.name.split(' ')[1]} {/* Show just the color name */}
		          </Text>
		        </Pressable>
		      </Animated.View>
		    );
		  };
		
		  return (
		    <View>
		      <Text className="text-white text-lg font-semibold text-center mb-6">
		        Choose Your Color
		      </Text>
		      
		      {/* Color Grid */}
		      <View className="flex-row flex-wrap justify-center">
		        {/* First row - 4 colors */}
		        <View className="flex-row w-full mb-4">
		          {colors.slice(0, 4).map((color, index) => (
		            <ColorOption
		              key={color.color}
		              colorOption={color}
		              index={index}
		              isSelected={selectedColor === color.color}
		              onSelect={() => onColorSelect(color.color)}
		            />
		          ))}
		        </View>
		        
		        {/* Second row - 4 colors */}
		        <View className="flex-row w-full">
		          {colors.slice(4, 8).map((color, index) => (
		            <ColorOption
		              key={color.color}
		              colorOption={color}
		              index={index + 4}
		              isSelected={selectedColor === color.color}
		              onSelect={() => onColorSelect(color.color)}
		            />
		          ))}
		        </View>
		      </View>
		
		      {/* Color Harmony Note */}
		      <View className="mt-8 p-4 rounded-xl bg-white/5 border border-white/10">
		        <View className="flex-row items-center justify-center mb-2">
		          <Ionicons name="color-palette" size={16} color="rgba(255,255,255,0.6)" />
		          <Text className="text-white/60 text-sm ml-2 font-medium">
		            Color Harmony
		          </Text>
		        </View>
		        <Text className="text-white/50 text-xs text-center leading-5">
		          Each color reflects different aspects of your personality. 
		          Choose the one that feels most like you.
		        </Text>
		      </View>
		    </View>
		  );
		};]]></file>
	<file path='components/onboarding/TwinTypeSelector.tsx'><![CDATA[
		import React, { useRef, useEffect } from "react";
		import { View, Text, Pressable, Animated } from "react-native";
		import { LinearGradient } from "expo-linear-gradient";
		import { Ionicons } from "@expo/vector-icons";
		import { TwinType } from "../../state/twinStore";
		
		interface TwinTypeData {
		  type: TwinType;
		  title: string;
		  subtitle: string;
		  description: string;
		  icon: keyof typeof Ionicons.glyphMap;
		  features: string[];
		}
		
		interface TwinTypeSelectorProps {
		  twinType: TwinTypeData;
		  isSelected: boolean;
		  onSelect: (type: TwinType) => void;
		  showDetails: boolean;
		}
		
		export const TwinTypeSelector: React.FC<TwinTypeSelectorProps> = ({
		  twinType,
		  isSelected,
		  onSelect,
		  showDetails,
		}) => {
		  const slideAnim = useRef(new Animated.Value(0)).current;
		  const heightAnim = useRef(new Animated.Value(0)).current;
		
		  useEffect(() => {
		    if (showDetails) {
		      Animated.parallel([
		        Animated.timing(slideAnim, {
		          toValue: 1,
		          duration: 300,
		          useNativeDriver: false,
		        }),
		        Animated.timing(heightAnim, {
		          toValue: 1,
		          duration: 300,
		          useNativeDriver: false,
		        }),
		      ]).start();
		    } else {
		      Animated.parallel([
		        Animated.timing(slideAnim, {
		          toValue: 0,
		          duration: 200,
		          useNativeDriver: false,
		        }),
		        Animated.timing(heightAnim, {
		          toValue: 0,
		          duration: 200,
		          useNativeDriver: false,
		        }),
		      ]).start();
		    }
		  }, [showDetails]);
		
		  const getTypeColor = (type: TwinType): string => {
		    switch (type) {
		      case 'identical':
		        return '#ff69b4'; // Pink for identical
		      case 'fraternal':
		        return '#00bfff'; // Blue for fraternal  
		      case 'other':
		        return '#9370db'; // Purple for other
		      default:
		        return '#ffffff';
		    }
		  };
		
		  const typeColor = getTypeColor(twinType.type);
		
		  return (
		    <Pressable
		      onPress={() => onSelect(twinType.type)}
		      className={`rounded-2xl border-2 overflow-hidden ${
		        isSelected 
		          ? 'bg-white/15 border-white/40' 
		          : 'bg-white/5 border-white/20'
		      }`}
		      style={({ pressed }) => ({
		        opacity: pressed ? 0.8 : 1,
		        transform: [{ scale: pressed ? 0.98 : 1 }],
		      })}
		    >
		      <LinearGradient
		        colors={isSelected 
		          ? ['rgba(255,255,255,0.15)', 'rgba(255,255,255,0.05)']
		          : ['rgba(255,255,255,0.05)', 'rgba(255,255,255,0.02)']
		        }
		        className="p-6"
		      >
		        <View className="flex-row items-center">
		          {/* Selection Radio */}
		          <View className={`w-6 h-6 rounded-full border-2 mr-4 items-center justify-center ${
		            isSelected ? 'border-white/70' : 'border-white/30'
		          }`}>
		            {isSelected && (
		              <View 
		                className="w-3 h-3 rounded-full" 
		                style={{ backgroundColor: typeColor }}
		              />
		            )}
		          </View>
		
		          {/* Icon */}
		          <View 
		            className="w-12 h-12 rounded-full items-center justify-center mr-4"
		            style={{ backgroundColor: `${typeColor}20` }}
		          >
		            <Ionicons 
		              name={twinType.icon} 
		              size={24} 
		              color={typeColor}
		            />
		          </View>
		
		          {/* Content */}
		          <View className="flex-1">
		            <Text className="text-white text-xl font-semibold mb-1">
		              {twinType.title}
		            </Text>
		            <Text className="text-white/60 text-sm">
		              {twinType.subtitle}
		            </Text>
		          </View>
		
		          {/* Expand Indicator */}
		          <Ionicons 
		            name={showDetails ? "chevron-up" : "chevron-down"} 
		            size={20} 
		            color="rgba(255,255,255,0.4)" 
		          />
		        </View>
		
		        {/* Expandable Details */}
		        <Animated.View
		          style={{
		            height: heightAnim.interpolate({
		              inputRange: [0, 1],
		              outputRange: [0, 200], // Adjust based on content
		            }),
		            opacity: slideAnim,
		          }}
		        >
		          <View className="mt-6 pt-6 border-t border-white/10">
		            <Text className="text-white/80 text-base mb-4 leading-6">
		              {twinType.description}
		            </Text>
		
		            <Text className="text-white text-sm font-semibold mb-3">
		              Key Characteristics:
		            </Text>
		
		            <View className="space-y-2">
		              {twinType.features.map((feature, index) => (
		                <View key={index} className="flex-row items-center">
		                  <View 
		                    className="w-1.5 h-1.5 rounded-full mr-3" 
		                    style={{ backgroundColor: typeColor }}
		                  />
		                  <Text className="text-white/70 text-sm flex-1">
		                    {feature}
		                  </Text>
		                </View>
		              ))}
		            </View>
		
		            {/* Scientific Note */}
		            <View className="mt-4 p-3 rounded-lg bg-white/5 border border-white/10">
		              <Text className="text-white/60 text-xs leading-5">
		                {twinType.type === 'identical' && 
		                  "Research shows identical twins may have heightened synchronicity and shared sensory experiences."
		                }
		                {twinType.type === 'fraternal' && 
		                  "Studies indicate fraternal twins develop unique complementary strengths and perspectives."
		                }
		                {twinType.type === 'other' && 
		                  "All twin relationships create profound psychological and emotional bonds regardless of biology."
		                }
		              </Text>
		            </View>
		          </View>
		        </Animated.View>
		      </LinearGradient>
		    </Pressable>
		  );
		};]]></file>
	<file path='components/premium/PremiumBadge.tsx'><![CDATA[
		import React from "react";
		import { View, Text, TouchableOpacity } from "react-native";
		import { Ionicons } from "@expo/vector-icons";
		import { useTwinStore } from "../../state/twinStore";
		import { useSubscriptionStore } from "../../state/subscriptionStore";
		import { getNeonAccentColor } from "../../utils/neonColors";
		
		interface PremiumBadgeProps {
		  featureId: string;
		  size?: "small" | "medium" | "large";
		  variant?: "badge" | "button" | "icon";
		  onPress?: () => void;
		  showText?: boolean;
		}
		
		export const PremiumBadge: React.FC<PremiumBadgeProps> = ({
		  featureId,
		  size = "medium",
		  variant = "badge",
		  onPress,
		  showText = true
		}) => {
		  const userProfile = useTwinStore((state) => state.userProfile);
		  const hasAccessTo = useSubscriptionStore((state) => state.hasAccessTo);
		  const trackConversionEvent = useSubscriptionStore((state) => state.trackConversionEvent);
		  
		  const accentColor = userProfile?.accentColor || "neon-purple";
		  const neonColor = getNeonAccentColor(accentColor);
		  const hasAccess = hasAccessTo(featureId);
		
		  const handlePress = () => {
		    if (onPress) {
		      trackConversionEvent('premium_badge_clicked', { featureId, variant });
		      onPress();
		    }
		  };
		
		  // Don't show badge if user has access
		  if (hasAccess) {
		    return null;
		  }
		
		  const getSizeStyles = () => {
		    switch (size) {
		      case "small":
		        return {
		          container: "px-2 py-1",
		          text: "text-xs",
		          icon: 12
		        };
		      case "large": 
		        return {
		          container: "px-4 py-2",
		          text: "text-sm",
		          icon: 16
		        };
		      default:
		        return {
		          container: "px-3 py-1.5",
		          text: "text-xs",
		          icon: 14
		        };
		    }
		  };
		
		  const sizeStyles = getSizeStyles();
		
		  if (variant === "icon") {
		    return (
		      <TouchableOpacity
		        onPress={handlePress}
		        disabled={!onPress}
		        style={{ 
		          backgroundColor: `${neonColor}20`,
		          opacity: onPress ? 1 : 0.8
		        }}
		        className="w-6 h-6 rounded-full items-center justify-center"
		      >
		        <Ionicons name="star" size={sizeStyles.icon} color={neonColor} />
		      </TouchableOpacity>
		    );
		  }
		
		  if (variant === "button") {
		    return (
		      <TouchableOpacity
		        onPress={handlePress}
		        disabled={!onPress}
		        style={{ backgroundColor: `${neonColor}20`, borderColor: neonColor }}
		        className={`${sizeStyles.container} rounded-full border flex-row items-center ${!onPress ? 'opacity-60' : ''}`}
		      >
		        <Ionicons name="star" size={sizeStyles.icon} color={neonColor} />
		        {showText && (
		          <Text 
		            className={`${sizeStyles.text} font-bold ml-1`}
		            style={{ color: neonColor }}
		          >
		            PREMIUM
		          </Text>
		        )}
		      </TouchableOpacity>
		    );
		  }
		
		  // Default badge variant
		  return (
		    <View
		      style={{ backgroundColor: `${neonColor}20` }}
		      className={`${sizeStyles.container} rounded-full flex-row items-center`}
		    >
		      <Ionicons name="star" size={sizeStyles.icon} color={neonColor} />
		      {showText && (
		        <Text 
		          className={`${sizeStyles.text} font-bold ml-1`}
		          style={{ color: neonColor }}
		        >
		          PRO
		        </Text>
		      )}
		    </View>
		  );
		};
		
		// Utility component for quick feature labeling
		export const PremiumLabel: React.FC<{ featureId: string }> = ({ featureId }) => {
		  return (
		    <PremiumBadge 
		      featureId={featureId}
		      size="small"
		      variant="badge"
		      showText={true}
		    />
		  );
		};
		
		// Utility component for upgrade buttons
		export const PremiumUpgradeButton: React.FC<{ 
		  featureId: string; 
		  onUpgrade: () => void;
		  text?: string; 
		}> = ({ 
		  featureId, 
		  onUpgrade, 
		  text = "UPGRADE" 
		}) => {
		  const userProfile = useTwinStore((state) => state.userProfile);
		  const hasAccessTo = useSubscriptionStore((state) => state.hasAccessTo);
		  const accentColor = userProfile?.accentColor || "neon-purple";
		  const neonColor = getNeonAccentColor(accentColor);
		
		  if (hasAccessTo(featureId)) {
		    return null;
		  }
		
		  return (
		    <TouchableOpacity
		      onPress={onUpgrade}
		      style={{ backgroundColor: neonColor }}
		      className="px-4 py-2 rounded-full flex-row items-center"
		    >
		      <Ionicons name="star" size={14} color="black" />
		      <Text className="text-black font-bold text-sm ml-1">
		        {text}
		      </Text>
		    </TouchableOpacity>
		  );
		};]]></file>
	<file path='components/premium/PremiumFeatureList.tsx'><![CDATA[
		import React from "react";
		import { View, Text, ScrollView } from "react-native";
		import { Ionicons } from "@expo/vector-icons";
		import { LinearGradient } from "expo-linear-gradient";
		import { PREMIUM_FEATURES, PremiumFeature } from "../../types/premium/subscription";
		import { useTwinStore } from "../../state/twinStore";
		import { useSubscriptionStore } from "../../state/subscriptionStore";
		import { getNeonAccentColor } from "../../utils/neonColors";
		
		interface PremiumFeatureListProps {
		  showComparison?: boolean;
		  highlightPremium?: boolean;
		}
		
		export const PremiumFeatureList: React.FC<PremiumFeatureListProps> = ({
		  showComparison = true,
		  highlightPremium = true
		}) => {
		  const userProfile = useTwinStore((state) => state.userProfile);
		  const hasAccessTo = useSubscriptionStore((state) => state.hasAccessTo);
		  const accentColor = userProfile?.accentColor || "neon-purple";
		  const neonColor = getNeonAccentColor(accentColor);
		
		  const getFeatureIcon = (iconName: string) => {
		    const iconMap: Record<string, keyof typeof Ionicons.glyphMap> = {
		      analytics: "analytics",
		      fitness: "fitness",
		      "document-text": "document-text",
		      "stats-chart": "stats-chart",
		      bulb: "bulb",
		      refresh: "refresh"
		    };
		    return iconMap[iconName] || "star";
		  };
		
		  const groupedFeatures = PREMIUM_FEATURES.reduce((acc, feature) => {
		    if (!acc[feature.category]) {
		      acc[feature.category] = [];
		    }
		    acc[feature.category].push(feature);
		    return acc;
		  }, {} as Record<string, PremiumFeature[]>);
		
		  const categoryTitles: Record<string, string> = {
		    assessment: "Assessment & Analysis",
		    coaching: "Personal Growth",
		    analytics: "Progress Tracking", 
		    export: "Report Generation",
		    insights: "AI Intelligence"
		  };
		
		  return (
		    <ScrollView 
		      className="flex-1"
		      showsVerticalScrollIndicator={false}
		      contentContainerStyle={{ paddingBottom: 20 }}
		    >
		      {showComparison && (
		        <View className="mb-6">
		          <Text className="text-white text-2xl font-bold text-center mb-2">
		            Free vs Premium
		          </Text>
		          <Text className="text-gray-400 text-center px-4">
		            Unlock the full potential of your twin bond
		          </Text>
		        </View>
		      )}
		
		      {/* Free features */}
		      <View className="mb-8">
		        <View className="flex-row items-center mb-4">
		          <View 
		            className="w-3 h-3 rounded-full mr-3"
		            style={{ backgroundColor: '#10b981' }}
		          />
		          <Text className="text-white text-lg font-semibold">
		            Free Features
		          </Text>
		        </View>
		        
		        <View className="bg-gray-800/30 rounded-2xl p-4 border border-gray-700">
		          {[
		            "Basic assessment results",
		            "Twin pairing & chat", 
		            "Psychic games",
		            "Story sharing",
		            "Basic twintuition alerts"
		          ].map((feature, index) => (
		            <View key={index} className="flex-row items-center py-2">
		              <Ionicons name="checkmark-circle" size={20} color="#10b981" />
		              <Text className="text-gray-300 text-sm ml-3">{feature}</Text>
		            </View>
		          ))}
		        </View>
		      </View>
		
		      {/* Premium features by category */}
		      {Object.entries(groupedFeatures).map(([category, features]) => (
		        <View key={category} className="mb-8">
		          <View className="flex-row items-center mb-4">
		            <View 
		              className="w-3 h-3 rounded-full mr-3"
		              style={{ backgroundColor: neonColor }}
		            />
		            <Text className="text-white text-lg font-semibold">
		              {categoryTitles[category]} 
		            </Text>
		            <View 
		              className="ml-2 px-2 py-1 rounded-full"
		              style={{ backgroundColor: `${neonColor}20` }}
		            >
		              <Text 
		                className="text-xs font-bold"
		                style={{ color: neonColor }}
		              >
		                PREMIUM
		              </Text>
		            </View>
		          </View>
		
		          <LinearGradient
		            colors={[
		              `${neonColor}10`, 
		              'rgba(0, 0, 0, 0.2)', 
		              `${neonColor}05`
		            ]}
		            className="rounded-2xl p-4 border"
		            style={{ borderColor: `${neonColor}40` }}
		          >
		            {features.map((feature, index) => {
		              const userHasAccess = hasAccessTo(feature.id);
		              
		              return (
		                <View key={feature.id} className="py-3">
		                  <View className="flex-row items-center mb-2">
		                    <View 
		                      className="w-10 h-10 rounded-full items-center justify-center mr-3"
		                      style={{ backgroundColor: `${neonColor}20` }}
		                    >
		                      <Ionicons 
		                        name={getFeatureIcon(feature.icon)} 
		                        size={20} 
		                        color={neonColor} 
		                      />
		                    </View>
		                    
		                    <View className="flex-1">
		                      <Text className="text-white font-semibold text-base">
		                        {feature.name}
		                      </Text>
		                      <Text className="text-gray-400 text-sm mt-1">
		                        {feature.description}
		                      </Text>
		                    </View>
		
		                    <View className="ml-2">
		                      {userHasAccess ? (
		                        <View 
		                          className="w-6 h-6 rounded-full items-center justify-center"
		                          style={{ backgroundColor: neonColor }}
		                        >
		                          <Ionicons name="checkmark" size={14} color="black" />
		                        </View>
		                      ) : (
		                        <View 
		                          className="w-6 h-6 rounded-full items-center justify-center border-2"
		                          style={{ borderColor: '#6b7280' }}
		                        >
		                          <Ionicons name="lock-closed" size={12} color="#6b7280" />
		                        </View>
		                      )}
		                    </View>
		                  </View>
		
		                  {/* Feature teaser */}
		                  {feature.teaser && !userHasAccess && highlightPremium && (
		                    <View 
		                      className="mt-2 p-3 rounded-lg border-l-4"
		                      style={{ 
		                        backgroundColor: 'rgba(0, 0, 0, 0.3)',
		                        borderLeftColor: neonColor 
		                      }}
		                    >
		                      <Text 
		                        className="text-sm font-semibold mb-1"
		                        style={{ color: neonColor }}
		                      >
		                        {feature.teaser.title}
		                      </Text>
		                      <Text className="text-gray-400 text-xs">
		                        {feature.teaser.content}
		                      </Text>
		                    </View>
		                  )}
		
		                  {index < features.length - 1 && (
		                    <View className="mt-3 h-px bg-gray-700/50" />
		                  )}
		                </View>
		              );
		            })}
		          </LinearGradient>
		        </View>
		      ))}
		
		      {/* Bottom CTA */}
		      <View className="mt-4 p-6 rounded-2xl border" style={{ borderColor: neonColor }}>
		        <View className="items-center">
		          <Ionicons name="star" size={32} color={neonColor} />
		          <Text className="text-white text-xl font-bold text-center mt-2">
		            Unlock Your Twin Potential
		          </Text>
		          <Text className="text-gray-400 text-center mt-2">
		            Get personalized insights, coaching plans, and detailed analytics to strengthen your twin bond
		          </Text>
		        </View>
		      </View>
		    </ScrollView>
		  );
		};]]></file>
	<file path='components/premium/PremiumFeatureTeaser.tsx'><![CDATA[
		import React from "react";
		import { View, Text, TouchableOpacity } from "react-native";
		import { LinearGradient } from "expo-linear-gradient";
		import { Ionicons } from "@expo/vector-icons";
		import { useTwinStore } from "../../state/twinStore";
		import { useSubscriptionStore } from "../../state/subscriptionStore";
		import { getNeonAccentColor } from "../../utils/neonColors";
		import { PremiumFeature } from "../../types/premium/subscription";
		
		interface PremiumFeatureTeaserProps {
		  feature: PremiumFeature;
		  onUpgrade: () => void;
		  children?: React.ReactNode;
		  showPreview?: boolean;
		  customMessage?: string;
		}
		
		export const PremiumFeatureTeaser: React.FC<PremiumFeatureTeaserProps> = ({
		  feature,
		  onUpgrade,
		  children,
		  showPreview = true,
		  customMessage
		}) => {
		  const userProfile = useTwinStore((state) => state.userProfile);
		  const hasAccessTo = useSubscriptionStore((state) => state.hasAccessTo);
		  const trackConversionEvent = useSubscriptionStore((state) => state.trackConversionEvent);
		  
		  const accentColor = userProfile?.accentColor || "neon-purple";
		  const neonColor = getNeonAccentColor(accentColor);
		
		  const hasAccess = hasAccessTo(feature.id);
		
		  const handleUpgradePress = () => {
		    trackConversionEvent('feature_teaser_upgrade_clicked', { 
		      featureId: feature.id,
		      featureName: feature.name 
		    });
		    onUpgrade();
		  };
		
		  // If user has access, just render children
		  if (hasAccess) {
		    return <>{children}</>;
		  }
		
		  const getFeatureIcon = (iconName: string) => {
		    const iconMap: Record<string, keyof typeof Ionicons.glyphMap> = {
		      analytics: "analytics",
		      fitness: "fitness",
		      "document-text": "document-text",
		      "stats-chart": "stats-chart",
		      bulb: "bulb",
		      refresh: "refresh"
		    };
		    return iconMap[iconName] || "star";
		  };
		
		  return (
		    <View className="relative">
		      {/* Blurred/Dimmed Content */}
		      {children && (
		        <View className="opacity-30 blur-sm">
		          {children}
		        </View>
		      )}
		
		      {/* Overlay */}
		      <LinearGradient
		        colors={[
		          'rgba(0, 0, 0, 0.8)',
		          'rgba(0, 0, 0, 0.9)',
		          'rgba(0, 0, 0, 0.8)'
		        ]}
		        className="absolute inset-0 items-center justify-center p-6 rounded-2xl"
		      >
		        {/* Premium badge */}
		        <View 
		          className="px-3 py-1 rounded-full mb-4"
		          style={{ backgroundColor: `${neonColor}20`, borderColor: neonColor, borderWidth: 1 }}
		        >
		          <Text 
		            className="text-xs font-bold"
		            style={{ color: neonColor }}
		          >
		            PREMIUM FEATURE
		          </Text>
		        </View>
		
		        {/* Feature icon */}
		        <View 
		          className="w-16 h-16 rounded-full items-center justify-center mb-4"
		          style={{ backgroundColor: `${neonColor}20` }}
		        >
		          <Ionicons 
		            name={getFeatureIcon(feature.icon)} 
		            size={32} 
		            color={neonColor} 
		          />
		        </View>
		
		        {/* Content */}
		        <Text className="text-white text-xl font-bold text-center mb-2">
		          {feature.teaser?.title || feature.name}
		        </Text>
		        
		        <Text className="text-gray-300 text-center text-sm mb-6 px-4">
		          {customMessage || feature.teaser?.content || feature.description}
		        </Text>
		
		        {/* Preview content if available */}
		        {showPreview && feature.teaser?.preview && (
		          <View 
		            className="mb-6 p-4 rounded-xl border-l-4 w-full max-w-sm"
		            style={{ 
		              backgroundColor: 'rgba(255, 255, 255, 0.05)',
		              borderLeftColor: neonColor 
		            }}
		          >
		            <Text className="text-gray-400 text-xs mb-1">PREVIEW</Text>
		            {feature.teaser.preview}
		          </View>
		        )}
		
		        {/* Upgrade Button */}
		        <TouchableOpacity
		          onPress={handleUpgradePress}
		          style={{ backgroundColor: neonColor }}
		          className="py-3 px-8 rounded-full"
		        >
		          <View className="flex-row items-center">
		            <Ionicons name="star" size={16} color="black" />
		            <Text className="text-black font-bold ml-2">
		              Unlock the full analysis of your Twinship
		            </Text>
		          </View>
		        </TouchableOpacity>
		
		        {/* Small legal text */}
		        <Text className="text-gray-500 text-xs text-center mt-4">
		          Start your free trial today
		        </Text>
		      </LinearGradient>
		    </View>
		  );
		};
		
		// Higher-order component for easy feature gating
		export const withPremiumGate = <P extends object>(
		  WrappedComponent: React.ComponentType<P>,
		  feature: PremiumFeature,
		  onUpgrade: () => void
		) => {
		  return (props: P) => {
		    const hasAccessTo = useSubscriptionStore((state) => state.hasAccessTo);
		    
		    if (hasAccessTo(feature.id)) {
		      return <WrappedComponent {...props} />;
		    }
		    
		    return (
		      <PremiumFeatureTeaser feature={feature} onUpgrade={onUpgrade}>
		        <WrappedComponent {...props} />
		      </PremiumFeatureTeaser>
		    );
		  };
		};]]></file>
	<file path='components/premium/PremiumGatedContent.tsx'><![CDATA[
		import React, { ReactNode } from "react";
		import { View, TouchableOpacity, Text } from "react-native";
		import { LinearGradient } from "expo-linear-gradient";
		import { BlurView } from "expo-blur";
		import { Ionicons } from "@expo/vector-icons";
		
		import { PremiumFeatureTeaser } from "./PremiumFeatureTeaser";
		import { usePremiumFeatures } from "../../hooks/usePremiumFeatures";
		import { PREMIUM_FEATURES } from "../../types/premium/subscription";
		import { useTwinStore } from "../../state/twinStore";
		import { getNeonAccentColor } from "../../utils/neonColors";
		
		interface PremiumGatedContentProps {
		  featureId: string;
		  children: ReactNode;
		  fallbackComponent?: ReactNode;
		  gateType?: "teaser" | "blur" | "overlay" | "replacement";
		  showPreview?: boolean;
		  customMessage?: string;
		  onUpgradeRequest?: () => void;
		}
		
		/**
		 * Component that gates content behind premium subscription
		 * Automatically handles display logic based on user's subscription status
		 */
		export const PremiumGatedContent: React.FC<PremiumGatedContentProps> = ({
		  featureId,
		  children,
		  fallbackComponent,
		  gateType = "teaser",
		  showPreview = true,
		  customMessage,
		  onUpgradeRequest
		}) => {
		  const { hasAccessTo, navigateToUpgrade } = usePremiumFeatures();
		  const userProfile = useTwinStore((state) => state.userProfile);
		  const accentColor = userProfile?.accentColor || "neon-purple";
		  const neonColor = getNeonAccentColor(accentColor);
		  
		  const hasAccess = hasAccessTo(featureId);
		  const feature = PREMIUM_FEATURES.find(f => f.id === featureId);
		
		  const handleUpgrade = () => {
		    if (onUpgradeRequest) {
		      onUpgradeRequest();
		    } else {
		      navigateToUpgrade(featureId, 'gated_content');
		    }
		  };
		
		  // If user has access, show content normally
		  if (hasAccess) {
		    return <>{children}</>;
		  }
		
		  // If no feature found, show error state
		  if (!feature) {
		    console.warn(`Premium feature not found: ${featureId}`);
		    return <>{children}</>;
		  }
		
		  // Handle different gate types
		  switch (gateType) {
		    case "blur":
		      return (
		        <View className="relative">
		          <BlurView intensity={80} className="absolute inset-0 z-10">
		            <View className="flex-1 items-center justify-center bg-black/30">
		              <TouchableOpacity
		                onPress={handleUpgrade}
		                style={{ backgroundColor: neonColor }}
		                className="px-6 py-3 rounded-full flex-row items-center"
		              >
		                <Ionicons name="star" size={16} color="black" />
		                <Text className="text-black font-bold ml-2">
		                  Unlock Premium
		                </Text>
		              </TouchableOpacity>
		            </View>
		          </BlurView>
		          {children}
		        </View>
		      );
		
		    case "overlay":
		      return (
		        <View className="relative">
		          <View className="opacity-30">
		            {children}
		          </View>
		          <View className="absolute inset-0 items-center justify-center bg-black/50">
		            <View 
		              className="p-6 rounded-2xl border items-center max-w-sm"
		              style={{ 
		                backgroundColor: 'rgba(0, 0, 0, 0.8)',
		                borderColor: neonColor 
		              }}
		            >
		              <Ionicons name="lock-closed" size={32} color={neonColor} />
		              <Text className="text-white font-bold text-lg mt-3 text-center">
		                Premium Feature
		              </Text>
		              <Text className="text-gray-400 text-sm mt-2 text-center">
		                {customMessage || feature.description}
		              </Text>
		              <TouchableOpacity
		                onPress={handleUpgrade}
		                style={{ backgroundColor: neonColor }}
		                className="mt-4 px-4 py-2 rounded-full"
		              >
		                <Text className="text-black font-bold">Upgrade</Text>
		              </TouchableOpacity>
		            </View>
		          </View>
		        </View>
		      );
		
		    case "replacement":
		      if (fallbackComponent) {
		        return <>{fallbackComponent}</>;
		      }
		      return (
		        <View 
		          className="p-8 rounded-2xl border-2 border-dashed items-center"
		          style={{ borderColor: neonColor }}
		        >
		          <Ionicons name="star-outline" size={48} color={neonColor} />
		          <Text className="text-white font-bold text-lg mt-4 text-center">
		            {feature.name}
		          </Text>
		          <Text className="text-gray-400 text-sm mt-2 text-center">
		            {customMessage || feature.description}
		          </Text>
		          <TouchableOpacity
		            onPress={handleUpgrade}
		            style={{ backgroundColor: neonColor }}
		            className="mt-4 px-6 py-3 rounded-full"
		          >
		            <Text className="text-black font-bold">Unlock Now</Text>
		          </TouchableOpacity>
		        </View>
		      );
		
		    case "teaser":
		    default:
		      return (
		        <PremiumFeatureTeaser
		          feature={feature}
		          onUpgrade={handleUpgrade}
		          showPreview={showPreview}
		          customMessage={customMessage}
		        >
		          {children}
		        </PremiumFeatureTeaser>
		      );
		  }
		};
		
		/**
		 * Simpler wrapper for components that should be completely hidden if not premium
		 */
		export const PremiumOnly: React.FC<{ featureId: string; children: ReactNode }> = ({
		  featureId,
		  children
		}) => {
		  const { hasAccessTo } = usePremiumFeatures();
		  
		  if (hasAccessTo(featureId)) {
		    return <>{children}</>;
		  }
		  
		  return null;
		};
		
		/**
		 * Component that shows different content for free vs premium users
		 */
		export const PremiumConditional: React.FC<{
		  featureId: string;
		  freeContent: ReactNode;
		  premiumContent: ReactNode;
		}> = ({
		  featureId,
		  freeContent,
		  premiumContent
		}) => {
		  const { hasAccessTo } = usePremiumFeatures();
		  
		  return <>{hasAccessTo(featureId) ? premiumContent : freeContent}</>;
		};]]></file>
	<file path='components/premium/PremiumStatusIndicator.tsx'><![CDATA[
		import React from "react";
		import { View, Text, TouchableOpacity } from "react-native";
		import { Ionicons } from "@expo/vector-icons";
		import { LinearGradient } from "expo-linear-gradient";
		import { useTwinStore } from "../../state/twinStore";
		import { useSubscriptionStore } from "../../state/subscriptionStore";
		import { usePremiumFeatures } from "../../hooks/usePremiumFeatures";
		import { getNeonAccentColor } from "../../utils/neonColors";
		
		interface PremiumStatusIndicatorProps {
		  variant?: "compact" | "full" | "minimal";
		  showUpgradeButton?: boolean;
		  onUpgradePress?: () => void;
		}
		
		export const PremiumStatusIndicator: React.FC<PremiumStatusIndicatorProps> = ({
		  variant = "compact",
		  showUpgradeButton = true,
		  onUpgradePress
		}) => {
		  const userProfile = useTwinStore((state) => state.userProfile);
		  const subscriptionInfo = useSubscriptionStore((state) => state.subscriptionInfo);
		  const { navigateToUpgrade } = usePremiumFeatures();
		  
		  const accentColor = userProfile?.accentColor || "neon-purple";
		  const neonColor = getNeonAccentColor(accentColor);
		
		  const handleUpgradePress = () => {
		    if (onUpgradePress) {
		      onUpgradePress();
		    } else {
		      navigateToUpgrade(undefined, 'status_indicator');
		    }
		  };
		
		  if (subscriptionInfo.isActive) {
		    // Premium user indicator
		    const renderPremiumStatus = () => {
		      const expiryDate = subscriptionInfo.expiryDate ? new Date(subscriptionInfo.expiryDate) : null;
		      const daysUntilExpiry = expiryDate ? Math.ceil((expiryDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)) : null;
		      
		      switch (variant) {
		        case "minimal":
		          return (
		            <View className="flex-row items-center">
		              <Ionicons name="star" size={14} color={neonColor} />
		              <Text style={{ color: neonColor }} className="text-xs font-bold ml-1">
		                PREMIUM
		              </Text>
		            </View>
		          );
		
		        case "full":
		          return (
		            <LinearGradient
		              colors={[`${neonColor}20`, `${neonColor}10`, 'transparent']}
		              className="p-4 rounded-2xl border"
		              style={{ borderColor: neonColor }}
		            >
		              <View className="flex-row items-center justify-between">
		                <View className="flex-row items-center">
		                  <View 
		                    className="w-10 h-10 rounded-full items-center justify-center mr-3"
		                    style={{ backgroundColor: `${neonColor}30` }}
		                  >
		                    <Ionicons name="star" size={20} color={neonColor} />
		                  </View>
		                  <View>
		                    <Text className="text-white font-bold">Premium Active</Text>
		                    <Text className="text-gray-400 text-sm">
		                      {subscriptionInfo.plan === "yearly" ? "Annual" : "Monthly"} Plan
		                    </Text>
		                  </View>
		                </View>
		                
		                {daysUntilExpiry && daysUntilExpiry < 7 && (
		                  <View className="bg-yellow-500/20 px-2 py-1 rounded-full">
		                    <Text className="text-yellow-400 text-xs font-bold">
		                      {daysUntilExpiry}d left
		                    </Text>
		                  </View>
		                )}
		              </View>
		              
		              {expiryDate && (
		                <Text className="text-gray-500 text-xs mt-2">
		                  Renews {expiryDate.toLocaleDateString()}
		                </Text>
		              )}
		            </LinearGradient>
		          );
		
		        case "compact":
		        default:
		          return (
		            <View 
		              className="px-3 py-2 rounded-full border flex-row items-center"
		              style={{ 
		                backgroundColor: `${neonColor}20`,
		                borderColor: neonColor 
		              }}
		            >
		              <Ionicons name="star" size={16} color={neonColor} />
		              <Text 
		                className="text-sm font-bold ml-2"
		                style={{ color: neonColor }}
		              >
		                Premium
		              </Text>
		              {daysUntilExpiry && daysUntilExpiry < 7 && (
		                <Text className="text-yellow-400 text-xs ml-2">
		                  ({daysUntilExpiry}d)
		                </Text>
		              )}
		            </View>
		          );
		      }
		    };
		
		    return renderPremiumStatus();
		  }
		
		  // Free user - show upgrade option
		  const renderFreeStatus = () => {
		    switch (variant) {
		      case "minimal":
		        return showUpgradeButton ? (
		          <TouchableOpacity 
		            onPress={handleUpgradePress}
		            className="flex-row items-center"
		          >
		            <Ionicons name="star-outline" size={14} color="#6b7280" />
		            <Text className="text-gray-400 text-xs font-bold ml-1">
		              FREE
		            </Text>
		          </TouchableOpacity>
		        ) : (
		          <View className="flex-row items-center">
		            <Ionicons name="star-outline" size={14} color="#6b7280" />
		            <Text className="text-gray-400 text-xs font-bold ml-1">
		              FREE
		            </Text>
		          </View>
		        );
		
		      case "full":
		        return (
		          <View className="p-4 rounded-2xl border border-gray-600 bg-gray-800/30">
		            <View className="flex-row items-center justify-between">
		              <View className="flex-row items-center">
		                <View className="w-10 h-10 rounded-full bg-gray-600/30 items-center justify-center mr-3">
		                  <Ionicons name="star-outline" size={20} color="#6b7280" />
		                </View>
		                <View>
		                  <Text className="text-white font-bold">Free Plan</Text>
		                  <Text className="text-gray-400 text-sm">
		                    Basic features included
		                  </Text>
		                </View>
		              </View>
		              
		              {showUpgradeButton && (
		                <TouchableOpacity
		                  onPress={handleUpgradePress}
		                  style={{ backgroundColor: neonColor }}
		                  className="px-4 py-2 rounded-full"
		                >
		                  <Text className="text-black font-bold text-sm">
		                    Upgrade
		                  </Text>
		                </TouchableOpacity>
		              )}
		            </View>
		            
		            {showUpgradeButton && (
		              <Text className="text-gray-500 text-xs mt-2">
		                Unlock detailed insights and coaching plans
		              </Text>
		            )}
		          </View>
		        );
		
		      case "compact":
		      default:
		        return showUpgradeButton ? (
		          <TouchableOpacity 
		            onPress={handleUpgradePress}
		            className="px-3 py-2 rounded-full border border-gray-600 bg-gray-800/30 flex-row items-center"
		          >
		            <Ionicons name="star-outline" size={16} color="#6b7280" />
		            <Text className="text-gray-400 text-sm font-bold ml-2">
		              Free
		            </Text>
		            <Ionicons name="arrow-forward" size={14} color={neonColor} className="ml-2" />
		          </TouchableOpacity>
		        ) : (
		          <View className="px-3 py-2 rounded-full border border-gray-600 bg-gray-800/30 flex-row items-center">
		            <Ionicons name="star-outline" size={16} color="#6b7280" />
		            <Text className="text-gray-400 text-sm font-bold ml-2">
		              Free Plan
		            </Text>
		          </View>
		        );
		    }
		  };
		
		  return renderFreeStatus();
		};]]></file>
	<file path='components/premium/SubscriptionCard.tsx'><![CDATA[
		import React from "react";
		import { View, Text, TouchableOpacity, ActivityIndicator } from "react-native";
		import { LinearGradient } from "expo-linear-gradient";
		import { Ionicons } from "@expo/vector-icons";
		import { SubscriptionProduct } from "../../types/premium/subscription";
		import { useTwinStore } from "../../state/twinStore";
		import { getNeonAccentColor, getNeonGradientColors } from "../../utils/neonColors";
		
		interface SubscriptionCardProps {
		  product: SubscriptionProduct;
		  isSelected?: boolean;
		  isPopular?: boolean;
		  onSelect: (product: SubscriptionProduct) => void;
		  loading?: boolean;
		}
		
		export const SubscriptionCard: React.FC<SubscriptionCardProps> = ({
		  product,
		  isSelected = false,
		  isPopular = false,
		  onSelect,
		  loading = false
		}) => {
		  const userProfile = useTwinStore((state) => state.userProfile);
		  const accentColor = userProfile?.accentColor || "neon-purple";
		  const neonColor = getNeonAccentColor(accentColor);
		  const [gradientStart, gradientMid, gradientEnd] = getNeonGradientColors(accentColor);
		
		  const getSavingsPercentage = () => {
		    if (product.subscriptionPeriod === "yearly") {
		      const monthlyEquivalent = (product.priceAmountMicros / 1000000) / 12;
		      const monthlyPrice = 9.99; // Monthly product price
		      const savings = ((monthlyPrice - monthlyEquivalent) / monthlyPrice) * 100;
		      return Math.round(savings);
		    }
		    return 0;
		  };
		
		  const savingsPercentage = getSavingsPercentage();
		
		  return (
		    <TouchableOpacity
		      onPress={() => onSelect(product)}
		      disabled={loading}
		      className="mb-4"
		      style={{ opacity: loading ? 0.7 : 1 }}
		    >
		      <View className="relative">
		        {/* Popular badge */}
		        {isPopular && (
		          <View 
		            className="absolute -top-3 left-4 z-10 px-3 py-1 rounded-full"
		            style={{ backgroundColor: neonColor }}
		          >
		            <Text className="text-black text-xs font-bold">MOST POPULAR</Text>
		          </View>
		        )}
		
		        {/* Savings badge */}
		        {savingsPercentage > 0 && (
		          <View 
		            className="absolute -top-3 right-4 z-10 px-3 py-1 rounded-full border-2"
		            style={{ 
		              backgroundColor: 'rgba(0, 0, 0, 0.8)', 
		              borderColor: neonColor 
		            }}
		          >
		            <Text style={{ color: neonColor }} className="text-xs font-bold">
		              SAVE {savingsPercentage}%
		            </Text>
		          </View>
		        )}
		
		        <LinearGradient
		          colors={
		            isSelected 
		              ? [gradientStart, gradientMid, gradientEnd]
		              : ['rgba(255, 255, 255, 0.05)', 'rgba(255, 255, 255, 0.02)', 'rgba(255, 255, 255, 0.05)']
		          }
		          className="rounded-2xl p-6 border-2"
		          style={{
		            borderColor: isSelected ? neonColor : 'rgba(255, 255, 255, 0.2)',
		          }}
		        >
		          <View className="flex-row items-center justify-between mb-4">
		            <View className="flex-1">
		              <Text className="text-white text-xl font-bold mb-1">
		                {product.title}
		              </Text>
		              <Text className="text-gray-300 text-sm">
		                {product.description}
		              </Text>
		            </View>
		            
		            {loading ? (
		              <ActivityIndicator color={neonColor} size="small" />
		            ) : (
		              <View 
		                className="w-6 h-6 rounded-full border-2 items-center justify-center"
		                style={{ borderColor: neonColor }}
		              >
		                {isSelected && (
		                  <View 
		                    className="w-3 h-3 rounded-full"
		                    style={{ backgroundColor: neonColor }}
		                  />
		                )}
		              </View>
		            )}
		          </View>
		
		          <View className="flex-row items-baseline justify-between">
		            <View className="flex-row items-baseline">
		              <Text className="text-white text-3xl font-bold">
		                {product.price}
		              </Text>
		              <Text className="text-gray-400 text-sm ml-1">
		                /{product.subscriptionPeriod === "yearly" ? "year" : "month"}
		              </Text>
		            </View>
		
		            {product.subscriptionPeriod === "yearly" && (
		              <Text className="text-gray-400 text-sm">
		                ${((product.priceAmountMicros / 1000000) / 12).toFixed(2)}/month
		              </Text>
		            )}
		          </View>
		
		          {/* Introductory offer */}
		          {product.introductoryPrice && (
		            <View className="mt-3 p-3 rounded-lg" style={{ backgroundColor: 'rgba(0, 0, 0, 0.3)' }}>
		              <View className="flex-row items-center">
		                <Ionicons name="gift-outline" size={16} color={neonColor} />
		                <Text className="text-white text-sm font-semibold ml-2">
		                  Special Offer: {product.introductoryPrice.price} for first 3 months
		                </Text>
		              </View>
		            </View>
		          )}
		
		          {/* Features preview for yearly */}
		          {product.subscriptionPeriod === "yearly" && (
		            <View className="mt-4 space-y-2">
		              {[
		                "Detailed assessment results",
		                "Personalized coaching plans", 
		                "PDF report exports",
		                "Advanced twin analytics",
		                "AI-powered recommendations"
		              ].map((feature, index) => (
		                <View key={index} className="flex-row items-center">
		                  <Ionicons name="checkmark-circle" size={16} color={neonColor} />
		                  <Text className="text-gray-300 text-sm ml-2">{feature}</Text>
		                </View>
		              ))}
		            </View>
		          )}
		        </LinearGradient>
		      </View>
		    </TouchableOpacity>
		  );
		};]]></file>
	<file path='components/research/ConsentForm.tsx'><![CDATA[
		import React, { useState } from 'react';
		import { View, Text, ScrollView, Pressable, Switch } from 'react-native';
		import { Ionicons } from '@expo/vector-icons';
		import { ResearchStudy, ConsentItem } from '../../types/research';
		
		interface ConsentFormProps {
		  study: ResearchStudy;
		  onConsent: (consentItems: ConsentItem[]) => void;
		  onCancel: () => void;
		  isLoading?: boolean;
		}
		
		export const ConsentForm: React.FC<ConsentFormProps> = ({
		  study,
		  onConsent,
		  onCancel,
		  isLoading = false
		}) => {
		  const [consentItems, setConsentItems] = useState<ConsentItem[]>([
		    {
		      id: 'data_collection',
		      title: 'Data Collection Agreement',
		      description: `I consent to the collection and use of my anonymized data for the "${study.title}" research study.`,
		      required: true,
		      consented: false,
		      dataTypes: study.dataTypes.map(dt => dt.type)
		    },
		    {
		      id: 'data_sharing',
		      title: 'Academic Data Sharing',
		      description: 'I consent to sharing my anonymized data with qualified academic researchers.',
		      required: true,
		      consented: false,
		      dataTypes: ['academic']
		    },
		    {
		      id: 'contact_research',
		      title: 'Research Updates',
		      description: 'I consent to receive updates about research findings and publications.',
		      required: false,
		      consented: false,
		      dataTypes: ['communication']
		    },
		    {
		      id: 'future_contact',
		      title: 'Future Studies',
		      description: 'I consent to be contacted about related future research opportunities.',
		      required: false,
		      consented: false,
		      dataTypes: ['communication']
		    }
		  ]);
		
		  const toggleConsent = (itemId: string) => {
		    setConsentItems(prev => prev.map(item => 
		      item.id === itemId ? { ...item, consented: !item.consented } : item
		    ));
		  };
		
		  const canProceed = consentItems
		    .filter(item => item.required)
		    .every(item => item.consented);
		
		  const handleSubmit = () => {
		    if (canProceed) {
		      onConsent(consentItems);
		    }
		  };
		
		  return (
		    <ScrollView className="flex-1 bg-black/90" contentContainerStyle={{ paddingBottom: 40 }}>
		      {/* Header */}
		      <View className="p-6 border-b border-white/20">
		        <Text className="text-white text-2xl font-bold mb-2">Informed Consent</Text>
		        <Text className="text-white/70 text-lg">{study.title}</Text>
		      </View>
		
		      {/* Study Information */}
		      <View className="p-6 space-y-6">
		        {/* Purpose */}
		        <View>
		          <Text className="text-white text-lg font-semibold mb-2">Study Purpose</Text>
		          <Text className="text-white/80 leading-6">{study.fullDescription}</Text>
		        </View>
		
		        {/* What We Collect */}
		        <View>
		          <Text className="text-white text-lg font-semibold mb-3">Data We Collect</Text>
		          <View className="space-y-3">
		            {study.dataTypes.map((dataType, index) => (
		              <View key={index} className="bg-white/5 rounded-lg p-4">
		                <Text className="text-white font-medium capitalize mb-1">
		                  {dataType.type} Data
		                </Text>
		                <Text className="text-white/70 text-sm mb-2">
		                  {dataType.description}
		                </Text>
		                <View className="flex-row flex-wrap gap-2">
		                  <View className="bg-purple-500/20 px-2 py-1 rounded">
		                    <Text className="text-purple-300 text-xs">
		                      {dataType.anonymizationLevel}
		                    </Text>
		                  </View>
		                  <View className="bg-blue-500/20 px-2 py-1 rounded">
		                    <Text className="text-blue-300 text-xs">
		                      {dataType.retentionPeriod}
		                    </Text>
		                  </View>
		                  <View className="bg-green-500/20 px-2 py-1 rounded">
		                    <Text className="text-green-300 text-xs">
		                      {dataType.sharingScope}
		                    </Text>
		                  </View>
		                </View>
		              </View>
		            ))}
		          </View>
		        </View>
		
		        {/* Benefits & Compensation */}
		        <View>
		          <Text className="text-white text-lg font-semibold mb-3">Benefits & Compensation</Text>
		          <View className="space-y-2">
		            {study.compensation.map((benefit, index) => (
		              <View key={index} className="flex-row items-center">
		                <Ionicons name="gift" size={16} color="#8b5cf6" />
		                <Text className="text-white/80 ml-2">{benefit}</Text>
		              </View>
		            ))}
		          </View>
		        </View>
		
		        {/* Risks & Privacy */}
		        <View>
		          <Text className="text-white text-lg font-semibold mb-3">Privacy & Risks</Text>
		          <View className="bg-amber-500/10 border border-amber-500/30 rounded-lg p-4 space-y-2">
		            <Text className="text-amber-300 font-medium">What you should know:</Text>
		            <Text className="text-white/80 text-sm">
		              • All data is fully anonymized before analysis
		            </Text>
		            <Text className="text-white/80 text-sm">
		              • No personal identifying information is shared
		            </Text>
		            <Text className="text-white/80 text-sm">
		              • You can withdraw from the study at any time
		            </Text>
		            <Text className="text-white/80 text-sm">
		              • Data retention follows research ethics guidelines
		            </Text>
		            <Text className="text-white/80 text-sm">
		              • Minimal risk - similar to everyday app usage
		            </Text>
		          </View>
		        </View>
		
		        {/* Research Team */}
		        <View>
		          <Text className="text-white text-lg font-semibold mb-3">Research Team</Text>
		          <View className="bg-white/5 rounded-lg p-4">
		            <Text className="text-white font-medium">{study.leadResearcher}</Text>
		            <Text className="text-white/70">{study.institution}</Text>
		            <Text className="text-white/50 text-sm mt-1">
		              Ethics Approval: {study.ethicsApproval}
		            </Text>
		          </View>
		        </View>
		
		        {/* Consent Items */}
		        <View>
		          <Text className="text-white text-lg font-semibold mb-4">Your Consent</Text>
		          <View className="space-y-4">
		            {consentItems.map((item) => (
		              <View key={item.id} className="bg-white/5 rounded-lg p-4">
		                <View className="flex-row items-start justify-between">
		                  <View className="flex-1 mr-4">
		                    <View className="flex-row items-center mb-2">
		                      <Text className="text-white font-medium">{item.title}</Text>
		                      {item.required && (
		                        <Text className="text-red-400 text-sm ml-2">*required</Text>
		                      )}
		                    </View>
		                    <Text className="text-white/70 text-sm leading-5">
		                      {item.description}
		                    </Text>
		                  </View>
		                  <Switch
		                    value={item.consented}
		                    onValueChange={() => toggleConsent(item.id)}
		                    trackColor={{ false: '#374151', true: '#8b5cf6' }}
		                    thumbColor={item.consented ? '#ffffff' : '#9ca3af'}
		                  />
		                </View>
		              </View>
		            ))}
		          </View>
		        </View>
		
		        {/* Your Rights */}
		        <View>
		          <Text className="text-white text-lg font-semibold mb-3">Your Rights</Text>
		          <View className="bg-white/5 rounded-lg p-4 space-y-2">
		            <View className="flex-row items-center">
		              <Ionicons name="checkmark-circle" size={16} color="#10b981" />
		              <Text className="text-white/80 text-sm ml-2">
		                Withdraw from the study at any time without penalty
		              </Text>
		            </View>
		            <View className="flex-row items-center">
		              <Ionicons name="checkmark-circle" size={16} color="#10b981" />
		              <Text className="text-white/80 text-sm ml-2">
		                Request a copy of your contributed data
		              </Text>
		            </View>
		            <View className="flex-row items-center">
		              <Ionicons name="checkmark-circle" size={16} color="#10b981" />
		              <Text className="text-white/80 text-sm ml-2">
		                Ask questions about the research at any time
		              </Text>
		            </View>
		            <View className="flex-row items-center">
		              <Ionicons name="checkmark-circle" size={16} color="#10b981" />
		              <Text className="text-white/80 text-sm ml-2">
		                Receive summaries of research findings
		              </Text>
		            </View>
		          </View>
		        </View>
		      </View>
		
		      {/* Action Buttons */}
		      <View className="p-6 space-y-3">
		        <Pressable
		          onPress={handleSubmit}
		          disabled={!canProceed || isLoading}
		          className={`py-4 rounded-xl items-center ${
		            canProceed && !isLoading
		              ? 'bg-purple-500'
		              : 'bg-gray-600'
		          }`}
		        >
		          <Text className={`text-lg font-semibold ${
		            canProceed && !isLoading ? 'text-white' : 'text-gray-400'
		          }`}>
		            {isLoading ? 'Processing...' : 'I Agree - Join Study'}
		          </Text>
		        </Pressable>
		
		        <Pressable
		          onPress={onCancel}
		          disabled={isLoading}
		          className="py-4 rounded-xl items-center bg-white/10"
		        >
		          <Text className="text-white text-lg font-semibold">Cancel</Text>
		        </Pressable>
		
		        {!canProceed && (
		          <View className="bg-amber-500/10 border border-amber-500/30 rounded-lg p-3">
		            <Text className="text-amber-300 text-sm text-center">
		              Please review and accept all required consent items to proceed
		            </Text>
		          </View>
		        )}
		      </View>
		    </ScrollView>
		  );
		};]]></file>
	<file path='components/research/index.ts'>
		export { ConsentForm } from './ConsentForm';</file>
	<file path='components/stories/index.ts'>
		// Export all story components
		export { StoryCard } from './StoryCard';
		export { MediaUpload } from './MediaUpload';
		export { StoryEditor } from './StoryEditor';</file>
	<file path='components/stories/MediaUpload.tsx'><![CDATA[
		import React, { useState } from 'react';
		import { View, Text, Pressable, Alert, Image, ScrollView, Dimensions } from 'react-native';
		import { Ionicons } from '@expo/vector-icons';
		import * as ImagePicker from 'expo-image-picker';
		import * as DocumentPicker from 'expo-document-picker';
		import { Audio } from 'expo-av';
		import { LinearGradient } from 'expo-linear-gradient';
		import { StoryMedia, MediaType } from '../../types/stories';
		import { useStoryStore } from '../../state/stores/stories/storyStore';
		
		interface MediaUploadProps {
		  media: StoryMedia[];
		  onAddMedia: (media: StoryMedia) => void;
		  onRemoveMedia: (mediaId: string) => void;
		  maxMedia?: number;
		  allowedTypes?: MediaType[];
		}
		
		const { width: screenWidth } = Dimensions.get('window');
		
		export const MediaUpload: React.FC<MediaUploadProps> = ({
		  media,
		  onAddMedia,
		  onRemoveMedia,
		  maxMedia = 10,
		  allowedTypes = ['photo', 'video', 'audio'],
		}) => {
		  const [isRecording, setIsRecording] = useState(false);
		  const [recording, setRecording] = useState<Audio.Recording | null>(null);
		  const [recordingDuration, setRecordingDuration] = useState(0);
		  const { isUploadingMedia, uploadProgress, setIsUploadingMedia, setUploadProgress } = useStoryStore();
		
		  const requestPermissions = async () => {
		    const { status: mediaStatus } = await ImagePicker.requestMediaLibraryPermissionsAsync();
		    const { status: cameraStatus } = await ImagePicker.requestCameraPermissionsAsync();
		    const { status: audioStatus } = await Audio.requestPermissionsAsync();
		    
		    if (mediaStatus !== 'granted' || cameraStatus !== 'granted' || audioStatus !== 'granted') {
		      Alert.alert(
		        'Permissions Required',
		        'Please grant camera, photo library, and microphone permissions to add media to your stories.',
		        [{ text: 'OK' }]
		      );
		      return false;
		    }
		    return true;
		  };
		
		  const simulateUpload = async () => {
		    setIsUploadingMedia(true);
		    for (let i = 0; i <= 100; i += 10) {
		      setUploadProgress(i);
		      await new Promise(resolve => setTimeout(resolve, 100));
		    }
		    setIsUploadingMedia(false);
		    setUploadProgress(0);
		  };
		
		  const createMediaObject = (uri: string, type: MediaType, mimeType: string, duration?: number): StoryMedia => {
		    return {
		      id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
		      type,
		      uri,
		      mimeType,
		      size: 0, // Would be calculated from actual file
		      duration,
		      compressed: false,
		    };
		  };
		
		  const pickImageFromLibrary = async () => {
		    if (!allowedTypes.includes('photo')) return;
		    if (media.length >= maxMedia) {
		      Alert.alert('Limit Reached', `You can only add up to ${maxMedia} media files per story.`);
		      return;
		    }
		
		    const hasPermission = await requestPermissions();
		    if (!hasPermission) return;
		
		    const result = await ImagePicker.launchImageLibraryAsync({
		      mediaTypes: ImagePicker.MediaTypeOptions.Images,
		      allowsEditing: true,
		      aspect: [16, 9],
		      quality: 0.8,
		    });
		
		    if (!result.canceled && result.assets[0]) {
		      await simulateUpload();
		      const mediaObject = createMediaObject(
		        result.assets[0].uri,
		        'photo',
		        'image/jpeg'
		      );
		      onAddMedia(mediaObject);
		    }
		  };
		
		  const pickVideoFromLibrary = async () => {
		    if (!allowedTypes.includes('video')) return;
		    if (media.length >= maxMedia) {
		      Alert.alert('Limit Reached', `You can only add up to ${maxMedia} media files per story.`);
		      return;
		    }
		
		    const hasPermission = await requestPermissions();
		    if (!hasPermission) return;
		
		    const result = await ImagePicker.launchImageLibraryAsync({
		      mediaTypes: ImagePicker.MediaTypeOptions.Videos,
		      allowsEditing: true,
		      quality: 0.8,
		    });
		
		    if (!result.canceled && result.assets[0]) {
		      await simulateUpload();
		      const mediaObject = createMediaObject(
		        result.assets[0].uri,
		        'video',
		        'video/mp4',
		        result.assets[0].duration ? Math.round(result.assets[0].duration / 1000) : undefined
		      );
		      onAddMedia(mediaObject);
		    }
		  };
		
		  const takePhoto = async () => {
		    if (!allowedTypes.includes('photo')) return;
		    if (media.length >= maxMedia) {
		      Alert.alert('Limit Reached', `You can only add up to ${maxMedia} media files per story.`);
		      return;
		    }
		
		    const hasPermission = await requestPermissions();
		    if (!hasPermission) return;
		
		    const result = await ImagePicker.launchCameraAsync({
		      allowsEditing: true,
		      aspect: [16, 9],
		      quality: 0.8,
		    });
		
		    if (!result.canceled && result.assets[0]) {
		      await simulateUpload();
		      const mediaObject = createMediaObject(
		        result.assets[0].uri,
		        'photo',
		        'image/jpeg'
		      );
		      onAddMedia(mediaObject);
		    }
		  };
		
		  const startRecording = async () => {
		    if (!allowedTypes.includes('audio')) return;
		    if (media.length >= maxMedia) {
		      Alert.alert('Limit Reached', `You can only add up to ${maxMedia} media files per story.`);
		      return;
		    }
		
		    const hasPermission = await requestPermissions();
		    if (!hasPermission) return;
		
		    try {
		      await Audio.setAudioModeAsync({
		        allowsRecordingIOS: true,
		        playsInSilentModeIOS: true,
		      });
		
		      const { recording } = await Audio.Recording.createAsync(
		        Audio.RecordingOptionsPresets.HIGH_QUALITY
		      );
		      
		      setRecording(recording);
		      setIsRecording(true);
		      setRecordingDuration(0);
		
		      // Update recording duration every second
		      const interval = setInterval(() => {
		        setRecordingDuration(prev => prev + 1);
		      }, 1000);
		
		      recording.setOnRecordingStatusUpdate((status) => {
		        if (!status.isRecording) {
		          clearInterval(interval);
		        }
		      });
		    } catch (err) {
		      console.error('Failed to start recording', err);
		      Alert.alert('Error', 'Failed to start recording. Please try again.');
		    }
		  };
		
		  const stopRecording = async () => {
		    if (!recording) return;
		
		    setIsRecording(false);
		    await recording.stopAndUnloadAsync();
		    const uri = recording.getURI();
		    
		    if (uri) {
		      await simulateUpload();
		      const mediaObject = createMediaObject(
		        uri,
		        'audio',
		        'audio/m4a',
		        recordingDuration
		      );
		      onAddMedia(mediaObject);
		    }
		
		    setRecording(null);
		    setRecordingDuration(0);
		  };
		
		  const formatDuration = (seconds: number): string => {
		    const mins = Math.floor(seconds / 60);
		    const secs = seconds % 60;
		    return `${mins}:${secs.toString().padStart(2, '0')}`;
		  };
		
		  const MediaPreview: React.FC<{ item: StoryMedia; index: number }> = ({ item, index }) => (
		    <View className="relative mr-3 mb-3" style={{ width: 100, height: 100 }}>
		      {item.type === 'photo' ? (
		        <Image
		          source={{ uri: item.uri }}
		          className="w-full h-full rounded-xl"
		          resizeMode="cover"
		        />
		      ) : item.type === 'video' ? (
		        <View className="w-full h-full bg-black/20 rounded-xl items-center justify-center">
		          <Ionicons name="play" size={32} color="white" />
		        </View>
		      ) : (
		        <View className="w-full h-full bg-purple-500/20 rounded-xl items-center justify-center">
		          <Ionicons name="mic" size={32} color="white" />
		          {item.duration && (
		            <Text className="text-white text-xs mt-1">
		              {formatDuration(item.duration)}
		            </Text>
		          )}
		        </View>
		      )}
		      
		      {/* Remove Button */}
		      <Pressable
		        onPress={() => onRemoveMedia(item.id)}
		        className="absolute -top-2 -right-2 bg-red-500 rounded-full w-6 h-6 items-center justify-center"
		      >
		        <Ionicons name="close" size={14} color="white" />
		      </Pressable>
		      
		      {/* Duration Badge for Video */}
		      {item.type === 'video' && item.duration && (
		        <View className="absolute bottom-1 right-1 bg-black/60 rounded px-1">
		          <Text className="text-white text-xs">
		            {formatDuration(item.duration)}
		          </Text>
		        </View>
		      )}
		    </View>
		  );
		
		  const MediaUploadButton: React.FC<{ icon: string; label: string; onPress: () => void; disabled?: boolean }> = ({ 
		    icon, 
		    label, 
		    onPress, 
		    disabled = false 
		  }) => (
		    <Pressable
		      onPress={onPress}
		      disabled={disabled || isUploadingMedia}
		      className={`flex-1 items-center py-4 px-3 rounded-xl mr-2 ${
		        disabled || isUploadingMedia ? 'bg-white/10' : 'bg-white/20'
		      }`}
		    >
		      <Ionicons 
		        name={icon as any} 
		        size={24} 
		        color={disabled || isUploadingMedia ? "rgba(255,255,255,0.3)" : "rgba(255,255,255,0.8)"} 
		      />
		      <Text className={`text-xs mt-1 text-center ${
		        disabled || isUploadingMedia ? 'text-white/30' : 'text-white/80'
		      }`}>
		        {label}
		      </Text>
		    </Pressable>
		  );
		
		  return (
		    <View className="mb-6">
		      <Text className="text-white text-lg font-semibold mb-4">
		        Add Media ({media.length}/{maxMedia})
		      </Text>
		      
		      {/* Upload Progress */}
		      {isUploadingMedia && (
		        <View className="mb-4">
		          <View className="flex-row items-center justify-between mb-2">
		            <Text className="text-white/80 text-sm">Uploading...</Text>
		            <Text className="text-white/80 text-sm">{uploadProgress}%</Text>
		          </View>
		          <View className="bg-white/20 rounded-full h-2">
		            <View 
		              className="bg-blue-500 rounded-full h-2" 
		              style={{ width: `${uploadProgress}%` }}
		            />
		          </View>
		        </View>
		      )}
		
		      {/* Media Preview Grid */}
		      {media.length > 0 && (
		        <ScrollView 
		          horizontal 
		          showsHorizontalScrollIndicator={false} 
		          className="mb-4"
		          contentContainerStyle={{ paddingRight: 20 }}
		        >
		          {media.map((item, index) => (
		            <MediaPreview key={item.id} item={item} index={index} />
		          ))}
		        </ScrollView>
		      )}
		
		      {/* Recording Interface */}
		      {isRecording ? (
		        <View className="bg-red-500/20 border-2 border-red-500/50 rounded-xl p-6 mb-4">
		          <View className="flex-row items-center justify-between">
		            <View className="flex-row items-center">
		              <View className="w-3 h-3 bg-red-500 rounded-full mr-3 animate-pulse" />
		              <Text className="text-white text-lg font-semibold">Recording</Text>
		            </View>
		            <Text className="text-white text-xl font-mono">
		              {formatDuration(recordingDuration)}
		            </Text>
		          </View>
		          <Pressable
		            onPress={stopRecording}
		            className="bg-red-500 rounded-full py-3 mt-4 items-center"
		          >
		            <Text className="text-white font-semibold">Stop Recording</Text>
		          </Pressable>
		        </View>
		      ) : (
		        <>
		          {/* Upload Buttons */}
		          <View className="flex-row mb-4">
		            {allowedTypes.includes('photo') && (
		              <MediaUploadButton
		                icon="image"
		                label="Gallery"
		                onPress={pickImageFromLibrary}
		                disabled={media.length >= maxMedia}
		              />
		            )}
		            
		            {allowedTypes.includes('photo') && (
		              <MediaUploadButton
		                icon="camera"
		                label="Camera"
		                onPress={takePhoto}
		                disabled={media.length >= maxMedia}
		              />
		            )}
		            
		            {allowedTypes.includes('video') && (
		              <MediaUploadButton
		                icon="videocam"
		                label="Video"
		                onPress={pickVideoFromLibrary}
		                disabled={media.length >= maxMedia}
		              />
		            )}
		            
		            {allowedTypes.includes('audio') && (
		              <MediaUploadButton
		                icon="mic"
		                label="Record"
		                onPress={startRecording}
		                disabled={media.length >= maxMedia}
		              />
		            )}
		          </View>
		
		          {/* Upload Guidelines */}
		          <View className="bg-blue-500/10 border border-blue-500/30 rounded-xl p-4">
		            <View className="flex-row items-center mb-2">
		              <Ionicons name="information-circle" size={20} color="#60A5FA" />
		              <Text className="text-blue-300 font-semibold ml-2">Media Guidelines</Text>
		            </View>
		            <Text className="text-blue-200/80 text-sm leading-5">
		              • Photos and videos are automatically compressed for storage
		              {'\n'}• Audio recordings can be up to 5 minutes long
		              {'\n'}• Maximum {maxMedia} media files per story
		              {'\n'}• All media is stored securely and privately
		            </Text>
		          </View>
		        </>
		      )}
		    </View>
		  );
		};]]></file>
	<file path='components/stories/StoryCard.tsx'><![CDATA[
		import React, { useState } from 'react';
		import { View, Text, Pressable, Image, Dimensions } from 'react-native';
		import { Ionicons } from '@expo/vector-icons';
		import { LinearGradient } from 'expo-linear-gradient';
		import { Story, StoryCategory } from '../../types/stories';
		import { useTwinStore } from '../../state/twinStore';
		import { useStoryStore } from '../../state/stores/stories/storyStore';
		
		interface StoryCardProps {
		  story: Story;
		  onPress?: () => void;
		  showActions?: boolean;
		  compact?: boolean;
		}
		
		const { width: screenWidth } = Dimensions.get('window');
		const cardWidth = screenWidth - 32;
		
		export const StoryCard: React.FC<StoryCardProps> = ({
		  story,
		  onPress,
		  showActions = true,
		  compact = false,
		}) => {
		  const [expanded, setExpanded] = useState(false);
		  const { userProfile } = useTwinStore();
		  const { likeStory, unlikeStory, favoriteStory, unfavoriteStory, viewStory } = useStoryStore();
		  
		  const currentUserId = userProfile?.id || '';
		  const isLiked = story.likes.includes(currentUserId);
		  const isFavorited = story.favorites.includes(currentUserId);
		  const canExpand = story.content.length > 150;
		  const displayContent = expanded || !canExpand 
		    ? story.content 
		    : story.content.substring(0, 150) + '...';
		
		  const getCategoryIcon = (category: StoryCategory): string => {
		    switch (category) {
		      case 'childhood': return 'happy-outline';
		      case 'milestones': return 'trophy-outline';
		      case 'adventures': return 'map-outline';
		      case 'synchronicity': return 'radio-outline';
		      case 'achievements': return 'star-outline';
		      case 'memories': return 'heart-outline';
		      default: return 'book-outline';
		    }
		  };
		
		  const getCategoryColor = (category: StoryCategory): string => {
		    switch (category) {
		      case 'childhood': return '#FFB347';
		      case 'milestones': return '#FFD700';
		      case 'adventures': return '#32CD32';
		      case 'synchronicity': return '#FF1493';
		      case 'achievements': return '#8A2BE2';
		      case 'memories': return '#FF69B4';
		      default: return '#87CEEB';
		    }
		  };
		
		  const formatDate = (timestamp: string) => {
		    const date = new Date(timestamp);
		    const now = new Date();
		    const diffTime = Math.abs(now.getTime() - date.getTime());
		    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
		
		    if (diffDays === 1) return 'Yesterday';
		    if (diffDays < 7) return `${diffDays} days ago`;
		    if (diffDays < 30) return `${Math.ceil(diffDays / 7)} weeks ago`;
		    
		    return date.toLocaleDateString('en-US', {
		      year: 'numeric',
		      month: 'long',
		      day: 'numeric',
		    });
		  };
		
		  const handleLike = () => {
		    if (isLiked) {
		      unlikeStory(story.id, currentUserId);
		    } else {
		      likeStory(story.id, currentUserId);
		    }
		  };
		
		  const handleFavorite = () => {
		    if (isFavorited) {
		      unfavoriteStory(story.id, currentUserId);
		    } else {
		      favoriteStory(story.id, currentUserId);
		    }
		  };
		
		  const handlePress = () => {
		    if (onPress) {
		      viewStory(story.id, currentUserId);
		      onPress();
		    }
		  };
		
		  return (
		    <Pressable
		      onPress={handlePress}
		      className={`mb-4 ${compact ? 'mx-2' : ''}`}
		      style={{ width: compact ? cardWidth * 0.8 : undefined }}
		    >
		      <LinearGradient
		        colors={['rgba(255,255,255,0.15)', 'rgba(255,255,255,0.05)']}
		        className="rounded-2xl p-6 border border-white/20"
		      >
		        {/* Header */}
		        <View className="flex-row items-start justify-between mb-4">
		          <View className="flex-1">
		            <View className="flex-row items-center mb-2">
		              {/* Category Icon */}
		              <View 
		                className="rounded-full p-2 mr-3"
		                style={{ backgroundColor: getCategoryColor(story.category) + '30' }}
		              >
		                <Ionicons 
		                  name={getCategoryIcon(story.category) as any} 
		                  size={18} 
		                  color={getCategoryColor(story.category)} 
		                />
		              </View>
		              
		              {/* Milestone Indicator */}
		              {story.milestone && (
		                <View className="bg-yellow-400/30 rounded-full p-1 mr-2">
		                  <Ionicons name="star" size={16} color="#FFD700" />
		                </View>
		              )}
		              
		              <Text className="text-white text-lg font-semibold flex-1" numberOfLines={2}>
		                {story.title}
		              </Text>
		            </View>
		            
		            <View className="flex-row items-center">
		              <Text className="text-white/60 text-sm">
		                {formatDate(story.timestamp)}
		              </Text>
		              
		              {story.isShared && (
		                <>
		                  <Text className="text-white/40 mx-2">•</Text>
		                  <View className="flex-row items-center">
		                    <Ionicons name="people" size={14} color="rgba(255,255,255,0.6)" />
		                    <Text className="text-white/60 text-sm ml-1">Shared</Text>
		                  </View>
		                </>
		              )}
		              
		              {story.location && (
		                <>
		                  <Text className="text-white/40 mx-2">•</Text>
		                  <Ionicons name="location" size={14} color="rgba(255,255,255,0.6)" />
		                </>
		              )}
		            </View>
		          </View>
		          
		          {/* Story Actions */}
		          {showActions && (
		            <Pressable className="p-1 ml-2">
		              <Ionicons name="ellipsis-vertical" size={20} color="rgba(255,255,255,0.7)" />
		            </Pressable>
		          )}
		        </View>
		
		        {/* Media Preview */}
		        {story.media.length > 0 && (
		          <View className="mb-4">
		            {story.media[0].type === 'photo' ? (
		              <View className="relative">
		                <Image
		                  source={{ uri: story.media[0].uri }}
		                  className="w-full h-48 rounded-xl"
		                  resizeMode="cover"
		                />
		                {story.media.length > 1 && (
		                  <View className="absolute bottom-2 right-2 bg-black/60 rounded-full px-2 py-1">
		                    <Text className="text-white text-xs">
		                      +{story.media.length - 1}
		                    </Text>
		                  </View>
		                )}
		              </View>
		            ) : story.media[0].type === 'video' ? (
		              <View className="relative bg-black/20 rounded-xl h-48 items-center justify-center">
		                <Ionicons name="play-circle" size={64} color="rgba(255,255,255,0.8)" />
		                {story.media[0].duration && (
		                  <View className="absolute bottom-2 right-2 bg-black/60 rounded px-2 py-1">
		                    <Text className="text-white text-xs">
		                      {Math.floor(story.media[0].duration / 60)}:{(story.media[0].duration % 60).toString().padStart(2, '0')}
		                    </Text>
		                  </View>
		                )}
		              </View>
		            ) : (
		              <View className="bg-purple-500/20 rounded-xl p-4 flex-row items-center">
		                <Ionicons name="mic" size={24} color="rgba(255,255,255,0.8)" />
		                <Text className="text-white/80 ml-3 flex-1">Audio note</Text>
		                {story.media[0].duration && (
		                  <Text className="text-white/60 text-sm">
		                    {Math.floor(story.media[0].duration / 60)}:{(story.media[0].duration % 60).toString().padStart(2, '0')}
		                  </Text>
		                )}
		              </View>
		            )}
		          </View>
		        )}
		
		        {/* Content */}
		        <View className="mb-4">
		          <Text className="text-white text-base leading-6">
		            {displayContent}
		          </Text>
		          
		          {canExpand && (
		            <Pressable onPress={() => setExpanded(!expanded)}>
		              <Text className="text-blue-400 text-sm mt-2">
		                {expanded ? 'Show less' : 'Read more'}
		              </Text>
		            </Pressable>
		          )}
		        </View>
		
		        {/* Tags */}
		        {story.tags.length > 0 && (
		          <View className="flex-row flex-wrap mb-4">
		            {story.tags.slice(0, 3).map((tag, index) => (
		              <View key={index} className="bg-white/10 rounded-full px-3 py-1 mr-2 mb-2">
		                <Text className="text-white/80 text-xs">#{tag}</Text>
		              </View>
		            ))}
		            {story.tags.length > 3 && (
		              <View className="bg-white/10 rounded-full px-3 py-1 mr-2 mb-2">
		                <Text className="text-white/60 text-xs">+{story.tags.length - 3}</Text>
		              </View>
		            )}
		          </View>
		        )}
		
		        {/* Milestone Info */}
		        {story.milestone && (
		          <View className="bg-yellow-400/10 border border-yellow-400/30 rounded-xl p-3 mb-4">
		            <View className="flex-row items-center">
		              <Ionicons name="star" size={20} color="#FFD700" />
		              <Text className="text-yellow-300 font-semibold ml-2">
		                {story.milestone.type.charAt(0).toUpperCase() + story.milestone.type.slice(1)} Milestone
		              </Text>
		            </View>
		            <Text className="text-yellow-200/80 text-sm mt-1">
		              {story.milestone.significance}
		            </Text>
		          </View>
		        )}
		
		        {/* Footer Actions */}
		        {showActions && !compact && (
		          <View className="flex-row items-center justify-between pt-4 border-t border-white/10">
		            <View className="flex-row items-center space-x-6">
		              {/* Like Button */}
		              <Pressable onPress={handleLike} className="flex-row items-center">
		                <Ionicons 
		                  name={isLiked ? "heart" : "heart-outline"} 
		                  size={20} 
		                  color={isLiked ? "#FF1493" : "rgba(255,255,255,0.7)"} 
		                />
		                <Text className="text-white/70 text-sm ml-2">
		                  {story.likes.length}
		                </Text>
		              </Pressable>
		              
		              {/* Comment Button */}
		              <Pressable className="flex-row items-center">
		                <Ionicons name="chatbubble-outline" size={20} color="rgba(255,255,255,0.7)" />
		                <Text className="text-white/70 text-sm ml-2">
		                  {story.comments.length}
		                </Text>
		              </Pressable>
		              
		              {/* Views */}
		              <View className="flex-row items-center">
		                <Ionicons name="eye-outline" size={20} color="rgba(255,255,255,0.5)" />
		                <Text className="text-white/50 text-sm ml-2">
		                  {story.views.length}
		                </Text>
		              </View>
		            </View>
		            
		            {/* Favorite Button */}
		            <Pressable onPress={handleFavorite}>
		              <Ionicons 
		                name={isFavorited ? "bookmark" : "bookmark-outline"} 
		                size={20} 
		                color={isFavorited ? "#FFD700" : "rgba(255,255,255,0.7)"} 
		              />
		            </Pressable>
		          </View>
		        )}
		      </LinearGradient>
		    </Pressable>
		  );
		};]]></file>
	<file path='components/stories/StoryEditor.tsx'><![CDATA[
		import React, { useState, useEffect } from 'react';
		import { 
		  View, 
		  Text, 
		  TextInput, 
		  Pressable, 
		  ScrollView, 
		  KeyboardAvoidingView, 
		  Platform,
		  Alert
		} from 'react-native';
		import { Ionicons } from '@expo/vector-icons';
		import { LinearGradient } from 'expo-linear-gradient';
		import { StoryCategory, StoryMedia, StoryMilestone, StoryDraft } from '../../types/stories';
		import { MediaUpload } from './MediaUpload';
		import { useStoryStore } from '../../state/stores/stories/storyStore';
		import { useTwinStore } from '../../state/twinStore';
		
		interface StoryEditorProps {
		  draft?: StoryDraft;
		  onSave?: (storyData: any) => void;
		  onCancel?: () => void;
		  autoSave?: boolean;
		}
		
		const CATEGORIES: { key: StoryCategory; label: string; icon: string; color: string }[] = [
		  { key: 'childhood', label: 'Childhood', icon: 'happy', color: '#FFB347' },
		  { key: 'milestones', label: 'Milestones', icon: 'trophy', color: '#FFD700' },
		  { key: 'adventures', label: 'Adventures', icon: 'map', color: '#32CD32' },
		  { key: 'synchronicity', label: 'Twin Sync', icon: 'radio', color: '#FF1493' },
		  { key: 'achievements', label: 'Achievements', icon: 'star', color: '#8A2BE2' },
		  { key: 'memories', label: 'Memories', icon: 'heart', color: '#FF69B4' },
		  { key: 'other', label: 'Other', icon: 'book', color: '#87CEEB' },
		];
		
		const MILESTONE_TYPES = [
		  'birthday', 'anniversary', 'achievement', 'first', 'last', 'custom'
		];
		
		export const StoryEditor: React.FC<StoryEditorProps> = ({
		  draft,
		  onSave,
		  onCancel,
		  autoSave = true,
		}) => {
		  const [title, setTitle] = useState(draft?.title || '');
		  const [content, setContent] = useState(draft?.content || '');
		  const [category, setCategory] = useState<StoryCategory>(draft?.category || 'memories');
		  const [tags, setTags] = useState<string[]>(draft?.tags || []);
		  const [tagInput, setTagInput] = useState('');
		  const [media, setMedia] = useState<StoryMedia[]>(draft?.media || []);
		  const [showMilestone, setShowMilestone] = useState(!!draft?.milestone);
		  const [milestone, setMilestone] = useState<Partial<StoryMilestone>>(draft?.milestone || {});
		  const [lastAutoSave, setLastAutoSave] = useState<Date | null>(null);
		
		  const { saveDraft, updateDraft, currentDraft, setCurrentDraft } = useStoryStore();
		  const { userProfile } = useTwinStore();
		
		  // Auto-save functionality
		  useEffect(() => {
		    if (!autoSave || (!title.trim() && !content.trim())) return;
		    
		    const autoSaveTimer = setTimeout(() => {
		      const draftData = {
		        title: title.trim(),
		        content: content.trim(),
		        category,
		        tags,
		        media,
		        milestone: showMilestone ? milestone as StoryMilestone : undefined,
		      };
		
		      if (currentDraft?.id) {
		        updateDraft(currentDraft.id, draftData);
		      } else if (title.trim() || content.trim()) {
		        saveDraft(draftData);
		        // Note: In a real implementation, you'd get the new draft ID from the store
		        setLastAutoSave(new Date());
		      }
		    }, 3000); // Auto-save after 3 seconds of inactivity
		
		    return () => clearTimeout(autoSaveTimer);
		  }, [title, content, category, tags, media, milestone, showMilestone]);
		
		  const addTag = () => {
		    const newTag = tagInput.trim().toLowerCase();
		    if (newTag && !tags.includes(newTag) && tags.length < 10) {
		      setTags([...tags, newTag]);
		      setTagInput('');
		    }
		  };
		
		  const removeTag = (tagToRemove: string) => {
		    setTags(tags.filter(tag => tag !== tagToRemove));
		  };
		
		  const addMedia = (newMedia: StoryMedia) => {
		    setMedia([...media, newMedia]);
		  };
		
		  const removeMedia = (mediaId: string) => {
		    setMedia(media.filter(m => m.id !== mediaId));
		  };
		
		  const validateStory = (): boolean => {
		    if (!title.trim()) {
		      Alert.alert('Missing Title', 'Please add a title for your story.');
		      return false;
		    }
		    if (!content.trim()) {
		      Alert.alert('Missing Content', 'Please add some content to your story.');
		      return false;
		    }
		    if (showMilestone && (!milestone.type || !milestone.significance)) {
		      Alert.alert('Incomplete Milestone', 'Please complete the milestone information or turn off milestone marking.');
		      return false;
		    }
		    return true;
		  };
		
		  const handleSave = () => {
		    if (!validateStory()) return;
		
		    const storyData = {
		      title: title.trim(),
		      content: content.trim(),
		      category,
		      tags,
		      media,
		      milestone: showMilestone ? milestone as StoryMilestone : undefined,
		      authorId: userProfile?.id || '',
		      isShared: false,
		      isPrivate: false,
		      sharedWith: [],
		      sharePermissions: 'view' as const,
		    };
		
		    if (onSave) {
		      onSave(storyData);
		    }
		  };
		
		  const CategorySelector: React.FC = () => (
		    <View className="mb-6">
		      <Text className="text-white text-lg font-semibold mb-3">Category</Text>
		      <ScrollView horizontal showsHorizontalScrollIndicator={false}>
		        {CATEGORIES.map((cat) => (
		          <Pressable
		            key={cat.key}
		            onPress={() => setCategory(cat.key)}
		            className={`mr-3 ${category === cat.key ? 'opacity-100' : 'opacity-60'}`}
		          >
		            <LinearGradient
		              colors={
		                category === cat.key 
		                  ? [cat.color + '40', cat.color + '20'] 
		                  : ['rgba(255,255,255,0.1)', 'rgba(255,255,255,0.05)']
		              }
		              className={`rounded-xl p-4 items-center border-2 ${
		                category === cat.key ? 'border-opacity-60' : 'border-white/10'
		              }`}
		              style={{ borderColor: category === cat.key ? cat.color : undefined }}
		            >
		              <Ionicons 
		                name={cat.icon as any} 
		                size={28} 
		                color={category === cat.key ? cat.color : 'rgba(255,255,255,0.7)'} 
		              />
		              <Text 
		                className={`mt-2 text-sm font-medium ${
		                  category === cat.key ? 'text-white' : 'text-white/70'
		                }`}
		              >
		                {cat.label}
		              </Text>
		            </LinearGradient>
		          </Pressable>
		        ))}
		      </ScrollView>
		    </View>
		  );
		
		  const MilestoneEditor: React.FC = () => (
		    <View className="mb-6">
		      <View className="flex-row items-center justify-between mb-3">
		        <Text className="text-white text-lg font-semibold">Milestone</Text>
		        <Pressable
		          onPress={() => setShowMilestone(!showMilestone)}
		          className={`flex-row items-center px-3 py-1 rounded-full ${
		            showMilestone ? 'bg-yellow-400/30' : 'bg-white/10'
		          }`}
		        >
		          <Ionicons 
		            name={showMilestone ? 'star' : 'star-outline'} 
		            size={16} 
		            color={showMilestone ? '#FFD700' : 'rgba(255,255,255,0.7)'} 
		          />
		          <Text className={`ml-1 text-sm ${showMilestone ? 'text-yellow-300' : 'text-white/70'}`}>
		            Mark as milestone
		          </Text>
		        </Pressable>
		      </View>
		
		      {showMilestone && (
		        <View className="bg-yellow-400/10 border border-yellow-400/30 rounded-xl p-4">
		          {/* Milestone Type */}
		          <View className="mb-4">
		            <Text className="text-yellow-300 font-semibold mb-2">Type</Text>
		            <ScrollView horizontal showsHorizontalScrollIndicator={false}>
		              {MILESTONE_TYPES.map((type) => (
		                <Pressable
		                  key={type}
		                  onPress={() => setMilestone({ ...milestone, type: type as any })}
		                  className={`mr-2 px-3 py-2 rounded-full border ${
		                    milestone.type === type
		                      ? 'bg-yellow-400/30 border-yellow-400/60'
		                      : 'bg-white/10 border-white/20'
		                  }`}
		                >
		                  <Text 
		                    className={`text-sm ${
		                      milestone.type === type ? 'text-yellow-300' : 'text-white/70'
		                    }`}
		                  >
		                    {type.charAt(0).toUpperCase() + type.slice(1)}
		                  </Text>
		                </Pressable>
		              ))}
		            </ScrollView>
		          </View>
		
		          {/* Milestone Date */}
		          <View className="mb-4">
		            <Text className="text-yellow-300 font-semibold mb-2">Date</Text>
		            <TextInput
		              value={milestone.date}
		              onChangeText={(text) => setMilestone({ ...milestone, date: text })}
		              placeholder="When did this milestone happen?"
		              placeholderTextColor="rgba(255,255,255,0.4)"
		              className="bg-white/10 rounded-xl px-4 py-3 text-white"
		            />
		          </View>
		
		          {/* Milestone Significance */}
		          <View>
		            <Text className="text-yellow-300 font-semibold mb-2">Significance</Text>
		            <TextInput
		              value={milestone.significance}
		              onChangeText={(text) => setMilestone({ ...milestone, significance: text })}
		              placeholder="Why is this milestone important?"
		              placeholderTextColor="rgba(255,255,255,0.4)"
		              className="bg-white/10 rounded-xl px-4 py-3 text-white"
		              multiline
		              numberOfLines={2}
		            />
		          </View>
		        </View>
		      )}
		    </View>
		  );
		
		  const TagEditor: React.FC = () => (
		    <View className="mb-6">
		      <Text className="text-white text-lg font-semibold mb-3">Tags</Text>
		      
		      {/* Tag Input */}
		      <View className="flex-row items-center mb-3">
		        <TextInput
		          value={tagInput}
		          onChangeText={setTagInput}
		          onSubmitEditing={addTag}
		          placeholder="Add a tag..."
		          placeholderTextColor="rgba(255,255,255,0.5)"
		          className="flex-1 bg-white/10 rounded-xl px-4 py-3 text-white mr-3"
		          maxLength={20}
		        />
		        <Pressable
		          onPress={addTag}
		          disabled={!tagInput.trim() || tags.length >= 10}
		          className={`px-4 py-3 rounded-xl ${
		            tagInput.trim() && tags.length < 10 ? 'bg-blue-500' : 'bg-white/20'
		          }`}
		        >
		          <Ionicons 
		            name="add" 
		            size={20} 
		            color={tagInput.trim() && tags.length < 10 ? 'white' : 'rgba(255,255,255,0.5)'} 
		          />
		        </Pressable>
		      </View>
		
		      {/* Tags Display */}
		      {tags.length > 0 && (
		        <View className="flex-row flex-wrap">
		          {tags.map((tag, index) => (
		            <View key={index} className="bg-blue-500/30 rounded-full px-3 py-1 mr-2 mb-2 flex-row items-center">
		              <Text className="text-blue-300 text-sm">#{tag}</Text>
		              <Pressable onPress={() => removeTag(tag)} className="ml-2">
		                <Ionicons name="close" size={14} color="rgba(59, 130, 246, 0.8)" />
		              </Pressable>
		            </View>
		          ))}
		        </View>
		      )}
		      
		      {tags.length >= 10 && (
		        <Text className="text-orange-400 text-sm mt-2">
		          Maximum 10 tags reached
		        </Text>
		      )}
		    </View>
		  );
		
		  return (
		    <KeyboardAvoidingView 
		      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
		      className="flex-1"
		    >
		      <ScrollView className="flex-1 px-6" showsVerticalScrollIndicator={false}>
		        {/* Auto-save Indicator */}
		        {lastAutoSave && (
		          <View className="bg-green-500/20 rounded-xl p-3 mb-4 flex-row items-center">
		            <Ionicons name="cloud-done" size={20} color="#10B981" />
		            <Text className="text-green-400 text-sm ml-2">
		              Draft auto-saved at {lastAutoSave.toLocaleTimeString()}
		            </Text>
		          </View>
		        )}
		
		        {/* Title Input */}
		        <View className="mb-6">
		          <Text className="text-white text-lg font-semibold mb-3">Title</Text>
		          <TextInput
		            value={title}
		            onChangeText={setTitle}
		            placeholder="Give your story a memorable title..."
		            placeholderTextColor="rgba(255,255,255,0.5)"
		            className="bg-white/10 rounded-xl px-4 py-4 text-white text-lg font-medium"
		            maxLength={100}
		          />
		          <Text className="text-white/40 text-sm mt-1 text-right">
		            {title.length}/100
		          </Text>
		        </View>
		
		        {/* Category Selector */}
		        <CategorySelector />
		
		        {/* Content Input */}
		        <View className="mb-6">
		          <Text className="text-white text-lg font-semibold mb-3">Your Story</Text>
		          <View className="bg-white/10 rounded-xl p-4 border border-white/20">
		            <TextInput
		              value={content}
		              onChangeText={setContent}
		              placeholder="Share your twin journey, memories, or special moments... What made this experience unique to your twin bond?"
		              placeholderTextColor="rgba(255,255,255,0.5)"
		              className="text-white text-base leading-6"
		              multiline
		              numberOfLines={8}
		              textAlignVertical="top"
		              maxLength={2000}
		            />
		          </View>
		          <Text className="text-white/40 text-sm mt-1 text-right">
		            {content.length}/2000
		          </Text>
		        </View>
		
		        {/* Media Upload */}
		        <MediaUpload
		          media={media}
		          onAddMedia={addMedia}
		          onRemoveMedia={removeMedia}
		          maxMedia={8}
		        />
		
		        {/* Milestone Editor */}
		        <MilestoneEditor />
		
		        {/* Tag Editor */}
		        <TagEditor />
		
		        {/* Action Buttons */}
		        <View className="flex-row space-x-4 py-6">
		          {onCancel && (
		            <Pressable
		              onPress={onCancel}
		              className="flex-1 bg-white/10 rounded-xl py-4 items-center border border-white/20"
		            >
		              <Text className="text-white/80 text-lg font-semibold">Cancel</Text>
		            </Pressable>
		          )}
		          
		          <Pressable
		            onPress={handleSave}
		            disabled={!title.trim() || !content.trim()}
		            className={`flex-1 rounded-xl py-4 items-center ${
		              title.trim() && content.trim() 
		                ? 'bg-purple-500' 
		                : 'bg-white/20'
		            }`}
		          >
		            <Text className="text-white text-lg font-semibold">
		              Save Story
		            </Text>
		          </Pressable>
		        </View>
		      </ScrollView>
		    </KeyboardAvoidingView>
		  );
		};]]></file>
	<file path='components/TwintuitionAlert.tsx'><![CDATA[
		import React, { useEffect, useRef } from 'react';
		import {
		  View,
		  Text,
		  Modal,
		  TouchableOpacity,
		  Animated,
		  Dimensions,
		  StyleSheet,
		} from 'react-native';
		import { BlurView } from 'expo-blur';
		import { LinearGradient } from 'expo-linear-gradient';
		import { useTwinStore, TwintuitionAlert as TwintuitionAlertType } from '../state/twinStore';
		import { getNeonAccentColor, getNeonGradientColors } from '../utils/neonColors';
		
		interface TwintuitionAlertProps {
		  alert: TwintuitionAlertType | null;
		  visible: boolean;
		  onDismiss: () => void;
		  onViewDetails?: () => void;
		}
		
		const { width, height } = Dimensions.get('window');
		
		export const TwintuitionAlert: React.FC<TwintuitionAlertProps> = ({
		  alert,
		  visible,
		  onDismiss,
		  onViewDetails,
		}) => {
		  const { userProfile, markAlertAsRead } = useTwinStore();
		  const fadeAnim = useRef(new Animated.Value(0)).current;
		  const scaleAnim = useRef(new Animated.Value(0.5)).current;
		  const glowAnim = useRef(new Animated.Value(0)).current;
		
		  useEffect(() => {
		    if (visible && alert) {
		      // Entrance animation
		      Animated.parallel([
		        Animated.timing(fadeAnim, {
		          toValue: 1,
		          duration: 300,
		          useNativeDriver: true,
		        }),
		        Animated.spring(scaleAnim, {
		          toValue: 1,
		          tension: 50,
		          friction: 7,
		          useNativeDriver: true,
		        }),
		        Animated.loop(
		          Animated.sequence([
		            Animated.timing(glowAnim, {
		              toValue: 1,
		              duration: 1500,
		              useNativeDriver: false,
		            }),
		            Animated.timing(glowAnim, {
		              toValue: 0,
		              duration: 1500,
		              useNativeDriver: false,
		            }),
		          ])
		        ),
		      ]).start();
		    } else {
		      // Reset animations
		      fadeAnim.setValue(0);
		      scaleAnim.setValue(0.5);
		      glowAnim.stopAnimation();
		      glowAnim.setValue(0);
		    }
		  }, [visible, alert]);
		
		  const handleDismiss = () => {
		    if (alert) {
		      markAlertAsRead(alert.id);
		    }
		    
		    // Exit animation
		    Animated.parallel([
		      Animated.timing(fadeAnim, {
		        toValue: 0,
		        duration: 200,
		        useNativeDriver: true,
		      }),
		      Animated.timing(scaleAnim, {
		        toValue: 0.5,
		        duration: 200,
		        useNativeDriver: true,
		      }),
		    ]).start(() => {
		      onDismiss();
		    });
		  };
		
		  const handleViewDetails = () => {
		    if (alert) {
		      markAlertAsRead(alert.id);
		    }
		    onViewDetails?.();
		    handleDismiss();
		  };
		
		  if (!alert || !visible) {
		    return null;
		  }
		
		  const accentColor = userProfile?.accentColor || 'neon-purple';
		  const primaryColor = getNeonAccentColor(accentColor);
		  const [color1, color2, color3] = getNeonGradientColors(accentColor);
		
		  const getAlertIcon = (type: string) => {
		    switch (type) {
		      case 'feeling':
		        return '💫';
		      case 'thought':
		        return '🧠';
		      case 'action':
		        return '⚡';
		      default:
		        return '✨';
		    }
		  };
		
		  const getAlertTypeText = (type: string) => {
		    switch (type) {
		      case 'feeling':
		        return 'Emotional Sync';
		      case 'thought':
		        return 'Mental Connection';
		      case 'action':
		        return 'Synchronized Action';
		      default:
		        return 'Twin Connection';
		    }
		  };
		
		  return (
		    <Modal
		      visible={visible}
		      transparent
		      animationType="none"
		      onRequestClose={handleDismiss}
		    >
		      <BlurView intensity={50} style={styles.overlay}>
		        <Animated.View
		          style={[
		            styles.alertContainer,
		            {
		              opacity: fadeAnim,
		              transform: [{ scale: scaleAnim }],
		            },
		          ]}
		        >
		          {/* Animated Glow Effect */}
		          <Animated.View
		            style={[
		              styles.glowContainer,
		              {
		                shadowColor: primaryColor,
		                shadowOpacity: glowAnim,
		                shadowRadius: glowAnim.interpolate({
		                  inputRange: [0, 1],
		                  outputRange: [10, 30],
		                }),
		              },
		            ]}
		          >
		            <LinearGradient
		              colors={[color1, color2, color3]}
		              start={{ x: 0, y: 0 }}
		              end={{ x: 1, y: 1 }}
		              style={styles.alertContent}
		            >
		              {/* Header */}
		              <View style={styles.header}>
		                <View style={styles.iconContainer}>
		                  <Text style={styles.icon}>{getAlertIcon(alert.type)}</Text>
		                  <Animated.View
		                    style={[
		                      styles.iconGlow,
		                      {
		                        backgroundColor: primaryColor,
		                        opacity: glowAnim.interpolate({
		                          inputRange: [0, 1],
		                          outputRange: [0.2, 0.6],
		                        }),
		                      },
		                    ]}
		                  />
		                </View>
		                <View style={styles.headerText}>
		                  <Text style={styles.title}>Twintuition Alert</Text>
		                  <Text style={styles.subtitle}>{getAlertTypeText(alert.type)}</Text>
		                </View>
		              </View>
		
		              {/* Message */}
		              <View style={styles.messageContainer}>
		                <Text style={styles.message}>{alert.message}</Text>
		                <Text style={styles.timestamp}>
		                  {new Date(alert.timestamp).toLocaleTimeString([], {
		                    hour: '2-digit',
		                    minute: '2-digit',
		                  })}
		                </Text>
		              </View>
		
		              {/* Action Buttons */}
		              <View style={styles.buttonContainer}>
		                <TouchableOpacity
		                  style={[styles.button, styles.dismissButton]}
		                  onPress={handleDismiss}
		                  activeOpacity={0.8}
		                >
		                  <Text style={styles.dismissButtonText}>Dismiss</Text>
		                </TouchableOpacity>
		                
		                <TouchableOpacity
		                  style={[
		                    styles.button,
		                    styles.actionButton,
		                    { backgroundColor: primaryColor },
		                  ]}
		                  onPress={handleViewDetails}
		                  activeOpacity={0.8}
		                >
		                  <Text style={styles.actionButtonText}>View History</Text>
		                </TouchableOpacity>
		              </View>
		
		              {/* Decorative Elements */}
		              <View style={styles.decorativeElements}>
		                <View style={[styles.sparkle, { backgroundColor: color1 }]} />
		                <View style={[styles.sparkle, styles.sparkle2, { backgroundColor: color2 }]} />
		                <View style={[styles.sparkle, styles.sparkle3, { backgroundColor: color3 }]} />
		              </View>
		            </LinearGradient>
		          </Animated.View>
		        </Animated.View>
		      </BlurView>
		    </Modal>
		  );
		};
		
		const styles = StyleSheet.create({
		  overlay: {
		    flex: 1,
		    justifyContent: 'center',
		    alignItems: 'center',
		    backgroundColor: 'rgba(0, 0, 0, 0.5)',
		  },
		  alertContainer: {
		    width: width * 0.85,
		    maxWidth: 350,
		  },
		  glowContainer: {
		    borderRadius: 25,
		    elevation: 10,
		  },
		  alertContent: {
		    borderRadius: 25,
		    padding: 25,
		    position: 'relative',
		    overflow: 'hidden',
		  },
		  header: {
		    flexDirection: 'row',
		    alignItems: 'center',
		    marginBottom: 20,
		  },
		  iconContainer: {
		    position: 'relative',
		    marginRight: 15,
		  },
		  icon: {
		    fontSize: 40,
		    textAlign: 'center',
		    zIndex: 2,
		  },
		  iconGlow: {
		    position: 'absolute',
		    width: 50,
		    height: 50,
		    borderRadius: 25,
		    top: -5,
		    left: -5,
		    zIndex: 1,
		  },
		  headerText: {
		    flex: 1,
		  },
		  title: {
		    fontSize: 22,
		    fontWeight: 'bold',
		    color: '#ffffff',
		    textShadowColor: 'rgba(0, 0, 0, 0.5)',
		    textShadowOffset: { width: 0, height: 1 },
		    textShadowRadius: 2,
		  },
		  subtitle: {
		    fontSize: 14,
		    color: 'rgba(255, 255, 255, 0.8)',
		    marginTop: 2,
		  },
		  messageContainer: {
		    backgroundColor: 'rgba(255, 255, 255, 0.1)',
		    borderRadius: 15,
		    padding: 18,
		    marginBottom: 25,
		    borderWidth: 1,
		    borderColor: 'rgba(255, 255, 255, 0.2)',
		  },
		  message: {
		    fontSize: 16,
		    color: '#ffffff',
		    lineHeight: 22,
		    textAlign: 'center',
		    fontWeight: '500',
		  },
		  timestamp: {
		    fontSize: 12,
		    color: 'rgba(255, 255, 255, 0.6)',
		    textAlign: 'center',
		    marginTop: 8,
		  },
		  buttonContainer: {
		    flexDirection: 'row',
		    justifyContent: 'space-between',
		    gap: 12,
		  },
		  button: {
		    flex: 1,
		    paddingVertical: 12,
		    paddingHorizontal: 20,
		    borderRadius: 25,
		    alignItems: 'center',
		  },
		  dismissButton: {
		    backgroundColor: 'rgba(255, 255, 255, 0.2)',
		    borderWidth: 1,
		    borderColor: 'rgba(255, 255, 255, 0.3)',
		  },
		  dismissButtonText: {
		    color: '#ffffff',
		    fontSize: 14,
		    fontWeight: '600',
		  },
		  actionButton: {
		    elevation: 2,
		    shadowColor: '#000',
		    shadowOffset: { width: 0, height: 2 },
		    shadowOpacity: 0.25,
		    shadowRadius: 3.84,
		  },
		  actionButtonText: {
		    color: '#ffffff',
		    fontSize: 14,
		    fontWeight: 'bold',
		    textShadowColor: 'rgba(0, 0, 0, 0.3)',
		    textShadowOffset: { width: 0, height: 1 },
		    textShadowRadius: 1,
		  },
		  decorativeElements: {
		    position: 'absolute',
		    top: 0,
		    left: 0,
		    right: 0,
		    bottom: 0,
		    zIndex: -1,
		  },
		  sparkle: {
		    position: 'absolute',
		    width: 4,
		    height: 4,
		    borderRadius: 2,
		    opacity: 0.6,
		  },
		  sparkle2: {
		    top: '20%',
		    right: '15%',
		    width: 6,
		    height: 6,
		    borderRadius: 3,
		  },
		  sparkle3: {
		    bottom: '25%',
		    left: '20%',
		    width: 3,
		    height: 3,
		    borderRadius: 1.5,
		  },
		});]]></file>
	<file path='components/TwintuitionSettingsCard.tsx'><![CDATA[
		import React, { useState } from 'react';
		import {
		  View,
		  Text,
		  Switch,
		  TouchableOpacity,
		  StyleSheet,
		} from 'react-native';
		import { BlurView } from 'expo-blur';
		import { LinearGradient } from 'expo-linear-gradient';
		import { useTwinStore } from '../state/twinStore';
		import { useTwintuitionStore } from '../state/twintuitionStore';
		import { useTwintuition } from '../hooks/useTwintuition';
		import { getNeonAccentColor, getNeonGradientColors } from '../utils/neonColors';
		
		interface TwintuitionSettingsCardProps {
		  onViewHistory?: () => void;
		}
		
		export const TwintuitionSettingsCard: React.FC<TwintuitionSettingsCardProps> = ({
		  onViewHistory,
		}) => {
		  const { userProfile } = useTwinStore();
		  const { config, notificationPrefs } = useTwintuitionStore();
		  const {
		    updateSensitivity,
		    updateTimeWindow,
		    enableLocationSync,
		    getSyncScore,
		    syncScore,
		  } = useTwintuition();
		
		  const [isExpanded, setIsExpanded] = useState(false);
		  const [loading, setLoading] = useState(false);
		
		  const accentColor = userProfile?.accentColor || 'neon-purple';
		  const primaryColor = getNeonAccentColor(accentColor);
		  const [color1, color2, color3] = getNeonGradientColors(accentColor);
		
		  const handleLocationToggle = async (enabled: boolean) => {
		    setLoading(true);
		    const success = await enableLocationSync(enabled);
		    if (!success && enabled) {
		      // Show error message or prompt
		      console.warn('Location permission required for location sync');
		    }
		    setLoading(false);
		  };
		
		  const handleSensitivityChange = (value: number) => {
		    updateSensitivity(value);
		  };
		
		  const handleTimeWindowChange = (minutes: number) => {
		    updateTimeWindow(minutes);
		  };
		
		  const refreshSyncScore = async () => {
		    setLoading(true);
		    await getSyncScore();
		    setLoading(false);
		  };
		
		  const getSensitivityLabel = (sensitivity: number) => {
		    if (sensitivity >= 0.8) return 'Very High';
		    if (sensitivity >= 0.6) return 'High';
		    if (sensitivity >= 0.4) return 'Medium';
		    if (sensitivity >= 0.2) return 'Low';
		    return 'Very Low';
		  };
		
		  const renderSensitivityButtons = () => {
		    const levels = [
		      { label: 'Low', value: 0.3 },
		      { label: 'Medium', value: 0.6 },
		      { label: 'High', value: 0.8 },
		    ];
		
		    return (
		      <View style={styles.buttonGroup}>
		        {levels.map((level) => (
		          <TouchableOpacity
		            key={level.value}
		            style={[
		              styles.levelButton,
		              config.sensitivity === level.value && {
		                backgroundColor: primaryColor,
		              },
		            ]}
		            onPress={() => handleSensitivityChange(level.value)}
		          >
		            <Text
		              style={[
		                styles.levelButtonText,
		                config.sensitivity === level.value && styles.selectedButtonText,
		              ]}
		            >
		              {level.label}
		            </Text>
		          </TouchableOpacity>
		        ))}
		      </View>
		    );
		  };
		
		  const renderTimeWindowButtons = () => {
		    const windows = [
		      { label: '5 min', value: 5 },
		      { label: '15 min', value: 15 },
		      { label: '30 min', value: 30 },
		      { label: '1 hour', value: 60 },
		    ];
		
		    return (
		      <View style={styles.buttonGroup}>
		        {windows.map((window) => (
		          <TouchableOpacity
		            key={window.value}
		            style={[
		              styles.timeButton,
		              config.timeWindowMinutes === window.value && {
		                backgroundColor: primaryColor,
		              },
		            ]}
		            onPress={() => handleTimeWindowChange(window.value)}
		          >
		            <Text
		              style={[
		                styles.levelButtonText,
		                config.timeWindowMinutes === window.value && styles.selectedButtonText,
		              ]}
		            >
		              {window.label}
		            </Text>
		          </TouchableOpacity>
		        ))}
		      </View>
		    );
		  };
		
		  return (
		    <BlurView intensity={20} style={styles.container}>
		      <LinearGradient
		        colors={[`${color1}20`, `${color2}30`, `${color3}20`]}
		        style={styles.content}
		      >
		        {/* Header */}
		        <TouchableOpacity
		          style={styles.header}
		          onPress={() => setIsExpanded(!isExpanded)}
		        >
		          <View style={styles.headerLeft}>
		            <Text style={styles.icon}>✨</Text>
		            <View>
		              <Text style={styles.title}>Twintuition Alerts</Text>
		              <Text style={styles.subtitle}>
		                Sync Score: {syncScore} | Sensitivity: {getSensitivityLabel(config.sensitivity)}
		              </Text>
		            </View>
		          </View>
		          <Text style={[styles.expandIcon, { color: primaryColor }]}>
		            {isExpanded ? '▲' : '▼'}
		          </Text>
		        </TouchableOpacity>
		
		        {/* Expanded Content */}
		        {isExpanded && (
		          <View style={styles.expandedContent}>
		            {/* Sync Score Section */}
		            <View style={styles.section}>
		              <View style={styles.sectionHeader}>
		                <Text style={styles.sectionTitle}>Twin Connection Score</Text>
		                <TouchableOpacity
		                  onPress={refreshSyncScore}
		                  disabled={loading}
		                  style={[styles.refreshButton, { borderColor: primaryColor }]}
		                >
		                  <Text style={[styles.refreshButtonText, { color: primaryColor }]}>
		                    {loading ? 'Loading...' : 'Refresh'}
		                  </Text>
		                </TouchableOpacity>
		              </View>
		              <Text style={[styles.scoreValue, { color: primaryColor }]}>
		                {syncScore}/100
		              </Text>
		              {onViewHistory && (
		                <TouchableOpacity
		                  onPress={onViewHistory}
		                  style={[styles.historyButton, { backgroundColor: primaryColor }]}
		                >
		                  <Text style={styles.historyButtonText}>View History</Text>
		                </TouchableOpacity>
		              )}
		            </View>
		
		            {/* Detection Settings */}
		            <View style={styles.section}>
		              <Text style={styles.sectionTitle}>Detection Sensitivity</Text>
		              <Text style={styles.description}>
		                Higher sensitivity detects more subtle connections but may include false positives.
		              </Text>
		              {renderSensitivityButtons()}
		            </View>
		
		            {/* Time Window Settings */}
		            <View style={styles.section}>
		              <Text style={styles.sectionTitle}>Time Window</Text>
		              <Text style={styles.description}>
		                How long to look for matching behaviors between twins.
		              </Text>
		              {renderTimeWindowButtons()}
		            </View>
		
		            {/* Feature Toggles */}
		            <View style={styles.section}>
		              <Text style={styles.sectionTitle}>Sync Features</Text>
		              
		              <View style={styles.toggleRow}>
		                <View style={styles.toggleInfo}>
		                  <Text style={styles.toggleTitle}>Location Sync</Text>
		                  <Text style={styles.toggleDescription}>
		                    Detect when you're in similar places
		                  </Text>
		                </View>
		                <Switch
		                  value={config.enableLocationSync}
		                  onValueChange={handleLocationToggle}
		                  trackColor={{ false: '#767577', true: `${primaryColor}80` }}
		                  thumbColor={config.enableLocationSync ? primaryColor : '#f4f3f4'}
		                  disabled={loading}
		                />
		              </View>
		
		              <View style={styles.toggleRow}>
		                <View style={styles.toggleInfo}>
		                  <Text style={styles.toggleTitle}>Mood Sync</Text>
		                  <Text style={styles.toggleDescription}>
		                    Track emotional synchronicity
		                  </Text>
		                </View>
		                <Switch
		                  value={config.enableMoodSync}
		                  onValueChange={(enabled) => {
		                    // Update config through store
		                    useTwintuitionStore.getState().updateConfig({ enableMoodSync: enabled });
		                  }}
		                  trackColor={{ false: '#767577', true: `${primaryColor}80` }}
		                  thumbColor={config.enableMoodSync ? primaryColor : '#f4f3f4'}
		                />
		              </View>
		
		              <View style={styles.toggleRow}>
		                <View style={styles.toggleInfo}>
		                  <Text style={styles.toggleTitle}>Action Sync</Text>
		                  <Text style={styles.toggleDescription}>
		                    Detect simultaneous actions
		                  </Text>
		                </View>
		                <Switch
		                  value={config.enableActionSync}
		                  onValueChange={(enabled) => {
		                    useTwintuitionStore.getState().updateConfig({ enableActionSync: enabled });
		                  }}
		                  trackColor={{ false: '#767577', true: `${primaryColor}80` }}
		                  thumbColor={config.enableActionSync ? primaryColor : '#f4f3f4'}
		                />
		              </View>
		            </View>
		
		            {/* Privacy Notice */}
		            <View style={styles.privacySection}>
		              <Text style={styles.privacyTitle}>🔒 Privacy & Ethics</Text>
		              <Text style={styles.privacyText}>
		                All behavior analysis is processed locally on your device. Location data is anonymized. 
		                You can opt out at any time, and data is never shared without your explicit consent.
		              </Text>
		            </View>
		          </View>
		        )}
		      </LinearGradient>
		    </BlurView>
		  );
		};
		
		const styles = StyleSheet.create({
		  container: {
		    borderRadius: 15,
		    marginVertical: 10,
		    overflow: 'hidden',
		  },
		  content: {
		    padding: 20,
		  },
		  header: {
		    flexDirection: 'row',
		    justifyContent: 'space-between',
		    alignItems: 'center',
		  },
		  headerLeft: {
		    flexDirection: 'row',
		    alignItems: 'center',
		    flex: 1,
		  },
		  icon: {
		    fontSize: 24,
		    marginRight: 12,
		  },
		  title: {
		    fontSize: 18,
		    fontWeight: 'bold',
		    color: '#ffffff',
		  },
		  subtitle: {
		    fontSize: 12,
		    color: 'rgba(255, 255, 255, 0.7)',
		    marginTop: 2,
		  },
		  expandIcon: {
		    fontSize: 16,
		    fontWeight: 'bold',
		  },
		  expandedContent: {
		    marginTop: 20,
		  },
		  section: {
		    marginBottom: 25,
		  },
		  sectionHeader: {
		    flexDirection: 'row',
		    justifyContent: 'space-between',
		    alignItems: 'center',
		    marginBottom: 10,
		  },
		  sectionTitle: {
		    fontSize: 16,
		    fontWeight: 'bold',
		    color: '#ffffff',
		    marginBottom: 8,
		  },
		  description: {
		    fontSize: 14,
		    color: 'rgba(255, 255, 255, 0.7)',
		    marginBottom: 15,
		    lineHeight: 18,
		  },
		  scoreValue: {
		    fontSize: 32,
		    fontWeight: 'bold',
		    textAlign: 'center',
		    marginVertical: 10,
		  },
		  refreshButton: {
		    borderWidth: 1,
		    borderRadius: 15,
		    paddingHorizontal: 12,
		    paddingVertical: 6,
		  },
		  refreshButtonText: {
		    fontSize: 12,
		    fontWeight: '600',
		  },
		  historyButton: {
		    borderRadius: 25,
		    paddingVertical: 12,
		    paddingHorizontal: 20,
		    alignItems: 'center',
		    marginTop: 10,
		  },
		  historyButtonText: {
		    color: '#ffffff',
		    fontSize: 14,
		    fontWeight: 'bold',
		  },
		  buttonGroup: {
		    flexDirection: 'row',
		    gap: 8,
		    flexWrap: 'wrap',
		  },
		  levelButton: {
		    flex: 1,
		    minWidth: 70,
		    paddingVertical: 8,
		    paddingHorizontal: 12,
		    borderRadius: 20,
		    backgroundColor: 'rgba(255, 255, 255, 0.1)',
		    alignItems: 'center',
		  },
		  timeButton: {
		    paddingVertical: 8,
		    paddingHorizontal: 12,
		    borderRadius: 20,
		    backgroundColor: 'rgba(255, 255, 255, 0.1)',
		    alignItems: 'center',
		  },
		  levelButtonText: {
		    fontSize: 12,
		    color: 'rgba(255, 255, 255, 0.8)',
		    fontWeight: '600',
		  },
		  selectedButtonText: {
		    color: '#ffffff',
		    fontWeight: 'bold',
		  },
		  toggleRow: {
		    flexDirection: 'row',
		    justifyContent: 'space-between',
		    alignItems: 'center',
		    paddingVertical: 12,
		    borderBottomWidth: 1,
		    borderBottomColor: 'rgba(255, 255, 255, 0.1)',
		  },
		  toggleInfo: {
		    flex: 1,
		    marginRight: 15,
		  },
		  toggleTitle: {
		    fontSize: 14,
		    fontWeight: '600',
		    color: '#ffffff',
		  },
		  toggleDescription: {
		    fontSize: 12,
		    color: 'rgba(255, 255, 255, 0.6)',
		    marginTop: 2,
		  },
		  privacySection: {
		    backgroundColor: 'rgba(255, 255, 255, 0.05)',
		    borderRadius: 10,
		    padding: 15,
		    marginTop: 10,
		  },
		  privacyTitle: {
		    fontSize: 14,
		    fontWeight: 'bold',
		    color: '#ffffff',
		    marginBottom: 8,
		  },
		  privacyText: {
		    fontSize: 12,
		    color: 'rgba(255, 255, 255, 0.7)',
		    lineHeight: 16,
		  },
		});]]></file>
	<file path='data/assessmentItemBank.json'>
		{
		  "version": "1.0.0",
		  "totalItems": 210,
		  "categories": {
		    "identity_fusion": {
		      "description": "Measures the degree to which twins merge their identities",
		      "items": [
		        {
		          "id": "IF001",
		          "question": "I feel incomplete without my twin",
		          "category": "identity_fusion",
		          "reverseScored": false,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "IF002",
		          "question": "My twin and I are basically the same person",
		          "category": "identity_fusion",
		          "reverseScored": false,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "IF003",
		          "question": "I have my own identity separate from my twin",
		          "category": "identity_fusion",
		          "reverseScored": true,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "IF004",
		          "question": "When my twin is hurt, I feel physical pain",
		          "category": "identity_fusion",
		          "reverseScored": false,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "IF005",
		          "question": "I can't imagine life without my twin",
		          "category": "identity_fusion",
		          "reverseScored": false,
		          "compositeIndices": ["CI", "TRS"]
		        },
		        {
		          "id": "IF006",
		          "question": "My twin's achievements feel like my own",
		          "category": "identity_fusion",
		          "reverseScored": false,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "IF007",
		          "question": "I enjoy having different interests from my twin",
		          "category": "identity_fusion",
		          "reverseScored": true,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "IF008",
		          "question": "People often can't tell us apart emotionally",
		          "category": "identity_fusion",
		          "reverseScored": false,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "IF009",
		          "question": "I feel anxious when separated from my twin",
		          "category": "identity_fusion",
		          "reverseScored": false,
		          "compositeIndices": ["CI", "TRS"]
		        },
		        {
		          "id": "IF010",
		          "question": "My twin and I share the same dreams and goals",
		          "category": "identity_fusion",
		          "reverseScored": false,
		          "compositeIndices": ["CI"]
		        }
		      ]
		    },
		    "autonomy": {
		      "description": "Measures independence and self-direction in the twin relationship",
		      "items": [
		        {
		          "id": "AU001",
		          "question": "I make important decisions without consulting my twin",
		          "category": "autonomy",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "AU002",
		          "question": "I need my twin's approval before trying new things",
		          "category": "autonomy",
		          "reverseScored": true,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "AU003",
		          "question": "I pursue my own hobbies independently",
		          "category": "autonomy",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "AU004",
		          "question": "My twin and I support each other's individual goals",
		          "category": "autonomy",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "AU005",
		          "question": "I feel guilty when I succeed without my twin",
		          "category": "autonomy",
		          "reverseScored": true,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "AU006",
		          "question": "I can be happy even when my twin is sad",
		          "category": "autonomy",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "AU007",
		          "question": "My career choices are influenced by my twin's opinions",
		          "category": "autonomy",
		          "reverseScored": true,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "AU008",
		          "question": "I maintain friendships that don't include my twin",
		          "category": "autonomy",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "AU009",
		          "question": "I check with my twin before making plans",
		          "category": "autonomy",
		          "reverseScored": true,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "AU010",
		          "question": "I'm comfortable traveling without my twin",
		          "category": "autonomy",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        }
		      ]
		    },
		    "boundaries": {
		      "description": "Assesses healthy emotional and physical boundaries",
		      "items": [
		        {
		          "id": "BO001",
		          "question": "My twin and I respect each other's privacy",
		          "category": "boundaries",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "BO002",
		          "question": "We share everything, including passwords",
		          "category": "boundaries",
		          "reverseScored": true,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "BO003",
		          "question": "I can say no to my twin without feeling guilty",
		          "category": "boundaries",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "BO004",
		          "question": "My twin gets upset when I need alone time",
		          "category": "boundaries",
		          "reverseScored": true,
		          "compositeIndices": ["CI", "TRS"]
		        },
		        {
		          "id": "BO005",
		          "question": "We have separate friend groups",
		          "category": "boundaries",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "BO006",
		          "question": "I feel obligated to share all my experiences with my twin",
		          "category": "boundaries",
		          "reverseScored": true,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "BO007",
		          "question": "My twin respects my romantic relationships",
		          "category": "boundaries",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "BO008",
		          "question": "We read each other's messages without asking",
		          "category": "boundaries",
		          "reverseScored": true,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "BO009",
		          "question": "I can keep secrets from my twin",
		          "category": "boundaries",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "BO010",
		          "question": "My twin expects to be included in all my activities",
		          "category": "boundaries",
		          "reverseScored": true,
		          "compositeIndices": ["CI", "TRS"]
		        }
		      ]
		    },
		    "communication": {
		      "description": "Evaluates communication patterns and effectiveness",
		      "items": [
		        {
		          "id": "CO001",
		          "question": "My twin and I communicate openly about our feelings",
		          "category": "communication",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "CO002",
		          "question": "We often communicate without words",
		          "category": "communication",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "CO003",
		          "question": "I avoid difficult conversations with my twin",
		          "category": "communication",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "CO004",
		          "question": "We resolve conflicts constructively",
		          "category": "communication",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "CO005",
		          "question": "I hide my true feelings to protect my twin",
		          "category": "communication",
		          "reverseScored": true,
		          "compositeIndices": ["CI", "TRS"]
		        },
		        {
		          "id": "CO006",
		          "question": "We can discuss our differences calmly",
		          "category": "communication",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "CO007",
		          "question": "My twin gets defensive when I express concerns",
		          "category": "communication",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "CO008",
		          "question": "We listen to each other without judgment",
		          "category": "communication",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "CO009",
		          "question": "I feel like I'm walking on eggshells around my twin",
		          "category": "communication",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "CO010",
		          "question": "We can apologize and forgive each other easily",
		          "category": "communication",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        }
		      ]
		    },
		    "codependency": {
		      "description": "Measures unhealthy emotional dependence",
		      "items": [
		        {
		          "id": "CD001",
		          "question": "I prioritize my twin's needs over my own",
		          "category": "codependency",
		          "reverseScored": false,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "CD002",
		          "question": "I feel responsible for my twin's emotions",
		          "category": "codependency",
		          "reverseScored": false,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "CD003",
		          "question": "My mood depends on my twin's mood",
		          "category": "codependency",
		          "reverseScored": false,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "CD004",
		          "question": "I sacrifice my own happiness for my twin",
		          "category": "codependency",
		          "reverseScored": false,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "CD005",
		          "question": "I can't enjoy activities unless my twin enjoys them too",
		          "category": "codependency",
		          "reverseScored": false,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "CD006",
		          "question": "I feel worthless when my twin doesn't need me",
		          "category": "codependency",
		          "reverseScored": false,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "CD007",
		          "question": "My self-esteem comes from helping my twin",
		          "category": "codependency",
		          "reverseScored": false,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "CD008",
		          "question": "I neglect my own problems to focus on my twin's",
		          "category": "codependency",
		          "reverseScored": false,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "CD009",
		          "question": "I feel anxious when my twin is independent",
		          "category": "codependency",
		          "reverseScored": false,
		          "compositeIndices": ["CI", "TRS"]
		        },
		        {
		          "id": "CD010",
		          "question": "My twin's problems become my problems",
		          "category": "codependency",
		          "reverseScored": false,
		          "compositeIndices": ["CI"]
		        }
		      ]
		    },
		    "differentiation": {
		      "description": "Assesses ability to maintain individual identity",
		      "items": [
		        {
		          "id": "DI001",
		          "question": "I have interests my twin doesn't share",
		          "category": "differentiation",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "DI002",
		          "question": "People see us as individuals, not just as twins",
		          "category": "differentiation",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "DI003",
		          "question": "I feel pressure to be similar to my twin",
		          "category": "differentiation",
		          "reverseScored": true,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "DI004",
		          "question": "I celebrate what makes me different from my twin",
		          "category": "differentiation",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "DI005",
		          "question": "We dress differently to express our individuality",
		          "category": "differentiation",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "DI006",
		          "question": "I feel threatened when my twin develops new traits",
		          "category": "differentiation",
		          "reverseScored": true,
		          "compositeIndices": ["CI", "TRS"]
		        },
		        {
		          "id": "DI007",
		          "question": "We have different career paths",
		          "category": "differentiation",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "DI008",
		          "question": "I compare myself constantly to my twin",
		          "category": "differentiation",
		          "reverseScored": true,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "DI009",
		          "question": "We have different political or religious views",
		          "category": "differentiation",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "DI010",
		          "question": "I feel lost when people don't mention my twin",
		          "category": "differentiation",
		          "reverseScored": true,
		          "compositeIndices": ["CI"]
		        }
		      ]
		    },
		    "attachment": {
		      "description": "Evaluates attachment patterns in twin relationship",
		      "items": [
		        {
		          "id": "AT001",
		          "question": "I trust my twin completely",
		          "category": "attachment",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "AT002",
		          "question": "I worry my twin will abandon me",
		          "category": "attachment",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "AT003",
		          "question": "Our bond feels secure and stable",
		          "category": "attachment",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "AT004",
		          "question": "I'm clingy with my twin",
		          "category": "attachment",
		          "reverseScored": true,
		          "compositeIndices": ["CI"]
		        },
		        {
		          "id": "AT005",
		          "question": "We give each other space when needed",
		          "category": "attachment",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "AT006",
		          "question": "I panic when I can't reach my twin",
		          "category": "attachment",
		          "reverseScored": true,
		          "compositeIndices": ["CI", "TRS"]
		        },
		        {
		          "id": "AT007",
		          "question": "Our relationship feels balanced",
		          "category": "attachment",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "AT008",
		          "question": "I'm jealous of my twin's other relationships",
		          "category": "attachment",
		          "reverseScored": true,
		          "compositeIndices": ["CI", "TRS"]
		        },
		        {
		          "id": "AT009",
		          "question": "We can be apart without anxiety",
		          "category": "attachment",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "AT010",
		          "question": "I feel possessive of my twin",
		          "category": "attachment",
		          "reverseScored": true,
		          "compositeIndices": ["CI"]
		        }
		      ]
		    },
		    "conflict_resolution": {
		      "description": "Assesses ability to handle disagreements",
		      "items": [
		        {
		          "id": "CR001",
		          "question": "We resolve conflicts quickly and fairly",
		          "category": "conflict_resolution",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "CR002",
		          "question": "Our fights escalate quickly",
		          "category": "conflict_resolution",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "CR003",
		          "question": "We can agree to disagree",
		          "category": "conflict_resolution",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "CR004",
		          "question": "I hold grudges against my twin",
		          "category": "conflict_resolution",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "CR005",
		          "question": "We find compromises that work for both of us",
		          "category": "conflict_resolution",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "CR006",
		          "question": "One of us always has to win arguments",
		          "category": "conflict_resolution",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "CR007",
		          "question": "We take breaks during heated discussions",
		          "category": "conflict_resolution",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "CR008",
		          "question": "We bring up past conflicts during new arguments",
		          "category": "conflict_resolution",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "CR009",
		          "question": "We seek to understand each other's perspective",
		          "category": "conflict_resolution",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "CR010",
		          "question": "Silent treatment is common after disagreements",
		          "category": "conflict_resolution",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        }
		      ]
		    },
		    "partner_inclusion": {
		      "description": "Measures how romantic partners affect twin dynamic",
		      "items": [
		        {
		          "id": "PI001",
		          "question": "My twin accepts my romantic partners",
		          "category": "partner_inclusion",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "PI002",
		          "question": "Romantic relationships threaten our twin bond",
		          "category": "partner_inclusion",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "PI003",
		          "question": "We include partners in twin activities appropriately",
		          "category": "partner_inclusion",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "PI004",
		          "question": "I feel jealous when my twin dates",
		          "category": "partner_inclusion",
		          "reverseScored": true,
		          "compositeIndices": ["CI", "TRS"]
		        },
		        {
		          "id": "PI005",
		          "question": "We maintain our bond despite romantic relationships",
		          "category": "partner_inclusion",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "PI006",
		          "question": "My twin sabotages my romantic relationships",
		          "category": "partner_inclusion",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "PI007",
		          "question": "Partners understand our twin connection",
		          "category": "partner_inclusion",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "PI008",
		          "question": "I have to choose between my twin and my partner",
		          "category": "partner_inclusion",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "PI009",
		          "question": "We respect each other's romantic boundaries",
		          "category": "partner_inclusion",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "PI010",
		          "question": "My twin competes with my romantic partner",
		          "category": "partner_inclusion",
		          "reverseScored": true,
		          "compositeIndices": ["CI", "TRS"]
		        }
		      ]
		    },
		    "power_dynamics": {
		      "description": "Evaluates balance of power in relationship",
		      "items": [
		        {
		          "id": "PD001",
		          "question": "We make decisions together as equals",
		          "category": "power_dynamics",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "PD002",
		          "question": "One twin dominates the relationship",
		          "category": "power_dynamics",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "PD003",
		          "question": "We take turns being the leader",
		          "category": "power_dynamics",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "PD004",
		          "question": "I feel inferior to my twin",
		          "category": "power_dynamics",
		          "reverseScored": true,
		          "compositeIndices": ["CI", "TRS"]
		        },
		        {
		          "id": "PD005",
		          "question": "We respect each other's strengths",
		          "category": "power_dynamics",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "PD006",
		          "question": "My twin makes all the important decisions",
		          "category": "power_dynamics",
		          "reverseScored": true,
		          "compositeIndices": ["CI", "TRS"]
		        },
		        {
		          "id": "PD007",
		          "question": "Our relationship feels balanced",
		          "category": "power_dynamics",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "PD008",
		          "question": "I'm always the one who compromises",
		          "category": "power_dynamics",
		          "reverseScored": true,
		          "compositeIndices": ["CI", "TRS"]
		        },
		        {
		          "id": "PD009",
		          "question": "We both have equal say in our relationship",
		          "category": "power_dynamics",
		          "reverseScored": false,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "PD010",
		          "question": "My twin controls our social life",
		          "category": "power_dynamics",
		          "reverseScored": true,
		          "compositeIndices": ["CI", "TRS"]
		        }
		      ]
		    },
		    "openness": {
		      "description": "Big Five trait adapted for twin context",
		      "items": [
		        {
		          "id": "OP001",
		          "question": "My twin and I explore new ideas together",
		          "category": "openness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "OP002",
		          "question": "We're open to different perspectives",
		          "category": "openness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "OP003",
		          "question": "We resist change in our relationship",
		          "category": "openness",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "OP004",
		          "question": "We enjoy intellectual discussions",
		          "category": "openness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "OP005",
		          "question": "We're curious about each other's experiences",
		          "category": "openness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "OP006",
		          "question": "We prefer routine over adventure",
		          "category": "openness",
		          "reverseScored": true,
		          "compositeIndices": []
		        },
		        {
		          "id": "OP007",
		          "question": "We appreciate art and beauty together",
		          "category": "openness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "OP008",
		          "question": "We're imaginative in solving problems",
		          "category": "openness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "OP009",
		          "question": "We avoid philosophical discussions",
		          "category": "openness",
		          "reverseScored": true,
		          "compositeIndices": []
		        },
		        {
		          "id": "OP010",
		          "question": "We embrace new experiences together",
		          "category": "openness",
		          "reverseScored": false,
		          "compositeIndices": []
		        }
		      ]
		    },
		    "conscientiousness": {
		      "description": "Big Five trait adapted for twin context",
		      "items": [
		        {
		          "id": "CN001",
		          "question": "We keep our commitments to each other",
		          "category": "conscientiousness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "CN002",
		          "question": "We're organized in our shared activities",
		          "category": "conscientiousness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "CN003",
		          "question": "We procrastinate on twin responsibilities",
		          "category": "conscientiousness",
		          "reverseScored": true,
		          "compositeIndices": []
		        },
		        {
		          "id": "CN004",
		          "question": "We plan our future together carefully",
		          "category": "conscientiousness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "CN005",
		          "question": "We follow through on our promises",
		          "category": "conscientiousness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "CN006",
		          "question": "We're careless with each other's belongings",
		          "category": "conscientiousness",
		          "reverseScored": true,
		          "compositeIndices": []
		        },
		        {
		          "id": "CN007",
		          "question": "We work diligently on shared goals",
		          "category": "conscientiousness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "CN008",
		          "question": "We're reliable for each other",
		          "category": "conscientiousness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "CN009",
		          "question": "We're impulsive in our decisions",
		          "category": "conscientiousness",
		          "reverseScored": true,
		          "compositeIndices": []
		        },
		        {
		          "id": "CN010",
		          "question": "We maintain structure in our relationship",
		          "category": "conscientiousness",
		          "reverseScored": false,
		          "compositeIndices": []
		        }
		      ]
		    },
		    "extraversion": {
		      "description": "Big Five trait adapted for twin context",
		      "items": [
		        {
		          "id": "EX001",
		          "question": "We're social butterflies together",
		          "category": "extraversion",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "EX002",
		          "question": "We energize each other",
		          "category": "extraversion",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "EX003",
		          "question": "We prefer quiet time over social events",
		          "category": "extraversion",
		          "reverseScored": true,
		          "compositeIndices": []
		        },
		        {
		          "id": "EX004",
		          "question": "We're the life of the party together",
		          "category": "extraversion",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "EX005",
		          "question": "We seek excitement and adventure",
		          "category": "extraversion",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "EX006",
		          "question": "We're reserved around others",
		          "category": "extraversion",
		          "reverseScored": true,
		          "compositeIndices": []
		        },
		        {
		          "id": "EX007",
		          "question": "We express ourselves openly",
		          "category": "extraversion",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "EX008",
		          "question": "We enjoy meeting new people together",
		          "category": "extraversion",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "EX009",
		          "question": "We avoid being the center of attention",
		          "category": "extraversion",
		          "reverseScored": true,
		          "compositeIndices": []
		        },
		        {
		          "id": "EX010",
		          "question": "We're enthusiastic and optimistic",
		          "category": "extraversion",
		          "reverseScored": false,
		          "compositeIndices": []
		        }
		      ]
		    },
		    "agreeableness": {
		      "description": "Big Five trait adapted for twin context",
		      "items": [
		        {
		          "id": "AG001",
		          "question": "We're compassionate with each other",
		          "category": "agreeableness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "AG002",
		          "question": "We cooperate well together",
		          "category": "agreeableness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "AG003",
		          "question": "We're competitive rather than supportive",
		          "category": "agreeableness",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "AG004",
		          "question": "We trust each other deeply",
		          "category": "agreeableness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "AG005",
		          "question": "We're considerate of each other's feelings",
		          "category": "agreeableness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "AG006",
		          "question": "We're critical and judgmental",
		          "category": "agreeableness",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "AG007",
		          "question": "We forgive each other easily",
		          "category": "agreeableness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "AG008",
		          "question": "We're helpful and unselfish",
		          "category": "agreeableness",
		          "reverseScored": false,
		          "compositeIndices": []
		        },
		        {
		          "id": "AG009",
		          "question": "We hold grudges against each other",
		          "category": "agreeableness",
		          "reverseScored": true,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "AG010",
		          "question": "We're warm and caring",
		          "category": "agreeableness",
		          "reverseScored": false,
		          "compositeIndices": []
		        }
		      ]
		    },
		    "neuroticism": {
		      "description": "Big Five trait adapted for twin context",
		      "items": [
		        {
		          "id": "NE001",
		          "question": "Our relationship causes me anxiety",
		          "category": "neuroticism",
		          "reverseScored": false,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "NE002",
		          "question": "We handle stress well together",
		          "category": "neuroticism",
		          "reverseScored": true,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "NE003",
		          "question": "I worry constantly about our twin bond",
		          "category": "neuroticism",
		          "reverseScored": false,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "NE004",
		          "question": "We remain calm during conflicts",
		          "category": "neuroticism",
		          "reverseScored": true,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "NE005",
		          "question": "Our relationship is emotionally volatile",
		          "category": "neuroticism",
		          "reverseScored": false,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "NE006",
		          "question": "We're emotionally stable together",
		          "category": "neuroticism",
		          "reverseScored": true,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "NE007",
		          "question": "I feel insecure about our twin connection",
		          "category": "neuroticism",
		          "reverseScored": false,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "NE008",
		          "question": "We bounce back quickly from setbacks",
		          "category": "neuroticism",
		          "reverseScored": true,
		          "compositeIndices": ["ARI"]
		        },
		        {
		          "id": "NE009",
		          "question": "Small issues become major problems for us",
		          "category": "neuroticism",
		          "reverseScored": false,
		          "compositeIndices": ["TRS"]
		        },
		        {
		          "id": "NE010",
		          "question": "We maintain emotional equilibrium",
		          "category": "neuroticism",
		          "reverseScored": true,
		          "compositeIndices": ["ARI"]
		        }
		      ]
		    }
		  }
		}</file>
	<file path='docs/invitation-system.md'><![CDATA[
		# Twinship Invitation System
		
		## Overview
		
		The Twinship Invitation System is a comprehensive, secure, and user-friendly solution for connecting twins through email and SMS invitations. This system was designed to match the app's neon-themed galaxy aesthetic while providing enterprise-level security and reliability.
		
		## Architecture
		
		### Core Components
		
		1. **InvitationService** (`/src/services/invitationService.ts`)
		   - Handles invitation creation, sending, and management
		   - Provides secure token generation and validation
		   - Manages rate limiting and retry logic
		   - Supports both email and SMS delivery
		
		2. **InvitationStore** (`/src/state/invitationStore.ts`)
		   - Zustand-based state management for invitation flow
		   - Handles UI state, loading states, and error handling
		   - Persists essential invitation data
		   - Provides selector hooks for optimal performance
		
		3. **DeepLinking** (`/src/utils/deepLinking.ts`)
		   - Manages invitation deep links and URL parsing
		   - Handles app state restoration from links
		   - Supports universal links for cross-platform compatibility
		
		4. **InvitationScreen** (`/src/screens/InvitationScreen.tsx`)
		   - Unified component for sending and receiving invitations
		   - Animated UI with proper loading states
		   - Supports manual token entry as fallback
		
		## Features
		
		### Security & Privacy
		- ✅ Cryptographically secure 256-bit invitation tokens
		- ✅ Rate limiting (5 invitations per hour)
		- ✅ Invitation expiration (7 days default)
		- ✅ Secure token validation and format checking
		- ✅ No storage of inviter's contact information
		- ✅ Protection against spam and abuse
		
		### User Experience
		- ✅ Intuitive invitation flow with step-by-step guidance
		- ✅ Support for both email and SMS invitations
		- ✅ Real-time status updates and progress tracking
		- ✅ Graceful error handling with retry logic
		- ✅ Deep linking for seamless invitation acceptance
		- ✅ Manual token entry as backup method
		- ✅ Animated transitions and haptic feedback
		
		### Technical Features
		- ✅ Expo MailComposer integration
		- ✅ Expo SMS integration
		- ✅ AsyncStorage persistence
		- ✅ Comprehensive analytics and history tracking
		- ✅ Automatic cleanup of expired invitations
		- ✅ Cross-platform compatibility
		
		## Usage
		
		### Basic Usage
		
		```typescript
		import { InvitationButton } from '../components/InvitationButton';
		import { useInvitationStore } from '../state/invitationStore';
		
		// Simple invitation button
		<InvitationButton 
		  variant="primary" 
		  size="medium" 
		  onPress={() => navigation.navigate('SendInvitation')}
		/>
		
		// Using the invitation store
		const { createAndSendInvitation } = useInvitationStore();
		
		await createAndSendInvitation(
		  userProfile, 
		  { email: 'twin@example.com', phone: '+1234567890' },
		  'both' // Send via both email and SMS
		);
		```
		
		### Navigation Integration
		
		```typescript
		// Navigate to send invitation screen
		navigation.navigate('SendInvitation');
		
		// Navigate to receive invitation screen
		navigation.navigate('ReceiveInvitation', { token: 'invitation_token' });
		
		// Navigate to analytics screen
		navigation.navigate('InvitationAnalytics');
		```
		
		### Deep Link Handling
		
		The system automatically handles deep links in the format:
		```
		twinshipvibe://invitation/[64-character-hex-token]
		```
		
		## API Reference
		
		### InvitationService
		
		#### Methods
		
		- `createInvitation(inviterProfile, recipientContact)` - Create a new invitation
		- `sendEmailInvitation(invitation)` - Send invitation via email
		- `sendSMSInvitation(invitation)` - Send invitation via SMS
		- `acceptInvitation(token)` - Accept an invitation using token
		- `declineInvitation(token)` - Decline an invitation
		- `getInvitationAnalytics()` - Get comprehensive analytics
		- `retryInvitation(invitationId, method)` - Retry a failed invitation
		
		#### Security Features
		
		- Rate limiting: Maximum 5 invitations per hour
		- Token validation: 64-character hexadecimal format
		- Expiration: 7 days (configurable)
		- Retry limits: Maximum 3 attempts per invitation
		
		### InvitationStore
		
		#### State
		
		```typescript
		interface InvitationState {
		  currentInvitation: Invitation | null;
		  isLoading: boolean;
		  error: string | null;
		  invitationStep: 'contact' | 'method' | 'sending' | 'sent' | 'success' | 'error';
		  selectedMethod: 'email' | 'sms' | 'both' | null;
		  recipientContact: {
		    email?: string;
		    phone?: string;
		    name?: string;
		  };
		  analytics: InvitationAnalytics | null;
		  // ... more state properties
		}
		```
		
		#### Actions
		
		- `createAndSendInvitation()` - Main invitation flow
		- `processIncomingInvitation()` - Handle received invitations
		- `acceptInvitation()` / `declineInvitation()` - Invitation responses
		- `refreshAnalytics()` - Update analytics data
		- `reset()` - Reset invitation state
		
		### InvitationScreen Props
		
		```typescript
		interface InvitationScreenProps {
		  mode?: 'send' | 'receive' | 'manual';
		  invitationData?: {
		    fromName: string;
		    fromEmail?: string;
		    fromPhone?: string;
		    twinType: TwinType;
		    accentColor: ThemeColor;
		  };
		  onComplete?: () => void;
		}
		```
		
		## Component Library
		
		### InvitationButton
		
		A flexible button component for invitation actions:
		
		```typescript
		<InvitationButton 
		  variant="primary" | "secondary" | "minimal"
		  size="small" | "medium" | "large"
		  showIcon={boolean}
		  disabled={boolean}
		  onPress={() => {}}
		/>
		```
		
		### InvitationFAB
		
		Floating Action Button for quick invitations:
		
		```typescript
		<InvitationFAB onPress={() => navigation.navigate('SendInvitation')} />
		```
		
		### InvitationStatusBadge
		
		Shows current invitation status:
		
		```typescript
		<InvitationStatusBadge />
		```
		
		## Analytics
		
		The system provides comprehensive analytics including:
		
		- Total invitations sent
		- Acceptance rate
		- Response times
		- Recent invitation history
		- Retry attempts and success rates
		
		Access analytics through:
		```typescript
		const analytics = useInvitationAnalytics();
		```
		
		## Error Handling
		
		The system provides robust error handling for:
		
		- Network connectivity issues
		- Invalid email/phone formats
		- Rate limiting violations
		- Expired invitations
		- Service unavailability (email/SMS)
		
		Errors are displayed in user-friendly format with suggested actions.
		
		## Customization
		
		### Theming
		
		The invitation system respects the user's selected neon theme:
		
		```typescript
		const themeColor = getNeonAccentColor(userProfile.accentColor);
		const themeColorWithOpacity = getNeonAccentColorWithOpacity(accentColor, 0.3);
		```
		
		### Email Templates
		
		Customize email content in `generatePlainTextEmail()` method of InvitationService.
		
		### SMS Templates
		
		Customize SMS content in `generateSMSTemplate()` method of InvitationService.
		
		## Testing
		
		### Test Scenarios
		
		1. **Send Invitation Flow**
		   - Valid email/phone input
		   - Invalid input validation
		   - Rate limiting behavior
		   - Network error handling
		
		2. **Receive Invitation Flow**
		   - Valid token processing
		   - Invalid token handling
		   - Expired invitation handling
		   - Deep link integration
		
		3. **Analytics**
		   - Data accuracy
		   - Persistence
		   - Performance with large datasets
		
		### Mock Data
		
		Use the included mock data for testing:
		
		```typescript
		import { mockInvitationData } from '../tests/mocks/invitationMockData';
		```
		
		## Performance Considerations
		
		- ✅ Lazy loading of invitation history
		- ✅ Efficient state management with Zustand
		- ✅ Optimized re-renders with selector hooks
		- ✅ Automatic cleanup of expired data
		- ✅ Pagination for large datasets
		
		## Future Enhancements
		
		### Phase 2 Features
		- [ ] Rich HTML email templates
		- [ ] Push notification integration
		- [ ] Batch invitation sending
		- [ ] Invitation scheduling
		- [ ] Advanced analytics dashboard
		
		### Phase 3 Features
		- [ ] Social media sharing
		- [ ] QR code invitations
		- [ ] Invitation customization
		- [ ] Multi-language support
		- [ ] Admin dashboard for monitoring
		
		## Troubleshooting
		
		### Common Issues
		
		1. **Invitations not sending**
		   - Check device email/SMS capability
		   - Verify network connectivity
		   - Check rate limiting status
		
		2. **Deep links not working**
		   - Verify URL scheme configuration
		   - Check deep link initialization
		   - Validate token format
		
		3. **State not persisting**
		   - Check AsyncStorage permissions
		   - Verify persistence configuration
		   - Clear storage if corrupted
		
		### Debug Mode
		
		Enable debug logging:
		
		```typescript
		// In development
		console.log('Invitation Debug:', { token, status, error });
		```
		
		## Contributing
		
		When contributing to the invitation system:
		
		1. Follow the established TypeScript patterns
		2. Maintain security best practices
		3. Add comprehensive error handling
		4. Include analytics tracking
		5. Test across platforms
		6. Update documentation
		
		## Security Audit Checklist
		
		- [ ] Token generation uses crypto-secure randomness
		- [ ] Rate limiting is properly implemented
		- [ ] Input validation covers all edge cases
		- [ ] No sensitive data logged or persisted inappropriately
		- [ ] Deep links are properly validated
		- [ ] Invitation expiration is enforced
		- [ ] Error messages don't leak sensitive information
		
		This invitation system provides a solid foundation for twin connections while maintaining the special feeling that Twinship aims to create. The implementation balances security, usability, and performance to deliver a best-in-class invitation experience.]]></file>
	<file path='docs/TwinGames.md'><![CDATA[
		## Feature: Twin Connection Games Suite
		
		### Background
		
		Twins represent a unique user segment with specific psychological needs around understanding and quantifying their special bond. Current "telepathy test" apps offer generic, unscientific games that fail to provide meaningful insights or sustained engagement. Our research indicates twins seek tools that validate their subjective experience of connection through objective, shareable data.
		
		### Motivation
		
		**User Problem**: Twins want to explore and understand their unique cognitive, emotional, and behavioral synchronicities but lack scientifically-grounded, engaging tools to do so.
		
		**Business Opportunity**: By creating games that provide specific, actionable insights into twin connections, we can build a highly engaged user base that returns frequently and shares results socially, driving organic growth.
		
		**Key Insights**:
		- Twins simultaneously want to prove their unique connection while maintaining individual identity
		- Generic "telepathy scores" fail to satisfy; twins crave specific, measurable insights
		- Social sharing and competitive elements (leaderboards) can drive engagement
		- Entertainment value must be balanced with meaningful psychological insights
		
		### Approach
		
		We will develop four distinct games, each measuring different aspects of twin connection:
		
		#### Game 1: Cognitive Synchrony Maze
		**What it measures**: Problem-solving strategies and decision-making patterns
		**How it works**: 
		- Identical mazes/puzzles presented to each twin independently
		- Touch-based navigation with continuous finger tracking
		- Records every movement, mistake, correction, and timing
		- Analyzes pathways for similarity in approach
		
		**Key Metrics**:
		- Solution pathway overlap percentage
		- Time synchronization scores
		- Error pattern similarities
		- Decision point analysis (left vs right preferences, systematic vs intuitive approaches)
		
		#### Game 2: Emotional Resonance Mapping
		**What it measures**: Emotional synchrony and empathic connection
		**How it works**:
		- Series of ambiguous images (abstract art, micro-expressions, atmospheric photos)
		- Multi-dimensional response capture:
		  - Emotional intensity ratings (1-10 scale)
		  - Word association (3 words per image)
		  - Somatic mapping (where emotions are felt in the body)
		  - Color association
		
		**Key Metrics**:
		- Emotional vocabulary overlap percentage
		- Somatic response similarity scores
		- Response time synchronization
		- Color-emotion association patterns
		
		#### Game 3: Temporal Decision Synchrony
		**What it measures**: Values alignment and stress-response patterns
		**How it works**:
		- Rapid-fire scenario decisions with time pressure
		- Categories include crisis management, resource allocation, social choices
		- 30-60 second time limits per scenario
		- Measures both choices and decision timing
		
		**Key Metrics**:
		- Value priority alignment scores
		- Risk tolerance correlation
		- Decision speed synchronization
		- Stress response similarity (measured through choice pattern changes)
		
		#### Game 4: Iconic Duo Matcher
		**What it measures**: Relationship dynamics and self-perception alignment
		**How it works**:
		- Personality and relationship questions answered individually
		- Predictions about twin's answers
		- Algorithm matches to famous duos across all media
		- Categories: complementary, mirror image, leader/follower, chaos twins, etc.
		
		**Key Metrics**:
		- Self-perception vs twin-perception gaps
		- Relationship style classification
		- Prediction accuracy scores
		- Social sharing rates
		
		### Details
		
		#### Technical Requirements
		- Real-time data capture and analysis engine
		- Touch gesture recording system for maze game
		- ML-powered similarity scoring algorithms
		- Secure twin-pairing and verification system
		- Social sharing integration
		- Leaderboard infrastructure
		
		#### Psychological Framework
		- Grounded in research by Dr. Nancy Segal on twin cognitive similarities
		- Incorporates psychoanalytic concepts of "transitional space" (Winnicott)
		- Measures both conscious decisions and unconscious patterns
		- Provides specific, actionable insights rather than vague scores
		
		#### Engagement Mechanisms
		- Progressive insight unlocking (play more to learn more)
		- Weekly challenges with new maze/puzzle types
		- Twin pair leaderboards and achievements
		- Shareable insight cards for social media
		- Comparison stats with global twin population
		
		#### Example Insights
		- "You both favor right-hand turns in mazes 73% of the time"
		- "Your problem-solving speeds synchronize within 2 seconds on spatial tasks"
		- "You process melancholy through visual-spatial metaphors 80% of the time"
		- "Your emotional vocabularies overlap by 67%, compared to 23% for random pairs"
		- "You're most like Fred & George Weasley: synchronized mischief with 85% match"
		
		#### Success Metrics
		- Daily Active Twin Pairs
		- Average session duration > 15 minutes
		- Social sharing rate > 30%
		- 7-day retention > 60%
		- Twin verification completion rate > 80%]]></file>
	<file path='examples/AssessmentWithTelemetry.tsx'><![CDATA[
		/**
		 * Assessment with Telemetry Integration Example
		 * Demonstrates how to integrate telemetry collection in assessment flow
		 */
		
		import React, { useState, useEffect, useCallback } from 'react';
		import {
		  View,
		  Text,
		  TouchableOpacity,
		  ScrollView,
		  Alert,
		  SafeAreaView,
		} from 'react-native';
		import { useTelemetryIntegration } from '../hooks/useTelemetryIntegration';
		import { useTelemetryStore, selectTelemetryStatus } from '../state/telemetryStore';
		import PrivacyConsentModal from '../components/common/PrivacyConsentModal';
		import TelemetryDashboard from '../components/admin/TelemetryDashboard';
		import { AssessmentCategory, LikertScale } from '../types/assessment';
		
		interface AssessmentQuestion {
		  id: string;
		  category: AssessmentCategory;
		  text: string;
		  sectionId: string;
		}
		
		// Sample assessment questions
		const SAMPLE_QUESTIONS: AssessmentQuestion[] = [
		  {
		    id: 'if_01',
		    category: 'identity_fusion',
		    text: 'I often feel like my twin and I are the same person.',
		    sectionId: 'identity_section',
		  },
		  {
		    id: 'if_02', 
		    category: 'identity_fusion',
		    text: 'I have difficulty making decisions without my twin\'s input.',
		    sectionId: 'identity_section',
		  },
		  {
		    id: 'au_01',
		    category: 'autonomy',
		    text: 'I feel comfortable pursuing interests that my twin doesn\'t share.',
		    sectionId: 'autonomy_section',
		  },
		  {
		    id: 'au_02',
		    category: 'autonomy', 
		    text: 'I can express disagreement with my twin without feeling guilty.',
		    sectionId: 'autonomy_section',
		  },
		  {
		    id: 'bd_01',
		    category: 'boundaries',
		    text: 'I respect my twin\'s need for private space and time.',
		    sectionId: 'boundaries_section',
		  },
		];
		
		const LIKERT_OPTIONS = [
		  { value: 1, label: 'Strongly Disagree' },
		  { value: 2, label: 'Disagree' },
		  { value: 3, label: 'Somewhat Disagree' },
		  { value: 4, label: 'Neither Agree nor Disagree' },
		  { value: 5, label: 'Somewhat Agree' },
		  { value: 6, label: 'Agree' },
		  { value: 7, label: 'Strongly Agree' },
		];
		
		interface AssessmentWithTelemetryProps {
		  userId: string;
		  onComplete?: (responses: Record<string, LikertScale>) => void;
		  showAdminDashboard?: boolean;
		}
		
		const AssessmentWithTelemetry: React.FC<AssessmentWithTelemetryProps> = ({
		  userId,
		  onComplete,
		  showAdminDashboard = false,
		}) => {
		  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
		  const [responses, setResponses] = useState<Record<string, LikertScale>>({});
		  const [revisionCounts, setRevisionCounts] = useState<Record<string, number>>({});
		  const [confidenceLevels, setConfidenceLevels] = useState<Record<string, number>>({});
		  const [isStarted, setIsStarted] = useState(false);
		  const [isCompleted, setIsCompleted] = useState(false);
		  const [showConsentModal, setShowConsentModal] = useState(false);
		  const [showDashboard, setShowDashboard] = useState(false);
		  const [startTime, setStartTime] = useState<number>(0);
		
		  const { userConsent, config } = useTelemetryStore();
		  const telemetryStatus = selectTelemetryStatus();
		
		  // Initialize telemetry integration
		  const {
		    trackAssessmentStart,
		    trackQuestionView,
		    trackQuestionResponse,
		    trackQuestionRevision,
		    trackSectionCompletion,
		    trackAssessmentCompletion,
		    isEnabled,
		    resetSession,
		  } = useTelemetryIntegration({
		    sessionId: `assessment_${userId}_${Date.now()}`,
		    userId,
		    assessmentVersion: '1.0.0',
		    totalQuestions: SAMPLE_QUESTIONS.length,
		  });
		
		  const currentQuestion = SAMPLE_QUESTIONS[currentQuestionIndex];
		  const isLastQuestion = currentQuestionIndex === SAMPLE_QUESTIONS.length - 1;
		  const currentResponse = responses[currentQuestion?.id];
		
		  // Check if consent is needed on mount
		  useEffect(() => {
		    if (config.consentRequired && !userConsent) {
		      setShowConsentModal(true);
		    }
		  }, [config.consentRequired, userConsent]);
		
		  // Handle assessment start
		  const handleStartAssessment = useCallback(async () => {
		    setIsStarted(true);
		    setStartTime(Date.now());
		    
		    // Track assessment start
		    if (isEnabled()) {
		      await trackAssessmentStart();
		    }
		    
		    // Track first question view
		    if (SAMPLE_QUESTIONS.length > 0) {
		      await handleQuestionView(0);
		    }
		  }, [trackAssessmentStart, isEnabled]);
		
		  // Handle question view tracking
		  const handleQuestionView = useCallback(async (questionIndex: number) => {
		    const question = SAMPLE_QUESTIONS[questionIndex];
		    if (!question || !isEnabled()) return;
		
		    await trackQuestionView({
		      questionId: question.id,
		      questionCategory: question.category,
		      questionIndex,
		      sectionId: question.sectionId,
		    });
		  }, [trackQuestionView, isEnabled]);
		
		  // Handle response change
		  const handleResponseChange = useCallback(async (value: LikertScale, confidence?: number) => {
		    if (!currentQuestion) return;
		
		    const previousResponse = responses[currentQuestion.id];
		    const isRevision = previousResponse !== undefined;
		    const currentRevisions = revisionCounts[currentQuestion.id] || 0;
		
		    // Update local state
		    setResponses(prev => ({ ...prev, [currentQuestion.id]: value }));
		    
		    if (confidence) {
		      setConfidenceLevels(prev => ({ ...prev, [currentQuestion.id]: confidence }));
		    }
		
		    if (isRevision) {
		      setRevisionCounts(prev => ({
		        ...prev,
		        [currentQuestion.id]: currentRevisions + 1,
		      }));
		    }
		
		    // Track telemetry
		    if (isEnabled()) {
		      if (isRevision) {
		        await trackQuestionRevision(
		          {
		            questionId: currentQuestion.id,
		            questionCategory: currentQuestion.category,
		            questionIndex: currentQuestionIndex,
		            sectionId: currentQuestion.sectionId,
		          },
		          value,
		          currentRevisions + 1
		        );
		      } else {
		        await trackQuestionResponse(
		          {
		            questionId: currentQuestion.id,
		            questionCategory: currentQuestion.category,
		            questionIndex: currentQuestionIndex,
		            sectionId: currentQuestion.sectionId,
		          },
		          value,
		          currentRevisions,
		          confidence
		        );
		      }
		    }
		  }, [currentQuestion, currentQuestionIndex, responses, revisionCounts, 
		      trackQuestionResponse, trackQuestionRevision, isEnabled]);
		
		  // Handle navigation
		  const handleNext = useCallback(async () => {
		    if (!currentResponse) {
		      Alert.alert('Required', 'Please select a response before continuing.');
		      return;
		    }
		
		    if (isLastQuestion) {
		      await handleCompleteAssessment();
		    } else {
		      const nextIndex = currentQuestionIndex + 1;
		      setCurrentQuestionIndex(nextIndex);
		      await handleQuestionView(nextIndex);
		
		      // Track section completion if moving to new section
		      const currentSection = currentQuestion.sectionId;
		      const nextQuestion = SAMPLE_QUESTIONS[nextIndex];
		      
		      if (nextQuestion.sectionId !== currentSection) {
		        await trackSectionCompletion(
		          currentSection,
		          currentQuestion.category,
		          SAMPLE_QUESTIONS.filter(q => q.sectionId === currentSection).length,
		          1.0, // 100% completion
		          confidenceLevels[currentQuestion.id]
		        );
		      }
		    }
		  }, [currentResponse, isLastQuestion, currentQuestionIndex, currentQuestion,
		      handleCompleteAssessment, trackSectionCompletion, confidenceLevels]);
		
		  const handlePrevious = useCallback(async () => {
		    if (currentQuestionIndex > 0) {
		      const prevIndex = currentQuestionIndex - 1;
		      setCurrentQuestionIndex(prevIndex);
		      await handleQuestionView(prevIndex);
		    }
		  }, [currentQuestionIndex, handleQuestionView]);
		
		  // Handle assessment completion
		  const handleCompleteAssessment = useCallback(async () => {
		    const completedQuestions = Object.keys(responses).length;
		    const totalTime = Date.now() - startTime;
		    const totalRevisions = Object.values(revisionCounts).reduce((sum, count) => sum + count, 0);
		
		    // Track final section completion
		    const lastSection = currentQuestion.sectionId;
		    await trackSectionCompletion(
		      lastSection,
		      currentQuestion.category,
		      SAMPLE_QUESTIONS.filter(q => q.sectionId === lastSection).length,
		      1.0,
		      confidenceLevels[currentQuestion.id]
		    );
		
		    // Track assessment completion
		    if (isEnabled()) {
		      await trackAssessmentCompletion(completedQuestions);
		    }
		
		    setIsCompleted(true);
		    
		    if (onComplete) {
		      onComplete(responses);
		    }
		  }, [responses, startTime, revisionCounts, currentQuestion, trackSectionCompletion,
		      trackAssessmentCompletion, confidenceLevels, onComplete, isEnabled]);
		
		  // Handle privacy consent
		  const handleConsentChange = useCallback(async (consent: boolean, newConfig?: any) => {
		    const store = useTelemetryStore.getState();
		    
		    if (newConfig) {
		      store.updateConfig(newConfig);
		    }
		    
		    await store.updateConsent(consent);
		    
		    // Reset session when consent changes
		    resetSession();
		  }, [resetSession]);
		
		  // Render consent modal
		  if (showConsentModal) {
		    return (
		      <PrivacyConsentModal
		        visible={true}
		        onClose={() => setShowConsentModal(false)}
		        onConsentChange={handleConsentChange}
		        initialConsent={userConsent}
		        isUpdate={false}
		      />
		    );
		  }
		
		  // Render admin dashboard
		  if (showDashboard && showAdminDashboard) {
		    return (
		      <TelemetryDashboard
		        isAdmin={true}
		        onPrivacySettings={() => setShowConsentModal(true)}
		        onExportData={() => {
		          const exportData = useTelemetryStore.getState().exportData();
		          Alert.alert('Export Complete', 'Telemetry data has been exported.');
		          console.log('Exported data:', exportData);
		        }}
		      />
		    );
		  }
		
		  // Render completion screen
		  if (isCompleted) {
		    return (
		      <SafeAreaView className="flex-1 bg-gray-100">
		        <View className="flex-1 justify-center items-center px-4">
		          <View className="bg-white rounded-xl p-8 items-center shadow-lg max-w-sm w-full">
		            <Text className="text-2xl font-bold text-gray-900 mb-4 text-center">
		              Assessment Complete!
		            </Text>
		            
		            <Text className="text-gray-600 text-center mb-6">
		              Thank you for completing the twin relationship assessment. Your responses
		              help us improve our understanding of twin dynamics.
		            </Text>
		
		            {isEnabled() && (
		              <Text className="text-sm text-blue-600 text-center mb-4">
		                Your anonymous data contributes to assessment research while maintaining
		                complete privacy.
		              </Text>
		            )}
		
		            <View className="w-full space-y-3">
		              <TouchableOpacity
		                className="bg-blue-600 py-3 px-6 rounded-lg"
		                onPress={() => {
		                  // Reset for new assessment
		                  setCurrentQuestionIndex(0);
		                  setResponses({});
		                  setRevisionCounts({});
		                  setConfidenceLevels({});
		                  setIsStarted(false);
		                  setIsCompleted(false);
		                  resetSession();
		                }}
		              >
		                <Text className="text-white font-medium text-center">Take Another Assessment</Text>
		              </TouchableOpacity>
		
		              {showAdminDashboard && (
		                <TouchableOpacity
		                  className="border border-gray-300 py-3 px-6 rounded-lg"
		                  onPress={() => setShowDashboard(true)}
		                >
		                  <Text className="text-gray-700 font-medium text-center">View Analytics</Text>
		                </TouchableOpacity>
		              )}
		            </View>
		          </View>
		        </View>
		      </SafeAreaView>
		    );
		  }
		
		  // Render start screen
		  if (!isStarted) {
		    return (
		      <SafeAreaView className="flex-1 bg-gray-100">
		        <View className="flex-1 justify-center items-center px-4">
		          <View className="bg-white rounded-xl p-8 items-center shadow-lg max-w-sm w-full">
		            <Text className="text-2xl font-bold text-gray-900 mb-4 text-center">
		              Twin Relationship Assessment
		            </Text>
		            
		            <Text className="text-gray-600 text-center mb-6">
		              This assessment explores various aspects of twin relationships including
		              identity, autonomy, boundaries, and communication patterns.
		            </Text>
		
		            <Text className="text-sm text-gray-500 text-center mb-6">
		              Estimated time: 5-10 minutes
		            </Text>
		
		            {/* Telemetry status indicator */}
		            <View className="w-full mb-6">
		              <View className={`p-3 rounded-lg border ${
		                telemetryStatus === 'enabled' ? 'bg-green-50 border-green-200' :
		                telemetryStatus === 'consent_required' ? 'bg-yellow-50 border-yellow-200' :
		                'bg-gray-50 border-gray-200'
		              }`}>
		                <Text className={`text-xs text-center ${
		                  telemetryStatus === 'enabled' ? 'text-green-700' :
		                  telemetryStatus === 'consent_required' ? 'text-yellow-700' :
		                  'text-gray-600'
		                }`}>
		                  Analytics: {telemetryStatus === 'enabled' ? 'Contributing to research' :
		                            telemetryStatus === 'consent_required' ? 'Consent required' :
		                            'Disabled'}
		                </Text>
		              </View>
		            </View>
		
		            <TouchableOpacity
		              className="w-full bg-blue-600 py-3 px-6 rounded-lg mb-3"
		              onPress={handleStartAssessment}
		            >
		              <Text className="text-white font-medium text-center">Start Assessment</Text>
		            </TouchableOpacity>
		
		            <TouchableOpacity
		              className="w-full border border-gray-300 py-3 px-6 rounded-lg"
		              onPress={() => setShowConsentModal(true)}
		            >
		              <Text className="text-gray-700 font-medium text-center">Privacy Settings</Text>
		            </TouchableOpacity>
		          </View>
		        </View>
		      </SafeAreaView>
		    );
		  }
		
		  // Render assessment question
		  return (
		    <SafeAreaView className="flex-1 bg-gray-100">
		      <View className="flex-1">
		        {/* Header */}
		        <View className="bg-white border-b border-gray-200 px-4 py-3">
		          <View className="flex-row items-center justify-between">
		            <Text className="text-lg font-semibold text-gray-900">
		              Question {currentQuestionIndex + 1} of {SAMPLE_QUESTIONS.length}
		            </Text>
		            
		            {isEnabled() && (
		              <View className="bg-green-100 px-2 py-1 rounded">
		                <Text className="text-green-700 text-xs font-medium">Research Mode</Text>
		              </View>
		            )}
		          </View>
		          
		          {/* Progress bar */}
		          <View className="mt-2 bg-gray-200 rounded-full h-2">
		            <View 
		              className="bg-blue-600 h-2 rounded-full transition-all duration-300"
		              style={{ 
		                width: `${((currentQuestionIndex + 1) / SAMPLE_QUESTIONS.length) * 100}%` 
		              }}
		            />
		          </View>
		        </View>
		
		        {/* Question content */}
		        <ScrollView className="flex-1 px-4 py-6">
		          <Text className="text-xl font-semibold text-gray-900 mb-6 leading-relaxed">
		            {currentQuestion.text}
		          </Text>
		
		          {/* Likert scale options */}
		          <View className="space-y-3">
		            {LIKERT_OPTIONS.map((option) => (
		              <TouchableOpacity
		                key={option.value}
		                className={`p-4 rounded-lg border-2 ${
		                  currentResponse === option.value
		                    ? 'border-blue-500 bg-blue-50'
		                    : 'border-gray-200 bg-white'
		                }`}
		                onPress={() => handleResponseChange(option.value as LikertScale, 4)}
		              >
		                <View className="flex-row items-center">
		                  <View className={`w-4 h-4 rounded-full border-2 mr-3 ${
		                    currentResponse === option.value
		                      ? 'border-blue-500 bg-blue-500'
		                      : 'border-gray-300'
		                  }`} />
		                  
		                  <Text className={`flex-1 ${
		                    currentResponse === option.value
		                      ? 'text-blue-700 font-medium'
		                      : 'text-gray-700'
		                  }`}>
		                    {option.label}
		                  </Text>
		                  
		                  <Text className={`text-sm ${
		                    currentResponse === option.value
		                      ? 'text-blue-600'
		                      : 'text-gray-400'
		                  }`}>
		                    {option.value}
		                  </Text>
		                </View>
		              </TouchableOpacity>
		            ))}
		          </View>
		
		          {/* Revision indicator */}
		          {revisionCounts[currentQuestion?.id] > 0 && (
		            <View className="mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
		              <Text className="text-yellow-700 text-sm text-center">
		                Response revised {revisionCounts[currentQuestion.id]} time(s)
		              </Text>
		            </View>
		          )}
		        </ScrollView>
		
		        {/* Navigation */}
		        <View className="bg-white border-t border-gray-200 px-4 py-3">
		          <View className="flex-row justify-between">
		            <TouchableOpacity
		              className={`flex-1 py-3 px-4 rounded-lg mr-2 ${
		                currentQuestionIndex === 0
		                  ? 'bg-gray-100'
		                  : 'bg-gray-200'
		              }`}
		              onPress={handlePrevious}
		              disabled={currentQuestionIndex === 0}
		            >
		              <Text className={`text-center font-medium ${
		                currentQuestionIndex === 0
		                  ? 'text-gray-400'
		                  : 'text-gray-700'
		              }`}>
		                Previous
		              </Text>
		            </TouchableOpacity>
		
		            <TouchableOpacity
		              className={`flex-1 py-3 px-4 rounded-lg ml-2 ${
		                currentResponse
		                  ? 'bg-blue-600'
		                  : 'bg-gray-300'
		              }`}
		              onPress={handleNext}
		              disabled={!currentResponse}
		            >
		              <Text className={`text-center font-medium ${
		                currentResponse
		                  ? 'text-white'
		                  : 'text-gray-500'
		              }`}>
		                {isLastQuestion ? 'Complete' : 'Next'}
		              </Text>
		            </TouchableOpacity>
		          </View>
		        </View>
		      </View>
		    </SafeAreaView>
		  );
		};
		
		export default AssessmentWithTelemetry;]]></file>
	<file path='hooks/games/useGameConfig.ts'><![CDATA[
		import { TwinGameConfig, SymbolChoice } from '../../types/games';
		
		export const GAME_CONFIGS: Record<string, TwinGameConfig> = {
		  cognitive_sync_maze: {
		    id: 'cognitive_sync_maze',
		    name: 'Cognitive Synchrony Maze',
		    description: 'Navigate identical mazes to reveal how your minds work in harmony',
		    psychologicalFocus: 'Problem-solving patterns & decision-making styles',
		    icon: 'git-branch',
		    difficulty: 'medium',
		    insightExample: 'You both favor right-hand turns 73% of the time',
		    timeLimit: 120,
		    rounds: 1
		  },
		  emotional_resonance: {
		    id: 'emotional_resonance',
		    name: 'Emotional Resonance Mapping',
		    description: 'Explore emotional synchrony through abstract imagery and sensations',
		    psychologicalFocus: 'Emotional processing & empathic connection',
		    icon: 'heart-circle',
		    difficulty: 'hard',
		    insightExample: 'Your emotional vocabularies overlap by 67%',
		    rounds: 4
		  },
		  temporal_decision: {
		    id: 'temporal_decision',
		    name: 'Temporal Decision Synchrony',
		    description: 'Make rapid-fire decisions to uncover shared values and instincts',
		    psychologicalFocus: 'Values alignment & stress responses',
		    icon: 'timer',
		    difficulty: 'medium',
		    insightExample: 'You both become 40% more pragmatic under pressure',
		    rounds: 5
		  },
		  iconic_duo: {
		    id: 'iconic_duo',
		    name: 'Which Iconic Duo Are You?',
		    description: 'Discover which famous pair best represents your twin dynamic',
		    psychologicalFocus: 'Relationship dynamics & self-perception',
		    icon: 'people',
		    difficulty: 'easy',
		    insightExample: "You're most like Fred & George Weasley: synchronized mischief",
		    rounds: 1
		  }
		};
		
		// Keep symbol choices as they're still used in the new system
		export const SYMBOL_CHOICES: SymbolChoice[] = [
		  { id: 'infinity', symbol: '∞', meaning: 'Eternal Connection', category: 'mystical' },
		  { id: 'triangle', symbol: '△', meaning: 'Balance & Harmony', category: 'geometric' },
		  { id: 'circle', symbol: '○', meaning: 'Unity & Wholeness', category: 'geometric' },
		  { id: 'star', symbol: '✦', meaning: 'Guidance & Light', category: 'cosmic' },
		  { id: 'moon', symbol: '☽', meaning: 'Intuition & Mystery', category: 'cosmic' },
		  { id: 'spiral', symbol: '🌀', meaning: 'Growth & Evolution', category: 'mystical' },
		  { id: 'hexagon', symbol: '⬡', meaning: 'Perfect Structure', category: 'geometric' },
		  { id: 'yin_yang', symbol: '☯', meaning: 'Duality & Balance', category: 'mystical' },
		  { id: 'lotus', symbol: '🪷', meaning: 'Spiritual Awakening', category: 'mystical' },
		  { id: 'diamond', symbol: '◊', meaning: 'Clarity & Strength', category: 'geometric' }
		];
		
		// New emotion choices for emotional resonance game
		export const EMOTION_RATINGS = [
		  'joy',
		  'sadness',
		  'peace',
		  'anxiety',
		  'love',
		  'curiosity'
		];
		
		// Word options for emotional resonance
		export const EMOTION_WORDS = [
		  'flowing', 'sharp', 'warm', 'cold', 'expansive', 'contained',
		  'rising', 'falling', 'vibrant', 'muted', 'chaotic', 'ordered',
		  'ancient', 'new', 'familiar', 'strange', 'peaceful', 'energetic'
		];
		
		// Color choices for emotional associations
		export const EMOTION_COLORS = [
		  '#FF6B6B', '#4ECDC4', '#45B7D1', '#F9C74F', '#90BE6D', '#8B5CF6',
		  '#F72585', '#4361EE', '#F77F00', '#06FFA5', '#FF006E', '#3A86FF'
		];
		
		export const useGameConfig = () => {
		  const getGameConfig = (gameType: string): TwinGameConfig | undefined => {
		    return GAME_CONFIGS[gameType];
		  };
		
		  const getSymbolChoices = (): SymbolChoice[] => SYMBOL_CHOICES;
		  
		  const getEmotionRatings = (): string[] => EMOTION_RATINGS;
		  
		  const getEmotionWords = (): string[] => EMOTION_WORDS;
		  
		  const getEmotionColors = (): string[] => EMOTION_COLORS;
		  
		  const getNumberRange = (difficulty: string) => {
		    switch (difficulty) {
		      case 'easy': return { min: 1, max: 5 };
		      case 'medium': return { min: 1, max: 10 };
		      case 'hard': return { min: 1, max: 20 };
		      default: return { min: 1, max: 10 };
		    }
		  };
		
		  return {
		    getGameConfig,
		    getSymbolChoices,
		    getEmotionRatings,
		    getEmotionWords,
		    getEmotionColors,
		    getNumberRange,
		    allGames: Object.values(GAME_CONFIGS)
		  };
		};
		
		export default useGameConfig;]]></file>
	<file path='hooks/usePremiumFeatures.ts'>
		import { useCallback } from "react";
		import { useNavigation } from "@react-navigation/native";
		import { useSubscriptionStore } from "../state/subscriptionStore";
		import { PREMIUM_FEATURES } from "../types/premium/subscription";
		
		/**
		 * Hook for managing premium feature access and upgrade flow
		 */
		export const usePremiumFeatures = () => {
		  const navigation = useNavigation();
		  const {
		    subscriptionInfo,
		    hasAccessTo,
		    canAccessFeature,
		    getPremiumUpsellData,
		    trackConversionEvent
		  } = useSubscriptionStore();
		
		  const navigateToUpgrade = useCallback((featureId?: string, source?: string) => {
		    trackConversionEvent('upgrade_flow_started', { featureId, source });
		    
		    navigation.navigate('Premium' as never, { 
		      feature: featureId, 
		      source: source || 'feature_gate' 
		    } as never);
		  }, [navigation, trackConversionEvent]);
		
		  const checkFeatureAccess = useCallback((featureId: string) => {
		    return {
		      hasAccess: hasAccessTo(featureId),
		      canAccess: canAccessFeature(featureId),
		      upsellInfo: getPremiumUpsellData(featureId)
		    };
		  }, [hasAccessTo, canAccessFeature, getPremiumUpsellData]);
		
		  const requirePremiumAccess = useCallback((
		    featureId: string,
		    onUpgrade?: () => void,
		    source?: string
		  ): boolean => {
		    const hasAccess = hasAccessTo(featureId);
		    
		    if (!hasAccess) {
		      trackConversionEvent('feature_blocked', { featureId, source });
		      
		      if (onUpgrade) {
		        onUpgrade();
		      } else {
		        navigateToUpgrade(featureId, source);
		      }
		      
		      return false;
		    }
		    
		    return true;
		  }, [hasAccessTo, navigateToUpgrade, trackConversionEvent]);
		
		  const getFeatureInfo = useCallback((featureId: string) => {
		    return PREMIUM_FEATURES.find(f => f.id === featureId);
		  }, []);
		
		  const getPremiumFeaturesByCategory = useCallback((category: string) => {
		    return PREMIUM_FEATURES.filter(f => f.category === category);
		  }, []);
		
		  const isSubscriptionActive = subscriptionInfo.isActive;
		  const subscriptionPlan = subscriptionInfo.plan;
		  const subscriptionStatus = subscriptionInfo.status;
		
		  return {
		    // Subscription info
		    isSubscriptionActive,
		    subscriptionPlan,
		    subscriptionStatus,
		    subscriptionInfo,
		    
		    // Feature access
		    hasAccessTo,
		    canAccessFeature,
		    checkFeatureAccess,
		    requirePremiumAccess,
		    
		    // Feature info
		    getFeatureInfo,
		    getPremiumFeaturesByCategory,
		    
		    // Navigation
		    navigateToUpgrade,
		    
		    // Upsell
		    getPremiumUpsellData
		  };
		};
		
		/**
		 * Hook for assessment-specific premium features
		 */
		export const useAssessmentPremium = () => {
		  const premium = usePremiumFeatures();
		  
		  const canViewDetailedResults = premium.hasAccessTo('detailed_results');
		  const canExportPDF = premium.hasAccessTo('pdf_export');
		  const canAccessCoaching = premium.hasAccessTo('coaching_plans');
		  const canViewAnalytics = premium.hasAccessTo('twin_analytics');
		  const canGetRecommendations = premium.hasAccessTo('recommendations');
		  
		  const requireDetailedResults = (onUpgrade?: () => void) => 
		    premium.requirePremiumAccess('detailed_results', onUpgrade, 'assessment');
		  
		  const requirePDFExport = (onUpgrade?: () => void) => 
		    premium.requirePremiumAccess('pdf_export', onUpgrade, 'assessment');
		    
		  const requireCoachingPlans = (onUpgrade?: () => void) => 
		    premium.requirePremiumAccess('coaching_plans', onUpgrade, 'assessment');
		  
		  return {
		    ...premium,
		    canViewDetailedResults,
		    canExportPDF,
		    canAccessCoaching,
		    canViewAnalytics,
		    canGetRecommendations,
		    requireDetailedResults,
		    requirePDFExport,
		    requireCoachingPlans
		  };
		};
		
		/**
		 * Hook for analytics-specific premium features
		 */
		export const useAnalyticsPremium = () => {
		  const premium = usePremiumFeatures();
		  
		  const canViewAdvancedAnalytics = premium.hasAccessTo('twin_analytics');
		  const canRetakeAssessments = premium.hasAccessTo('unlimited_assessments');
		  
		  const requireAdvancedAnalytics = (onUpgrade?: () => void) => 
		    premium.requirePremiumAccess('twin_analytics', onUpgrade, 'dashboard');
		    
		  const requireUnlimitedRetakes = (onUpgrade?: () => void) => 
		    premium.requirePremiumAccess('unlimited_assessments', onUpgrade, 'dashboard');
		  
		  return {
		    ...premium,
		    canViewAdvancedAnalytics,
		    canRetakeAssessments,
		    requireAdvancedAnalytics,
		    requireUnlimitedRetakes
		  };
		};</file>
	<file path='hooks/usePushNotifications.ts'><![CDATA[
		import { useEffect, useRef } from 'react';
		import * as Notifications from 'expo-notifications';
		import * as Device from 'expo-device';
		import { Platform } from 'react-native';
		import { useTwinStore } from '../state/twinStore';
		import { useChatStore } from '../state/chatStore';
		
		// Configure notification handling
		Notifications.setNotificationHandler({
		  handleNotification: async () => ({
		    shouldShowAlert: true,
		    shouldPlaySound: true,
		    shouldSetBadge: true,
		  }),
		});
		
		export const usePushNotifications = () => {
		  const notificationListener = useRef<any>();
		  const responseListener = useRef<any>();
		  const { notificationsEnabled } = useTwinStore();
		  const { incrementUnreadCount } = useChatStore();
		
		  useEffect(() => {
		    if (!notificationsEnabled) return;
		
		    registerForPushNotificationsAsync();
		
		    // Listen for notifications received while app is foregrounded
		    notificationListener.current = Notifications.addNotificationReceivedListener(
		      notification => {
		        console.log('Notification received:', notification);
		        // Handle twintuition alerts specially
		        if (notification.request.content.data?.type === 'twintuition') {
		          // Add haptic feedback or special handling
		        } else if (notification.request.content.data?.screen === 'TwinTalk') {
		          incrementUnreadCount();
		        }
		      }
		    );
		
		    // Listen for notification taps
		    responseListener.current = Notifications.addNotificationResponseReceivedListener(
		      response => {
		        console.log('Notification tapped:', response);
		        const data = response.notification.request.content.data;
		        
		        if (data?.screen === 'TwinTalk') {
		          // Navigate to Twin Talk (would need navigation context)
		        } else if (data?.screen === 'Twintuition') {
		          // Navigate to Twintuition screen
		        }
		      }
		    );
		
		    return () => {
		      Notifications.removeNotificationSubscription(notificationListener.current);
		      Notifications.removeNotificationSubscription(responseListener.current);
		    };
		  }, [notificationsEnabled]);
		
		  const registerForPushNotificationsAsync = async () => {
		    if (!Device.isDevice) {
		      console.log('Must use physical device for Push Notifications');
		      return;
		    }
		
		    const { status: existingStatus } = await Notifications.getPermissionsAsync();
		    let finalStatus = existingStatus;
		    
		    if (existingStatus !== 'granted') {
		      const { status } = await Notifications.requestPermissionsAsync();
		      finalStatus = status;
		    }
		    
		    if (finalStatus !== 'granted') {
		      console.log('Failed to get push token for push notification!');
		      return;
		    }
		
		    const token = await Notifications.getExpoPushTokenAsync({
		      projectId: 'your-project-id', // Replace with your actual project ID
		    });
		
		    if (Platform.OS === 'android') {
		      await Notifications.setNotificationChannelAsync('twinship-default', {
		        name: 'Twinship',
		        importance: Notifications.AndroidImportance.MAX,
		        vibrationPattern: [0, 250, 250, 250],
		        lightColor: '#8a2be2',
		      });
		
		      await Notifications.setNotificationChannelAsync('twintuition', {
		        name: 'Twintuition Alerts',
		        description: 'Sacred twin connection moments',
		        importance: Notifications.AndroidImportance.MAX,
		        vibrationPattern: [0, 500, 200, 500],
		        lightColor: '#ff1493',
		        sound: 'twintuition_sound.wav', // Custom sound file
		      });
		    }
		
		    return token.data;
		  };
		
		  const scheduleLocalTwintuitionAlert = async (message: string) => {
		    if (!notificationsEnabled) return;
		
		    await Notifications.scheduleNotificationAsync({
		      content: {
		        title: 'Twintuition Moment! 🔮',
		        body: message,
		        data: { type: 'twintuition', screen: 'Twintuition' },
		        sound: 'twintuition_sound.wav',
		      },
		      trigger: null, // Show immediately
		    });
		  };
		
		  const scheduleMessageNotification = async (senderName: string, messageText: string, messageId: string) => {
		    if (!notificationsEnabled) return;
		
		    await Notifications.scheduleNotificationAsync({
		      content: {
		        title: `${senderName} sent a message`,
		        body: messageText.length > 50 ? messageText.substring(0, 50) + '...' : messageText,
		        data: { messageId, screen: 'TwinTalk' },
		      },
		      trigger: null,
		    });
		  };
		
		  return {
		    scheduleLocalTwintuitionAlert,
		    scheduleMessageNotification,
		  };
		};]]></file>
	<file path='hooks/useResearchIntegration.ts'><![CDATA[
		import { useEffect } from 'react';
		import { useTwinStore } from '../state/twinStore';
		import { useResearchStore } from '../state/researchStore';
		import { researchService } from '../services/researchService';
		import { AssessmentResults } from '../types/assessment';
		import { PsychicGameResult } from '../state/twinStore';
		
		/**
		 * Hook to automatically contribute data to research studies
		 * when users participate in assessments or activities
		 */
		export const useResearchIntegration = () => {
		  const { userProfile, gameResults, incrementResearchContributions } = useTwinStore();
		  const { participation, contributeData } = useResearchStore();
		
		  /**
		   * Contribute assessment data to research studies
		   */
		  const contributeAssessmentData = async (assessmentResults: AssessmentResults) => {
		    if (!userProfile || !participation?.activeStudies.length) return;
		
		    try {
		      await researchService.contributeAssessmentData(userProfile.id, assessmentResults);
		      incrementResearchContributions();
		      
		      // Update the research store
		      if (contributeData) {
		        await contributeData(userProfile.id, 'assessment', assessmentResults.subscaleScores.length);
		      }
		    } catch (error) {
		      console.error('Failed to contribute assessment data to research:', error);
		    }
		  };
		
		  /**
		   * Contribute psychic game data to research studies
		   */
		  const contributePsychicGameData = async (gameResult: PsychicGameResult) => {
		    if (!userProfile || !participation?.activeStudies.length) return;
		
		    try {
		      await researchService.contributeBehavioralData(
		        userProfile.id, 
		        `psychic_game_${gameResult.gameType}`, 
		        1
		      );
		      incrementResearchContributions();
		      
		      // Update the research store
		      if (contributeData) {
		        await contributeData(userProfile.id, 'games', 1);
		      }
		    } catch (error) {
		      console.error('Failed to contribute psychic game data to research:', error);
		    }
		  };
		
		  /**
		   * Contribute communication patterns to research studies
		   */
		  const contributeCommunicationData = async (messageCount: number) => {
		    if (!userProfile || !participation?.activeStudies.length) return;
		
		    try {
		      await researchService.contributeBehavioralData(
		        userProfile.id, 
		        'communication_patterns', 
		        messageCount
		      );
		      incrementResearchContributions();
		      
		      // Update the research store
		      if (contributeData) {
		        await contributeData(userProfile.id, 'communication', messageCount);
		      }
		    } catch (error) {
		      console.error('Failed to contribute communication data to research:', error);
		    }
		  };
		
		  /**
		   * Contribute twintuition alert data to research studies
		   */
		  const contributeTwintuitionData = async (alertType: string) => {
		    if (!userProfile || !participation?.activeStudies.length) return;
		
		    try {
		      await researchService.contributeBehavioralData(
		        userProfile.id, 
		        `twintuition_${alertType}`, 
		        1
		      );
		      incrementResearchContributions();
		      
		      // Update the research store
		      if (contributeData) {
		        await contributeData(userProfile.id, 'behavioral', 1);
		      }
		    } catch (error) {
		      console.error('Failed to contribute twintuition data to research:', error);
		    }
		  };
		
		  // Auto-contribute latest game results
		  useEffect(() => {
		    if (gameResults.length > 0 && participation?.activeStudies.length) {
		      const latestGame = gameResults[0];
		      // Check if this game result was already contributed
		      const gameTimestamp = new Date(latestGame.timestamp).getTime();
		      const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
		      
		      if (gameTimestamp > fiveMinutesAgo) {
		        contributePsychicGameData(latestGame);
		      }
		    }
		  }, [gameResults, participation]);
		
		  return {
		    contributeAssessmentData,
		    contributePsychicGameData,
		    contributeCommunicationData,
		    contributeTwintuitionData,
		    isParticipatingInResearch: participation?.activeStudies.length > 0
		  };
		};]]></file>
	<file path='hooks/useTelemetryIntegration.ts'><![CDATA[
		/**
		 * Telemetry Integration Hook
		 * Seamlessly integrates telemetry collection with assessment flow
		 */
		
		import { useEffect, useRef, useCallback } from 'react';
		import { useTelemetryStore } from '../state/telemetryStore';
		import { telemetryService } from '../services/telemetryService';
		import { anomalyDetector } from '../utils/anomalyDetection';
		import { statisticalNorming } from '../utils/statisticalNorming';
		import { AssessmentCategory, LikertScale } from '../types/assessment';
		import { AnomalyType } from '../types/telemetry';
		
		interface AssessmentContext {
		  sessionId: string;
		  userId: string;
		  assessmentVersion: string;
		  totalQuestions: number;
		}
		
		interface QuestionContext {
		  questionId: string;
		  questionCategory: AssessmentCategory;
		  questionIndex: number;
		  sectionId: string;
		}
		
		export const useTelemetryIntegration = (context?: AssessmentContext) => {
		  const {
		    config,
		    userConsent,
		    currentSession,
		    addAlert,
		    incrementEventQueue,
		    decrementEventQueue,
		    updatePerformanceMetrics,
		  } = useTelemetryStore();
		
		  const questionStartTime = useRef<number>(0);
		  const sectionStartTime = useRef<number>(0);
		  const assessmentStartTime = useRef<number>(0);
		  const responseHistory = useRef<Array<{
		    questionId: string;
		    category: AssessmentCategory;
		    response: LikertScale | string | number;
		    responseTime: number;
		    revisions: number;
		  }>>([]);
		
		  // Initialize telemetry service
		  useEffect(() => {
		    if (userConsent && config.enabled) {
		      telemetryService.initialize(true, config);
		    }
		  }, [userConsent, config.enabled]);
		
		  // Track assessment start
		  const trackAssessmentStart = useCallback(async () => {
		    if (!isEnabled() || !context) return;
		
		    assessmentStartTime.current = Date.now();
		    
		    try {
		      await telemetryService.trackAssessmentEvent('assessment_started', {
		        assessmentVersion: context.assessmentVersion,
		        totalQuestions: context.totalQuestions,
		        completedQuestions: 0,
		        totalTimeSpent: 0,
		        totalRevisions: 0,
		      });
		
		      // Track performance metric
		      await telemetryService.trackPerformance('assessment_start_time', Date.now());
		    } catch (error) {
		      console.error('Failed to track assessment start:', error);
		    }
		  }, [context, config.enabled, userConsent]);
		
		  // Track question view
		  const trackQuestionView = useCallback(async (questionContext: QuestionContext) => {
		    if (!isEnabled()) return;
		
		    questionStartTime.current = Date.now();
		    
		    try {
		      await telemetryService.trackQuestionEvent('question_viewed', {
		        questionId: questionContext.questionId,
		        questionCategory: questionContext.questionCategory,
		        questionIndex: questionContext.questionIndex,
		        sectionId: questionContext.sectionId,
		        timeOnQuestion: 0,
		        revisionCount: 0,
		      });
		
		      incrementEventQueue();
		    } catch (error) {
		      console.error('Failed to track question view:', error);
		    }
		  }, [config.enabled, userConsent]);
		
		  // Track question response
		  const trackQuestionResponse = useCallback(async (
		    questionContext: QuestionContext,
		    response: LikertScale | string | number,
		    revisionCount: number = 0,
		    confidenceLevel?: number
		  ) => {
		    if (!isEnabled()) return;
		
		    const responseTime = Date.now() - questionStartTime.current;
		    
		    try {
		      await telemetryService.trackQuestionEvent('question_answered', {
		        questionId: questionContext.questionId,
		        questionCategory: questionContext.questionCategory,
		        questionIndex: questionContext.questionIndex,
		        sectionId: questionContext.sectionId,
		        timeOnQuestion: responseTime,
		        responseValue: response,
		        revisionCount,
		        confidenceLevel,
		      });
		
		      // Store response for pattern analysis
		      responseHistory.current.push({
		        questionId: questionContext.questionId,
		        category: questionContext.questionCategory,
		        response,
		        responseTime,
		        revisions: revisionCount,
		      });
		
		      // Perform real-time anomaly detection
		      await performAnomalyCheck(questionContext, response, responseTime, revisionCount);
		
		      incrementEventQueue();
		    } catch (error) {
		      console.error('Failed to track question response:', error);
		    }
		  }, [config.enabled, userConsent]);
		
		  // Track question revision
		  const trackQuestionRevision = useCallback(async (
		    questionContext: QuestionContext,
		    newResponse: LikertScale | string | number,
		    revisionCount: number
		  ) => {
		    if (!isEnabled()) return;
		
		    const responseTime = Date.now() - questionStartTime.current;
		    
		    try {
		      await telemetryService.trackQuestionEvent('question_revised', {
		        questionId: questionContext.questionId,
		        questionCategory: questionContext.questionCategory,
		        questionIndex: questionContext.questionIndex,
		        sectionId: questionContext.sectionId,
		        timeOnQuestion: responseTime,
		        responseValue: newResponse,
		        revisionCount,
		      });
		
		      // Check for excessive revisions
		      if (revisionCount > 5) {
		        await telemetryService.trackAnomaly('excessive_revisions', {
		          severity: revisionCount > 10 ? 'high' : 'medium',
		          detectionAlgorithm: 'revision_counter',
		          contextData: {
		            questionId: questionContext.questionId,
		            revisionCount,
		            responseTime,
		          },
		          actionTaken: 'flagged',
		        });
		      }
		
		      incrementEventQueue();
		    } catch (error) {
		      console.error('Failed to track question revision:', error);
		    }
		  }, [config.enabled, userConsent]);
		
		  // Track section completion
		  const trackSectionCompletion = useCallback(async (
		    sectionId: string,
		    sectionCategory: AssessmentCategory,
		    questionsInSection: number,
		    completionRate: number,
		    averageConfidence?: number
		  ) => {
		    if (!isEnabled()) return;
		
		    const sectionTime = Date.now() - sectionStartTime.current;
		    const sectionResponses = responseHistory.current.filter(r => 
		      r.questionId.includes(sectionId) // Simplified section matching
		    );
		    const totalRevisions = sectionResponses.reduce((sum, r) => sum + r.revisions, 0);
		
		    try {
		      await telemetryService.trackSectionCompletion({
		        sectionId,
		        sectionCategory,
		        questionsInSection,
		        timeInSection: sectionTime,
		        completionRate,
		        averageConfidence,
		        revisionsInSection: totalRevisions,
		      });
		
		      // Reset section timer
		      sectionStartTime.current = Date.now();
		
		      incrementEventQueue();
		    } catch (error) {
		      console.error('Failed to track section completion:', error);
		    }
		  }, [config.enabled, userConsent]);
		
		  // Track assessment completion
		  const trackAssessmentCompletion = useCallback(async (
		    completedQuestions: number,
		    abandonmentPoint?: { sectionId: string; questionIndex: number }
		  ) => {
		    if (!isEnabled() || !context) return;
		
		    const totalTime = Date.now() - assessmentStartTime.current;
		    const totalRevisions = responseHistory.current.reduce((sum, r) => sum + r.revisions, 0);
		    const isCompleted = completedQuestions === context.totalQuestions;
		
		    try {
		      await telemetryService.trackAssessmentEvent(
		        isCompleted ? 'assessment_completed' : 'assessment_abandoned',
		        {
		          assessmentVersion: context.assessmentVersion,
		          totalQuestions: context.totalQuestions,
		          completedQuestions,
		          totalTimeSpent: totalTime,
		          totalRevisions,
		          abandonmentPoint: abandonmentPoint ? {
		            ...abandonmentPoint,
		            timeSpent: totalTime,
		          } : undefined,
		        }
		      );
		
		      // Perform final data analysis if completed
		      if (isCompleted && responseHistory.current.length > 0) {
		        await performFinalAnalysis();
		      }
		
		      // Update performance metrics
		      updatePerformanceMetrics({
		        averageResponseTime: totalTime / Math.max(1, completedQuestions),
		        lastUpdated: new Date().toISOString(),
		      });
		
		      incrementEventQueue();
		    } catch (error) {
		      console.error('Failed to track assessment completion:', error);
		    }
		  }, [context, config.enabled, userConsent]);
		
		  // Perform real-time anomaly detection
		  const performAnomalyCheck = useCallback(async (
		    questionContext: QuestionContext,
		    response: LikertScale | string | number,
		    responseTime: number,
		    revisionCount: number
		  ) => {
		    if (!config.collectAnomalyData) return;
		
		    try {
		      // Check for individual question anomalies
		      const anomalies: Array<{ type: AnomalyType; severity: string; reason: string }> = [];
		
		      // Too fast response
		      if (responseTime < 500) {
		        anomalies.push({
		          type: 'too_fast_completion',
		          severity: responseTime < 200 ? 'high' : 'medium',
		          reason: `Response time ${responseTime}ms is unusually fast`,
		        });
		      }
		
		      // Too slow response (might indicate distraction or difficulty)
		      if (responseTime > 120000) { // 2 minutes
		        anomalies.push({
		          type: 'too_slow_completion',
		          severity: 'low',
		          reason: `Response time ${Math.round(responseTime / 1000)}s is unusually slow`,
		        });
		      }
		
		      // Check for pattern anomalies if we have enough history
		      if (responseHistory.current.length >= 5) {
		        const recentResponses = responseHistory.current.slice(-5);
		        const responses = recentResponses.map(r => 
		          typeof r.response === 'number' ? r.response : 0
		        );
		        
		        // Simple straight-line detection
		        const uniqueResponses = new Set(responses);
		        if (uniqueResponses.size === 1 && responses.length >= 5) {
		          anomalies.push({
		            type: 'straight_line_responding',
		            severity: 'high',
		            reason: `Last 5 responses are identical (${responses[0]})`,
		          });
		        }
		      }
		
		      // Track detected anomalies
		      for (const anomaly of anomalies) {
		        await telemetryService.trackAnomaly(anomaly.type, {
		          severity: anomaly.severity as any,
		          detectionAlgorithm: 'real_time_question_check',
		          contextData: {
		            questionId: questionContext.questionId,
		            responseTime,
		            response: response.toString(),
		            revisionCount,
		            reason: anomaly.reason,
		          },
		          actionTaken: 'flagged',
		        });
		
		        // Add alert for high severity anomalies
		        if (anomaly.severity === 'high') {
		          addAlert({
		            type: 'anomaly_spike',
		            severity: 'warning',
		            message: `Potential data quality issue detected: ${anomaly.reason}`,
		            context: {
		              questionId: questionContext.questionId,
		              anomalyType: anomaly.type,
		            },
		          });
		        }
		      }
		    } catch (error) {
		      console.error('Failed to perform anomaly check:', error);
		    }
		  }, [config.collectAnomalyData]);
		
		  // Perform comprehensive analysis at assessment completion
		  const performFinalAnalysis = useCallback(async () => {
		    if (!config.collectNormingData || responseHistory.current.length === 0) return;
		
		    try {
		      // Group responses by question for analysis
		      const questionGroups = responseHistory.current.reduce((groups, response) => {
		        if (!groups[response.questionId]) {
		          groups[response.questionId] = {
		            questionId: response.questionId,
		            category: response.category,
		            responses: [],
		            responseTimes: [],
		            revisions: [],
		            sessionIds: [currentSession?.sessionId || 'unknown'],
		          };
		        }
		        
		        groups[response.questionId].responses.push(
		          typeof response.response === 'number' ? response.response : 1
		        );
		        groups[response.questionId].responseTimes.push(response.responseTime);
		        groups[response.questionId].revisions.push(response.revisions);
		        
		        return groups;
		      }, {} as Record<string, any>);
		
		      // Perform statistical analysis for each question
		      for (const [questionId, data] of Object.entries(questionGroups)) {
		        // Skip if insufficient data
		        if (data.responses.length < 1) continue;
		
		        // Generate norming statistics (in production, this would accumulate over many sessions)
		        const normingStats = statisticalNorming.calculateNormingStatistics(data);
		        
		        // Perform item analysis
		        const itemAnalysis = statisticalNorming.analyzeItem(data);
		        
		        // Update store with new statistics
		        useTelemetryStore.getState().addNormingStatistics(questionId, normingStats);
		        useTelemetryStore.getState().addItemAnalysis(questionId, itemAnalysis);
		
		        // Flag problematic items
		        if (itemAnalysis.flagged) {
		          addAlert({
		            type: 'data_concern',
		            severity: itemAnalysis.recommendations.some(r => r.priority === 'critical') ? 'error' : 'warning',
		            message: `Item ${questionId} flagged for quality issues`,
		            context: {
		              questionId,
		              flagReasons: itemAnalysis.flagReasons,
		              recommendations: itemAnalysis.recommendations.length,
		            },
		          });
		        }
		      }
		
		      // Perform comprehensive pattern analysis
		      const responsePattern = anomalyDetector.createResponsePattern(
		        responseHistory.current.map((r, index) => ({
		          type: 'question_answered' as const,
		          questionId: r.questionId,
		          questionCategory: r.category,
		          questionIndex: index,
		          sectionId: 'section_1', // Simplified
		          timeOnQuestion: r.responseTime,
		          responseValue: typeof r.response === 'number' ? r.response : 1,
		          revisionCount: r.revisions,
		          id: `event_${index}`,
		          timestamp: new Date().toISOString(),
		          sessionId: currentSession?.sessionId || 'unknown',
		          privacyLevel: 'anonymous' as const,
		        }))
		      );
		
		      const timingPattern = anomalyDetector.createTimingPattern(
		        responseHistory.current.map((r, index) => ({
		          type: 'question_answered' as const,
		          questionId: r.questionId,
		          questionCategory: r.category,
		          questionIndex: index,
		          sectionId: 'section_1', // Simplified
		          timeOnQuestion: r.responseTime,
		          responseValue: typeof r.response === 'number' ? r.response : 1,
		          revisionCount: r.revisions,
		          id: `event_${index}`,
		          timestamp: new Date().toISOString(),
		          sessionId: currentSession?.sessionId || 'unknown',
		          privacyLevel: 'anonymous' as const,
		        }))
		      );
		
		      const allAnomalies = anomalyDetector.analyzeAllPatterns(responsePattern, timingPattern);
		      
		      // Track significant anomalies
		      for (const anomaly of allAnomalies.filter(a => a.severity !== 'low')) {
		        await telemetryService.trackAnomaly(anomaly.type, {
		          severity: anomaly.severity,
		          detectionAlgorithm: 'comprehensive_post_assessment',
		          contextData: {
		            ...anomaly.statisticalEvidence,
		            explanation: anomaly.explanation,
		          },
		          actionTaken: anomaly.recommendedAction,
		        });
		      }
		
		      // Update data quality score based on anomalies
		      const qualityScore = Math.max(0.1, 1.0 - (allAnomalies.length * 0.1));
		      updatePerformanceMetrics({
		        dataQualityScore: qualityScore,
		        anomalyRate: allAnomalies.length / responseHistory.current.length,
		      });
		
		    } catch (error) {
		      console.error('Failed to perform final analysis:', error);
		    }
		  }, [config.collectNormingData, currentSession]);
		
		  // Track performance metrics
		  const trackPerformanceMetric = useCallback(async (
		    metricName: string,
		    metricValue: number,
		    context: Record<string, any> = {}
		  ) => {
		    if (!isEnabled() || !config.collectPerformanceMetrics) return;
		
		    try {
		      await telemetryService.trackPerformance(metricName, metricValue, context);
		      decrementEventQueue();
		    } catch (error) {
		      console.error('Failed to track performance metric:', error);
		    }
		  }, [config.enabled, userConsent, config.collectPerformanceMetrics]);
		
		  // Check if telemetry is enabled and consented
		  const isEnabled = useCallback(() => {
		    return config.enabled && userConsent && currentSession;
		  }, [config.enabled, userConsent, currentSession]);
		
		  // Get telemetry status
		  const getTelemetryStatus = useCallback(() => {
		    return useTelemetryStore.getState().getTelemetryStatus();
		  }, []);
		
		  // Reset session data
		  const resetSession = useCallback(() => {
		    questionStartTime.current = 0;
		    sectionStartTime.current = 0;
		    assessmentStartTime.current = 0;
		    responseHistory.current = [];
		  }, []);
		
		  return {
		    // Tracking functions
		    trackAssessmentStart,
		    trackQuestionView,
		    trackQuestionResponse,
		    trackQuestionRevision,
		    trackSectionCompletion,
		    trackAssessmentCompletion,
		    trackPerformanceMetric,
		    
		    // Utility functions
		    isEnabled,
		    getTelemetryStatus,
		    resetSession,
		    
		    // State
		    currentSession,
		    config,
		    userConsent,
		  };
		};
		
		export default useTelemetryIntegration;]]></file>
	<file path='hooks/useTwintuition.tsx'><![CDATA[
		import React, { useEffect, useState, useCallback, useRef } from 'react';
		import { AppState, AppStateStatus } from 'react-native';
		import * as Notifications from 'expo-notifications';
		import { useTwinStore } from '../state/twinStore';
		import { useTwintuitionStore, shouldShowNotification } from '../state/twintuitionStore';
		import { twintuitionService } from '../services/twintuitionService';
		import { TwintuitionAlert } from '../components/TwintuitionAlert';
		
		interface UseTwintuitionOptions {
		  enableAutoTracking?: boolean;
		  trackAppStateChanges?: boolean;
		  enableNotifications?: boolean;
		}
		
		export const useTwintuition = (options: UseTwintuitionOptions = {}) => {
		  const {
		    enableAutoTracking = true,
		    trackAppStateChanges = true,
		    enableNotifications = true,
		  } = options;
		
		  const twinStore = useTwinStore();
		  const twintuitionStore = useTwintuitionStore();
		  
		  const [isInitialized, setIsInitialized] = useState(false);
		  const [currentAlert, setCurrentAlert] = useState(null);
		  const [showAlert, setShowAlert] = useState(false);
		  const appState = useRef(AppState.currentState);
		  const lastActiveTime = useRef(Date.now());
		
		  // Initialize the service
		  useEffect(() => {
		    const initializeService = async () => {
		      try {
		        await twintuitionService.initialize();
		        setIsInitialized(true);
		        
		        // Track initial app open if auto-tracking is enabled
		        if (enableAutoTracking && twinStore.paired) {
		          await twintuitionService.trackAppOpen();
		        }
		      } catch (error) {
		        console.error('Failed to initialize twintuition service:', error);
		      }
		    };
		
		    initializeService();
		  }, [enableAutoTracking, twinStore.paired]);
		
		  // Handle app state changes
		  useEffect(() => {
		    if (!trackAppStateChanges || !isInitialized) return;
		
		    const handleAppStateChange = async (nextAppState: AppStateStatus) => {
		      if (appState.current.match(/inactive|background/) && nextAppState === 'active') {
		        // App came to foreground
		        const timeDifference = Date.now() - lastActiveTime.current;
		        
		        // If app was in background for more than 5 minutes, track as new session
		        if (timeDifference > 5 * 60 * 1000 && twinStore.paired) {
		          await twintuitionService.trackAppOpen();
		        }
		      } else if (nextAppState.match(/inactive|background/)) {
		        // App went to background
		        lastActiveTime.current = Date.now();
		      }
		
		      appState.current = nextAppState;
		    };
		
		    const subscription = AppState.addEventListener('change', handleAppStateChange);
		    
		    return () => subscription?.remove();
		  }, [trackAppStateChanges, isInitialized, twinStore.paired]);
		
		  // Listen for new twintuition alerts
		  useEffect(() => {
		    if (!enableNotifications || !isInitialized) return;
		
		    const checkForNewAlerts = () => {
		      const unreadAlerts = twinStore.twintuitionAlerts.filter(alert => !alert.isRead);
		      if (unreadAlerts.length > 0 && shouldShowNotification(twintuitionStore)) {
		        const latestAlert = unreadAlerts[0];
		        setCurrentAlert(latestAlert);
		        setShowAlert(true);
		      }
		    };
		
		    // Check immediately
		    checkForNewAlerts();
		
		    // Set up periodic check (every 30 seconds)
		    const interval = setInterval(checkForNewAlerts, 30000);
		
		    return () => clearInterval(interval);
		  }, [twinStore.twintuitionAlerts, enableNotifications, isInitialized, twintuitionStore]);
		
		  // Listen for notification responses
		  useEffect(() => {
		    if (!enableNotifications) return;
		
		    const subscription = Notifications.addNotificationResponseReceivedListener(response => {
		      const actionIdentifier = response.actionIdentifier;
		      const notificationData = response.notification.request.content.data;
		
		      if (notificationData.type === 'twintuition') {
		        if (actionIdentifier === 'view') {
		          // Handle view action - could navigate to history screen
		          console.log('User wants to view twintuition details');
		        }
		        // Dismiss action is handled automatically
		      }
		    });
		
		    return () => subscription.remove();
		  }, [enableNotifications]);
		
		  // Tracking functions
		  const trackMessage = useCallback(async (message: string) => {
		    if (!isInitialized || !twinStore.paired) return;
		    
		    try {
		      await twintuitionService.trackMessage(message);
		    } catch (error) {
		      console.error('Failed to track message:', error);
		    }
		  }, [isInitialized, twinStore.paired]);
		
		  const trackMoodUpdate = useCallback(async (mood: string, intensity: number = 5) => {
		    if (!isInitialized || !twinStore.paired) return;
		    
		    try {
		      await twintuitionService.trackMoodUpdate(mood, intensity);
		    } catch (error) {
		      console.error('Failed to track mood update:', error);
		    }
		  }, [isInitialized, twinStore.paired]);
		
		  const trackGameAction = useCallback(async (gameType: string, action: string, context: any = {}) => {
		    if (!isInitialized || !twinStore.paired) return;
		    
		    try {
		      await twintuitionService.trackBehavior({
		        type: 'game_action',
		        action: `${gameType}_${action}`,
		        context: {
		          gameType,
		          ...context,
		        },
		        userId: twinStore.userProfile?.id || 'anonymous',
		        twinId: twinStore.twinProfile?.id,
		      });
		    } catch (error) {
		      console.error('Failed to track game action:', error);
		    }
		  }, [isInitialized, twinStore.paired, twinStore.userProfile, twinStore.twinProfile]);
		
		  const trackCustomEvent = useCallback(async (eventType: string, action: string, context: any = {}) => {
		    if (!isInitialized || !twinStore.paired) return;
		    
		    try {
		      await twintuitionService.trackBehavior({
		        type: eventType as any,
		        action,
		        context,
		        userId: twinStore.userProfile?.id || 'anonymous',
		        twinId: twinStore.twinProfile?.id,
		      });
		    } catch (error) {
		      console.error('Failed to track custom event:', error);
		    }
		  }, [isInitialized, twinStore.paired, twinStore.userProfile, twinStore.twinProfile]);
		
		  // Configuration functions
		  const updateSensitivity = useCallback(async (sensitivity: number) => {
		    await twintuitionService.updateConfig({ sensitivity });
		    twintuitionStore.updateConfig({ sensitivity });
		  }, [twintuitionStore]);
		
		  const updateTimeWindow = useCallback(async (timeWindowMinutes: number) => {
		    await twintuitionService.updateConfig({ timeWindowMinutes });
		    twintuitionStore.updateConfig({ timeWindowMinutes });
		  }, [twintuitionStore]);
		
		  const enableLocationSync = useCallback(async (enabled: boolean) => {
		    if (enabled) {
		      const hasPermission = await twintuitionService.requestLocationPermission();
		      if (!hasPermission) {
		        console.warn('Location permission denied');
		        return false;
		      }
		    }
		    
		    await twintuitionService.updateConfig({ enableLocationSync: enabled });
		    twintuitionStore.updateConfig({ enableLocationSync: enabled });
		    return true;
		  }, [twintuitionStore]);
		
		  // Analytics functions
		  const getSyncHistory = useCallback(async (days: number = 7) => {
		    try {
		      return await twintuitionService.getSyncHistory(days);
		    } catch (error) {
		      console.error('Failed to get sync history:', error);
		      return [];
		    }
		  }, []);
		
		  const getSyncScore = useCallback(async () => {
		    try {
		      const score = await twintuitionService.getTwinSyncScore();
		      twintuitionStore.updateSyncScore(score.score);
		      return score;
		    } catch (error) {
		      console.error('Failed to get sync score:', error);
		      return { score: 0, breakdown: {} };
		    }
		  }, [twintuitionStore]);
		
		  // Alert management
		  const dismissAlert = useCallback(() => {
		    setShowAlert(false);
		    setCurrentAlert(null);
		  }, []);
		
		  const markAllAlertsAsRead = useCallback(() => {
		    twinStore.twintuitionAlerts.forEach(alert => {
		      if (!alert.isRead) {
		        twinStore.markAlertAsRead(alert.id);
		      }
		    });
		  }, [twinStore]);
		
		  return {
		    // State
		    isInitialized,
		    currentAlert,
		    showAlert,
		    syncScore: twintuitionStore.syncScore,
		    config: twintuitionStore.config,
		    
		    // Tracking functions
		    trackMessage,
		    trackMoodUpdate,
		    trackGameAction,
		    trackCustomEvent,
		    
		    // Configuration functions
		    updateSensitivity,
		    updateTimeWindow,
		    enableLocationSync,
		    
		    // Analytics functions
		    getSyncHistory,
		    getSyncScore,
		    
		    // Alert management
		    dismissAlert,
		    markAllAlertsAsRead,
		    
		    // Components
		    TwintuitionAlertComponent: () => {
		      return (
		        <TwintuitionAlert
		          alert={currentAlert}
		          visible={showAlert}
		          onDismiss={dismissAlert}
		          onViewDetails={() => {
		            // Navigate to history screen
		            console.log('Navigate to twintuition history');
		          }}
		        />
		      );
		    }
		  };
		};
		
		// Hook for getting twintuition statistics
		export const useTwintuitionStats = () => {
		  const twinStore = useTwinStore();
		  const [stats, setStats] = useState({
		    totalAlerts: 0,
		    todayAlerts: 0,
		    weekAlerts: 0,
		    mostCommonType: 'action' as 'feeling' | 'thought' | 'action',
		    streak: 0,
		  });
		
		  useEffect(() => {
		    const calculateStats = () => {
		      const alerts = twinStore.twintuitionAlerts;
		      const now = new Date();
		      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
		      const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
		
		      const todayAlerts = alerts.filter(alert => 
		        new Date(alert.timestamp) >= today
		      ).length;
		
		      const weekAlerts = alerts.filter(alert => 
		        new Date(alert.timestamp) >= weekAgo
		      ).length;
		
		      // Find most common type
		      const typeCounts = alerts.reduce((acc, alert) => {
		        acc[alert.type] = (acc[alert.type] || 0) + 1;
		        return acc;
		      }, {} as Record<string, number>);
		
		      const mostCommonType = Object.entries(typeCounts).reduce((max, [type, count]) => 
		        count > max.count ? { type, count } : max,
		        { type: 'action', count: 0 }
		      ).type as 'feeling' | 'thought' | 'action';
		
		      // Calculate streak (consecutive days with alerts)
		      let streak = 0;
		      const sortedDates = [...new Set(alerts.map(alert => 
		        new Date(alert.timestamp).toDateString()
		      ))].sort().reverse();
		
		      let currentDate = new Date();
		      for (const dateStr of sortedDates) {
		        const alertDate = new Date(dateStr);
		        const daysDiff = Math.floor((currentDate.getTime() - alertDate.getTime()) / (1000 * 60 * 60 * 24));
		        
		        if (daysDiff === streak) {
		          streak++;
		          currentDate = alertDate;
		        } else {
		          break;
		        }
		      }
		
		      setStats({
		        totalAlerts: alerts.length,
		        todayAlerts,
		        weekAlerts,
		        mostCommonType,
		        streak,
		      });
		    };
		
		    calculateStats();
		  }, [twinStore.twintuitionAlerts]);
		
		  return stats;
		};]]></file>
	<file path='navigation/AppNavigator.tsx'><![CDATA[
		import React, { useRef, useEffect } from "react";
		import { NavigationContainer, NavigationContainerRef } from "@react-navigation/native";
		import { createBottomTabNavigator } from "@react-navigation/bottom-tabs";
		import { createNativeStackNavigator } from "@react-navigation/native-stack";
		import { Ionicons } from "@expo/vector-icons";
		import { useTwinStore } from "../state/twinStore";
		import { BMadNavigationTracker } from "../../.bmad-mobile-app/navigation-tracker";
		import { MobilePerformanceAgent } from "../../.bmad-mobile-app/mobile-performance.agent";
		
		// Screens
		import { OnboardingScreen } from "../screens/OnboardingScreen";
		import { HomeScreen } from "../screens/HomeScreen";
		import { TwinTalkScreen } from "../screens/chat/TwinTalkScreen";
		import { TwintuitionScreen } from "../screens/TwintuitionScreen";
		import { PsychicGamesHub } from "../screens/PsychicGamesHub";
		import { CognitiveSyncMaze } from "../screens/games/CognitiveSyncMaze";
		import { EmotionalResonanceMapping } from "../screens/games/EmotionalResonanceMapping";
		import { IconicDuoMatcher } from "../screens/games/IconicDuoMatcher";
		import { TemporalDecisionSync } from "../screens/games/TemporalDecisionSync";
		import { ResearchScreen } from "../screens/ResearchScreen";
		import { SettingsScreen } from "../screens/SettingsScreen";
		
		// Assessment Screens
		import { AssessmentIntroScreen } from "../screens/assessment/AssessmentIntroScreen";
		import { AssessmentSurveyScreen } from "../screens/assessment/AssessmentSurveyScreen";
		import { AssessmentLoadingScreen } from "../screens/assessment/AssessmentLoadingScreen";
		import { AssessmentResultsScreen } from "../screens/assessment/AssessmentResultsScreen";
		import { AssessmentRecommendationsScreen } from "../screens/assessment/AssessmentRecommendationsScreen";
		import { PairComparisonScreen } from "../screens/assessment/PairComparisonScreen";
		
		// Story Screens
		import { StoriesScreen } from "../screens/stories/StoriesScreen";
		import { CreateStoryScreen } from "../screens/stories/CreateStoryScreen";
		import { StoryDetailScreen } from "../screens/stories/StoryDetailScreen";
		
		// Research Screens
		import { ConsentScreen } from "../screens/research/ConsentScreen";
		import { ResearchParticipationScreen } from "../screens/research/ResearchParticipationScreen";
		import { ResearchDashboardScreen } from "../screens/research/ResearchDashboardScreen";
		
		const Tab = createBottomTabNavigator();
		const Stack = createNativeStackNavigator();
		
		type RootStackParamList = {
		  Onboarding: undefined;
		  Main: undefined;
		  Twindex: undefined;
		  Twinbox: undefined;
		  TwinTalk: undefined;
		  Twintuition: undefined;
		  Twingames: undefined;
		  Twinquiry: undefined;
		  Twinsettings: undefined;
		  Twinspirations: undefined;
		  Twinvitation: undefined;
		  // New invitation screens
		  SendInvitation: undefined;
		  ReceiveInvitation: { token?: string };
		  InvitationAnalytics: undefined;
		  // Assessment screens
		  AssessmentIntro: undefined;
		  AssessmentSurvey: undefined;
		  AssessmentLoading: { responses: Record<number, number> };
		  AssessmentResults: { results: any };
		  AssessmentRecommendations: { results: any };
		  PairComparison: undefined;
		  // Premium screens
		  Premium: { feature?: string; source?: 'assessment' | 'settings' | 'dashboard' | 'onboarding' };
		  PremiumFeatures: undefined;
		  // Story screens
		  Stories: undefined;
		  CreateStory: { draftId?: string };
		  StoryDetail: { storyId: string };
		  EditStory: { storyId: string };
		  // Missing routes identified in navigation calls
		  GameStats: undefined;
		  Home: undefined;
		  Settings: undefined;
		  Recommendations: { sessionId: string };
		  AssessmentDetails: { sessionId: string };
		  // Research routes
		  ConsentScreen: { studyId?: string };
		  ResearchParticipationScreen: undefined;
		  ResearchDashboardScreen: undefined;
		  // Pair route
		  Pair: undefined;
		};
		
		const TabNavigator = () => {
		  const userProfile = useTwinStore((state) => state.userProfile);
		  const themeColor = userProfile?.accentColor || "neon-purple";
		  
		  const getTabBarColors = () => {
		    switch (themeColor) {
		      case "neon-pink":
		        return { active: "#ff1493", inactive: "#6b7280", background: "rgba(26, 10, 26, 0.9)" };
		      case "neon-blue":
		        return { active: "#00bfff", inactive: "#6b7280", background: "rgba(10, 26, 46, 0.9)" };
		      case "neon-green":
		        return { active: "#00ff7f", inactive: "#6b7280", background: "rgba(10, 26, 10, 0.9)" };
		      case "neon-yellow":
		        return { active: "#ffff00", inactive: "#6b7280", background: "rgba(26, 26, 10, 0.9)" };
		      case "neon-purple":
		        return { active: "#8a2be2", inactive: "#6b7280", background: "rgba(26, 10, 26, 0.9)" };
		      case "neon-orange":
		        return { active: "#ff4500", inactive: "#6b7280", background: "rgba(26, 10, 10, 0.9)" };
		      case "neon-cyan":
		        return { active: "#00ffff", inactive: "#6b7280", background: "rgba(10, 26, 26, 0.9)" };
		      case "neon-red":
		        return { active: "#ff0000", inactive: "#6b7280", background: "rgba(26, 10, 10, 0.9)" };
		      default:
		        return { active: "#8a2be2", inactive: "#6b7280", background: "rgba(26, 10, 26, 0.9)" };
		    }
		  };
		
		  const colors = getTabBarColors();
		
		  return (
		    <Tab.Navigator
		      initialRouteName="Twinbox"
		      screenOptions={({ route }) => ({
		        tabBarIcon: ({ focused, color, size }) => {
		          let iconName: keyof typeof Ionicons.glyphMap;
		
		          if (route.name === "Twinbox") {
		            iconName = focused ? "chatbubbles" : "chatbubbles-outline";
		          } else if (route.name === "Twindex") {
		            iconName = focused ? "grid" : "grid-outline";
		          } else {
		            iconName = "ellipse";
		          }
		
		          return <Ionicons name={iconName} size={size} color={color} />;
		        },
		        tabBarActiveTintColor: colors.active,
		        tabBarInactiveTintColor: colors.inactive,
		        tabBarStyle: {
		          backgroundColor: colors.background,
		          borderTopColor: "rgba(255, 255, 255, 0.1)",
		          borderTopWidth: 1,
		        },
		        headerShown: false,
		      })}
		    >
		      <Tab.Screen name="Twinbox" component={TwinTalkScreen} />
		      <Tab.Screen name="Twindex" component={HomeScreen} />
		    </Tab.Navigator>
		  );
		};
		
		export const AppNavigator = () => {
		  const isOnboarded = useTwinStore((state) => state.isOnboarded);
		  const navigationRef = useRef<NavigationContainerRef<RootStackParamList>>(null);
		  const routeNameRef = useRef<string | undefined>(undefined);
		  const bmadTracker = useRef(new BMadNavigationTracker());
		  const performanceAgent = useRef(new MobilePerformanceAgent());
		
		  // BMAD Navigation Tracking
		  useEffect(() => {
		    // Performance monitoring interval
		    const interval = setInterval(() => {
		      // Measure current performance metrics
		      const memoryUsage = (performance as any).memory?.usedJSHeapSize / 1048576; // MB
		      if (memoryUsage) {
		        performanceAgent.current.measure('memory', memoryUsage);
		      }
		    }, 5000);
		
		    return () => clearInterval(interval);
		  }, []);
		
		  return (
		    <NavigationContainer
		      ref={navigationRef}
		      onReady={() => {
		        routeNameRef.current = navigationRef.current?.getCurrentRoute()?.name;
		      }}
		      onStateChange={async () => {
		        const previousRouteName = routeNameRef.current;
		        const currentRouteName = navigationRef.current?.getCurrentRoute()?.name;
		        const currentRoute = navigationRef.current?.getCurrentRoute();
		
		        if (previousRouteName !== currentRouteName && currentRouteName) {
		          // Track screen view with BMAD
		          bmadTracker.current.trackScreenView(currentRouteName, currentRoute?.params);
		          
		          // Track navigation timing
		          if (previousRouteName) {
		            const navStartTime = Date.now();
		            requestAnimationFrame(() => {
		              const navEndTime = Date.now();
		              const duration = navEndTime - navStartTime;
		              bmadTracker.current.trackNavigationTime(previousRouteName, currentRouteName, duration);
		              performanceAgent.current.measure('renderTime', duration);
		            });
		          }
		
		          // Log analytics (can be sent to backend)
		          console.log('[BMAD] Screen View:', currentRouteName);
		          
		          // Export metrics periodically
		          if (Math.random() < 0.1) { // 10% chance to export
		            const analytics = bmadTracker.current.getNavigationAnalytics();
		            const perfAnalysis = performanceAgent.current.analyze();
		            console.log('[BMAD] Navigation Analytics:', analytics);
		            console.log('[BMAD] Performance Analysis:', perfAnalysis);
		          }
		        }
		
		        // Save the current route name for comparison next time
		        routeNameRef.current = currentRouteName;
		      }}>
		      <Stack.Navigator screenOptions={{ headerShown: false }}>
		        {!isOnboarded ? (
		          <Stack.Screen name="Onboarding">
		            {(props) => (
		              <OnboardingScreen
		                {...props}
		                onComplete={() => {}}
		              />
		            )}
		          </Stack.Screen>
		        ) : (
		          <>
		            <Stack.Screen name="Main" component={TabNavigator} />
		            <Stack.Screen name="TwinTalk" component={TwinTalkScreen} />
		            <Stack.Screen name="Twintuition" component={TwintuitionScreen} />
		            <Stack.Screen name="Twingames" component={PsychicGamesHub} />
		            <Stack.Screen name="Twinquiry" component={ResearchScreen} />
		            <Stack.Screen name="Twinsettings" component={SettingsScreen} />
		            <Stack.Screen name="Twinspirations" component={StoriesScreen} />
		            <Stack.Screen name="CreateStory" component={CreateStoryScreen} />
		            <Stack.Screen name="StoryDetail" component={StoryDetailScreen} />
		            <Stack.Screen name="EditStory" component={CreateStoryScreen} />
		            <Stack.Screen name="Twinvitation" component={require("../screens/PairScreen").PairScreen} />
		            {/* New invitation screens */}
		            <Stack.Screen 
		              name="SendInvitation" 
		              component={require('../screens/InvitationScreen').InvitationScreen}
		              initialParams={{ mode: 'send' }}
		            />
		            <Stack.Screen 
		              name="ReceiveInvitation" 
		              component={require('../screens/InvitationScreen').InvitationScreen}
		              initialParams={{ mode: 'receive' }}
		            />
		            <Stack.Screen 
		              name="InvitationAnalytics" 
		              component={require('../screens/InvitationAnalyticsScreen').InvitationAnalyticsScreen}
		            />
		            {/* Assessment Screens */}
		            <Stack.Screen name="AssessmentIntro" component={AssessmentIntroScreen} />
		            <Stack.Screen name="AssessmentSurvey" component={AssessmentSurveyScreen} />
		            <Stack.Screen name="AssessmentLoading" component={AssessmentLoadingScreen} />
		            <Stack.Screen name="AssessmentResults" component={AssessmentResultsScreen} />
		            <Stack.Screen name="AssessmentRecommendations" component={AssessmentRecommendationsScreen} />
		            <Stack.Screen name="PairComparison" component={PairComparisonScreen} />
		            {/* Premium Screens */}
		            <Stack.Screen 
		              name="Premium" 
		              component={require('../screens/premium/PremiumDashboardScreen').PremiumDashboardScreen}
		            />
		            <Stack.Screen 
		              name="PremiumFeatures" 
		              component={require('../screens/premium/PremiumDashboardScreen').PremiumDashboardScreen}
		            />
		            {/* Psychic Game Screens */}
		            <Stack.Screen name="PsychicGamesHub" component={PsychicGamesHub} />
		            <Stack.Screen name="CognitiveSyncMaze" component={CognitiveSyncMaze} />
		            <Stack.Screen name="EmotionalResonanceMapping" component={EmotionalResonanceMapping} />
		            <Stack.Screen name="IconicDuoMatcher" component={IconicDuoMatcher} />
		            <Stack.Screen name="TemporalDecisionSync" component={TemporalDecisionSync} />
		            <Stack.Screen name="cognitive_sync_maze" component={CognitiveSyncMaze} />
		            <Stack.Screen name="emotional_resonance" component={EmotionalResonanceMapping} />
		            <Stack.Screen name="temporal_decision" component={TemporalDecisionSync} />
		            <Stack.Screen name="iconic_duo" component={IconicDuoMatcher} />
		            {/* Research Screens */}
		            <Stack.Screen name="ConsentScreen" component={ConsentScreen} />
		            <Stack.Screen name="ResearchParticipationScreen" component={ResearchParticipationScreen} />
		            <Stack.Screen name="ResearchDashboardScreen" component={ResearchDashboardScreen} />
		            {/* Missing route placeholders - redirect to proper screens */}
		            <Stack.Screen name="GameStats" component={PsychicGamesHub} />
		            <Stack.Screen name="Home" component={TabNavigator} />
		            <Stack.Screen name="Settings" component={SettingsScreen} />
		            <Stack.Screen name="Recommendations" component={AssessmentRecommendationsScreen} />
		            <Stack.Screen name="AssessmentDetails" component={AssessmentResultsScreen} />
		            <Stack.Screen name="Pair" component={require("../screens/PairScreen").PairScreen} />
		          </>
		        )}
		      </Stack.Navigator>
		    </NavigationContainer>
		  );
		};]]></file>
	<file path='navigation/TwintuitionNavigator.tsx'><![CDATA[
		import React from 'react';
		import { createStackNavigator } from '@react-navigation/stack';
		import { TwintuitionHistoryScreen } from '../screens/TwintuitionHistoryScreen';
		import { TwintuitionSettingsScreen } from '../screens/TwintuitionSettingsScreen';
		
		export type TwintuitionStackParamList = {
		  TwintuitionHistory: undefined;
		  TwintuitionSettings: undefined;
		};
		
		const Stack = createStackNavigator<TwintuitionStackParamList>();
		
		export const TwintuitionNavigator: React.FC = () => {
		  return (
		    <Stack.Navigator
		      screenOptions={{
		        headerShown: false,
		        gestureEnabled: true,
		      }}
		    >
		      <Stack.Screen 
		        name="TwintuitionHistory" 
		        component={TwintuitionHistoryScreen} 
		      />
		      <Stack.Screen 
		        name="TwintuitionSettings" 
		        component={TwintuitionSettingsScreen} 
		      />
		    </Stack.Navigator>
		  );
		};]]></file>
	<file path='screens/assessment/AssessmentIntroScreen.tsx'><![CDATA[
		import React from 'react';
		import { View, Text, ScrollView, Pressable, ImageBackground } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { useNavigation } from '@react-navigation/native';
		import { Ionicons } from '@expo/vector-icons';
		import { useTwinStore } from '../../state/twinStore';
		import { useAssessmentStore } from '../../state/assessmentStore';
		
		export const AssessmentIntroScreen = () => {
		  const navigation = useNavigation<any>();
		  const { userProfile, twinProfile } = useTwinStore();
		  const { startAssessment, sessions } = useAssessmentStore();
		  
		  const themeColor = userProfile?.accentColor || 'neon-purple';
		  
		  // Check if user has incomplete assessment
		  const incompleteSession = sessions.find(
		    s => s.userId === userProfile?.id && !s.isComplete
		  );
		
		  const handleStartAssessment = () => {
		    if (userProfile) {
		      startAssessment(userProfile.id, twinProfile?.id);
		      navigation.navigate('AssessmentSurvey');
		    }
		  };
		
		  const handleResumeAssessment = () => {
		    if (incompleteSession) {
		      useAssessmentStore.getState().resumeAssessment(incompleteSession.id);
		      navigation.navigate('AssessmentSurvey');
		    }
		  };
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <ScrollView className="flex-1 px-6">
		          {/* Header */}
		          <View className="flex-row items-center justify-between pt-4 pb-6">
		            <Pressable onPress={() => navigation.goBack()}>
		              <Ionicons name="arrow-back" size={24} color="white" />
		            </Pressable>
		            <Text className="text-white text-xl font-semibold">Twin Assessment</Text>
		            <View className="w-6" />
		          </View>
		
		          {/* Hero Section */}
		          <View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 mb-6">
		            <View className="items-center mb-4">
		              <View className="bg-purple-500/30 rounded-full p-4 mb-4">
		                <Ionicons name="analytics" size={48} color="white" />
		              </View>
		              <Text className="text-white text-2xl font-bold text-center">
		                Discover Your Twin Dynamic
		              </Text>
		              <Text className="text-white/70 text-center mt-2">
		                Research-grade assessment designed specifically for twins
		              </Text>
		            </View>
		          </View>
		
		          {/* What to Expect */}
		          <View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 mb-6">
		            <Text className="text-white text-lg font-semibold mb-4">What to Expect</Text>
		            
		            <View className="space-y-3">
		              <View className="flex-row items-start">
		                <Ionicons name="time-outline" size={20} color="rgba(255,255,255,0.7)" />
		                <View className="ml-3 flex-1">
		                  <Text className="text-white font-medium">30-45 minutes</Text>
		                  <Text className="text-white/60 text-sm">210 questions about your twin relationship</Text>
		                </View>
		              </View>
		
		              <View className="flex-row items-start mt-3">
		                <Ionicons name="save-outline" size={20} color="rgba(255,255,255,0.7)" />
		                <View className="ml-3 flex-1">
		                  <Text className="text-white font-medium">Auto-save progress</Text>
		                  <Text className="text-white/60 text-sm">Take breaks and resume anytime</Text>
		                </View>
		              </View>
		
		              <View className="flex-row items-start mt-3">
		                <Ionicons name="lock-closed-outline" size={20} color="rgba(255,255,255,0.7)" />
		                <View className="ml-3 flex-1">
		                  <Text className="text-white font-medium">Private & secure</Text>
		                  <Text className="text-white/60 text-sm">Your data stays on your device by default</Text>
		                </View>
		              </View>
		
		              <View className="flex-row items-start mt-3">
		                <Ionicons name="bar-chart-outline" size={20} color="rgba(255,255,255,0.7)" />
		                <View className="ml-3 flex-1">
		                  <Text className="text-white font-medium">Comprehensive results</Text>
		                  <Text className="text-white/60 text-sm">15 personality dimensions + 3 composite indices</Text>
		                </View>
		              </View>
		            </View>
		          </View>
		
		          {/* What You'll Learn */}
		          <View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 mb-6">
		            <Text className="text-white text-lg font-semibold mb-4">What You'll Learn</Text>
		            
		            <View className="space-y-2">
		              <View className="flex-row items-center">
		                <View className="w-2 h-2 bg-green-400 rounded-full" />
		                <Text className="text-white/80 ml-3 flex-1">Your Codependency Index (CI)</Text>
		              </View>
		              <View className="flex-row items-center mt-2">
		                <View className="w-2 h-2 bg-blue-400 rounded-full" />
		                <Text className="text-white/80 ml-3 flex-1">Autonomy & Resilience Index (ARI)</Text>
		              </View>
		              <View className="flex-row items-center mt-2">
		                <View className="w-2 h-2 bg-yellow-400 rounded-full" />
		                <Text className="text-white/80 ml-3 flex-1">Transition Risk Score (TRS)</Text>
		              </View>
		              <View className="flex-row items-center mt-2">
		                <View className="w-2 h-2 bg-purple-400 rounded-full" />
		                <Text className="text-white/80 ml-3 flex-1">Personalized recommendations</Text>
		              </View>
		              <View className="flex-row items-center mt-2">
		                <View className="w-2 h-2 bg-pink-400 rounded-full" />
		                <Text className="text-white/80 ml-3 flex-1">Weekly micro-experiments</Text>
		              </View>
		            </View>
		          </View>
		
		          {/* Privacy Notice */}
		          <View className="bg-blue-500/20 rounded-xl p-4 mb-6">
		            <View className="flex-row items-start">
		              <Ionicons name="shield-checkmark" size={20} color="rgba(147, 197, 253, 1)" />
		              <View className="ml-3 flex-1">
		                <Text className="text-blue-300 font-medium">Privacy First</Text>
		                <Text className="text-blue-200/80 text-sm mt-1">
		                  This assessment is not diagnostic. Your responses are stored locally and never shared without your explicit consent.
		                </Text>
		              </View>
		            </View>
		          </View>
		
		          {/* Action Buttons */}
		          <View className="mb-8">
		            {incompleteSession ? (
		              <>
		                <Pressable
		                  onPress={handleResumeAssessment}
		                  className="bg-purple-500 rounded-xl p-4 mb-3"
		                >
		                  <Text className="text-white text-center font-semibold text-lg">
		                    Resume Assessment ({Math.round(incompleteSession.currentProgress)}% complete)
		                  </Text>
		                </Pressable>
		                
		                <Pressable
		                  onPress={handleStartAssessment}
		                  className="bg-white/10 rounded-xl p-4"
		                >
		                  <Text className="text-white text-center font-medium">
		                    Start New Assessment
		                  </Text>
		                </Pressable>
		              </>
		            ) : (
		              <Pressable
		                onPress={handleStartAssessment}
		                className="bg-purple-500 rounded-xl p-4"
		              >
		                <Text className="text-white text-center font-semibold text-lg">
		                  Begin Assessment
		                </Text>
		              </Pressable>
		            )}
		          </View>
		        </ScrollView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/assessment/AssessmentLoadingScreen.tsx'><![CDATA[
		import React, { useEffect, useState } from "react";
		import { View, Text, ImageBackground } from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { useTwinStore } from "../../state/twinStore";
		import { Ionicons } from "@expo/vector-icons";
		import { useNavigation, useRoute } from "@react-navigation/native";
		import { ProcessingAnimation } from "../../components/assessment/ProcessingAnimation";
		import Animated, {
		  useSharedValue,
		  useAnimatedStyle,
		  withTiming,
		  withRepeat,
		  withSequence,
		} from "react-native-reanimated";
		
		interface AssessmentResults {
		  overallScore: number;
		  categoryScores: {
		    emotionalConnection: number;
		    telepathicExperiences: number;
		    behavioralSynchrony: number;
		    sharedExperiences: number;
		    physicalSensations: number;
		  };
		  level: "Developing" | "Moderate" | "Strong" | "Extraordinary";
		  insights: string[];
		  recommendations: string[];
		}
		
		const PROCESSING_STEPS = [
		  "Analyzing your responses...",
		  "Calculating connection strength...",
		  "Identifying patterns...",
		  "Generating insights...",
		  "Preparing recommendations...",
		  "Finalizing your results..."
		];
		
		export const AssessmentLoadingScreen = () => {
		  const { userProfile } = useTwinStore();
		  const navigation = useNavigation<any>();
		  const route = useRoute<any>();
		  const [currentStep, setCurrentStep] = useState(0);
		  const [progress, setProgress] = useState(0);
		  
		  const responses = route.params?.responses || {};
		  const themeColor = userProfile?.accentColor || "neon-purple";
		  
		  const getAccentColor = () => {
		    switch (themeColor) {
		      case "neon-pink": return "#ff1493";
		      case "neon-blue": return "#00bfff";
		      case "neon-green": return "#00ff7f";
		      case "neon-yellow": return "#ffff00";
		      case "neon-purple": return "#8a2be2";
		      case "neon-orange": return "#ff4500";
		      case "neon-cyan": return "#00ffff";
		      case "neon-red": return "#ff0000";
		      default: return "#8a2be2";
		    }
		  };
		
		  const accentColor = getAccentColor();
		  
		  // Animation values
		  const pulseScale = useSharedValue(1);
		  const rotateValue = useSharedValue(0);
		  
		  const pulseStyle = useAnimatedStyle(() => ({
		    transform: [{ scale: pulseScale.value }]
		  }));
		  
		  const rotateStyle = useAnimatedStyle(() => ({
		    transform: [{ rotate: `${rotateValue.value}deg` }]
		  }));
		
		  // Calculate assessment results
		  const calculateResults = (): AssessmentResults => {
		    const responseValues = Object.values(responses) as number[];
		    const averageScore = responseValues.reduce((sum, val) => sum + val, 0) / responseValues.length;
		    const normalizedScore = (averageScore / 7) * 100;
		    
		    // Category-specific calculations (simplified)
		    const categoryScores = {
		      emotionalConnection: Math.min(100, normalizedScore + (Math.random() * 20 - 10)),
		      telepathicExperiences: Math.min(100, normalizedScore + (Math.random() * 20 - 10)),
		      behavioralSynchrony: Math.min(100, normalizedScore + (Math.random() * 20 - 10)),
		      sharedExperiences: Math.min(100, normalizedScore + (Math.random() * 20 - 10)),
		      physicalSensations: Math.min(100, normalizedScore + (Math.random() * 20 - 10)),
		    };
		    
		    let level: "Developing" | "Moderate" | "Strong" | "Extraordinary";
		    if (normalizedScore < 30) level = "Developing";
		    else if (normalizedScore < 50) level = "Moderate";
		    else if (normalizedScore < 75) level = "Strong";
		    else level = "Extraordinary";
		    
		    const insights = [
		      "Your twin connection shows unique patterns of synchronicity",
		      "You demonstrate above-average emotional attunement",
		      "Your telepathic experiences suggest a strong psychic bond"
		    ];
		    
		    const recommendations = [
		      "Practice daily meditation together to strengthen your connection",
		      "Keep a shared journal of synchronistic events",
		      "Try the telepathic communication exercises in our app"
		    ];
		    
		    return {
		      overallScore: Math.round(normalizedScore),
		      categoryScores,
		      level,
		      insights,
		      recommendations
		    };
		  };
		
		  useEffect(() => {
		    // Start animations
		    pulseScale.value = withRepeat(
		      withSequence(
		        withTiming(1.1, { duration: 800 }),
		        withTiming(1, { duration: 800 })
		      ),
		      -1,
		      true
		    );
		    
		    rotateValue.value = withRepeat(
		      withTiming(360, { duration: 3000 }),
		      -1,
		      false
		    );
		    
		    // Progress through steps
		    const stepInterval = setInterval(() => {
		      setCurrentStep(prev => {
		        if (prev < PROCESSING_STEPS.length - 1) {
		          setProgress(((prev + 1) / PROCESSING_STEPS.length) * 100);
		          return prev + 1;
		        }
		        return prev;
		      });
		    }, 1000);
		    
		    // Navigate to results after processing
		    const resultsTimeout = setTimeout(() => {
		      const results = calculateResults();
		      navigation.replace("AssessmentResults" as never, { results });
		    }, PROCESSING_STEPS.length * 1000 + 1000);
		    
		    return () => {
		      clearInterval(stepInterval);
		      clearTimeout(resultsTimeout);
		    };
		  }, []);
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <View className="flex-1 px-6 justify-center items-center">
		          {/* Processing Icon */}
		          <Animated.View 
		            style={[pulseStyle]}
		            className="mb-8"
		          >
		            <Animated.View 
		              style={[rotateStyle]}
		              className="w-24 h-24 rounded-full items-center justify-center"
		              backgroundColor={`${accentColor}30`}
		            >
		              <Ionicons name="analytics" size={48} color={accentColor} />
		            </Animated.View>
		          </Animated.View>
		
		          {/* Processing Text */}
		          <View className="items-center mb-8">
		            <Text className="text-white text-2xl font-bold mb-2">
		              Processing Your Results
		            </Text>
		            <Text className="text-white/70 text-center">
		              Analyzing your twin connection patterns
		            </Text>
		          </View>
		
		          {/* Progress Bar */}
		          <View className="w-full max-w-sm mb-8">
		            <View className="bg-white/10 rounded-full h-2 overflow-hidden">
		              <View 
		                className="h-full rounded-full transition-all duration-300"
		                style={{ 
		                  width: `${progress}%`,
		                  backgroundColor: accentColor 
		                }}
		              />
		            </View>
		            <Text className="text-white/70 text-center text-sm mt-2">
		              {Math.round(progress)}% complete
		            </Text>
		          </View>
		
		          {/* Current Step */}
		          <View className="bg-white/10 backdrop-blur-sm rounded-xl p-4 w-full max-w-sm">
		            <View className="flex-row items-center">
		              <View 
		                className="w-3 h-3 rounded-full mr-3"
		                style={{ backgroundColor: accentColor }}
		              />
		              <Text className="text-white text-sm">
		                {PROCESSING_STEPS[currentStep]}
		              </Text>
		            </View>
		          </View>
		
		          {/* Processing Animation */}
		          <View className="mt-8">
		            <ProcessingAnimation color={accentColor} />
		          </View>
		
		          {/* Fun Facts */}
		          <View className="mt-8 bg-white/5 rounded-xl p-4 w-full max-w-sm">
		            <Text className="text-white/70 text-xs text-center">
		              💫 Did you know? Identical twins share 99.9% of their DNA, which may contribute to their psychic connection
		            </Text>
		          </View>
		        </View>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/assessment/AssessmentRecommendationsScreen.tsx'><![CDATA[
		import React, { useState } from "react";
		import { View, Text, Pressable, ScrollView, Alert, ImageBackground } from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { useTwinStore } from "../../state/twinStore";
		import { Ionicons } from "@expo/vector-icons";
		import { useNavigation, useRoute } from "@react-navigation/native";
		import { RecommendationCard } from "../../components/assessment/RecommendationCard";
		import { MicroExperimentCard } from "../../components/assessment/MicroExperimentCard";
		import Animated, {
		  useSharedValue,
		  useAnimatedStyle,
		  withSpring,
		  withDelay,
		} from "react-native-reanimated";
		
		interface AssessmentResults {
		  overallScore: number;
		  categoryScores: {
		    emotionalConnection: number;
		    telepathicExperiences: number;
		    behavioralSynchrony: number;
		    sharedExperiences: number;
		    physicalSensations: number;
		  };
		  level: "Developing" | "Moderate" | "Strong" | "Extraordinary";
		  insights: string[];
		  recommendations: string[];
		}
		
		const COACHING_PLANS = {
		  "Developing": {
		    title: "Foundation Builder Plan",
		    duration: "2-4 weeks",
		    focus: "Building basic twin connection awareness",
		    activities: [
		      "Daily 5-minute meditation together",
		      "Weekly twin journaling sessions",
		      "Basic telepathy exercises",
		      "Emotional check-ins twice daily"
		    ]
		  },
		  "Moderate": {
		    title: "Connection Enhancer Plan",
		    duration: "4-6 weeks",
		    focus: "Strengthening existing psychic abilities",
		    activities: [
		      "Advanced meditation techniques",
		      "Dream sharing and analysis",
		      "Telepathic communication practice",
		      "Energy healing exercises"
		    ]
		  },
		  "Strong": {
		    title: "Mastery Development Plan",
		    duration: "6-8 weeks",
		    focus: "Refining and expanding psychic abilities",
		    activities: [
		      "Complex telepathy challenges",
		      "Remote viewing exercises",
		      "Psychic healing practices",
		      "Advanced synchronicity work"
		    ]
		  },
		  "Extraordinary": {
		    title: "Transcendence Program",
		    duration: "8+ weeks",
		    focus: "Exploring the depths of twin consciousness",
		    activities: [
		      "Consciousness merging techniques",
		      "Advanced astral projection",
		      "Psychic research participation",
		      "Mentoring other twin pairs"
		    ]
		  }
		};
		
		const MICRO_EXPERIMENTS = [
		  {
		    id: 1,
		    title: "Emotion Mirror",
		    description: "Try to sense your twin's current emotional state, then check with them",
		    duration: "2 minutes",
		    difficulty: "Easy",
		    category: "Emotional Connection"
		  },
		  {
		    id: 2,
		    title: "Color Transmission",
		    description: "One twin thinks of a color, the other tries to receive it telepathically",
		    duration: "5 minutes",
		    difficulty: "Medium",
		    category: "Telepathic Experiences"
		  },
		  {
		    id: 3,
		    title: "Synchronous Breathing",
		    description: "Breathe together in perfect synchrony for 10 minutes, even when apart",
		    duration: "10 minutes",
		    difficulty: "Easy",
		    category: "Behavioral Synchrony"
		  },
		  {
		    id: 4,
		    title: "Dream Connection",
		    description: "Try to visit each other's dreams or share the same dream",
		    duration: "1 night",
		    difficulty: "Hard",
		    category: "Shared Experiences"
		  },
		  {
		    id: 5,
		    title: "Energy Touch",
		    description: "Send healing energy to your twin when they're feeling unwell",
		    duration: "15 minutes",
		    difficulty: "Medium",
		    category: "Physical Sensations"
		  },
		  {
		    id: 6,
		    title: "Thought Transmission",
		    description: "Send a specific word or phrase to your twin telepathically",
		    duration: "3 minutes",
		    difficulty: "Medium",
		    category: "Telepathic Experiences"
		  }
		];
		
		export const AssessmentRecommendationsScreen = () => {
		  const { userProfile } = useTwinStore();
		  const navigation = useNavigation<any>();
		  const route = useRoute<any>();
		  const [selectedTab, setSelectedTab] = useState<'plan' | 'exercises' | 'tips'>('plan');
		  const [completedExperiments, setCompletedExperiments] = useState<number[]>([]);
		  
		  const results: AssessmentResults = route.params?.results;
		  const themeColor = userProfile?.accentColor || "neon-purple";
		  
		  const getAccentColor = () => {
		    switch (themeColor) {
		      case "neon-pink": return "#ff1493";
		      case "neon-blue": return "#00bfff";
		      case "neon-green": return "#00ff7f";
		      case "neon-yellow": return "#ffff00";
		      case "neon-purple": return "#8a2be2";
		      case "neon-orange": return "#ff4500";
		      case "neon-cyan": return "#00ffff";
		      case "neon-red": return "#ff0000";
		      default: return "#8a2be2";
		    }
		  };
		
		  const accentColor = getAccentColor();
		  const coachingPlan = COACHING_PLANS[results?.level];
		  
		  // Animation
		  const fadeIn = useSharedValue(0);
		  
		  React.useEffect(() => {
		    fadeIn.value = withSpring(1);
		  }, []);
		  
		  const animatedStyle = useAnimatedStyle(() => ({
		    opacity: fadeIn.value
		  }));
		
		  const handleExperimentComplete = (experimentId: number) => {
		    setCompletedExperiments(prev => [...prev, experimentId]);
		    Alert.alert(
		      "Experiment Completed! 🎉",
		      "Great job! Keep practicing to strengthen your twin connection.",
		      [{ text: "Continue", style: "default" }]
		    );
		  };
		
		  const handleStartPlan = () => {
		    Alert.alert(
		      "Start Coaching Plan",
		      `Ready to begin your ${coachingPlan?.title}? This will help you develop your twin connection over the next ${coachingPlan?.duration}.`,
		      [
		        { text: "Maybe Later", style: "cancel" },
		        { 
		          text: "Start Now", 
		          style: "default",
		          onPress: () => {
		            // Here you would integrate with a coaching system
		            Alert.alert("Plan Started!", "Your coaching plan has been activated. Check back daily for new activities.");
		          }
		        }
		      ]
		    );
		  };
		
		  const renderCoachingPlan = () => (
		    <Animated.View style={animatedStyle} className="space-y-6">
		      {/* Plan Overview */}
		      <View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6">
		        <View className="flex-row items-center mb-4">
		          <View 
		            className="w-12 h-12 rounded-full items-center justify-center mr-4"
		            style={{ backgroundColor: `${accentColor}30` }}
		          >
		            <Ionicons name="trophy" size={24} color={accentColor} />
		          </View>
		          <View className="flex-1">
		            <Text className="text-white text-xl font-bold">{coachingPlan?.title}</Text>
		            <Text className="text-white/70">{coachingPlan?.duration}</Text>
		          </View>
		        </View>
		        
		        <Text className="text-white/80 mb-4">{coachingPlan?.focus}</Text>
		        
		        <Pressable
		          onPress={handleStartPlan}
		          className="rounded-xl py-3 px-4"
		          style={{ backgroundColor: accentColor }}
		        >
		          <Text className="text-white font-semibold text-center">Start This Plan</Text>
		        </Pressable>
		      </View>
		
		      {/* Plan Activities */}
		      <View className="bg-white/5 backdrop-blur-sm rounded-xl p-4">
		        <Text className="text-white font-semibold mb-4">Included Activities</Text>
		        <View className="space-y-3">
		          {coachingPlan?.activities.map((activity, index) => (
		            <View key={index} className="flex-row items-center">
		              <View 
		                className="w-2 h-2 rounded-full mr-3"
		                style={{ backgroundColor: accentColor }}
		              />
		              <Text className="text-white/80 flex-1">{activity}</Text>
		            </View>
		          ))}
		        </View>
		      </View>
		
		      {/* Progress Tracking */}
		      <View className="bg-white/5 backdrop-blur-sm rounded-xl p-4">
		        <Text className="text-white font-semibold mb-2">Track Your Progress</Text>
		        <Text className="text-white/70 text-sm mb-4">
		          Complete daily check-ins to monitor your twin connection growth
		        </Text>
		        <View className="flex-row space-x-3">
		          <Pressable className="flex-1 bg-white/10 rounded-lg py-3">
		            <Text className="text-white text-center text-sm">Daily Check-in</Text>
		          </Pressable>
		          <Pressable className="flex-1 bg-white/10 rounded-lg py-3">
		            <Text className="text-white text-center text-sm">View Progress</Text>
		          </Pressable>
		        </View>
		      </View>
		    </Animated.View>
		  );
		
		  const renderMicroExperiments = () => (
		    <Animated.View style={animatedStyle} className="space-y-4">
		      <View className="mb-2">
		        <Text className="text-white text-lg font-semibold mb-2">Quick Experiments</Text>
		        <Text className="text-white/70 text-sm">
		          Try these bite-sized exercises to strengthen your connection
		        </Text>
		      </View>
		      
		      {MICRO_EXPERIMENTS.map((experiment) => (
		        <MicroExperimentCard
		          key={experiment.id}
		          experiment={experiment}
		          isCompleted={completedExperiments.includes(experiment.id)}
		          onComplete={() => handleExperimentComplete(experiment.id)}
		          accentColor={accentColor}
		        />
		      ))}
		    </Animated.View>
		  );
		
		  const renderTips = () => (
		    <Animated.View style={animatedStyle} className="space-y-4">
		      <Text className="text-white text-lg font-semibold mb-2">Personalized Tips</Text>
		      
		      {results?.recommendations.map((recommendation, index) => (
		        <RecommendationCard
		          key={index}
		          recommendation={recommendation}
		          index={index}
		          accentColor={accentColor}
		        />
		      ))}
		      
		      {/* General Tips */}
		      <View className="bg-white/5 backdrop-blur-sm rounded-xl p-4">
		        <Text className="text-white font-semibold mb-3">General Guidelines</Text>
		        <View className="space-y-2">
		          {[
		            "Practice regularly - consistency is key for developing psychic abilities",
		            "Stay relaxed and open-minded during experiments",
		            "Keep a journal to track your experiences and progress",
		            "Trust your intuition, even if it seems unlikely",
		            "Be patient - psychic abilities develop over time"
		          ].map((tip, index) => (
		            <View key={index} className="flex-row items-start">
		              <Text className="text-white/70 mr-2">•</Text>
		              <Text className="text-white/70 text-sm flex-1">{tip}</Text>
		            </View>
		          ))}
		        </View>
		      </View>
		    </Animated.View>
		  );
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        {/* Header */}
		        <View className="px-6 pt-4 pb-2">
		          <View className="flex-row items-center justify-between mb-4">
		            <Pressable onPress={() => navigation.goBack()}>
		              <Ionicons name="chevron-back" size={28} color="white" />
		            </Pressable>
		            
		            <Text className="text-white text-xl font-bold">Your Action Plan</Text>
		            
		            <View className="w-7" />
		          </View>
		          
		          {/* Tab Navigation */}
		          <View className="flex-row bg-white/10 rounded-xl p-1">
		            {[
		              { key: 'plan', label: 'Coaching' },
		              { key: 'exercises', label: 'Exercises' },
		              { key: 'tips', label: 'Tips' }
		            ].map(tab => (
		              <Pressable
		                key={tab.key}
		                onPress={() => setSelectedTab(tab.key as any)}
		                className={`flex-1 py-2 px-3 rounded-lg ${
		                  selectedTab === tab.key ? 'opacity-100' : 'opacity-70'
		                }`}
		                style={selectedTab === tab.key ? { backgroundColor: `${accentColor}40` } : {}}
		              >
		                <Text className="text-white text-center font-medium text-sm">
		                  {tab.label}
		                </Text>
		              </Pressable>
		            ))}
		          </View>
		        </View>
		
		        <ScrollView className="flex-1 px-6">
		          {selectedTab === 'plan' && renderCoachingPlan()}
		          {selectedTab === 'exercises' && renderMicroExperiments()}
		          {selectedTab === 'tips' && renderTips()}
		          
		          <View className="h-6" />
		        </ScrollView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/assessment/AssessmentResultsScreen_Premium.tsx'><![CDATA[
		import React, { useState, useEffect } from 'react';
		import { View, Text, ScrollView, Pressable, Dimensions, Alert } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { useNavigation, useRoute } from '@react-navigation/native';
		import { Ionicons } from '@expo/vector-icons';
		import { LinearGradient } from 'expo-linear-gradient';
		
		// Import new premium components
		import { PremiumGatedContent } from '../../components/premium/PremiumGatedContent';
		import { PremiumBadge, PremiumUpgradeButton } from '../../components/premium/PremiumBadge';
		import { PremiumStatusIndicator } from '../../components/premium/PremiumStatusIndicator';
		import { PremiumFeatureTeaser } from '../../components/premium/PremiumFeatureTeaser';
		
		// Import hooks and utilities
		import { useAssessmentPremium } from '../../hooks/usePremiumFeatures';
		import { pdfExportService } from '../../utils/pdfExportService';
		import { PREMIUM_FEATURES } from '../../types/premium/subscription';
		
		// Import existing components
		import { useTwinStore } from '../../state/twinStore';
		import { useAssessmentStore } from '../../state/assessmentStore';
		import { getNeonAccentColor } from '../../utils/neonColors';
		
		const { width } = Dimensions.get('window');
		
		// Enhanced Circular Progress with premium styling
		const CircularProgress = ({ 
		  value, 
		  maxValue = 100, 
		  size = 120, 
		  strokeWidth = 12,
		  color = '#a855f7',
		  label = '',
		  isPremium = false
		}) => {
		  const radius = (size - strokeWidth) / 2;
		  const circumference = 2 * Math.PI * radius;
		  const progress = (value / maxValue) * circumference;
		
		  return (
		    <View className="items-center">
		      <View style={{ width: size, height: size }}>
		        <View className="absolute inset-0 items-center justify-center">
		          <Text className="text-white text-2xl font-bold">{Math.round(value)}</Text>
		          <Text className="text-white/60 text-xs">{label}</Text>
		          {isPremium && (
		            <View className="absolute -top-2 -right-2">
		              <PremiumBadge featureId="detailed_results" size="small" />
		            </View>
		          )}
		        </View>
		        <View 
		          style={{ 
		            transform: [{ rotate: '-90deg' }],
		            width: size,
		            height: size
		          }}
		        >
		          {/* Background circle */}
		          <View
		            className="absolute"
		            style={{
		              width: size,
		              height: size,
		              borderRadius: size / 2,
		              borderWidth: strokeWidth,
		              borderColor: isPremium ? `${color}30` : 'rgba(255,255,255,0.1)'
		            }}
		          />
		          {/* Progress circle */}
		          <View
		            className="absolute"
		            style={{
		              width: size,
		              height: size,
		              borderRadius: size / 2,
		              borderWidth: strokeWidth,
		              borderColor: color,
		              borderTopColor: 'transparent',
		              borderRightColor: 'transparent',
		              borderBottomColor: 'transparent',
		              transform: [{ 
		                rotate: `${(progress / circumference) * 360}deg` 
		              }]
		            }}
		          />
		        </View>
		      </View>
		    </View>
		  );
		};
		
		export const AssessmentResultsScreen = () => {
		  const navigation = useNavigation<any>();
		  const route = useRoute<any>();
		  const { userProfile, twinProfile } = useTwinStore();
		  const { getResultsById } = useAssessmentStore();
		  
		  // Use the new premium hook
		  const {
		    canViewDetailedResults,
		    canExportPDF,
		    canAccessCoaching,
		    canViewAnalytics,
		    canGetRecommendations,
		    requireDetailedResults,
		    requirePDFExport,
		    requireCoachingPlans,
		    navigateToUpgrade,
		    trackConversionEvent
		  } = useAssessmentPremium();
		  
		  const [isExporting, setIsExporting] = useState(false);
		  
		  const themeColor = userProfile?.accentColor || 'neon-purple';
		  const neonColor = getNeonAccentColor(themeColor);
		  const sessionId = route.params?.sessionId;
		  const results = getResultsById(sessionId);
		
		  useEffect(() => {
		    // Track that user viewed results
		    trackConversionEvent('assessment_results_viewed', { sessionId });
		  }, [sessionId]);
		
		  if (!results) {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1 items-center justify-center">
		          <Text className="text-white text-lg">Results not found</Text>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  const ci = results.compositeScores.find(s => s.index === 'CI')?.value || 0;
		  const ari = results.compositeScores.find(s => s.index === 'ARI')?.value || 0;
		  const trs = results.compositeScores.find(s => s.index === 'TRS')?.value || 0;
		
		  const handleViewDetails = () => {
		    if (!requireDetailedResults(() => navigateToUpgrade('detailed_results', 'assessment_details'))) {
		      return;
		    }
		    navigation.navigate('AssessmentDetails', { sessionId });
		  };
		
		  const handleExportPDF = async () => {
		    if (!requirePDFExport(() => navigateToUpgrade('pdf_export', 'export_button'))) {
		      return;
		    }
		
		    try {
		      setIsExporting(true);
		      trackConversionEvent('pdf_export_initiated', { sessionId });
		      
		      const assessmentResults = {
		        personalityScores: results.personalityScores.reduce((acc, score) => {
		          acc[score.trait] = score.value;
		          return acc;
		        }, {} as Record<string, number>),
		        twinDynamics: {
		          codependencyIndex: ci,
		          autonomyScore: ari,
		          transitionRisk: trs
		        },
		        recommendations: results.recommendations.map(r => r.description),
		        timestamp: results.timestamp,
		        userProfile: {
		          name: userProfile?.name || 'User',
		          twinType: userProfile?.twinType || 'unknown'
		        },
		        twinProfile: twinProfile ? {
		          name: twinProfile.name
		        } : undefined
		      };
		
		      await pdfExportService.shareAssessmentPDF(assessmentResults, {
		        format: 'detailed',
		        includeRecommendations: true,
		        includeTwinComparison: !!twinProfile
		      });
		
		      trackConversionEvent('pdf_export_completed', { sessionId });
		    } catch (error) {
		      Alert.alert('Export Failed', 'Unable to export PDF. Please try again.');
		      trackConversionEvent('pdf_export_failed', { sessionId, error: error.message });
		    } finally {
		      setIsExporting(false);
		    }
		  };
		
		  const handleViewRecommendations = () => {
		    if (!requireCoachingPlans(() => navigateToUpgrade('coaching_plans', 'recommendations_button'))) {
		      return;
		    }
		    navigation.navigate('AssessmentRecommendations', { sessionId });
		  };
		
		  const detailedResultsFeature = PREMIUM_FEATURES.find(f => f.id === 'detailed_results')!;
		  const coachingFeature = PREMIUM_FEATURES.find(f => f.id === 'coaching_plans')!;
		  const pdfFeature = PREMIUM_FEATURES.find(f => f.id === 'pdf_export')!;
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <ScrollView className="flex-1 px-6">
		          {/* Header with Premium Status */}
		          <View className="flex-row items-center justify-between pt-4 pb-6">
		            <Pressable onPress={() => navigation.navigate('Home')}>
		              <Ionicons name="close" size={24} color="white" />
		            </Pressable>
		            <View className="flex-1 items-center">
		              <Text className="text-white text-xl font-semibold">Your Results</Text>
		              <View className="mt-1">
		                <PremiumStatusIndicator variant="minimal" />
		              </View>
		            </View>
		            <View className="flex-row space-x-2">
		              {canExportPDF ? (
		                <Pressable onPress={handleExportPDF} disabled={isExporting}>
		                  <Ionicons 
		                    name="download-outline" 
		                    size={24} 
		                    color={isExporting ? "#6b7280" : "white"} 
		                  />
		                </Pressable>
		              ) : (
		                <PremiumBadge 
		                  featureId="pdf_export" 
		                  variant="icon" 
		                  onPress={() => navigateToUpgrade('pdf_export', 'header_icon')}
		                />
		              )}
		              <Pressable onPress={() => {/* Share logic */}}>
		                <Ionicons name="share-outline" size={24} color="white" />
		              </Pressable>
		            </View>
		          </View>
		
		          {/* Overall Profile */}
		          <View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 mb-6">
		            <Text className="text-white text-lg font-semibold mb-3">Your Twin Profile</Text>
		            <Text className="text-white/80 leading-relaxed">
		              {results.overallProfile}
		            </Text>
		          </View>
		
		          {/* Composite Scores - Premium Gated */}
		          <PremiumGatedContent
		            featureId="detailed_results"
		            gateType="teaser"
		            onUpgradeRequest={() => navigateToUpgrade('detailed_results', 'composite_scores')}
		          >
		            <View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 mb-6">
		              <View className="flex-row items-center justify-between mb-6">
		                <Text className="text-white text-lg font-semibold">Key Indices</Text>
		                {canViewDetailedResults && (
		                  <PremiumBadge featureId="detailed_results" variant="badge" showText={false} />
		                )}
		              </View>
		              
		              <View className="flex-row justify-around mb-4">
		                <CircularProgress
		                  value={ci}
		                  color="#10b981"
		                  label="CI"
		                  size={100}
		                  isPremium={canViewDetailedResults}
		                />
		                <CircularProgress
		                  value={ari}
		                  color="#3b82f6"
		                  label="ARI"
		                  size={100}
		                  isPremium={canViewDetailedResults}
		                />
		                <CircularProgress
		                  value={trs}
		                  color="#f59e0b"
		                  label="TRS"
		                  size={100}
		                  isPremium={canViewDetailedResults}
		                />
		              </View>
		
		              {canViewDetailedResults && (
		                <View className="space-y-3 mt-4">
		                  <View>
		                    <Text className="text-green-400 font-medium">Codependency Index (CI)</Text>
		                    <Text className="text-white/60 text-sm">
		                      {results.compositeScores.find(s => s.index === 'CI')?.interpretation}
		                    </Text>
		                  </View>
		                  <View className="mt-3">
		                    <Text className="text-blue-400 font-medium">Autonomy & Resilience (ARI)</Text>
		                    <Text className="text-white/60 text-sm">
		                      {results.compositeScores.find(s => s.index === 'ARI')?.interpretation}
		                    </Text>
		                  </View>
		                  <View className="mt-3">
		                    <Text className="text-yellow-400 font-medium">Transition Risk (TRS)</Text>
		                    <Text className="text-white/60 text-sm">
		                      {results.compositeScores.find(s => s.index === 'TRS')?.interpretation}
		                    </Text>
		                  </View>
		                </View>
		              )}
		            </View>
		          </PremiumGatedContent>
		
		          {/* Recommendations Section */}
		          <View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 mb-6">
		            <View className="flex-row items-center justify-between mb-4">
		              <Text className="text-white text-lg font-semibold">Your Recommendations</Text>
		              {!canGetRecommendations && (
		                <PremiumBadge featureId="recommendations" variant="button" size="small" />
		              )}
		            </View>
		            
		            {/* Show first recommendation as teaser */}
		            {results.recommendations.length > 0 && (
		              <View className="bg-white/5 rounded-xl p-4 mb-4">
		                <View className="flex-row items-start">
		                  <View className={`w-2 h-2 rounded-full mt-2 ${
		                    results.recommendations[0].priority === 'high' 
		                      ? 'bg-red-400' 
		                      : results.recommendations[0].priority === 'medium'
		                      ? 'bg-yellow-400'
		                      : 'bg-green-400'
		                  }`} />
		                  <View className="ml-3 flex-1">
		                    <Text className="text-white font-medium">
		                      {results.recommendations[0].title}
		                    </Text>
		                    <Text className="text-white/60 text-sm mt-1">
		                      {results.recommendations[0].description}
		                    </Text>
		                  </View>
		                </View>
		              </View>
		            )}
		
		            {/* Premium gate for additional recommendations */}
		            {!canGetRecommendations && results.recommendations.length > 1 && (
		              <PremiumFeatureTeaser
		                feature={coachingFeature}
		                onUpgrade={() => navigateToUpgrade('coaching_plans', 'recommendations_teaser')}
		                customMessage={`Unlock ${results.recommendations.length - 1} more personalized recommendations and weekly micro-experiments`}
		                showPreview={false}
		              >
		                <View className="bg-purple-500/20 rounded-xl p-3">
		                  <Text className="text-purple-300 text-sm text-center">
		                    🔒 {results.recommendations.length - 1} more recommendations available
		                  </Text>
		                </View>
		              </PremiumFeatureTeaser>
		            )}
		          </View>
		
		          {/* Action Buttons */}
		          <View className="mb-8 space-y-3">
		            {/* Primary CTA based on subscription status */}
		            {canViewDetailedResults ? (
		              <Pressable
		                onPress={handleViewDetails}
		                style={{ backgroundColor: neonColor }}
		                className="rounded-xl p-4"
		              >
		                <Text className="text-black text-center font-semibold text-lg">
		                  View Detailed Analysis
		                </Text>
		              </Pressable>
		            ) : (
		              <PremiumUpgradeButton
		                featureId="detailed_results"
		                onUpgrade={() => navigateToUpgrade('detailed_results', 'primary_cta')}
		                text="Unlock Full Results & Coaching"
		              />
		            )}
		
		            {/* Secondary actions */}
		            <View className="flex-row space-x-3">
		              {canAccessCoaching ? (
		                <Pressable
		                  onPress={handleViewRecommendations}
		                  className="flex-1 bg-white/10 rounded-xl p-3"
		                >
		                  <Text className="text-white text-center font-medium">
		                    Weekly Coaching
		                  </Text>
		                </Pressable>
		              ) : (
		                <Pressable
		                  onPress={() => navigateToUpgrade('coaching_plans', 'coaching_button')}
		                  className="flex-1 bg-white/10 rounded-xl p-3 border border-gray-600"
		                >
		                  <View className="flex-row items-center justify-center">
		                    <Ionicons name="lock-closed" size={16} color="#6b7280" />
		                    <Text className="text-gray-400 text-center font-medium ml-2">
		                      Coaching
		                    </Text>
		                  </View>
		                </Pressable>
		              )}
		
		              {canExportPDF ? (
		                <Pressable
		                  onPress={handleExportPDF}
		                  disabled={isExporting}
		                  className="flex-1 bg-white/10 rounded-xl p-3"
		                >
		                  <Text className="text-white text-center font-medium">
		                    {isExporting ? 'Exporting...' : 'Export PDF'}
		                  </Text>
		                </Pressable>
		              ) : (
		                <Pressable
		                  onPress={() => navigateToUpgrade('pdf_export', 'export_button')}
		                  className="flex-1 bg-white/10 rounded-xl p-3 border border-gray-600"
		                >
		                  <View className="flex-row items-center justify-center">
		                    <Ionicons name="lock-closed" size={16} color="#6b7280" />
		                    <Text className="text-gray-400 text-center font-medium ml-2">
		                      Export
		                    </Text>
		                  </View>
		                </Pressable>
		              )}
		            </View>
		
		            {/* Return home button */}
		            <Pressable
		              onPress={() => navigation.navigate('Home')}
		              className="bg-white/5 rounded-xl p-4"
		            >
		              <Text className="text-white/80 text-center font-medium">
		                Return Home
		              </Text>
		            </Pressable>
		          </View>
		
		          {/* Share with Twin */}
		          {userProfile?.twinId && (
		            <View className="bg-blue-500/10 rounded-xl p-4 mb-4">
		              <View className="flex-row items-center">
		                <Ionicons name="people-outline" size={20} color="rgba(147, 197, 253, 0.8)" />
		                <View className="ml-3 flex-1">
		                  <Text className="text-blue-300 font-medium">Share with your twin</Text>
		                  <Text className="text-blue-200/60 text-xs mt-1">
		                    Compare results when both complete the assessment
		                  </Text>
		                </View>
		              </View>
		            </View>
		          )}
		        </ScrollView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/assessment/AssessmentResultsScreen.tsx'><![CDATA[
		import React, { useState } from 'react';
		import { View, Text, ScrollView, Pressable, Dimensions, ImageBackground } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { useNavigation, useRoute } from '@react-navigation/native';
		import { Ionicons } from '@expo/vector-icons';
		import { useTwinStore } from '../../state/twinStore';
		import { useAssessmentStore } from '../../state/assessmentStore';
		
		const { width } = Dimensions.get('window');
		
		// Circular progress component
		const CircularProgress = ({ 
		  value, 
		  maxValue = 100, 
		  size = 120, 
		  strokeWidth = 12,
		  color = '#a855f7',
		  label = ''
		}) => {
		  const radius = (size - strokeWidth) / 2;
		  const circumference = 2 * Math.PI * radius;
		  const progress = (value / maxValue) * circumference;
		
		  return (
		    <View className="items-center">
		      <View style={{ width: size, height: size }}>
		        <View className="absolute inset-0 items-center justify-center">
		          <Text className="text-white text-2xl font-bold">{Math.round(value)}</Text>
		          <Text className="text-white/60 text-xs">{label}</Text>
		        </View>
		        <View 
		          style={{ 
		            transform: [{ rotate: '-90deg' }],
		            width: size,
		            height: size
		          }}
		        >
		          {/* Background circle */}
		          <View
		            className="absolute"
		            style={{
		              width: size,
		              height: size,
		              borderRadius: size / 2,
		              borderWidth: strokeWidth,
		              borderColor: 'rgba(255,255,255,0.1)'
		            }}
		          />
		          {/* Progress circle */}
		          <View
		            className="absolute"
		            style={{
		              width: size,
		              height: size,
		              borderRadius: size / 2,
		              borderWidth: strokeWidth,
		              borderColor: color,
		              borderTopColor: 'transparent',
		              borderRightColor: 'transparent',
		              borderBottomColor: 'transparent',
		              transform: [{ 
		                rotate: `${(progress / circumference) * 360}deg` 
		              }]
		            }}
		          />
		        </View>
		      </View>
		    </View>
		  );
		};
		
		export const AssessmentResultsScreen = () => {
		  const navigation = useNavigation<any>();
		  const route = useRoute<any>();
		  const { userProfile } = useTwinStore();
		  const { getResultsById, isPremium, markTeaserSeen, hasSeenTeaser } = useAssessmentStore();
		  
		  const [showPaywall, setShowPaywall] = useState(!isPremium && !hasSeenTeaser);
		  
		  const themeColor = userProfile?.accentColor || 'neon-purple';
		  const sessionId = route.params?.sessionId;
		  const results = getResultsById(sessionId);
		
		  if (!results) {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1 items-center justify-center">
		          <Text className="text-white text-lg">Results not found</Text>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  const ci = results.compositeScores.find(s => s.index === 'CI')?.value || 0;
		  const ari = results.compositeScores.find(s => s.index === 'ARI')?.value || 0;
		  const trs = results.compositeScores.find(s => s.index === 'TRS')?.value || 0;
		
		  const handleViewDetails = () => {
		    if (!isPremium) {
		      setShowPaywall(true);
		    } else {
		      navigation.navigate('AssessmentDetails', { sessionId });
		    }
		  };
		
		  const handleUnlockPremium = () => {
		    markTeaserSeen();
		    // Navigate to payment/subscription screen with source
		    navigation.navigate('Premium', { source: 'assessment' });
		  };
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <ScrollView className="flex-1 px-6">
		          {/* Header */}
		          <View className="flex-row items-center justify-between pt-4 pb-6">
		            <Pressable onPress={() => navigation.navigate('Main')}>
		              <Ionicons name="close" size={24} color="white" />
		            </Pressable>
		            <Text className="text-white text-xl font-semibold">Your Results</Text>
		            <Pressable onPress={() => navigation.navigate('Twinsettings')}>
		              <Ionicons name="share-outline" size={24} color="white" />
		            </Pressable>
		          </View>
		
		          {/* Overall Profile */}
		          <View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 mb-6">
		            <Text className="text-white text-lg font-semibold mb-3">Your Twin Profile</Text>
		            <Text className="text-white/80 leading-relaxed">
		              {results.overallProfile}
		            </Text>
		          </View>
		
		          {/* Composite Scores */}
		          <View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 mb-6">
		            <Text className="text-white text-lg font-semibold mb-6">Key Indices</Text>
		            
		            <View className="flex-row justify-around mb-4">
		              <CircularProgress
		                value={ci}
		                color="#10b981"
		                label="CI"
		                size={100}
		              />
		              <CircularProgress
		                value={ari}
		                color="#3b82f6"
		                label="ARI"
		                size={100}
		              />
		              <CircularProgress
		                value={trs}
		                color="#f59e0b"
		                label="TRS"
		                size={100}
		              />
		            </View>
		
		            <View className="space-y-3 mt-4">
		              <View>
		                <Text className="text-green-400 font-medium">Codependency Index (CI)</Text>
		                <Text className="text-white/60 text-sm">
		                  {results.compositeScores.find(s => s.index === 'CI')?.interpretation}
		                </Text>
		              </View>
		              <View className="mt-3">
		                <Text className="text-blue-400 font-medium">Autonomy & Resilience (ARI)</Text>
		                <Text className="text-white/60 text-sm">
		                  {results.compositeScores.find(s => s.index === 'ARI')?.interpretation}
		                </Text>
		              </View>
		              <View className="mt-3">
		                <Text className="text-yellow-400 font-medium">Transition Risk (TRS)</Text>
		                <Text className="text-white/60 text-sm">
		                  {results.compositeScores.find(s => s.index === 'TRS')?.interpretation}
		                </Text>
		              </View>
		            </View>
		          </View>
		
		          {/* Top Recommendations (Teaser) */}
		          <View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 mb-6">
		            <Text className="text-white text-lg font-semibold mb-4">Your Top Recommendation</Text>
		            
		            {results.recommendations.length > 0 && (
		              <View className="bg-white/5 rounded-xl p-4">
		                <View className="flex-row items-start">
		                  <View className={`w-2 h-2 rounded-full mt-2 ${
		                    results.recommendations[0].priority === 'high' 
		                      ? 'bg-red-400' 
		                      : results.recommendations[0].priority === 'medium'
		                      ? 'bg-yellow-400'
		                      : 'bg-green-400'
		                  }`} />
		                  <View className="ml-3 flex-1">
		                    <Text className="text-white font-medium">
		                      {results.recommendations[0].title}
		                    </Text>
		                    <Text className="text-white/60 text-sm mt-1">
		                      {results.recommendations[0].description}
		                    </Text>
		                  </View>
		                </View>
		              </View>
		            )}
		
		            {!isPremium && (
		              <View className="mt-4 bg-purple-500/20 rounded-xl p-3">
		                <Text className="text-purple-300 text-sm text-center">
		                  🔒 Unlock {results.recommendations.length - 1} more personalized recommendations
		                </Text>
		              </View>
		            )}
		          </View>
		
		          {/* Action Buttons */}
		          <View className="mb-8">
		            {!isPremium ? (
		              <>
		                <Pressable
		                  onPress={handleUnlockPremium}
		                  className="bg-purple-500 rounded-xl p-4 mb-3"
		                >
		                  <Text className="text-white text-center font-semibold text-lg">
		                    Unlock Full Results & Coaching
		                  </Text>
		                </Pressable>
		                
		                <Pressable
		                  onPress={() => navigation.navigate('Main')}
		                  className="bg-white/10 rounded-xl p-4"
		                >
		                  <Text className="text-white text-center font-medium">
		                    Return Home
		                  </Text>
		                </Pressable>
		              </>
		            ) : (
		              <>
		                <Pressable
		                  onPress={handleViewDetails}
		                  className="bg-purple-500 rounded-xl p-4 mb-3"
		                >
		                  <Text className="text-white text-center font-semibold text-lg">
		                    View Detailed Analysis
		                  </Text>
		                </Pressable>
		                
		                <Pressable
		                  onPress={() => navigation.navigate('AssessmentRecommendations', { results: session })}
		                  className="bg-white/10 rounded-xl p-4 mb-3"
		                >
		                  <Text className="text-white text-center font-medium">
		                    Weekly Micro-Experiments
		                  </Text>
		                </Pressable>
		                
		                <Pressable
		                  onPress={() => navigation.navigate('Main')}
		                  className="bg-white/10 rounded-xl p-4"
		                >
		                  <Text className="text-white text-center font-medium">
		                    Return Home
		                  </Text>
		                </Pressable>
		              </>
		            )}
		          </View>
		
		          {/* Share with Twin */}
		          {userProfile?.twinId && (
		            <View className="bg-blue-500/10 rounded-xl p-4 mb-4">
		              <View className="flex-row items-center">
		                <Ionicons name="people-outline" size={20} color="rgba(147, 197, 253, 0.8)" />
		                <View className="ml-3 flex-1">
		                  <Text className="text-blue-300 font-medium">Share with your twin</Text>
		                  <Text className="text-blue-200/60 text-xs mt-1">
		                    Compare results when both complete the assessment
		                  </Text>
		                </View>
		              </View>
		            </View>
		          )}
		        </ScrollView>
		
		        {/* Paywall Modal */}
		        {showPaywall && !isPremium && (
		          <View className="absolute inset-0 bg-black/80 items-center justify-center p-6">
		            <View className="bg-gray-900 rounded-2xl p-6 w-full max-w-sm">
		              <Text className="text-white text-xl font-bold text-center mb-4">
		                Unlock Your Full Twin Analysis
		              </Text>
		              
		              <View className="space-y-3 mb-6">
		                <View className="flex-row items-center">
		                  <Ionicons name="checkmark-circle" size={20} color="#10b981" />
		                  <Text className="text-white/80 ml-3">15 personality dimensions</Text>
		                </View>
		                <View className="flex-row items-center mt-2">
		                  <Ionicons name="checkmark-circle" size={20} color="#10b981" />
		                  <Text className="text-white/80 ml-3">All recommendations</Text>
		                </View>
		                <View className="flex-row items-center mt-2">
		                  <Ionicons name="checkmark-circle" size={20} color="#10b981" />
		                  <Text className="text-white/80 ml-3">Weekly micro-experiments</Text>
		                </View>
		                <View className="flex-row items-center mt-2">
		                  <Ionicons name="checkmark-circle" size={20} color="#10b981" />
		                  <Text className="text-white/80 ml-3">Pair comparison analytics</Text>
		                </View>
		                <View className="flex-row items-center mt-2">
		                  <Ionicons name="checkmark-circle" size={20} color="#10b981" />
		                  <Text className="text-white/80 ml-3">PDF export</Text>
		                </View>
		              </View>
		
		              <Pressable
		                onPress={handleUnlockPremium}
		                className="bg-purple-500 rounded-xl p-4 mb-3"
		              >
		                <Text className="text-white text-center font-semibold">
		                  Unlock Premium - $9.99
		                </Text>
		              </Pressable>
		
		              <Pressable
		                onPress={() => setShowPaywall(false)}
		                className="p-2"
		              >
		                <Text className="text-white/60 text-center">Maybe later</Text>
		              </Pressable>
		            </View>
		          </View>
		        )}
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/assessment/AssessmentSurveyScreen.tsx'><![CDATA[
		import React, { useState } from 'react';
		import { View, Text, ScrollView, Pressable, ImageBackground } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { useNavigation } from '@react-navigation/native';
		import { Ionicons } from '@expo/vector-icons';
		import { useTwinStore } from '../../state/twinStore';
		import { useAssessmentStore } from '../../state/assessmentStore';
		import { LikertScale } from '../../types/assessment';
		
		const likertOptions = [
		  { value: 1, label: 'Strongly\nDisagree' },
		  { value: 2, label: 'Disagree' },
		  { value: 3, label: 'Slightly\nDisagree' },
		  { value: 4, label: 'Neutral' },
		  { value: 5, label: 'Slightly\nAgree' },
		  { value: 6, label: 'Agree' },
		  { value: 7, label: 'Strongly\nAgree' }
		];
		
		export const AssessmentSurveyScreen = () => {
		  const navigation = useNavigation<any>();
		  const { userProfile } = useTwinStore();
		  const {
		    currentSession,
		    currentQuestionIndex,
		    saveResponse,
		    navigateToQuestion,
		    getCurrentQuestion,
		    getProgress,
		    canSubmit,
		    submitAssessment,
		    isLoading
		  } = useAssessmentStore();
		
		  const [selectedValue, setSelectedValue] = useState<LikertScale | null>(null);
		  
		  const themeColor = userProfile?.accentColor || 'neon-purple';
		  const currentQuestion = getCurrentQuestion();
		  const progress = getProgress();
		  const totalQuestions = 210; // From item bank
		
		  // Check if current question already has a response
		  React.useEffect(() => {
		    if (currentQuestion && currentSession) {
		      const existingResponse = currentSession.responses.find(
		        r => r.itemId === currentQuestion.id
		      );
		      setSelectedValue(existingResponse?.value || null);
		    }
		  }, [currentQuestion, currentSession]);
		
		  const handleResponse = (value: LikertScale) => {
		    setSelectedValue(value);
		  };
		
		  const handleNext = () => {
		    if (selectedValue && currentQuestion) {
		      saveResponse(currentQuestion.id, selectedValue);
		      setSelectedValue(null);
		      
		      // Check if this was the last question
		      if (currentQuestionIndex === totalQuestions - 1) {
		        handleSubmit();
		      }
		    }
		  };
		
		  const handlePrevious = () => {
		    if (currentQuestionIndex > 0) {
		      navigateToQuestion(currentQuestionIndex - 1);
		    }
		  };
		
		  const handleSubmit = async () => {
		    if (canSubmit()) {
		      const results = await submitAssessment();
		      if (results) {
		        navigation.navigate('AssessmentResults', { sessionId: results.sessionId });
		      }
		    } else {
		      // Show warning about minimum completion
		      alert('Please complete at least 70% of the assessment for valid results.');
		    }
		  };
		
		  const handleExit = () => {
		    // Auto-save is handled by Zustand persist
		    navigation.goBack();
		  };
		
		  if (!currentQuestion) {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1 items-center justify-center">
		          <Text className="text-white text-lg">Loading question...</Text>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        {/* Header with Progress */}
		        <View className="px-6 pt-4 pb-2">
		          <View className="flex-row items-center justify-between mb-4">
		            <Pressable onPress={handleExit}>
		              <Ionicons name="close" size={24} color="white" />
		            </Pressable>
		            <Text className="text-white font-medium">
		              Question {currentQuestionIndex + 1} of {totalQuestions}
		            </Text>
		            <Pressable 
		              onPress={handleSubmit}
		              disabled={!canSubmit()}
		              className={`${canSubmit() ? 'opacity-100' : 'opacity-50'}`}
		            >
		              <Text className="text-white font-medium">
		                {progress >= 100 ? 'Finish' : `${Math.round(progress)}%`}
		              </Text>
		            </Pressable>
		          </View>
		
		          {/* Progress Bar */}
		          <View className="h-2 bg-white/20 rounded-full overflow-hidden">
		            <View 
		              className="h-full bg-purple-500 rounded-full"
		              style={{ width: `${progress}%` }}
		            />
		          </View>
		        </View>
		
		        <ScrollView className="flex-1 px-6">
		          {/* Category Badge */}
		          <View className="mt-6 mb-4">
		            <View className="bg-white/10 rounded-full px-4 py-2 self-start">
		              <Text className="text-white/70 text-sm capitalize">
		                {currentQuestion.category.replace(/_/g, ' ')}
		              </Text>
		            </View>
		          </View>
		
		          {/* Question */}
		          <View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 mb-8">
		            <Text className="text-white text-xl font-medium leading-relaxed">
		              {currentQuestion.question}
		            </Text>
		            {currentQuestion.reverseScored && (
		              <View className="mt-3 flex-row items-center">
		                <Ionicons name="information-circle" size={16} color="rgba(147, 197, 253, 0.8)" />
		                <Text className="text-blue-300/80 text-xs ml-1">
		                  This question measures the opposite trait
		                </Text>
		              </View>
		            )}
		          </View>
		
		          {/* Likert Scale */}
		          <View className="mb-8">
		            <Text className="text-white/70 text-sm text-center mb-4">
		              Select your level of agreement
		            </Text>
		            
		            <View className="flex-row justify-between mb-2">
		              {likertOptions.map((option) => (
		                <Pressable
		                  key={option.value}
		                  onPress={() => handleResponse(option.value as LikertScale)}
		                  className="flex-1 items-center"
		                >
		                  <View 
		                    className={`w-12 h-12 rounded-full items-center justify-center mb-2 ${
		                      selectedValue === option.value 
		                        ? 'bg-purple-500' 
		                        : 'bg-white/10'
		                    }`}
		                  >
		                    <Text className={`text-lg font-bold ${
		                      selectedValue === option.value ? 'text-white' : 'text-white/60'
		                    }`}>
		                      {option.value}
		                    </Text>
		                  </View>
		                  <Text className={`text-xs text-center ${
		                    selectedValue === option.value ? 'text-white' : 'text-white/60'
		                  }`}>
		                    {option.label}
		                  </Text>
		                </Pressable>
		              ))}
		            </View>
		
		            {/* Scale Labels */}
		            <View className="flex-row justify-between mt-4 px-2">
		              <Text className="text-red-400 text-xs">Strongly Disagree</Text>
		              <Text className="text-green-400 text-xs">Strongly Agree</Text>
		            </View>
		          </View>
		
		          {/* Navigation Buttons */}
		          <View className="flex-row space-x-3 mb-8">
		            <Pressable
		              onPress={handlePrevious}
		              disabled={currentQuestionIndex === 0}
		              className={`flex-1 bg-white/10 rounded-xl p-4 ${
		                currentQuestionIndex === 0 ? 'opacity-50' : 'opacity-100'
		              }`}
		            >
		              <Text className="text-white text-center font-medium">Previous</Text>
		            </Pressable>
		
		            <Pressable
		              onPress={handleNext}
		              disabled={!selectedValue}
		              className={`flex-1 rounded-xl p-4 ${
		                selectedValue ? 'bg-purple-500' : 'bg-white/10 opacity-50'
		              }`}
		            >
		              <Text className="text-white text-center font-medium">
		                {currentQuestionIndex === totalQuestions - 1 ? 'Submit' : 'Next'}
		              </Text>
		            </Pressable>
		          </View>
		
		          {/* Save Notice */}
		          <View className="bg-blue-500/10 rounded-xl p-3 mb-4">
		            <View className="flex-row items-center">
		              <Ionicons name="save-outline" size={16} color="rgba(147, 197, 253, 0.8)" />
		              <Text className="text-blue-300/80 text-xs ml-2">
		                Your progress is automatically saved
		              </Text>
		            </View>
		          </View>
		        </ScrollView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/assessment/PairComparisonScreen.tsx'><![CDATA[
		import React, { useState } from "react";
		import { View, Text, Pressable, ScrollView, ImageBackground } from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { useTwinStore } from "../../state/twinStore";
		import { Ionicons } from "@expo/vector-icons";
		import { useNavigation } from "@react-navigation/native";
		import { ComparisonChart } from "../../components/assessment/ComparisonChart";
		import { CompatibilityMeter } from "../../components/assessment/CompatibilityMeter";
		import { DifferenceIndicator } from "../../components/assessment/DifferenceIndicator";
		import Animated, {
		  useSharedValue,
		  useAnimatedStyle,
		  withSpring,
		} from "react-native-reanimated";
		
		// Mock data - in real app this would come from both twins' assessments
		const MOCK_TWIN_RESULTS = {
		  user: {
		    overallScore: 78,
		    categoryScores: {
		      emotionalConnection: 85,
		      telepathicExperiences: 72,
		      behavioralSynchrony: 80,
		      sharedExperiences: 75,
		      physicalSensations: 68,
		    },
		    level: "Strong" as const
		  },
		  twin: {
		    overallScore: 71,
		    categoryScores: {
		      emotionalConnection: 78,
		      telepathicExperiences: 88,
		      behavioralSynchrony: 65,
		      sharedExperiences: 70,
		      physicalSensations: 74,
		    },
		    level: "Strong" as const
		  }
		};
		
		const COMPATIBILITY_INSIGHTS = [
		  {
		    type: "strength" as const,
		    title: "Emotional Harmony",
		    description: "You both score high in emotional connection, indicating a strong empathic bond.",
		    icon: "heart",
		    difference: 7
		  },
		  {
		    type: "balance" as const,
		    title: "Telepathic Balance",
		    description: "Your twin shows stronger telepathic abilities while you excel in behavioral sync.",
		    icon: "swap-horizontal",
		    difference: -16
		  },
		  {
		    type: "growth" as const,
		    title: "Physical Sensitivity",
		    description: "Both of you can work on developing physical sensation sharing.",
		    icon: "trending-up",
		    difference: -6
		  },
		  {
		    type: "synergy" as const,
		    title: "Complementary Strengths",
		    description: "Your different strength areas create a well-rounded psychic partnership.",
		    icon: "people",
		    difference: 0
		  }
		];
		
		interface InsightType {
		  type: 'strength' | 'balance' | 'growth' | 'synergy';
		  title: string;
		  description: string;
		  icon: string;
		  difference: number;
		}
		
		export const PairComparisonScreen = () => {
		  const { userProfile, twinProfile } = useTwinStore();
		  const navigation = useNavigation<any>();
		  const [selectedCategory, setSelectedCategory] = useState<string | null>(null);
		  
		  const themeColor = userProfile?.accentColor || "neon-purple";
		  
		  const getAccentColor = () => {
		    switch (themeColor) {
		      case "neon-pink": return "#ff1493";
		      case "neon-blue": return "#00bfff";
		      case "neon-green": return "#00ff7f";
		      case "neon-yellow": return "#ffff00";
		      case "neon-purple": return "#8a2be2";
		      case "neon-orange": return "#ff4500";
		      case "neon-cyan": return "#00ffff";
		      case "neon-red": return "#ff0000";
		      default: return "#8a2be2";
		    }
		  };
		
		  const accentColor = getAccentColor();
		  
		  // Calculate overall compatibility (0-100)
		  const calculateCompatibility = () => {
		    const userScores = Object.values(MOCK_TWIN_RESULTS.user.categoryScores);
		    const twinScores = Object.values(MOCK_TWIN_RESULTS.twin.categoryScores);
		    
		    let totalDifference = 0;
		    for (let i = 0; i < userScores.length; i++) {
		      totalDifference += Math.abs(userScores[i] - twinScores[i]);
		    }
		    
		    const averageDifference = totalDifference / userScores.length;
		    return Math.max(0, 100 - averageDifference);
		  };
		  
		  const compatibilityScore = calculateCompatibility();
		  
		  // Animation
		  const fadeIn = useSharedValue(0);
		  
		  React.useEffect(() => {
		    fadeIn.value = withSpring(1);
		  }, []);
		  
		  const animatedStyle = useAnimatedStyle(() => ({
		    opacity: fadeIn.value
		  }));
		
		  const getInsightColor = (type: InsightType['type']) => {
		    switch (type) {
		      case 'strength': return '#10b981';
		      case 'balance': return '#3b82f6';
		      case 'growth': return '#f59e0b';
		      case 'synergy': return '#8b5cf6';
		      default: return accentColor;
		    }
		  };
		
		  const categoryNames = {
		    emotionalConnection: "Emotional Connection",
		    telepathicExperiences: "Telepathic Experiences",
		    behavioralSynchrony: "Behavioral Synchrony", 
		    sharedExperiences: "Shared Experiences",
		    physicalSensations: "Physical Sensations"
		  };
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        {/* Header */}
		        <View className="px-6 pt-4 pb-2">
		          <View className="flex-row items-center justify-between mb-4">
		            <Pressable onPress={() => navigation.goBack()}>
		              <Ionicons name="chevron-back" size={28} color="white" />
		            </Pressable>
		            
		            <Text className="text-white text-xl font-bold">Twin Comparison</Text>
		            
		            <View className="w-7" />
		          </View>
		        </View>
		
		        <ScrollView className="flex-1 px-6">
		          <Animated.View style={animatedStyle} className="space-y-6">
		            
		            {/* Twin Profiles */}
		            <View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6">
		              <View className="flex-row items-center justify-between mb-6">
		                {/* User Profile */}
		                <View className="items-center flex-1">
		                  <View className="bg-white/20 rounded-full w-16 h-16 items-center justify-center mb-2">
		                    <Text className="text-white text-2xl font-bold">
		                      {userProfile?.name?.charAt(0) || "U"}
		                    </Text>
		                  </View>
		                  <Text className="text-white font-semibold">{userProfile?.name}</Text>
		                  <Text className="text-white/70 text-sm">{MOCK_TWIN_RESULTS.user.level}</Text>
		                  <Text className="font-bold mt-1" style={{ color: accentColor }}>
		                    {MOCK_TWIN_RESULTS.user.overallScore}%
		                  </Text>
		                </View>
		                
		                {/* Connection Symbol */}
		                <View className="mx-4">
		                  <View 
		                    className="w-8 h-8 rounded-full items-center justify-center"
		                    style={{ backgroundColor: `${accentColor}30` }}
		                  >
		                    <Ionicons name="link" size={20} color={accentColor} />
		                  </View>
		                </View>
		                
		                {/* Twin Profile */}
		                <View className="items-center flex-1">
		                  <View className="bg-white/20 rounded-full w-16 h-16 items-center justify-center mb-2">
		                    <Text className="text-white text-2xl font-bold">
		                      {twinProfile?.name?.charAt(0) || "T"}
		                    </Text>
		                  </View>
		                  <Text className="text-white font-semibold">{twinProfile?.name}</Text>
		                  <Text className="text-white/70 text-sm">{MOCK_TWIN_RESULTS.twin.level}</Text>
		                  <Text className="font-bold mt-1" style={{ color: accentColor }}>
		                    {MOCK_TWIN_RESULTS.twin.overallScore}%
		                  </Text>
		                </View>
		              </View>
		              
		              {/* Overall Compatibility */}
		              <View className="border-t border-white/10 pt-4">
		                <Text className="text-white text-center font-medium mb-2">Overall Compatibility</Text>
		                <CompatibilityMeter 
		                  score={compatibilityScore} 
		                  color={accentColor}
		                  showPercentage
		                />
		              </View>
		            </View>
		
		            {/* Category Comparison Chart */}
		            <View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6">
		              <Text className="text-white text-lg font-semibold mb-4">Detailed Comparison</Text>
		              <ComparisonChart 
		                userScores={MOCK_TWIN_RESULTS.user.categoryScores}
		                twinScores={MOCK_TWIN_RESULTS.twin.categoryScores}
		                accentColor={accentColor}
		                onCategorySelect={setSelectedCategory}
		                selectedCategory={selectedCategory}
		              />
		            </View>
		
		            {/* Category Details */}
		            <View className="space-y-3">
		              {Object.entries(MOCK_TWIN_RESULTS.user.categoryScores).map(([category, userScore]) => {
		                const twinScore = MOCK_TWIN_RESULTS.twin.categoryScores[category as keyof typeof MOCK_TWIN_RESULTS.twin.categoryScores];
		                const difference = userScore - twinScore;
		                
		                return (
		                  <Pressable 
		                    key={category}
		                    onPress={() => setSelectedCategory(selectedCategory === category ? null : category)}
		                    className={`bg-white/5 rounded-xl p-4 ${
		                      selectedCategory === category ? 'ring-2' : ''
		                    }`}
		                    style={selectedCategory === category ? { borderColor: accentColor, borderWidth: 1 } : {}}
		                  >
		                    <View className="flex-row justify-between items-center">
		                      <Text className="text-white font-medium flex-1">
		                        {categoryNames[category as keyof typeof categoryNames]}
		                      </Text>
		                      <DifferenceIndicator 
		                        difference={difference}
		                        accentColor={accentColor}
		                      />
		                    </View>
		                    
		                    <View className="flex-row items-center mt-3 space-x-4">
		                      <View className="flex-1">
		                        <View className="flex-row justify-between mb-1">
		                          <Text className="text-white/70 text-xs">You</Text>
		                          <Text className="text-white text-xs font-bold">{userScore}%</Text>
		                        </View>
		                        <View className="bg-white/10 rounded-full h-2 overflow-hidden">
		                          <View 
		                            className="h-full rounded-full"
		                            style={{ 
		                              width: `${userScore}%`,
		                              backgroundColor: accentColor
		                            }}
		                          />
		                        </View>
		                      </View>
		                      
		                      <View className="flex-1">
		                        <View className="flex-row justify-between mb-1">
		                          <Text className="text-white/70 text-xs">Twin</Text>
		                          <Text className="text-white text-xs font-bold">{twinScore}%</Text>
		                        </View>
		                        <View className="bg-white/10 rounded-full h-2 overflow-hidden">
		                          <View 
		                            className="h-full rounded-full"
		                            style={{ 
		                              width: `${twinScore}%`,
		                              backgroundColor: '#6b7280'
		                            }}
		                          />
		                        </View>
		                      </View>
		                    </View>
		                  </Pressable>
		                );
		              })}
		            </View>
		
		            {/* Compatibility Insights */}
		            <View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6">
		              <Text className="text-white text-lg font-semibold mb-4">Compatibility Insights</Text>
		              
		              <View className="space-y-4">
		                {COMPATIBILITY_INSIGHTS.map((insight, index) => (
		                  <View key={index} className="bg-white/5 rounded-xl p-4">
		                    <View className="flex-row items-center mb-2">
		                      <View 
		                        className="w-8 h-8 rounded-full items-center justify-center mr-3"
		                        style={{ backgroundColor: `${getInsightColor(insight.type)}30` }}
		                      >
		                        <Ionicons 
		                          name={insight.icon as any} 
		                          size={16} 
		                          color={getInsightColor(insight.type)} 
		                        />
		                      </View>
		                      <Text className="text-white font-medium flex-1">{insight.title}</Text>
		                      {insight.difference !== 0 && (
		                        <DifferenceIndicator 
		                          difference={insight.difference}
		                          accentColor={accentColor}
		                          size="small"
		                        />
		                      )}
		                    </View>
		                    <Text className="text-white/70 text-sm ml-11">{insight.description}</Text>
		                  </View>
		                ))}
		              </View>
		            </View>
		
		            {/* Action Buttons */}
		            <View className="space-y-3">
		              <Pressable 
		                onPress={() => navigation.navigate("AssessmentRecommendations" as never)}
		                className="rounded-xl py-4 px-6 flex-row items-center justify-center"
		                style={{ backgroundColor: accentColor }}
		              >
		                <Ionicons name="bulb-outline" size={20} color="white" />
		                <Text className="text-white font-semibold ml-2">Get Joint Exercises</Text>
		              </Pressable>
		              
		              <Pressable 
		                className="bg-white/10 rounded-xl py-4 px-6 flex-row items-center justify-center"
		              >
		                <Ionicons name="share-outline" size={20} color="white" />
		                <Text className="text-white font-medium ml-2">Share Comparison</Text>
		              </Pressable>
		            </View>
		
		            <View className="h-6" />
		          </Animated.View>
		        </ScrollView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/chat/TwinTalkScreen.tsx'><![CDATA[
		import React, { useEffect, useRef, useState } from 'react';
		import {
		  View,
		  Text,
		  ScrollView,
		  Pressable,
		  Alert,
		  RefreshControl,
		  AppState,
		  AppStateStatus,
		  ImageBackground,
		} from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { Ionicons } from '@expo/vector-icons';
		import { useNavigation } from '@react-navigation/native';
		import { MessageBubble } from '../../components/chat/MessageBubble';
		import { MessageInput } from '../../components/chat/MessageInput';
		import { TypingIndicator } from '../../components/chat/TypingIndicator';
		import { useTwinStore } from '../../state/twinStore';
		import { useChatStore } from '../../state/chatStore';
		import { chatService } from '../../services/chatService';
		import { getNeonAccentColor } from '../../utils/neonColors';
		import { ChatMessage } from '../../types/chat';
		import * as Haptics from 'expo-haptics';
		
		export const TwinTalkScreen = () => {
		  const navigation = useNavigation<any>();
		  const scrollViewRef = useRef<ScrollView>(null);
		  const [refreshing, setRefreshing] = useState(false);
		  const [showScrollToBottom, setShowScrollToBottom] = useState(false);
		
		  const { userProfile, twinProfile } = useTwinStore();
		  const {
		    messages,
		    typingIndicator,
		    connection,
		    twintuitionMoments,
		    resetUnreadCount,
		    selectedMessageId,
		    setSelectedMessage,
		  } = useChatStore();
		
		  const accentColor = userProfile?.accentColor || 'neon-purple';
		  const neonColor = getNeonAccentColor(accentColor);
		
		  // Scroll to bottom when new messages arrive
		  useEffect(() => {
		    if (messages.length > 0) {
		      setTimeout(() => {
		        scrollViewRef.current?.scrollToEnd({ animated: true });
		      }, 100);
		    }
		  }, [messages.length]);
		
		  // Mark messages as read when screen is focused
		  useEffect(() => {
		    const handleAppStateChange = (nextAppState: AppStateStatus) => {
		      if (nextAppState === 'active') {
		        chatService.markAllAsRead();
		        resetUnreadCount();
		      }
		    };
		
		    const subscription = AppState.addEventListener('change', handleAppStateChange);
		    
		    // Mark as read immediately when component mounts
		    chatService.markAllAsRead();
		    resetUnreadCount();
		
		    return () => subscription?.remove();
		  }, []);
		
		  const handleRefresh = async () => {
		    setRefreshing(true);
		    await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		    
		    // Simulate refresh - reconnect to chat service
		    chatService.disconnect();
		    setTimeout(() => {
		      chatService.connect();
		      setRefreshing(false);
		    }, 1000);
		  };
		
		  const handleMessageLongPress = (message: ChatMessage) => {
		    setSelectedMessage(selectedMessageId === message.id ? null : message.id);
		    
		    const isOwn = message.senderId === userProfile?.id;
		    const actions = isOwn 
		      ? ['Delete Message', 'Copy Text', 'Cancel']
		      : ['Copy Text', 'Reply', 'Cancel'];
		      
		    Alert.alert(
		      'Message Options',
		      message.text.length > 50 ? message.text.substring(0, 50) + '...' : message.text,
		      actions.map(action => ({
		        text: action,
		        style: action === 'Cancel' ? 'cancel' : action === 'Delete Message' ? 'destructive' : 'default',
		        onPress: () => {
		          switch (action) {
		            case 'Delete Message':
		              // Handle delete
		              break;
		            case 'Copy Text':
		              // Handle copy
		              break;
		            case 'Reply':
		              // Handle reply
		              break;
		          }
		          setSelectedMessage(null);
		        },
		      }))
		    );
		  };
		
		  const handleVideoCall = () => {
		    Alert.alert(
		      'Video Call',
		      'Would you like to start a video call with your twin?',
		      [
		        { text: 'Cancel', style: 'cancel' },
		        { 
		          text: 'Call', 
		          onPress: () => {
		            // In a real app, integrate with video calling service
		            Alert.alert('Feature Coming Soon', 'Video calling will be available in a future update!');
		          }
		        },
		      ]
		    );
		  };
		
		  const getConnectionStatusColor = () => {
		    switch (connection.status) {
		      case 'connected': return '#00ff7f';
		      case 'connecting': return '#ffff00';
		      case 'reconnecting': return '#ff8c00';
		      default: return '#ff4444';
		    }
		  };
		
		  const getConnectionStatusText = () => {
		    switch (connection.status) {
		      case 'connected': return 'Online';
		      case 'connecting': return 'Connecting...';
		      case 'reconnecting': return 'Reconnecting...';
		      default: return 'Offline';
		    }
		  };
		
		  const handleScroll = (event: any) => {
		    const { contentOffset, contentSize, layoutMeasurement } = event.nativeEvent;
		    const isNearBottom = contentOffset.y + layoutMeasurement.height >= contentSize.height - 100;
		    setShowScrollToBottom(!isNearBottom);
		  };
		
		  const scrollToBottom = () => {
		    scrollViewRef.current?.scrollToEnd({ animated: true });
		    setShowScrollToBottom(false);
		  };
		
		  if (!userProfile || !twinProfile) {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          {/* Header with back button */}
		          <View className="flex-row items-center justify-between px-6 py-4">
		            <Pressable onPress={() => navigation.goBack()} className="w-10 h-10 rounded-full bg-white/10 items-center justify-center">
		              <Ionicons name="chevron-back" size={20} color="white" />
		            </Pressable>
		            <Text className="text-white text-xl font-bold">Twin Talk</Text>
		            <View className="w-10" />
		          </View>
		          
		          <View className="flex-1 justify-center items-center px-6">
		            <View className="bg-white/10 rounded-2xl p-8 items-center max-w-sm">
		              <Ionicons name="people-outline" size={64} color="rgba(255,255,255,0.5)" />
		              <Text className="text-white text-xl font-semibold mb-4 text-center">Setting up Twin Talk...</Text>
		              <Text className="text-white/70 text-center mb-6 leading-6">
		                You need to pair with your twin before you can start chatting. Complete your profile and twin pairing first.
		              </Text>
		              
		              <Pressable 
		                onPress={() => navigation.navigate('Pair')}
		                className="bg-purple-500 rounded-xl px-6 py-3"
		              >
		                <Text className="text-white font-semibold">Pair with Twin</Text>
		              </Pressable>
		            </View>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        {/* Header */}
		        <View className="px-6 py-4 border-b border-white/10">
		          <View className="flex-row items-center justify-between">
		            <Pressable onPress={() => navigation.goBack()} className="mr-3">
		              <Ionicons name="chevron-back" size={24} color="white" />
		            </Pressable>
		            <View className="flex-row items-center flex-1">
		              {/* Twin Avatar */}
		              <View 
		                style={{
		                  backgroundColor: 'rgba(255,255,255,0.2)',
		                  borderColor: neonColor,
		                  borderWidth: 2,
		                }}
		                className="rounded-full w-12 h-12 items-center justify-center mr-3"
		              >
		                <Text className="text-white text-lg font-bold">
		                  {twinProfile.name.charAt(0)}
		                </Text>
		              </View>
		              
		              <View className="flex-1">
		                <Text className="text-white text-lg font-semibold">
		                  {twinProfile.name}
		                </Text>
		                <View className="flex-row items-center">
		                  <View 
		                    style={{ backgroundColor: getConnectionStatusColor() }}
		                    className="w-2 h-2 rounded-full mr-2" 
		                  />
		                  <Text className="text-white/70 text-sm">
		                    {getConnectionStatusText()}
		                  </Text>
		                  {connection.lastSeen && connection.status === 'disconnected' && (
		                    <Text className="text-white/50 text-xs ml-2">
		                      Last seen {new Date(connection.lastSeen).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
		                    </Text>
		                  )}
		                </View>
		              </View>
		            </View>
		            
		            {/* Action Buttons */}
		            <View className="flex-row items-center space-x-3">
		              {/* Video Call Button */}
		              <Pressable
		                onPress={handleVideoCall}
		                className="bg-white/10 rounded-full p-2"
		              >
		                <Ionicons name="videocam" size={20} color="white" />
		              </Pressable>
		              
		              {/* Settings Button */}
		              <Pressable
		                onPress={() => navigation.navigate('Twinsettings')}
		                className="bg-white/10 rounded-full p-2"
		              >
		                <Ionicons name="settings" size={20} color="white" />
		              </Pressable>
		            </View>
		          </View>
		        </View>
		
		        {/* Messages */}
		        <View className="flex-1 relative">
		          <ScrollView
		            ref={scrollViewRef}
		            className="flex-1 px-6"
		            contentContainerStyle={{ paddingTop: 16, paddingBottom: 16 }}
		            onScroll={handleScroll}
		            scrollEventThrottle={16}
		            refreshControl={
		              <RefreshControl
		                refreshing={refreshing}
		                onRefresh={handleRefresh}
		                tintColor={neonColor}
		                colors={[neonColor]}
		              />
		            }
		          >
		            {messages.length === 0 ? (
		              <View className="flex-1 justify-center items-center py-20">
		                <Ionicons name="chatbubbles-outline" size={64} color="rgba(255,255,255,0.3)" />
		                <Text className="text-white/50 text-lg mt-4 text-center">
		                  Start your sacred twin conversation
		                </Text>
		                <Text className="text-white/30 text-sm mt-2 text-center px-8">
		                  Your messages are private and secure between you and your twin
		                </Text>
		              </View>
		            ) : (
		              messages.map((message, index) => {
		                const isOwn = message.senderId === userProfile.id;
		                const showTimestamp = index === 0 || 
		                  new Date(message.timestamp).getTime() - new Date(messages[index - 1]?.timestamp || 0).getTime() > 300000; // 5 minutes
		                
		                return (
		                  <MessageBubble
		                    key={message.id}
		                    message={message}
		                    isOwn={isOwn}
		                    showTimestamp={showTimestamp}
		                    onLongPress={handleMessageLongPress}
		                  />
		                );
		              })
		            )}
		            
		            {/* Typing Indicator */}
		            {typingIndicator && (
		              <TypingIndicator typingIndicator={typingIndicator} />
		            )}
		          </ScrollView>
		
		          {/* Scroll to Bottom Button */}
		          {showScrollToBottom && (
		            <Pressable
		              onPress={scrollToBottom}
		              style={{
		                backgroundColor: neonColor,
		                position: 'absolute',
		                bottom: 20,
		                right: 20,
		                shadowColor: neonColor,
		                shadowOffset: { width: 0, height: 0 },
		                shadowOpacity: 0.5,
		                shadowRadius: 10,
		              }}
		              className="w-12 h-12 rounded-full items-center justify-center"
		            >
		              <Ionicons name="chevron-down" size={24} color="white" />
		            </Pressable>
		          )}
		        </View>
		
		        {/* Message Input */}
		        <MessageInput />
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/ChatScreen.tsx'><![CDATA[
		import React from 'react';
		import { ImageBackground, View, Text } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { useTwinStore } from '../state/twinStore';
		import { TwinTalkScreen } from './chat/TwinTalkScreen';
		
		// Legacy ChatScreen - now redirects to TwinTalkScreen
		export const ChatScreen = () => {
		  const userProfile = useTwinStore((state) => state.userProfile);
		  const accentColor = userProfile?.accentColor || 'neon-purple';
		
		  // Simply render the new TwinTalkScreen
		  return <TwinTalkScreen />;
		};]]></file>
	<file path='screens/games/CognitiveSyncMaze.tsx'><![CDATA[
		import React, { useState, useRef, useEffect } from 'react';
		import { View, Text, Pressable, PanResponder, Dimensions, ImageBackground } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { Ionicons } from '@expo/vector-icons';
		import Svg, { Path, Circle, Line } from 'react-native-svg';
		import { useTwinStore } from '../../state/twinStore';
		import * as Haptics from 'expo-haptics';
		
		interface TouchPoint {
		  x: number;
		  y: number;
		  timestamp: number;
		}
		
		interface MazeError {
		  position: TouchPoint;
		  correctionTime: number;
		  correctionType: 'immediate' | 'backtrack';
		}
		
		interface CognitiveInsight {
		  type: string;
		  message: string;
		  data: any;
		}
		
		const { width, height } = Dimensions.get('window');
		const MAZE_SIZE = width * 0.85;
		const CELL_SIZE = MAZE_SIZE / 10;
		
		export const CognitiveSyncMaze = ({ navigation }: any) => {
		  const { themeColor, twinProfile, addGameResult } = useTwinStore();
		  const [gamePhase, setGamePhase] = useState<'intro' | 'playing' | 'analyzing' | 'result'>('intro');
		  const [touchPath, setTouchPath] = useState<TouchPoint[]>([]);
		  const [startTime, setStartTime] = useState<number | null>(null);
		  const [endTime, setEndTime] = useState<number | null>(null);
		  const [mistakes, setMistakes] = useState<MazeError[]>([]);
		  const [isDrawing, setIsDrawing] = useState(false);
		  const [currentPosition, setCurrentPosition] = useState({ x: 0, y: 0 });
		  
		  // Simple maze layout (0 = wall, 1 = path)
		  const maze = [
		    [1,1,1,0,0,0,1,1,1,0],
		    [0,0,1,1,1,0,1,0,1,0],
		    [0,1,1,0,1,0,1,0,1,0],
		    [0,1,0,0,1,1,1,0,1,0],
		    [0,1,1,1,1,0,0,0,1,0],
		    [0,0,0,0,1,0,1,1,1,0],
		    [1,1,1,0,1,0,1,0,0,0],
		    [1,0,1,1,1,0,1,1,1,1],
		    [1,0,0,0,0,0,0,0,0,1],
		    [1,1,1,1,1,1,1,1,1,1],
		  ];
		  
		  const startPoint = { x: 0, y: 0 };
		  const endPoint = { x: 9, y: 9 };
		
		  const panResponder = PanResponder.create({
		    onStartShouldSetPanResponder: () => true,
		    onMoveShouldSetPanResponder: () => true,
		    onPanResponderGrant: (evt) => {
		      const touch = evt.nativeEvent;
		      const point = {
		        x: touch.locationX,
		        y: touch.locationY,
		        timestamp: Date.now()
		      };
		      
		      // Check if starting at the correct position
		      if (isNearStart(point) && gamePhase === 'playing') {
		        setIsDrawing(true);
		        setStartTime(Date.now());
		        setTouchPath([point]);
		        Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		      }
		    },
		    onPanResponderMove: (evt) => {
		      if (!isDrawing || gamePhase !== 'playing') return;
		      
		      const touch = evt.nativeEvent;
		      const point = {
		        x: touch.locationX,
		        y: touch.locationY,
		        timestamp: Date.now()
		      };
		      
		      setCurrentPosition(point);
		      setTouchPath(prev => [...prev, point]);
		      
		      // Check if on valid path
		      if (!isValidPath(point)) {
		        recordMistake(point);
		        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
		      }
		      
		      // Check if reached end
		      if (isNearEnd(point)) {
		        completeMaze();
		      }
		    },
		    onPanResponderRelease: () => {
		      if (isDrawing && !isNearEnd(currentPosition)) {
		        // Lifted finger before completing
		        setIsDrawing(false);
		        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);
		      }
		    }
		  });
		
		  const isNearStart = (point: TouchPoint) => {
		    const startX = startPoint.x * CELL_SIZE + CELL_SIZE / 2;
		    const startY = startPoint.y * CELL_SIZE + CELL_SIZE / 2;
		    const distance = Math.sqrt(Math.pow(point.x - startX, 2) + Math.pow(point.y - startY, 2));
		    return distance < CELL_SIZE;
		  };
		
		  const isNearEnd = (point: TouchPoint) => {
		    const endX = endPoint.x * CELL_SIZE + CELL_SIZE / 2;
		    const endY = endPoint.y * CELL_SIZE + CELL_SIZE / 2;
		    const distance = Math.sqrt(Math.pow(point.x - endX, 2) + Math.pow(point.y - endY, 2));
		    return distance < CELL_SIZE;
		  };
		
		  const isValidPath = (point: TouchPoint) => {
		    const cellX = Math.floor(point.x / CELL_SIZE);
		    const cellY = Math.floor(point.y / CELL_SIZE);
		    
		    if (cellX < 0 || cellX >= 10 || cellY < 0 || cellY >= 10) return false;
		    return maze[cellY][cellX] === 1;
		  };
		
		  const recordMistake = (point: TouchPoint) => {
		    const lastMistake = mistakes[mistakes.length - 1];
		    const timeSinceLastMistake = lastMistake ? Date.now() - lastMistake.position.timestamp : Infinity;
		    
		    setMistakes(prev => [...prev, {
		      position: point,
		      correctionTime: timeSinceLastMistake,
		      correctionType: timeSinceLastMistake < 500 ? 'immediate' : 'backtrack'
		    }]);
		  };
		
		  const completeMaze = () => {
		    setEndTime(Date.now());
		    setIsDrawing(false);
		    setGamePhase('analyzing');
		    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		    
		    // Analyze the cognitive patterns
		    setTimeout(() => {
		      const insights = analyzeCognitivePath();
		      saveResults(insights);
		    }, 2000);
		  };
		
		  const analyzeCognitivePath = (): CognitiveInsight[] => {
		    const insights: CognitiveInsight[] = [];
		    const totalTime = (endTime! - startTime!) / 1000;
		    
		    // Analyze directional preferences
		    let rightTurns = 0;
		    let leftTurns = 0;
		    
		    for (let i = 2; i < touchPath.length; i++) {
		      const prev = touchPath[i - 2];
		      const curr = touchPath[i - 1];
		      const next = touchPath[i];
		      
		      const angle1 = Math.atan2(curr.y - prev.y, curr.x - prev.x);
		      const angle2 = Math.atan2(next.y - curr.y, next.x - curr.x);
		      let turnAngle = angle2 - angle1;
		      
		      if (turnAngle > Math.PI) turnAngle -= 2 * Math.PI;
		      if (turnAngle < -Math.PI) turnAngle += 2 * Math.PI;
		      
		      if (turnAngle > 0.1) rightTurns++;
		      else if (turnAngle < -0.1) leftTurns++;
		    }
		    
		    const totalTurns = rightTurns + leftTurns;
		    const rightTurnPercentage = totalTurns > 0 ? (rightTurns / totalTurns) * 100 : 50;
		    
		    insights.push({
		      type: 'directional_bias',
		      message: `You favor ${rightTurnPercentage > 55 ? 'right' : rightTurnPercentage < 45 ? 'left' : 'balanced'} turns (${Math.round(rightTurnPercentage)}% right)`,
		      data: { rightTurns, leftTurns, percentage: rightTurnPercentage }
		    });
		    
		    // Analyze error correction style
		    const immediateCorrectionRate = mistakes.filter(m => m.correctionType === 'immediate').length / mistakes.length;
		    
		    insights.push({
		      type: 'correction_style',
		      message: `Your error correction is ${immediateCorrectionRate > 0.7 ? 'immediate' : 'deliberate'} (${Math.round(immediateCorrectionRate * 100)}% instant corrections)`,
		      data: { immediateCorrectionRate, totalMistakes: mistakes.length }
		    });
		    
		    // Analyze solving speed
		    const optimalTime = 15; // seconds
		    const speedRatio = totalTime / optimalTime;
		    
		    insights.push({
		      type: 'solving_speed',
		      message: `Completion time: ${totalTime.toFixed(1)}s (${speedRatio < 0.8 ? 'fast' : speedRatio < 1.2 ? 'moderate' : 'methodical'} solver)`,
		      data: { totalTime, speedRatio }
		    });
		    
		    return insights;
		  };
		
		  const saveResults = (insights: CognitiveInsight[]) => {
		    const score = calculateScore();
		    
		    addGameResult({
		      gameType: 'cognitive_sync_maze',
		      score,
		      twinScore: 0, // Will be compared when both complete
		      insights,
		      cognitiveData: {
		        touchPath,
		        mistakes,
		        totalTime: (endTime! - startTime!) / 1000,
		        rightTurnBias: insights[0].data.percentage
		      }
		    });
		    
		    setGamePhase('result');
		  };
		
		  const calculateScore = () => {
		    const timeScore = Math.max(0, 100 - ((endTime! - startTime!) / 1000 - 15) * 5);
		    const accuracyScore = Math.max(0, 100 - mistakes.length * 10);
		    return Math.round((timeScore + accuracyScore) / 2);
		  };
		
		  const renderMaze = () => {
		    return (
		      <Svg width={MAZE_SIZE} height={MAZE_SIZE}>
		        {/* Draw maze cells */}
		        {maze.map((row, y) => 
		          row.map((cell, x) => (
		            <View key={`${x}-${y}`}>
		              {cell === 0 && (
		                <Path
		                  d={`M ${x * CELL_SIZE} ${y * CELL_SIZE} h ${CELL_SIZE} v ${CELL_SIZE} h -${CELL_SIZE} z`}
		                  fill="#1a1a2e"
		                  stroke="#16213e"
		                  strokeWidth={1}
		                />
		              )}
		            </View>
		          ))
		        )}
		        
		        {/* Start point */}
		        <Circle
		          cx={startPoint.x * CELL_SIZE + CELL_SIZE / 2}
		          cy={startPoint.y * CELL_SIZE + CELL_SIZE / 2}
		          r={CELL_SIZE / 3}
		          fill="#10b981"
		        />
		        
		        {/* End point */}
		        <Circle
		          cx={endPoint.x * CELL_SIZE + CELL_SIZE / 2}
		          cy={endPoint.y * CELL_SIZE + CELL_SIZE / 2}
		          r={CELL_SIZE / 3}
		          fill="#f59e0b"
		        />
		        
		        {/* Draw path */}
		        {touchPath.length > 1 && (
		          <Path
		            d={`M ${touchPath[0].x} ${touchPath[0].y} ${touchPath.slice(1).map(p => `L ${p.x} ${p.y}`).join(' ')}`}
		            stroke="#8b5cf6"
		            strokeWidth={4}
		            fill="none"
		            strokeLinecap="round"
		            strokeLinejoin="round"
		          />
		        )}
		      </Svg>
		    );
		  };
		
		  if (gamePhase === 'intro') {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          {/* Header with back button */}
		          <View className="flex-row items-center justify-between px-6 py-4">
		            <Pressable onPress={() => navigation.goBack()}>
		              <Ionicons name="arrow-back" size={24} color="white" />
		            </Pressable>
		            <Text className="text-white text-lg font-semibold">Games</Text>
		            <View style={{ width: 24 }} />
		          </View>
		          <View className="flex-1 px-6 py-4 justify-center items-center">
		            <Ionicons name="git-branch" size={80} color="#8b5cf6" />
		            <Text className="text-white text-3xl font-bold text-center mt-6 mb-4">
		              Cognitive Synchrony Maze
		            </Text>
		            <Text className="text-white/70 text-lg text-center mb-8 max-w-sm">
		              Draw a path from the green start to the orange end. We'll analyze your cognitive patterns and compare them with {twinProfile?.name}.
		            </Text>
		            <Pressable
		              onPress={() => setGamePhase('playing')}
		              className="bg-purple-500 px-8 py-4 rounded-xl"
		            >
		              <Text className="text-white text-lg font-semibold">Start Maze</Text>
		            </Pressable>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  if (gamePhase === 'result') {
		    const insights = analyzeCognitivePath();
		    
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          <View className="flex-1 px-6 py-4">
		            <Text className="text-white text-2xl font-bold text-center mb-6">
		              Cognitive Analysis Complete
		            </Text>
		            
		            <View className="bg-white/10 rounded-2xl p-6 mb-6">
		              <Text className="text-white text-xl font-semibold mb-4">Your Cognitive Patterns</Text>
		              {insights.map((insight, index) => (
		                <View key={index} className="mb-4">
		                  <Text className="text-white/60 text-sm mb-1">
		                    {insight.type.replace(/_/g, ' ').toUpperCase()}
		                  </Text>
		                  <Text className="text-white text-base">
		                    {insight.message}
		                  </Text>
		                </View>
		              ))}
		            </View>
		            
		            <View className="bg-yellow-500/20 rounded-xl p-4 mb-6">
		              <Text className="text-white text-center">
		                Waiting for {twinProfile?.name} to complete their maze for comparison...
		              </Text>
		            </View>
		            
		            <View className="flex-row space-x-4">
		              <Pressable
		                onPress={() => navigation.goBack()}
		                className="flex-1 bg-white/20 py-3 rounded-xl"
		              >
		                <Text className="text-white text-center font-semibold">Back to Games</Text>
		              </Pressable>
		              <Pressable
		                onPress={() => {
		                  setGamePhase('intro');
		                  setTouchPath([]);
		                  setMistakes([]);
		                }}
		                className="flex-1 bg-purple-500 py-3 rounded-xl"
		              >
		                <Text className="text-white text-center font-semibold">Try Again</Text>
		              </Pressable>
		            </View>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <View className="flex-1 px-6 py-4">
		          {/* Header */}
		          <View className="flex-row items-center justify-between mb-4">
		            <Pressable onPress={() => navigation.goBack()}>
		              <Ionicons name="arrow-back" size={24} color="white" />
		            </Pressable>
		            <Text className="text-white text-xl font-semibold">
		              {gamePhase === 'analyzing' ? 'Analyzing...' : 'Draw Your Path'}
		            </Text>
		            <View className="w-6" />
		          </View>
		          
		          {/* Game Area */}
		          <View className="flex-1 justify-center items-center">
		            {gamePhase === 'analyzing' ? (
		              <View className="items-center">
		                <View className="w-20 h-20 border-4 border-purple-500 rounded-full animate-spin" />
		                <Text className="text-white text-xl mt-6">Analyzing your cognitive patterns...</Text>
		              </View>
		            ) : (
		              <View 
		                className="bg-white/10 rounded-2xl p-4"
		                {...panResponder.panHandlers}
		              >
		                {renderMaze()}
		              </View>
		            )}
		          </View>
		          
		          {/* Instructions */}
		          {gamePhase === 'playing' && (
		            <View className="bg-white/10 rounded-xl p-4">
		              <Text className="text-white text-center">
		                Place your finger on the green circle and draw to the orange circle without lifting
		              </Text>
		            </View>
		          )}
		        </View>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/games/EmotionalResonanceMapping.tsx'><![CDATA[
		import React, { useState, useEffect } from 'react';
		import { View, Text, Pressable, ScrollView, Image, ImageBackground } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { Ionicons } from '@expo/vector-icons';
		import { LinearGradient } from 'expo-linear-gradient';
		import Slider from '@react-native-community/slider';
		import { useTwinStore } from '../../state/twinStore';
		import * as Haptics from 'expo-haptics';
		
		interface EmotionalResponse {
		  imageId: string;
		  emotionalRatings: {
		    joy: number;
		    sadness: number;
		    peace: number;
		    anxiety: number;
		    love: number;
		    curiosity: number;
		  };
		  somaticLocation: {
		    x: number;
		    y: number;
		    area: 'head' | 'chest' | 'stomach' | 'full';
		  };
		  colorAssociation: string;
		  wordAssociations: string[];
		  responseTime: number;
		}
		
		interface EmotionalInsight {
		  type: string;
		  message: string;
		  data: any;
		}
		
		// Abstract images that evoke different emotions
		const abstractImages = [
		  { id: 'swirl1', source: require('../../assets/abstract/swirl1.png'), name: 'Cosmic Swirl' },
		  { id: 'fractal1', source: require('../../assets/abstract/fractal1.png'), name: 'Fractal Dreams' },
		  { id: 'organic1', source: require('../../assets/abstract/organic1.png'), name: 'Organic Flow' },
		  { id: 'geometric1', source: require('../../assets/abstract/geometric1.png'), name: 'Sacred Geometry' },
		];
		
		const emotionColors = [
		  '#FF6B6B', '#4ECDC4', '#45B7D1', '#F9C74F', '#90BE6D', '#8B5CF6',
		  '#F72585', '#4361EE', '#F77F00', '#06FFA5', '#FF006E', '#3A86FF'
		];
		
		const wordOptions = [
		  'flowing', 'sharp', 'warm', 'cold', 'expansive', 'contained',
		  'rising', 'falling', 'vibrant', 'muted', 'chaotic', 'ordered',
		  'ancient', 'new', 'familiar', 'strange', 'peaceful', 'energetic'
		];
		
		export const EmotionalResonanceMapping = ({ navigation }: any) => {
		  const { themeColor, twinProfile, addGameResult } = useTwinStore();
		  const [gamePhase, setGamePhase] = useState<'intro' | 'viewing' | 'rating' | 'mapping' | 'words' | 'result'>('intro');
		  const [currentImageIndex, setCurrentImageIndex] = useState(0);
		  const [responses, setResponses] = useState<EmotionalResponse[]>([]);
		  const [currentResponse, setCurrentResponse] = useState<Partial<EmotionalResponse>>({});
		  const [startTime, setStartTime] = useState<number>(0);
		  const [selectedWords, setSelectedWords] = useState<string[]>([]);
		
		  const startNewImage = () => {
		    setGamePhase('viewing');
		    setStartTime(Date.now());
		    setCurrentResponse({
		      imageId: abstractImages[currentImageIndex].id,
		      emotionalRatings: {
		        joy: 0,
		        sadness: 0,
		        peace: 0,
		        anxiety: 0,
		        love: 0,
		        curiosity: 0
		      }
		    });
		    setSelectedWords([]);
		    
		    // Auto-advance after viewing time
		    setTimeout(() => {
		      setGamePhase('rating');
		    }, 5000);
		  };
		
		  const handleEmotionRating = (emotion: keyof typeof currentResponse.emotionalRatings, value: number) => {
		    setCurrentResponse(prev => ({
		      ...prev,
		      emotionalRatings: {
		        ...prev.emotionalRatings!,
		        [emotion]: value
		      }
		    }));
		  };
		
		  const handleBodyMapping = (location: { x: number, y: number }) => {
		    const area = location.y < 100 ? 'head' : 
		                 location.y < 200 ? 'chest' : 
		                 location.y < 300 ? 'stomach' : 'full';
		    
		    setCurrentResponse(prev => ({
		      ...prev,
		      somaticLocation: { x: location.x, y: location.y, area }
		    }));
		    
		    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		  };
		
		  const handleColorSelection = (color: string) => {
		    setCurrentResponse(prev => ({ ...prev, colorAssociation: color }));
		    setGamePhase('words');
		  };
		
		  const handleWordSelection = (word: string) => {
		    if (selectedWords.includes(word)) {
		      setSelectedWords(prev => prev.filter(w => w !== word));
		    } else if (selectedWords.length < 3) {
		      setSelectedWords(prev => [...prev, word]);
		      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		    }
		  };
		
		  const completeCurrentImage = () => {
		    const responseTime = Date.now() - startTime;
		    const completeResponse: EmotionalResponse = {
		      ...currentResponse as EmotionalResponse,
		      wordAssociations: selectedWords,
		      responseTime
		    };
		    
		    setResponses(prev => [...prev, completeResponse]);
		    
		    // Move to next image or finish
		    if (currentImageIndex < abstractImages.length - 1) {
		      setCurrentImageIndex(prev => prev + 1);
		      startNewImage();
		    } else {
		      analyzeResults();
		    }
		  };
		
		  const analyzeResults = () => {
		    setGamePhase('result');
		    const insights = generateEmotionalInsights();
		    saveResults(insights);
		  };
		
		  const generateEmotionalInsights = (): EmotionalInsight[] => {
		    const insights: EmotionalInsight[] = [];
		    
		    // Analyze dominant emotions
		    const emotionTotals: Record<string, number> = {};
		    responses.forEach(r => {
		      Object.entries(r.emotionalRatings).forEach(([emotion, rating]) => {
		        emotionTotals[emotion] = (emotionTotals[emotion] || 0) + rating;
		      });
		    });
		    
		    const dominantEmotion = Object.entries(emotionTotals)
		      .sort(([,a], [,b]) => b - a)[0][0];
		    
		    insights.push({
		      type: 'dominant_emotion',
		      message: `Your emotional responses are primarily driven by ${dominantEmotion}`,
		      data: { emotionTotals, dominant: dominantEmotion }
		    });
		    
		    // Analyze somatic patterns
		    const bodyAreas = responses.map(r => r.somaticLocation.area);
		    const mostCommonArea = bodyAreas.sort((a, b) => 
		      bodyAreas.filter(v => v === a).length - bodyAreas.filter(v => v === b).length
		    ).pop();
		    
		    insights.push({
		      type: 'somatic_pattern',
		      message: `You tend to feel emotions most strongly in your ${mostCommonArea}`,
		      data: { areas: bodyAreas, dominant: mostCommonArea }
		    });
		    
		    // Analyze color-emotion associations
		    const colorEmotionMap: Record<string, string[]> = {};
		    responses.forEach(r => {
		      const topEmotion = Object.entries(r.emotionalRatings)
		        .sort(([,a], [,b]) => b - a)[0][0];
		      if (!colorEmotionMap[r.colorAssociation]) {
		        colorEmotionMap[r.colorAssociation] = [];
		      }
		      colorEmotionMap[r.colorAssociation].push(topEmotion);
		    });
		    
		    insights.push({
		      type: 'color_associations',
		      message: `Your color-emotion synesthesia shows unique patterns`,
		      data: colorEmotionMap
		    });
		    
		    // Analyze word patterns
		    const allWords = responses.flatMap(r => r.wordAssociations);
		    const wordFrequency = allWords.reduce((acc, word) => {
		      acc[word] = (acc[word] || 0) + 1;
		      return acc;
		    }, {} as Record<string, number>);
		    
		    const emotionalVocabulary = Object.keys(wordFrequency).length;
		    insights.push({
		      type: 'emotional_vocabulary',
		      message: `Your emotional vocabulary contains ${emotionalVocabulary} unique descriptors`,
		      data: { wordFrequency, vocabularySize: emotionalVocabulary }
		    });
		    
		    return insights;
		  };
		
		  const saveResults = (insights: EmotionalInsight[]) => {
		    addGameResult({
		      gameType: 'emotional_resonance',
		      score: calculateEmotionalSyncScore(),
		      twinScore: 0,
		      insights,
		      emotionalData: {
		        responses,
		        dominantEmotions: insights[0].data.emotionTotals,
		        somaticPattern: insights[1].data,
		        vocabularySize: insights[3].data.vocabularySize
		      }
		    });
		  };
		
		  const calculateEmotionalSyncScore = () => {
		    // This will be properly calculated when comparing with twin's data
		    const consistency = responses.reduce((acc, r) => {
		      const ratings = Object.values(r.emotionalRatings);
		      const variance = ratings.reduce((v, rating) => v + Math.pow(rating - 5, 2), 0) / ratings.length;
		      return acc + (10 - variance);
		    }, 0) / responses.length;
		    
		    return Math.round(consistency * 10);
		  };
		
		  const renderBodyMap = () => {
		    return (
		      <View className="bg-white/10 rounded-2xl p-6 items-center">
		        <Text className="text-white text-lg mb-4">Where do you feel this emotion?</Text>
		        <Pressable
		          onPress={(e) => handleBodyMapping({
		            x: e.nativeEvent.locationX,
		            y: e.nativeEvent.locationY
		          })}
		          className="w-48 h-80 bg-white/20 rounded-3xl relative"
		        >
		          {/* Simple body outline */}
		          <View className="absolute top-4 left-1/2 -ml-12 w-24 h-24 rounded-full bg-white/10" />
		          <View className="absolute top-28 left-1/2 -ml-16 w-32 h-40 rounded-t-3xl bg-white/10" />
		          <View className="absolute bottom-0 left-1/2 -ml-16 w-32 h-32 bg-white/10" />
		          
		          {currentResponse.somaticLocation && (
		            <View
		              className="absolute w-8 h-8 rounded-full bg-purple-500"
		              style={{
		                left: currentResponse.somaticLocation.x - 16,
		                top: currentResponse.somaticLocation.y - 16
		              }}
		            />
		          )}
		        </Pressable>
		        
		        {currentResponse.somaticLocation && (
		          <Pressable
		            onPress={() => setGamePhase('words')}
		            className="mt-4 bg-purple-500 px-6 py-3 rounded-xl"
		          >
		            <Text className="text-white font-semibold">Next</Text>
		          </Pressable>
		        )}
		      </View>
		    );
		  };
		
		  if (gamePhase === 'intro') {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          {/* Header with back button */}
		          <View className="flex-row items-center justify-between px-6 py-4">
		            <Pressable onPress={() => navigation.goBack()}>
		              <Ionicons name="arrow-back" size={24} color="white" />
		            </Pressable>
		            <Text className="text-white text-lg font-semibold">Games</Text>
		            <View style={{ width: 24 }} />
		          </View>
		          <View className="flex-1 px-6 py-4 justify-center items-center">
		            <Ionicons name="heart-circle" size={80} color="#ec4899" />
		            <Text className="text-white text-3xl font-bold text-center mt-6 mb-4">
		              Emotional Resonance Mapping
		            </Text>
		            <Text className="text-white/70 text-lg text-center mb-8 max-w-sm">
		              We'll show you abstract images. Feel your emotional response, where it lives in your body, and what colors and words arise.
		            </Text>
		            <Pressable
		              onPress={startNewImage}
		              className="bg-pink-500 px-8 py-4 rounded-xl"
		            >
		              <Text className="text-white text-lg font-semibold">Begin Journey</Text>
		            </Pressable>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  if (gamePhase === 'viewing') {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          {/* Header with back button */}
		          <View className="flex-row items-center justify-between px-6 py-4">
		            <Pressable onPress={() => navigation.goBack()}>
		              <Ionicons name="arrow-back" size={24} color="white" />
		            </Pressable>
		            <Text className="text-white text-lg font-semibold">Feeling</Text>
		            <View style={{ width: 24 }} />
		          </View>
		          <View className="flex-1 px-6 py-4 justify-center items-center">
		            <Text className="text-white text-xl mb-4">Breathe and feel...</Text>
		            <Image
		              source={abstractImages[currentImageIndex].source}
		              style={{ width: 300, height: 300 }}
		              className="rounded-2xl"
		            />
		            <Text className="text-white/60 mt-4">
		              {5 - Math.floor((Date.now() - startTime) / 1000)}s
		            </Text>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  if (gamePhase === 'rating') {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          {/* Header with back button */}
		          <View className="flex-row items-center justify-between px-6 py-4">
		            <Pressable onPress={() => navigation.goBack()}>
		              <Ionicons name="arrow-back" size={24} color="white" />
		            </Pressable>
		            <Text className="text-white text-lg font-semibold">Rating</Text>
		            <View style={{ width: 24 }} />
		          </View>
		          <ScrollView className="flex-1 px-6 py-4">
		            <Text className="text-white text-2xl font-bold text-center mb-6">
		              How does this make you feel?
		            </Text>
		            
		            <View className="space-y-4">
		              {Object.entries(currentResponse.emotionalRatings!).map(([emotion, value]) => (
		                <View key={emotion}>
		                  <Text className="text-white text-lg mb-2 capitalize">{emotion}</Text>
		                  <Slider
		                    minimumValue={0}
		                    maximumValue={10}
		                    value={value}
		                    onValueChange={(v) => handleEmotionRating(emotion as any, v)}
		                    minimumTrackTintColor="#8b5cf6"
		                    maximumTrackTintColor="rgba(255,255,255,0.3)"
		                    thumbTintColor="#8b5cf6"
		                  />
		                </View>
		              ))}
		            </View>
		            
		            <Pressable
		              onPress={() => setGamePhase('mapping')}
		              className="bg-purple-500 px-6 py-3 rounded-xl mt-6"
		            >
		              <Text className="text-white font-semibold text-center">Continue</Text>
		            </Pressable>
		          </ScrollView>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  if (gamePhase === 'mapping') {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          {/* Header with back button */}
		          <View className="flex-row items-center justify-between px-6 py-4">
		            <Pressable onPress={() => navigation.goBack()}>
		              <Ionicons name="arrow-back" size={24} color="white" />
		            </Pressable>
		            <Text className="text-white text-lg font-semibold">Body Mapping</Text>
		            <View style={{ width: 24 }} />
		          </View>
		          <View className="flex-1 px-6 py-4 justify-center">
		            {renderBodyMap()}
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  if (gamePhase === 'words') {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          {/* Header with back button */}
		          <View className="flex-row items-center justify-between px-6 py-4">
		            <Pressable onPress={() => navigation.goBack()}>
		              <Ionicons name="arrow-back" size={24} color="white" />
		            </Pressable>
		            <Text className="text-white text-lg font-semibold">Word Selection</Text>
		            <View style={{ width: 24 }} />
		          </View>
		          <View className="flex-1 px-6 py-4">
		            <Text className="text-white text-2xl font-bold text-center mb-6">
		              Choose 3 words that resonate
		            </Text>
		            
		            <View className="flex-row flex-wrap justify-center gap-3 mb-8">
		              {wordOptions.map(word => (
		                <Pressable
		                  key={word}
		                  onPress={() => handleWordSelection(word)}
		                  className={`px-4 py-2 rounded-full ${
		                    selectedWords.includes(word) ? 'bg-purple-500' : 'bg-white/20'
		                  }`}
		                >
		                  <Text className="text-white">{word}</Text>
		                </Pressable>
		              ))}
		            </View>
		            
		            <Text className="text-white text-xl mb-4 text-center">
		              What color feels right?
		            </Text>
		            
		            <View className="flex-row flex-wrap justify-center gap-3">
		              {emotionColors.map(color => (
		                <Pressable
		                  key={color}
		                  onPress={() => handleColorSelection(color)}
		                  className="w-12 h-12 rounded-full"
		                  style={{ backgroundColor: color }}
		                />
		              ))}
		            </View>
		            
		            {selectedWords.length === 3 && currentResponse.colorAssociation && (
		              <Pressable
		                onPress={completeCurrentImage}
		                className="bg-purple-500 px-6 py-3 rounded-xl mt-8 self-center"
		              >
		                <Text className="text-white font-semibold">
		                  {currentImageIndex < abstractImages.length - 1 ? 'Next Image' : 'Complete'}
		                </Text>
		              </Pressable>
		            )}
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  if (gamePhase === 'result') {
		    const insights = generateEmotionalInsights();
		    
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          <ScrollView className="flex-1 px-6 py-4">
		            <Text className="text-white text-2xl font-bold text-center mb-6">
		              Emotional Resonance Profile
		            </Text>
		            
		            <View className="bg-white/10 rounded-2xl p-6 mb-6">
		              <Text className="text-white text-xl font-semibold mb-4">Your Emotional Patterns</Text>
		              {insights.map((insight, index) => (
		                <View key={index} className="mb-4">
		                  <Text className="text-white/60 text-sm mb-1">
		                    {insight.type.replace(/_/g, ' ').toUpperCase()}
		                  </Text>
		                  <Text className="text-white text-base">
		                    {insight.message}
		                  </Text>
		                </View>
		              ))}
		            </View>
		            
		            <LinearGradient
		              colors={['rgba(236,72,153,0.2)', 'rgba(139,92,246,0.2)']}
		              className="rounded-xl p-4 mb-6"
		            >
		              <Text className="text-white text-center">
		                Your emotional fingerprint is being compared with {twinProfile?.name}'s...
		              </Text>
		            </LinearGradient>
		            
		            <View className="flex-row space-x-4">
		              <Pressable
		                onPress={() => navigation.goBack()}
		                className="flex-1 bg-white/20 py-3 rounded-xl"
		              >
		                <Text className="text-white text-center font-semibold">Back to Games</Text>
		              </Pressable>
		            </View>
		          </ScrollView>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  return null;
		};]]></file>
	<file path='screens/games/IconicDuoMatcher.tsx'><![CDATA[
		import React, { useState } from 'react';
		import { View, Text, Pressable, ScrollView, Image, ImageBackground } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { Ionicons } from '@expo/vector-icons';
		import { LinearGradient } from 'expo-linear-gradient';
		import { useTwinStore } from '../../state/twinStore';
		import * as Haptics from 'expo-haptics';
		
		interface Question {
		  id: string;
		  text: string;
		  type: 'self' | 'twin' | 'relationship';
		  options: {
		    text: string;
		    points: Record<string, number>;
		  }[];
		}
		
		interface DuoProfile {
		  id: string;
		  names: string;
		  category: string;
		  description: string;
		  dynamics: string[];
		  color: string;
		  icon: keyof typeof Ionicons.glyphMap;
		}
		
		const questions: Question[] = [
		  {
		    id: 'q1',
		    text: 'In an argument, who apologizes first?',
		    type: 'relationship',
		    options: [
		      { text: 'Always me', points: { 'leader-follower': 2, 'complementary': 1 } },
		      { text: 'Always them', points: { 'leader-follower': 2, 'complementary': 1 } },
		      { text: 'We both do simultaneously', points: { 'synchronized': 3, 'mirror': 2 } },
		      { text: 'Neither - we just move on', points: { 'chaos': 2, 'independent': 1 } }
		    ]
		  },
		  {
		    id: 'q2',
		    text: "Who's more likely to suggest a spontaneous road trip?",
		    type: 'relationship',
		    options: [
		      { text: 'Definitely me', points: { 'leader-follower': 2, 'adventure': 2 } },
		      { text: 'Definitely them', points: { 'leader-follower': 2, 'adventure': 2 } },
		      { text: 'We both would at the same time', points: { 'synchronized': 3, 'chaos': 2 } },
		      { text: 'Neither - we plan everything', points: { 'structured': 3, 'complementary': 1 } }
		    ]
		  },
		  {
		    id: 'q3',
		    text: 'If you robbed a bank together, who would be the mastermind?',
		    type: 'relationship',
		    options: [
		      { text: 'I\'d plan it all', points: { 'leader-follower': 3, 'strategic': 2 } },
		      { text: 'They\'d be the brains', points: { 'leader-follower': 3, 'strategic': 2 } },
		      { text: 'We\'d both plan equally', points: { 'synchronized': 3, 'partner': 2 } },
		      { text: 'We\'d wing it together', points: { 'chaos': 3, 'spontaneous': 2 } }
		    ]
		  },
		  {
		    id: 'q4',
		    text: 'Who cries at commercials?',
		    type: 'self',
		    options: [
		      { text: 'Me, every time', points: { 'emotional': 3, 'empathetic': 2 } },
		      { text: 'Them, always', points: { 'emotional': 3, 'empathetic': 2 } },
		      { text: 'Both of us together', points: { 'synchronized': 3, 'emotional': 2 } },
		      { text: 'Neither - we\'re stone cold', points: { 'stoic': 3, 'professional': 2 } }
		    ]
		  },
		  {
		    id: 'q5',
		    text: 'Your superpower as a duo would be:',
		    type: 'relationship',
		    options: [
		      { text: 'Reading each other\'s minds', points: { 'synchronized': 3, 'psychic': 3 } },
		      { text: 'Perfect balance of opposites', points: { 'complementary': 3, 'balanced': 2 } },
		      { text: 'Unstoppable chaos energy', points: { 'chaos': 3, 'wild': 2 } },
		      { text: 'Strategic domination', points: { 'strategic': 3, 'professional': 2 } }
		    ]
		  },
		  {
		    id: 'q6',
		    text: 'At a party, you two are:',
		    type: 'relationship',
		    options: [
		      { text: 'The life of the party together', points: { 'synchronized': 2, 'social': 3 } },
		      { text: 'One socializing, one observing', points: { 'complementary': 3, 'balanced': 2 } },
		      { text: 'Starting separate adventures', points: { 'independent': 3, 'chaos': 1 } },
		      { text: 'In a corner having deep talks', points: { 'intellectual': 3, 'deep': 2 } }
		    ]
		  }
		];
		
		const duoProfiles: DuoProfile[] = [
		  {
		    id: 'sherlock-watson',
		    names: 'Sherlock & Watson',
		    category: 'Complementary Intellects',
		    description: 'One brilliant mind, one grounding force. Together, unstoppable.',
		    dynamics: ['leader-follower', 'complementary', 'intellectual', 'strategic'],
		    color: '#4f46e5',
		    icon: 'flask'
		  },
		  {
		    id: 'fred-george',
		    names: 'Fred & George Weasley',
		    category: 'Synchronized Mischief',
		    description: 'Two halves of one chaotic whole. Finishing each other\'s pranks.',
		    dynamics: ['synchronized', 'chaos', 'mirror', 'spontaneous'],
		    color: '#f97316',
		    icon: 'flash'
		  },
		  {
		    id: 'thelma-louise',
		    names: 'Thelma & Louise',
		    category: 'Ride or Die',
		    description: 'Adventure, loyalty, and going down together if needed.',
		    dynamics: ['adventure', 'synchronized', 'emotional', 'wild'],
		    color: '#ef4444',
		    icon: 'car-sport'
		  },
		  {
		    id: 'batman-robin',
		    names: 'Batman & Robin',
		    category: 'Mentor & Protégé',
		    description: 'Teacher and student, protector and protected, dark and light.',
		    dynamics: ['leader-follower', 'complementary', 'strategic', 'professional'],
		    color: '#1f2937',
		    icon: 'shield'
		  },
		  {
		    id: 'spongebob-patrick',
		    names: 'SpongeBob & Patrick',
		    category: 'Chaotic Good Energy',
		    description: 'Pure hearts, empty heads, infinite fun.',
		    dynamics: ['chaos', 'emotional', 'spontaneous', 'social'],
		    color: '#fbbf24',
		    icon: 'star'
		  },
		  {
		    id: 'venus-serena',
		    names: 'Venus & Serena Williams',
		    category: 'Competitive Support',
		    description: 'Rivals on court, sisters off. Push each other to greatness.',
		    dynamics: ['synchronized', 'professional', 'strategic', 'balanced'],
		    color: '#10b981',
		    icon: 'trophy'
		  }
		];
		
		export const IconicDuoMatcher = ({ navigation }: any) => {
		  const { themeColor, twinProfile, addGameResult } = useTwinStore();
		  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
		  const [answers, setAnswers] = useState<Record<string, any>>({});
		  const [twinPredictions, setTwinPredictions] = useState<Record<string, any>>({});
		  const [gamePhase, setGamePhase] = useState<'intro' | 'questions' | 'predictions' | 'calculating' | 'result'>('intro');
		  const [matchedDuo, setMatchedDuo] = useState<DuoProfile | null>(null);
		
		  const handleAnswer = (questionId: string, option: any) => {
		    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		    
		    if (gamePhase === 'questions') {
		      setAnswers(prev => ({ ...prev, [questionId]: option }));
		    } else {
		      setTwinPredictions(prev => ({ ...prev, [questionId]: option }));
		    }
		    
		    // Move to next question
		    if (currentQuestionIndex < questions.length - 1) {
		      setCurrentQuestionIndex(prev => prev + 1);
		    } else {
		      if (gamePhase === 'questions') {
		        // Move to prediction phase
		        setGamePhase('predictions');
		        setCurrentQuestionIndex(0);
		      } else {
		        // Calculate results
		        calculateDuoMatch();
		      }
		    }
		  };
		
		  const calculateDuoMatch = () => {
		    setGamePhase('calculating');
		    
		    // Aggregate points
		    const points: Record<string, number> = {};
		    
		    // Add points from answers
		    Object.values(answers).forEach((answer: any) => {
		      Object.entries(answer.points).forEach(([trait, score]) => {
		        points[trait] = (points[trait] || 0) + (score as number);
		      });
		    });
		    
		    // Add points from predictions (if they match)
		    Object.entries(twinPredictions).forEach(([questionId, prediction]: [string, any]) => {
		      if (answers[questionId]?.text === prediction.text) {
		        Object.entries(prediction.points).forEach(([trait, score]) => {
		          points[trait] = (points[trait] || 0) + (score as number) * 0.5;
		        });
		      }
		    });
		    
		    // Find best matching duo
		    let bestMatch = duoProfiles[0];
		    let bestScore = 0;
		    
		    duoProfiles.forEach(duo => {
		      const score = duo.dynamics.reduce((acc, trait) => {
		        return acc + (points[trait] || 0);
		      }, 0);
		      
		      if (score > bestScore) {
		        bestScore = score;
		        bestMatch = duo;
		      }
		    });
		    
		    setMatchedDuo(bestMatch);
		    
		    setTimeout(() => {
		      setGamePhase('result');
		      saveResults(bestMatch);
		    }, 2000);
		  };
		
		  const saveResults = (duo: DuoProfile) => {
		    const perceptionGap = calculatePerceptionGap();
		    
		    addGameResult({
		      gameType: 'iconic_duo',
		      score: 100 - perceptionGap, // Higher score for better perception alignment
		      twinScore: 0,
		      insights: [
		        {
		          type: 'duo_match',
		          message: `You're most like ${duo.names}: ${duo.description}`,
		          data: { duoId: duo.id, category: duo.category }
		        },
		        {
		          type: 'perception_gap',
		          message: `Your perception alignment with ${twinProfile?.name} is ${100 - perceptionGap}%`,
		          data: { gap: perceptionGap }
		        }
		      ],
		      duoData: {
		        matchedDuo: duo.id,
		        answers,
		        predictions: twinPredictions,
		        perceptionGap
		      }
		    });
		  };
		
		  const calculatePerceptionGap = () => {
		    let mismatches = 0;
		    Object.keys(answers).forEach(questionId => {
		      if (answers[questionId]?.text !== twinPredictions[questionId]?.text) {
		        mismatches++;
		      }
		    });
		    return Math.round((mismatches / questions.length) * 100);
		  };
		
		  const currentQuestion = questions[currentQuestionIndex];
		
		  if (gamePhase === 'intro') {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          {/* Header with back button */}
		          <View className="flex-row items-center justify-between px-6 py-4">
		            <Pressable onPress={() => navigation.goBack()}>
		              <Ionicons name="arrow-back" size={24} color="white" />
		            </Pressable>
		            <Text className="text-white text-lg font-semibold">Games</Text>
		            <View style={{ width: 24 }} />
		          </View>
		          <View className="flex-1 px-6 py-4 justify-center items-center">
		            <Ionicons name="people" size={80} color="#8b5cf6" />
		            <Text className="text-white text-3xl font-bold text-center mt-6 mb-4">
		              Which Iconic Duo Are You?
		            </Text>
		            <Text className="text-white/70 text-lg text-center mb-8 max-w-sm">
		              Answer questions about your relationship, then predict what {twinProfile?.name} would say. 
		              Discover which famous duo represents your twin dynamic!
		            </Text>
		            <Pressable
		              onPress={() => setGamePhase('questions')}
		              className="bg-purple-500 px-8 py-4 rounded-xl"
		            >
		              <Text className="text-white text-lg font-semibold">Start Quiz</Text>
		            </Pressable>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  if (gamePhase === 'questions' || gamePhase === 'predictions') {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          {/* Header with back button */}
		          <View className="flex-row items-center justify-between px-6 py-4">
		            <Pressable onPress={() => navigation.goBack()}>
		              <Ionicons name="arrow-back" size={24} color="white" />
		            </Pressable>
		            <Text className="text-white text-lg font-semibold">Quiz</Text>
		            <View style={{ width: 24 }} />
		          </View>
		          <View className="flex-1 px-6 py-4">
		            {/* Progress bar */}
		            <View className="mb-6">
		              <Text className="text-white text-center mb-2">
		                {gamePhase === 'questions' ? 'Your Answers' : `Predict ${twinProfile?.name}'s Answers`}
		              </Text>
		              <View className="bg-white/10 h-2 rounded-full overflow-hidden">
		                <View 
		                  className="bg-purple-500 h-full rounded-full"
		                  style={{ width: `${((currentQuestionIndex + 1) / questions.length) * 100}%` }}
		                />
		              </View>
		              <Text className="text-white/60 text-center mt-2 text-sm">
		                Question {currentQuestionIndex + 1} of {questions.length}
		              </Text>
		            </View>
		            
		            {/* Question */}
		            <View className="flex-1 justify-center">
		              <Text className="text-white text-2xl font-bold text-center mb-8">
		                {currentQuestion.text}
		              </Text>
		              
		              {/* Options */}
		              <View className="space-y-3">
		                {currentQuestion.options.map((option, index) => (
		                  <Pressable
		                    key={index}
		                    onPress={() => handleAnswer(currentQuestion.id, option)}
		                    className="bg-white/10 p-5 rounded-xl"
		                  >
		                    <Text className="text-white text-lg text-center">
		                      {option.text}
		                    </Text>
		                  </Pressable>
		                ))}
		              </View>
		            </View>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  if (gamePhase === 'calculating') {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          <View className="flex-1 justify-center items-center px-6">
		            <View className="w-32 h-32 border-4 border-purple-500 rounded-full animate-spin" />
		            <Text className="text-white text-xl mt-6">Analyzing your twin dynamic...</Text>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  if (gamePhase === 'result' && matchedDuo) {
		    const perceptionGap = calculatePerceptionGap();
		    
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          <ScrollView className="flex-1 px-6 py-4">
		            <Text className="text-white text-2xl font-bold text-center mb-6">
		              Your Iconic Duo Match
		            </Text>
		            
		            {/* Duo Result */}
		            <LinearGradient
		              colors={[`${matchedDuo.color}40`, `${matchedDuo.color}20`]}
		              className="rounded-2xl p-6 mb-6 items-center"
		            >
		              <Ionicons name={matchedDuo.icon} size={60} color={matchedDuo.color} />
		              <Text className="text-white text-3xl font-bold mt-4">
		                {matchedDuo.names}
		              </Text>
		              <Text className="text-white/80 text-lg mt-2 mb-4">
		                {matchedDuo.category}
		              </Text>
		              <Text className="text-white/70 text-center">
		                {matchedDuo.description}
		              </Text>
		            </LinearGradient>
		            
		            {/* Perception Analysis */}
		            <View className="bg-white/10 rounded-xl p-6 mb-6">
		              <Text className="text-white text-xl font-semibold mb-4">
		                Perception Alignment
		              </Text>
		              <Text className="text-white/80 mb-4">
		                You and {twinProfile?.name} see your relationship with {100 - perceptionGap}% alignment
		              </Text>
		              
		              {/* Show mismatches */}
		              {perceptionGap > 0 && (
		                <View className="space-y-2">
		                  <Text className="text-white/60 text-sm mb-2">Areas of Different Perspectives:</Text>
		                  {Object.keys(answers).map(questionId => {
		                    if (answers[questionId]?.text !== twinPredictions[questionId]?.text) {
		                      const question = questions.find(q => q.id === questionId)!;
		                      return (
		                        <View key={questionId} className="bg-white/10 rounded p-3">
		                          <Text className="text-white/80 text-sm mb-1">{question.text}</Text>
		                          <Text className="text-white/60 text-xs">
		                            You: {answers[questionId]?.text} | 
		                            Predicted: {twinPredictions[questionId]?.text}
		                          </Text>
		                        </View>
		                      );
		                    }
		                    return null;
		                  })}
		                </View>
		              )}
		            </View>
		            
		            {/* Social Sharing */}
		            <View className="bg-purple-500/20 rounded-xl p-4 mb-6">
		              <Text className="text-white text-center">
		                Share your duo match with friends! 
		                Screenshot this result and tag your twin.
		              </Text>
		            </View>
		            
		            <Pressable
		              onPress={() => navigation.goBack()}
		              className="bg-white/20 py-3 rounded-xl"
		            >
		              <Text className="text-white text-center font-semibold">Back to Games</Text>
		            </Pressable>
		          </ScrollView>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  return null;
		};]]></file>
	<file path='screens/games/TemporalDecisionSync.tsx'><![CDATA[
		import React, { useState, useEffect } from 'react';
		import { View, Text, Pressable, ScrollView, ImageBackground } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { Ionicons } from '@expo/vector-icons';
		import { useTwinStore } from '../../state/twinStore';
		import * as Haptics from 'expo-haptics';
		
		interface Scenario {
		  id: string;
		  title: string;
		  prompt: string;
		  options: string[];
		  timeLimit: number;
		  category: 'crisis' | 'resource' | 'social' | 'ethical';
		}
		
		interface Decision {
		  scenarioId: string;
		  choices: string[];
		  timeToDecide: number;
		  timestamp: number;
		  stressLevel: 'low' | 'medium' | 'high';
		}
		
		interface DecisionInsight {
		  type: string;
		  message: string;
		  data: any;
		}
		
		const scenarios: Scenario[] = [
		  {
		    id: 'fire_rescue',
		    title: 'Emergency Evacuation',
		    prompt: 'Your house is on fire! You can save 3 items:',
		    options: ['Photo albums', 'Laptop/work', 'Pet supplies', 'Important documents', 'Jewelry/valuables', 'Artwork', 'Cash/cards', 'Family heirlooms', 'Electronics', 'Clothing'],
		    timeLimit: 60,
		    category: 'crisis'
		  },
		  {
		    id: 'sudden_wealth',
		    title: 'Instant Fortune',
		    prompt: 'You have $1000 and 60 seconds to spend it:',
		    options: ['Travel/experiences', 'Technology', 'Charity', 'Investments', 'Education/courses', 'Gifts for others', 'Home improvement', 'Health/wellness', 'Entertainment', 'Save it'],
		    timeLimit: 60,
		    category: 'resource'
		  },
		  {
		    id: 'zombie_team',
		    title: 'Survival Squad',
		    prompt: 'Pick 5 people for your zombie apocalypse team:',
		    options: ['Doctor/medic', 'Military/security', 'Engineer', 'Farmer', 'Teacher', 'Chef', 'Mechanic', 'Leader/politician', 'Athlete', 'Scientist', 'Artist', 'Comedian', 'Survivalist', 'Psychologist', 'Child'],
		    timeLimit: 30,
		    category: 'social'
		  },
		  {
		    id: 'time_machine',
		    title: 'Timeline Intervention',
		    prompt: 'You can prevent 3 historical events. Choose:',
		    options: ['Major wars', 'Pandemics', 'Natural disasters', 'Assassinations', 'Economic crashes', 'Environmental disasters', 'Genocides', 'Technological accidents', 'Cultural losses', 'Nothing - preserve timeline'],
		    timeLimit: 45,
		    category: 'ethical'
		  },
		  {
		    id: 'desert_island',
		    title: 'Island Essentials',
		    prompt: 'Stranded on an island. Pick 5 items:',
		    options: ['Knife', 'Lighter/matches', 'First aid kit', 'Water purifier', 'Fishing gear', 'Shelter materials', 'Solar charger', 'Radio', 'Rope', 'Mirror', 'Compass', 'Books', 'Seeds', 'Tools', 'Companion'],
		    timeLimit: 40,
		    category: 'crisis'
		  }
		];
		
		export const TemporalDecisionSync = ({ navigation }: any) => {
		  const { themeColor, twinProfile, addGameResult } = useTwinStore();
		  const [gamePhase, setGamePhase] = useState<'intro' | 'scenario' | 'deciding' | 'timeout' | 'result'>('intro');
		  const [currentScenarioIndex, setCurrentScenarioIndex] = useState(0);
		  const [selectedOptions, setSelectedOptions] = useState<string[]>([]);
		  const [decisions, setDecisions] = useState<Decision[]>([]);
		  const [timeRemaining, setTimeRemaining] = useState(0);
		  const [scenarioStartTime, setScenarioStartTime] = useState(0);
		  const [stressIndicator, setStressIndicator] = useState(0);
		
		  useEffect(() => {
		    let timer: NodeJS.Timeout;
		    
		    if (gamePhase === 'deciding' && timeRemaining > 0) {
		      timer = setInterval(() => {
		        setTimeRemaining(prev => {
		          if (prev <= 1) {
		            handleTimeout();
		            return 0;
		          }
		          
		          // Increase stress as time runs out
		          if (prev <= 10) {
		            setStressIndicator(3);
		            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Heavy);
		          } else if (prev <= 20) {
		            setStressIndicator(2);
		          } else {
		            setStressIndicator(1);
		          }
		          
		          return prev - 1;
		        });
		      }, 1000);
		    }
		    
		    return () => clearInterval(timer);
		  }, [gamePhase, timeRemaining]);
		
		  const startScenario = () => {
		    const scenario = scenarios[currentScenarioIndex];
		    setGamePhase('scenario');
		    
		    // Show scenario for 5 seconds
		    setTimeout(() => {
		      setGamePhase('deciding');
		      setTimeRemaining(scenario.timeLimit);
		      setScenarioStartTime(Date.now());
		    }, 5000);
		  };
		
		  const handleOptionToggle = (option: string) => {
		    const scenario = scenarios[currentScenarioIndex];
		    const maxSelections = scenario.id === 'zombie_team' || scenario.id === 'desert_island' ? 5 : 3;
		    
		    if (selectedOptions.includes(option)) {
		      setSelectedOptions(prev => prev.filter(o => o !== option));
		      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		    } else if (selectedOptions.length < maxSelections) {
		      setSelectedOptions(prev => [...prev, option]);
		      Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
		    }
		  };
		
		  const handleConfirmDecision = () => {
		    const timeToDecide = (Date.now() - scenarioStartTime) / 1000;
		    const scenario = scenarios[currentScenarioIndex];
		    
		    const decision: Decision = {
		      scenarioId: scenario.id,
		      choices: selectedOptions,
		      timeToDecide,
		      timestamp: Date.now(),
		      stressLevel: stressIndicator === 3 ? 'high' : stressIndicator === 2 ? 'medium' : 'low'
		    };
		    
		    setDecisions(prev => [...prev, decision]);
		    
		    // Move to next scenario or finish
		    if (currentScenarioIndex < scenarios.length - 1) {
		      setCurrentScenarioIndex(prev => prev + 1);
		      setSelectedOptions([]);
		      setStressIndicator(0);
		      setTimeout(startScenario, 1500);
		    } else {
		      analyzeDecisions();
		    }
		  };
		
		  const handleTimeout = () => {
		    setGamePhase('timeout');
		    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Warning);
		    
		    // Auto-select if not enough choices
		    const scenario = scenarios[currentScenarioIndex];
		    const minRequired = scenario.id === 'zombie_team' || scenario.id === 'desert_island' ? 5 : 3;
		    
		    if (selectedOptions.length < minRequired) {
		      const remaining = scenario.options
		        .filter(o => !selectedOptions.includes(o))
		        .slice(0, minRequired - selectedOptions.length);
		      setSelectedOptions(prev => [...prev, ...remaining]);
		    }
		    
		    setTimeout(handleConfirmDecision, 1000);
		  };
		
		  const analyzeDecisions = () => {
		    setGamePhase('result');
		    const insights = generateDecisionInsights();
		    saveResults(insights);
		  };
		
		  const generateDecisionInsights = (): DecisionInsight[] => {
		    const insights: DecisionInsight[] = [];
		    
		    // Analyze value priorities
		    const valueCounts: Record<string, number> = {
		      practical: 0,
		      emotional: 0,
		      social: 0,
		      survival: 0,
		      ethical: 0
		    };
		    
		    decisions.forEach(d => {
		      d.choices.forEach(choice => {
		        if (['Laptop/work', 'Important documents', 'Investments', 'Water purifier'].includes(choice)) {
		          valueCounts.practical++;
		        } else if (['Photo albums', 'Family heirlooms', 'Artwork', 'Companion'].includes(choice)) {
		          valueCounts.emotional++;
		        } else if (['Gifts for others', 'Charity', 'Teacher', 'Psychologist'].includes(choice)) {
		          valueCounts.social++;
		        } else if (['Knife', 'First aid kit', 'Doctor/medic', 'Military/security'].includes(choice)) {
		          valueCounts.survival++;
		        }
		      });
		    });
		    
		    const dominantValue = Object.entries(valueCounts)
		      .sort(([,a], [,b]) => b - a)[0][0];
		    
		    insights.push({
		      type: 'value_system',
		      message: `Your decisions reveal a ${dominantValue} value system under pressure`,
		      data: { valueCounts, dominant: dominantValue }
		    });
		    
		    // Analyze decision speed
		    const avgDecisionTime = decisions.reduce((acc, d) => acc + d.timeToDecide, 0) / decisions.length;
		    const speedCategory = avgDecisionTime < 20 ? 'rapid' : avgDecisionTime < 40 ? 'moderate' : 'deliberate';
		    
		    insights.push({
		      type: 'decision_speed',
		      message: `You make ${speedCategory} decisions (avg ${avgDecisionTime.toFixed(1)}s)`,
		      data: { avgTime: avgDecisionTime, category: speedCategory }
		    });
		    
		    // Analyze stress impact
		    const highStressDecisions = decisions.filter(d => d.stressLevel === 'high');
		    const stressImpact = highStressDecisions.length / decisions.length;
		    
		    insights.push({
		      type: 'stress_response',
		      message: `${Math.round(stressImpact * 100)}% of your decisions were made under high stress`,
		      data: { stressImpact, highStressCount: highStressDecisions.length }
		    });
		    
		    // Analyze risk tolerance
		    const riskChoices = decisions.flatMap(d => d.choices)
		      .filter(c => ['Nothing - preserve timeline', 'Save it', 'Investments'].includes(c));
		    const riskScore = riskChoices.length > 2 ? 'conservative' : 'moderate';
		    
		    insights.push({
		      type: 'risk_profile',
		      message: `Your risk tolerance appears to be ${riskScore}`,
		      data: { riskChoices, profile: riskScore }
		    });
		    
		    return insights;
		  };
		
		  const saveResults = (insights: DecisionInsight[]) => {
		    const score = calculateDecisionScore();
		    
		    addGameResult({
		      gameType: 'temporal_decision',
		      score,
		      twinScore: 0,
		      insights,
		      decisionData: {
		        decisions,
		        dominantValue: insights[0].data.dominant,
		        avgDecisionTime: insights[1].data.avgTime,
		        stressImpact: insights[2].data.stressImpact
		      }
		    });
		  };
		
		  const calculateDecisionScore = () => {
		    // Score based on consistency and decisiveness
		    const decisiveness = decisions.reduce((acc, d) => {
		      const scenario = scenarios.find(s => s.id === d.scenarioId)!;
		      const expectedChoices = scenario.id === 'zombie_team' || scenario.id === 'desert_island' ? 5 : 3;
		      return acc + (d.choices.length === expectedChoices ? 20 : 10);
		    }, 0) / decisions.length;
		    
		    const speedScore = decisions.reduce((acc, d) => {
		      return acc + Math.max(0, 20 - d.timeToDecide / 3);
		    }, 0) / decisions.length;
		    
		    return Math.round(decisiveness + speedScore);
		  };
		
		  const getStressColor = () => {
		    switch (stressIndicator) {
		      case 3: return '#ef4444';
		      case 2: return '#f59e0b';
		      case 1: return '#10b981';
		      default: return '#6b7280';
		    }
		  };
		
		  if (gamePhase === 'intro') {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          {/* Header with back button */}
		          <View className="flex-row items-center justify-between px-6 py-4">
		            <Pressable onPress={() => navigation.navigate('Twingames')}>
		              <Ionicons name="arrow-back" size={24} color="white" />
		            </Pressable>
		            <Text className="text-white text-lg font-semibold">Games</Text>
		            <View style={{ width: 24 }} />
		          </View>
		          <View className="flex-1 px-6 py-4 justify-center items-center">
		            <Ionicons name="timer" size={80} color="#f59e0b" />
		            <Text className="text-white text-3xl font-bold text-center mt-6 mb-4">
		              Temporal Decision Synchrony
		            </Text>
		            <Text className="text-white/70 text-lg text-center mb-8 max-w-sm">
		              Make rapid-fire decisions in high-pressure scenarios. We'll analyze how your values and instincts align with {twinProfile?.name}.
		            </Text>
		            <Pressable
		              onPress={startScenario}
		              className="bg-yellow-500 px-8 py-4 rounded-xl"
		            >
		              <Text className="text-white text-lg font-semibold">Start Challenge</Text>
		            </Pressable>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  if (gamePhase === 'scenario') {
		    const scenario = scenarios[currentScenarioIndex];
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          {/* Header with back button */}
		          <View className="flex-row items-center justify-between px-6 py-4">
		            <Pressable onPress={() => navigation.navigate('Twingames')}>
		              <Ionicons name="arrow-back" size={24} color="white" />
		            </Pressable>
		            <Text className="text-white text-lg font-semibold">Challenge</Text>
		            <View style={{ width: 24 }} />
		          </View>
		          <View className="flex-1 px-6 py-4 justify-center items-center">
		            <View className="bg-black/20 rounded-2xl p-6 mb-8">
		              <Text className="text-white text-2xl font-bold text-center mb-4">
		                {scenario.title}
		              </Text>
		              <Text className="text-white/90 text-lg text-center">
		                {scenario.prompt}
		              </Text>
		            </View>
		            <Text className="text-white/60 text-lg">
		              Get ready... Decision time starts in 5 seconds
		            </Text>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  if (gamePhase === 'deciding') {
		    const scenario = scenarios[currentScenarioIndex];
		    const maxSelections = scenario.id === 'zombie_team' || scenario.id === 'desert_island' ? 5 : 3;
		    
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          {/* Timer and stress indicator */}
		          <View className="flex-row justify-between items-center p-4 bg-black/20">
		            <Pressable onPress={() => navigation.navigate('Twingames')}>
		              <Ionicons name="arrow-back" size={24} color="white" />
		            </Pressable>
		            <View className="flex-row items-center">
		              <View 
		                className="w-4 h-4 rounded-full mr-2"
		                style={{ backgroundColor: getStressColor() }}
		              />
		              <Text className="text-white text-lg">
		                Stress Level
		              </Text>
		            </View>
		            <Text className="text-white text-2xl font-bold">
		              {timeRemaining}s
		            </Text>
		          </View>
		
		          {/* Scenario prompt */}
		          <View className="px-6 py-4">
		            <Text className="text-white text-xl font-bold mb-2">
		              {scenario.title}
		            </Text>
		            <Text className="text-white/90 text-lg mb-4">
		              {scenario.prompt}
		            </Text>
		            <Text className="text-white/60 text-sm">
		              Select {maxSelections} options ({selectedOptions.length}/{maxSelections})
		            </Text>
		          </View>
		
		          {/* Options */}
		          <ScrollView className="flex-1 px-6">
		            <View className="flex-row flex-wrap justify-between">
		              {scenario.options.map((option, index) => {
		                const isSelected = selectedOptions.includes(option);
		                return (
		                  <Pressable
		                    key={index}
		                    onPress={() => handleOptionToggle(option)}
		                    className={`w-[48%] mb-3 p-4 rounded-xl border-2 ${
		                      isSelected 
		                        ? 'bg-yellow-500/20 border-yellow-500' 
		                        : 'bg-white/10 border-white/30'
		                    }`}
		                  >
		                    <Text className={`text-center font-medium ${
		                      isSelected ? 'text-yellow-400' : 'text-white'
		                    }`}>
		                      {option}
		                    </Text>
		                  </Pressable>
		                );
		              })}
		            </View>
		          </ScrollView>
		
		          {/* Confirm button */}
		          {selectedOptions.length === maxSelections && (
		            <View className="p-6">
		              <Pressable
		                onPress={handleConfirmDecision}
		                className="bg-green-500 py-4 rounded-xl"
		              >
		                <Text className="text-white text-lg font-semibold text-center">
		                  Confirm Decisions
		                </Text>
		              </Pressable>
		            </View>
		          )}
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  if (gamePhase === 'timeout') {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          <View className="flex-1 justify-center items-center px-6">
		            <Ionicons name="time" size={80} color="#ef4444" />
		            <Text className="text-white text-2xl font-bold text-center mt-4 mb-2">
		              Time's Up!
		            </Text>
		            <Text className="text-white/70 text-lg text-center">
		              Auto-selecting remaining choices...
		            </Text>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  if (gamePhase === 'result') {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          <ScrollView className="flex-1 px-6 py-4">
		            <Text className="text-white text-3xl font-bold text-center mb-6">
		              Decision Analysis
		            </Text>
		            
		            {/* Generate insights display */}
		            <View className="space-y-4">
		              {generateDecisionInsights().map((insight, index) => (
		                <View key={index} className="bg-white/10 rounded-xl p-4">
		                  <Text className="text-white text-lg font-semibold mb-2">
		                    {insight.type.replace('_', ' ').toUpperCase()}
		                  </Text>
		                  <Text className="text-white/80 text-base">
		                    {insight.message}
		                  </Text>
		                </View>
		              ))}
		            </View>
		
		            <View className="mt-8 space-y-4">
		              <Pressable
		                onPress={() => navigation.navigate('Twingames')}
		                className="bg-blue-500 py-4 rounded-xl"
		              >
		                <Text className="text-white text-lg font-semibold text-center">
		                  Return to Games
		                </Text>
		              </Pressable>
		            </View>
		          </ScrollView>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  // Default return (should never reach here)
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <View className="flex-1 justify-center items-center">
		          <Text className="text-white text-xl">Loading...</Text>
		        </View>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/HomeScreen.tsx'><![CDATA[
		import React from "react";
		import { View, Text, Pressable, ScrollView, ImageBackground } from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { useTwinStore } from "../state/twinStore";
		import { Ionicons } from "@expo/vector-icons";
		import { useNavigation } from "@react-navigation/native";
		
		export const HomeScreen = () => {
		  const { themeColor, userProfile, twinProfile, twintuitionAlerts } = useTwinStore();
		  const navigation = useNavigation<any>();
		  
		  const unreadAlerts = twintuitionAlerts.filter(alert => !alert.isRead).length;
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <ScrollView className="flex-1 px-6">
		          {/* Header */}
		          <View className="pt-4 pb-8">
		            <Text className="text-white text-3xl font-bold text-center">
		              Twinship
		            </Text>
		            <Text className="text-white/70 text-center mt-2">
		              Twinfinity...and beyond!
		            </Text>
		          </View>
		
		          {/* Twin Connection Status */}
		          <View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 mb-6">
		            <View className="flex-row items-center justify-between mb-4">
		              <Text className="text-white text-xl font-semibold">Twin Connection</Text>
		              <Pressable onPress={() => navigation.navigate("Twinvitation")} className="bg-white/20 rounded-full px-3 py-1">
		                <Text className="text-white">Pair</Text>
		              </Pressable>
		            </View>
		            
		            <View className="flex-row items-center space-x-4">
		              <View className="bg-white/20 rounded-full w-16 h-16 items-center justify-center">
		                <Text className="text-white text-xl font-bold">
		                  {userProfile?.name?.charAt(0) || "U"}
		                </Text>
		              </View>
		              
		              <View className="flex-1 items-center">
		                <Ionicons name="heart" size={24} color="white" />
		                <Text className="text-white/70 text-xs mt-1">Connected</Text>
		              </View>
		              
		              <View className="bg-white/20 rounded-full w-16 h-16 items-center justify-center">
		                <Text className="text-white text-xl font-bold">
		                  {twinProfile?.name?.charAt(0) || "T"}
		                </Text>
		              </View>
		            </View>
		            
		            <Text className="text-white/70 text-center mt-4">
		              {userProfile?.name} & {twinProfile?.name}
		            </Text>
		          </View>
		
		          {/* Quick Actions */}
		          <View className="space-y-4">
		            <Pressable onPress={() => navigation.navigate("TwinTalk")} className="bg-white/10 rounded-xl p-4 flex-row items-center">
		              <View className="bg-blue-500/30 rounded-full p-3 mr-4">
		                <Ionicons name="chatbubbles" size={24} color="white" />
		              </View>
		              <View className="flex-1">
		                <Text className="text-white text-lg font-semibold">Private Chat</Text>
		                <Text className="text-white/70 text-sm">Connect instantly with your twin</Text>
		              </View>
		              <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		            </Pressable>
		
		            <Pressable onPress={() => navigation.navigate("Twintuition")} className="bg-white/10 rounded-xl p-4 flex-row items-center">
		              <View className="bg-purple-500/30 rounded-full p-3 mr-4">
		                <Ionicons name="flash" size={24} color="white" />
		              </View>
		              <View className="flex-1">
		                <Text className="text-white text-lg font-semibold">Twintuition Alerts</Text>
		                <Text className="text-white/70 text-sm">
		                  {unreadAlerts > 0 ? `${unreadAlerts} new alerts` : "No new alerts"}
		                </Text>
		              </View>
		              {unreadAlerts > 0 && (
		                <View className="bg-red-500 rounded-full w-6 h-6 items-center justify-center mr-2">
		                  <Text className="text-white text-xs font-bold">{unreadAlerts}</Text>
		                </View>
		              )}
		              <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		            </Pressable>
		
		            <Pressable onPress={() => navigation.navigate("AssessmentIntro")} className="bg-white/10 rounded-xl p-4 flex-row items-center relative overflow-hidden">
		              {/* Premium Badge */}
		              <View className="absolute top-2 right-2 bg-yellow-500 rounded-full px-2 py-1 border border-yellow-400">
		                <Text className="text-black text-xs font-bold">PREMIUM</Text>
		              </View>
		              <View className="bg-pink-500/30 rounded-full p-3 mr-4">
		                <Ionicons name="analytics" size={24} color="white" />
		              </View>
		              <View className="flex-1">
		                <Text className="text-white text-lg font-semibold">Personality Assessment</Text>
		                <Text className="text-white/70 text-sm">Deep insights into your twin personality dynamics</Text>
		              </View>
		              <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		            </Pressable>
		
		            <Pressable onPress={() => navigation.navigate("Twingames")} className="bg-white/10 rounded-xl p-4 flex-row items-center">
		              <View className="bg-green-500/30 rounded-full p-3 mr-4">
		                <Ionicons name="game-controller" size={24} color="white" />
		              </View>
		              <View className="flex-1">
		                <Text className="text-white text-lg font-semibold">Psychic Games</Text>
		                <Text className="text-white/70 text-sm">Test your twin synchronicity</Text>
		              </View>
		              <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		            </Pressable>
		
		             <Pressable onPress={() => navigation.navigate("Stories")} className="bg-white/10 rounded-xl p-4 flex-row items-center">
		              <View className="bg-orange-500/30 rounded-full p-3 mr-4">
		                <Ionicons name="book" size={24} color="white" />
		              </View>
		              <View className="flex-1">
		                <Text className="text-white text-lg font-semibold">Twin Stories</Text>
		                <Text className="text-white/70 text-sm">Share your journey together</Text>
		              </View>
		              <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		            </Pressable>
		
		            <Pressable onPress={() => navigation.navigate("Twinquiry")} className="bg-white/10 rounded-xl p-4 flex-row items-center">
		              <View className="bg-cyan-500/30 rounded-full p-3 mr-4">
		                <Ionicons name="flask" size={24} color="white" />
		              </View>
		              <View className="flex-1">
		                <Text className="text-white text-lg font-semibold">Research Studies</Text>
		                <Text className="text-white/70 text-sm">Contribute to twin science</Text>
		              </View>
		              <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		            </Pressable>
		          </View>
		
		          {/* Recent Activity */}
		          <View className="mt-8 mb-6">
		            <Text className="text-white text-xl font-semibold mb-4">Recent Activity</Text>
		            <View className="bg-white/5 backdrop-blur-sm rounded-xl p-6 items-center">
		              <Ionicons name="time-outline" size={48} color="rgba(255,255,255,0.5)" />
		              <Text className="text-white/70 text-center mt-4">
		                No recent activity yet. Start connecting with your twin!
		              </Text>
		            </View>
		          </View>
		        </ScrollView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/InvitationAnalyticsScreen.tsx'><![CDATA[
		import React, { useEffect } from 'react';
		import {
		  View,
		  Text,
		  ScrollView,
		  Pressable,
		  Alert,
		  ImageBackground,
		} from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { useNavigation } from '@react-navigation/native';
		import { Ionicons } from '@expo/vector-icons';
		
		import { useTwinStore } from '../state/twinStore';
		import { useInvitationStore, useInvitationAnalytics } from '../state/invitationStore';
		import { getNeonAccentColor, getNeonAccentColorWithOpacity } from '../utils/neonColors';
		
		export const InvitationAnalyticsScreen: React.FC = () => {
		  const navigation = useNavigation();
		  const { userProfile } = useTwinStore();
		  const { refreshAnalytics, retryFailedInvitation } = useInvitationStore();
		  const analytics = useInvitationAnalytics();
		  
		  const accentColor = userProfile?.accentColor || 'neon-purple';
		  const themeColor = getNeonAccentColor(accentColor);
		  const themeColorWithOpacity = getNeonAccentColorWithOpacity(accentColor, 0.3);
		
		  useEffect(() => {
		    refreshAnalytics();
		  }, [refreshAnalytics]);
		
		  const handleRetryInvitation = async (invitationId: string, method: 'email' | 'sms') => {
		    try {
		      const success = await retryFailedInvitation(invitationId, method);
		      if (success) {
		        Alert.alert('Success', 'Invitation resent successfully!');
		        refreshAnalytics();
		      } else {
		        Alert.alert('Error', 'Failed to resend invitation.');
		      }
		    } catch (error) {
		      Alert.alert('Error', 'Failed to resend invitation.');
		    }
		  };
		
		  const formatDate = (dateString: string) => {
		    return new Date(dateString).toLocaleDateString('en-US', {
		      month: 'short',
		      day: 'numeric',
		      hour: 'numeric',
		      minute: '2-digit',
		    });
		  };
		
		  const getStatusColor = (status: string) => {
		    switch (status) {
		      case 'accepted':
		        return '#10b981'; // green
		      case 'declined':
		        return '#ef4444'; // red
		      case 'expired':
		        return '#6b7280'; // gray
		      case 'sent':
		        return '#3b82f6'; // blue
		      case 'pending':
		        return '#eab308'; // yellow
		      default:
		        return '#6b7280';
		    }
		  };
		
		  const getStatusIcon = (status: string): keyof typeof Ionicons.glyphMap => {
		    switch (status) {
		      case 'accepted':
		        return 'checkmark-circle';
		      case 'declined':
		        return 'close-circle';
		      case 'expired':
		        return 'time';
		      case 'sent':
		        return 'paper-plane';
		      case 'pending':
		        return 'hourglass';
		      default:
		        return 'help-circle';
		    }
		  };
		
		  if (!analytics) {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          <View className="flex-1 justify-center items-center">
		            <Text className="text-white text-lg">Loading analytics...</Text>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        {/* Header */}
		        <View className="flex-row items-center justify-between px-6 py-4">
		          <Pressable
		            onPress={() => navigation.goBack()}
		            className="w-10 h-10 rounded-full bg-white/10 items-center justify-center"
		          >
		            <Ionicons name="arrow-back" size={20} color="white" />
		          </Pressable>
		          
		          <Text className="text-white text-lg font-semibold">
		            Invitation Analytics
		          </Text>
		          
		          <Pressable
		            onPress={refreshAnalytics}
		            className="w-10 h-10 rounded-full bg-white/10 items-center justify-center"
		          >
		            <Ionicons name="refresh" size={20} color="white" />
		          </Pressable>
		        </View>
		
		        <ScrollView className="flex-1 px-6" showsVerticalScrollIndicator={false}>
		          {/* Overview Stats */}
		          <View className="grid grid-cols-2 gap-4 mb-6">
		            <View className="bg-white/10 rounded-2xl p-4">
		              <Text className="text-white/70 text-sm font-medium">Total Sent</Text>
		              <Text className="text-white text-2xl font-bold mt-1">
		                {analytics.totalSent}
		              </Text>
		            </View>
		            
		            <View className="bg-white/10 rounded-2xl p-4">
		              <Text className="text-white/70 text-sm font-medium">Accepted</Text>
		              <Text className="text-green-400 text-2xl font-bold mt-1">
		                {analytics.totalAccepted}
		              </Text>
		            </View>
		            
		            <View className="bg-white/10 rounded-2xl p-4">
		              <Text className="text-white/70 text-sm font-medium">Success Rate</Text>
		              <Text 
		                className="text-2xl font-bold mt-1"
		                style={{ color: themeColor }}
		              >
		                {analytics.acceptanceRate.toFixed(1)}%
		              </Text>
		            </View>
		            
		            <View className="bg-white/10 rounded-2xl p-4">
		              <Text className="text-white/70 text-sm font-medium">Declined</Text>
		              <Text className="text-red-400 text-2xl font-bold mt-1">
		                {analytics.totalDeclined}
		              </Text>
		            </View>
		          </View>
		
		          {/* Average Response Time */}
		          {analytics.averageResponseTime > 0 && (
		            <View className="bg-white/10 rounded-2xl p-4 mb-6">
		              <Text className="text-white/70 text-sm font-medium mb-2">
		                Average Response Time
		              </Text>
		              <Text className="text-white text-lg font-semibold">
		                {Math.round(analytics.averageResponseTime / (1000 * 60 * 60))} hours
		              </Text>
		            </View>
		          )}
		
		          {/* Recent Invitations */}
		          <View className="bg-white/10 rounded-2xl p-4 mb-6">
		            <Text className="text-white text-lg font-semibold mb-4">
		              Recent Invitations
		            </Text>
		            
		            {analytics.recentInvitations.length === 0 ? (
		              <View className="py-8 items-center">
		                <Ionicons name="mail-outline" size={48} color="rgba(255, 255, 255, 0.3)" />
		                <Text className="text-white/50 text-center mt-4">
		                  No recent invitations
		                </Text>
		              </View>
		            ) : (
		              <View className="space-y-3">
		                {analytics.recentInvitations.map((invitation, index) => (
		                  <View 
		                    key={invitation.id} 
		                    className="bg-white/5 rounded-xl p-4"
		                  >
		                    <View className="flex-row items-center justify-between mb-2">
		                      <View className="flex-row items-center">
		                        <Ionicons
		                          name={getStatusIcon(invitation.status)}
		                          size={20}
		                          color={getStatusColor(invitation.status)}
		                        />
		                        <Text className="text-white font-medium ml-2">
		                          {invitation.recipientEmail || invitation.recipientPhone || 'Unknown'}
		                        </Text>
		                      </View>
		                      
		                      <Text 
		                        className="text-sm font-medium capitalize"
		                        style={{ color: getStatusColor(invitation.status) }}
		                      >
		                        {invitation.status}
		                      </Text>
		                    </View>
		                    
		                    <Text className="text-white/60 text-sm mb-2">
		                      Sent {formatDate(invitation.createdAt)}
		                    </Text>
		                    
		                    {invitation.status === 'pending' && invitation.attemptCount < 3 && (
		                      <View className="flex-row space-x-2 mt-3">
		                        {invitation.recipientEmail && (
		                          <Pressable
		                            onPress={() => handleRetryInvitation(invitation.id, 'email')}
		                            className="bg-blue-500/20 rounded-lg px-3 py-2 flex-row items-center"
		                          >
		                            <Ionicons name="mail" size={16} color="#3b82f6" />
		                            <Text className="text-blue-400 text-xs font-medium ml-1">
		                              Retry Email
		                            </Text>
		                          </Pressable>
		                        )}
		                        
		                        {invitation.recipientPhone && (
		                          <Pressable
		                            onPress={() => handleRetryInvitation(invitation.id, 'sms')}
		                            className="bg-green-500/20 rounded-lg px-3 py-2 flex-row items-center"
		                          >
		                            <Ionicons name="chatbubble" size={16} color="#10b981" />
		                            <Text className="text-green-400 text-xs font-medium ml-1">
		                              Retry SMS
		                            </Text>
		                          </Pressable>
		                        )}
		                      </View>
		                    )}
		                    
		                    {invitation.attemptCount >= 3 && (
		                      <View className="bg-red-500/20 rounded-lg p-2 mt-2">
		                        <Text className="text-red-200 text-xs">
		                          Maximum retry attempts reached
		                        </Text>
		                      </View>
		                    )}
		                  </View>
		                ))}
		              </View>
		            )}
		          </View>
		
		          {/* Quick Actions */}
		          <View className="bg-white/10 rounded-2xl p-4 mb-8">
		            <Text className="text-white text-lg font-semibold mb-4">
		              Quick Actions
		            </Text>
		            
		            <View className="space-y-3">
		              <Pressable
		                onPress={() => navigation.navigate('SendInvitation' as never)}
		                className="flex-row items-center p-3 rounded-xl"
		                style={{ backgroundColor: themeColorWithOpacity }}
		              >
		                <Ionicons name="add-circle" size={24} color={themeColor} />
		                <Text className="text-white font-medium ml-3">
		                  Send New Invitation
		                </Text>
		              </Pressable>
		              
		              <Pressable
		                onPress={() => navigation.navigate('ReceiveInvitation' as never)}
		                className="bg-white/5 flex-row items-center p-3 rounded-xl"
		              >
		                <Ionicons name="key" size={24} color="rgba(255, 255, 255, 0.7)" />
		                <Text className="text-white font-medium ml-3">
		                  Enter Invitation Code
		                </Text>
		              </Pressable>
		            </View>
		          </View>
		        </ScrollView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/InvitationScreen.tsx'><![CDATA[
		import React, { useState, useEffect } from "react";
		import { 
		  View, 
		  Text, 
		  Pressable, 
		  Alert, 
		  TextInput, 
		  ScrollView,
		  KeyboardAvoidingView,
		  Platform,
		  ActivityIndicator,
		  Animated,
		  ImageBackground,
		} from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { useNavigation } from "@react-navigation/native";
		import { Ionicons } from "@expo/vector-icons";
		import * as Haptics from "expo-haptics";
		
		import { useTwinStore, TwinType, ThemeColor } from "../state/twinStore";
		import { 
		  useInvitationStore, 
		  useInvitationLoading, 
		  useInvitationError, 
		  useInvitationStep,
		  useCurrentInvitation,
		  usePendingInvitationToken,
		} from "../state/invitationStore";
		import { useDeepLinkHandler } from "../utils/deepLinking";
		import { getNeonAccentColor, getNeonAccentColorWithOpacity } from "../utils/neonColors";
		import { Invitation } from "../services/invitationService";
		
		type InvitationMode = 'send' | 'receive' | 'manual';
		
		interface InvitationScreenProps {
		  mode?: InvitationMode;
		  invitationData?: {
		    fromName: string;
		    fromEmail?: string;
		    fromPhone?: string;
		    twinType: TwinType;
		    accentColor: ThemeColor;
		  };
		  onComplete?: () => void;
		}
		
		export const InvitationScreen: React.FC<InvitationScreenProps> = ({
		  mode = 'send',
		  invitationData,
		  onComplete,
		}) => {
		  const navigation = useNavigation();
		  const { userProfile, setTwinProfile, setPaired } = useTwinStore();
		  const {
		    invitationStep,
		    selectedMethod,
		    recipientContact,
		    currentInvitation,
		    setInvitationStep,
		    setSelectedMethod,
		    setRecipientContact,
		    createAndSendInvitation,
		    processIncomingInvitation,
		    acceptInvitation,
		    declineInvitation,
		    clearError,
		    reset,
		  } = useInvitationStore();
		  
		  const isLoading = useInvitationLoading();
		  const error = useInvitationError();
		  const pendingToken = usePendingInvitationToken();
		  const { processPendingInvitation, clearPendingData } = useDeepLinkHandler();
		  
		  const [localState, setLocalState] = useState({
		    manualToken: '',
		    showTokenInput: false,
		    isProcessing: false,
		  });
		  
		  const [animatedValue] = useState(new Animated.Value(0));
		  
		  const accentColor = userProfile?.accentColor || 'neon-purple';
		  const themeColor = getNeonAccentColor(accentColor);
		  const themeColorWithOpacity = getNeonAccentColorWithOpacity(accentColor, 0.3);
		
		  // Handle deep link invitation on component mount
		  useEffect(() => {
		    const handlePendingInvitation = async () => {
		      if (pendingToken && mode === 'receive') {
		        try {
		          const result = await processPendingInvitation();
		          if (result.success && result.invitation) {
		            setLocalState(prev => ({ ...prev, isProcessing: false }));
		            // Show invitation details for user to accept/decline
		          } else {
		            Alert.alert('Invalid Invitation', result.error || 'This invitation link is not valid.');
		          }
		        } catch (error) {
		          console.error('Error processing pending invitation:', error);
		        }
		      }
		    };
		    
		    handlePendingInvitation();
		  }, [pendingToken, mode, processPendingInvitation]);
		
		  // Animate entrance
		  useEffect(() => {
		    Animated.timing(animatedValue, {
		      toValue: 1,
		      duration: 800,
		      useNativeDriver: true,
		    }).start();
		  }, []);
		
		  // Clear error when component unmounts
		  useEffect(() => {
		    return () => {
		      clearError();
		    };
		  }, [clearError]);
		
		  const handleSendInvitation = async () => {
		    if (!userProfile) {
		      Alert.alert('Error', 'User profile not found');
		      return;
		    }
		
		    if (!recipientContact.email && !recipientContact.phone) {
		      Alert.alert('Missing Contact', 'Please provide either an email address or phone number.');
		      return;
		    }
		
		    if (!selectedMethod) {
		      Alert.alert('Select Method', 'Please select how you want to send the invitation.');
		      return;
		    }
		
		    try {
		      const success = await createAndSendInvitation(
		        userProfile,
		        recipientContact,
		        selectedMethod
		      );
		
		      if (success) {
		        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		        // Auto-navigate back after success
		        setTimeout(() => {
		          onComplete?.();
		          navigation.goBack();
		        }, 3000);
		      } else {
		        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
		      }
		    } catch (error) {
		      console.error('Send invitation error:', error);
		      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
		    }
		  };
		
		  const handleAcceptInvitation = async (invitation: Invitation) => {
		    setLocalState(prev => ({ ...prev, isProcessing: true }));
		    
		    try {
		      const success = await acceptInvitation(invitation.token);
		      
		      if (success) {
		        // Create twin profile from invitation data
		        const twinProfile = {
		          id: `twin_${Date.now()}`,
		          name: invitation.inviterName,
		          age: 0,
		          gender: '',
		          twinType: invitation.twinType,
		          birthDate: new Date().toISOString(),
		          accentColor: invitation.accentColor,
		          isConnected: true,
		        };
		
		        setTwinProfile(twinProfile);
		        setPaired(true);
		        
		        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		        
		        Alert.alert(
		          'Connection Established! 🌟',
		          `You are now connected with ${invitation.inviterName}! Your twin journey begins now.`,
		          [
		            {
		              text: 'Start Chatting',
		              onPress: () => {
		                onComplete?.();
		                navigation.navigate('Main' as never);
		              },
		            },
		          ]
		        );
		        
		        clearPendingData();
		      } else {
		        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
		        Alert.alert('Error', error || 'Failed to accept invitation. Please try again.');
		      }
		    } catch (error) {
		      console.error('Accept invitation error:', error);
		      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Error);
		      Alert.alert('Error', 'Failed to accept invitation. Please try again.');
		    } finally {
		      setLocalState(prev => ({ ...prev, isProcessing: false }));
		    }
		  };
		
		  const handleDeclineInvitation = async (invitation: Invitation) => {
		    Alert.alert(
		      'Decline Invitation',
		      'Are you sure you want to decline this twin invitation? This action cannot be undone.',
		      [
		        { text: 'Cancel', style: 'cancel' },
		        {
		          text: 'Decline',
		          style: 'destructive',
		          onPress: async () => {
		            try {
		              await declineInvitation(invitation.token);
		              clearPendingData();
		              navigation.goBack();
		            } catch (error) {
		              Alert.alert('Error', 'Failed to decline invitation.');
		            }
		          },
		        },
		      ]
		    );
		  };
		
		  const handleManualTokenEntry = async () => {
		    if (!localState.manualToken.trim()) {
		      Alert.alert('Enter Code', 'Please enter the invitation code.');
		      return;
		    }
		
		    setLocalState(prev => ({ ...prev, isProcessing: true }));
		
		    try {
		      const result = await processIncomingInvitation(localState.manualToken.trim().toUpperCase());
		      
		      if (result.success && result.invitation) {
		        // Show invitation for acceptance
		        setLocalState(prev => ({ ...prev, showTokenInput: false }));
		      } else {
		        Alert.alert('Invalid Code', result.error || 'The invitation code is not valid.');
		      }
		    } catch (error) {
		      Alert.alert('Error', 'Failed to process invitation code.');
		    } finally {
		      setLocalState(prev => ({ ...prev, isProcessing: false }));
		    }
		  };
		
		  const renderContactForm = () => (
		    <Animated.View
		      style={{
		        opacity: animatedValue,
		        transform: [{
		          translateY: animatedValue.interpolate({
		            inputRange: [0, 1],
		            outputRange: [50, 0],
		          }),
		        }],
		      }}
		      className="space-y-6"
		    >
		      <View className="bg-white/10 rounded-2xl p-6">
		        <Text className="text-white text-xl font-bold mb-4">Invite Your Twin 💫</Text>
		        
		        <View className="space-y-4">
		          <View>
		            <Text className="text-white/80 text-sm font-medium mb-2">Twin's Name (Optional)</Text>
		            <TextInput
		              value={recipientContact.name || ''}
		              onChangeText={(name) => setRecipientContact({ name })}
		              placeholder="Your twin's name"
		              placeholderTextColor="rgba(255, 255, 255, 0.5)"
		              className="bg-white/10 rounded-xl px-4 py-3 text-white text-base"
		            />
		          </View>
		          
		          <View>
		            <Text className="text-white/80 text-sm font-medium mb-2">Email Address</Text>
		            <TextInput
		              value={recipientContact.email || ''}
		              onChangeText={(email) => setRecipientContact({ email })}
		              placeholder="twin@example.com"
		              placeholderTextColor="rgba(255, 255, 255, 0.5)"
		              className="bg-white/10 rounded-xl px-4 py-3 text-white text-base"
		              keyboardType="email-address"
		              autoCapitalize="none"
		            />
		          </View>
		          
		          <Text className="text-white/60 text-center text-sm">— or —</Text>
		          
		          <View>
		            <Text className="text-white/80 text-sm font-medium mb-2">Phone Number</Text>
		            <TextInput
		              value={recipientContact.phone || ''}
		              onChangeText={(phone) => setRecipientContact({ phone })}
		              placeholder="+1 (555) 123-4567"
		              placeholderTextColor="rgba(255, 255, 255, 0.5)"
		              className="bg-white/10 rounded-xl px-4 py-3 text-white text-base"
		              keyboardType="phone-pad"
		            />
		          </View>
		        </View>
		      </View>
		      
		      <View className="bg-white/10 rounded-2xl p-6">
		        <Text className="text-white text-lg font-semibold mb-4">How would you like to send?</Text>
		        
		        <View className="space-y-3">
		          {recipientContact.email && (
		            <Pressable
		              onPress={() => setSelectedMethod('email')}
		              className={`flex-row items-center p-4 rounded-xl ${
		                selectedMethod === 'email' ? 'bg-white/20' : 'bg-white/5'
		              }`}
		            >
		              <Ionicons 
		                name={selectedMethod === 'email' ? 'radio-button-on' : 'radio-button-off'} 
		                size={24} 
		                color={selectedMethod === 'email' ? themeColor : 'rgba(255, 255, 255, 0.7)'} 
		              />
		              <Ionicons name="mail" size={20} color="white" className="ml-3" />
		              <Text className="text-white text-base font-medium ml-3">Email Invitation</Text>
		            </Pressable>
		          )}
		          
		          {recipientContact.phone && (
		            <Pressable
		              onPress={() => setSelectedMethod('sms')}
		              className={`flex-row items-center p-4 rounded-xl ${
		                selectedMethod === 'sms' ? 'bg-white/20' : 'bg-white/5'
		              }`}
		            >
		              <Ionicons 
		                name={selectedMethod === 'sms' ? 'radio-button-on' : 'radio-button-off'} 
		                size={24} 
		                color={selectedMethod === 'sms' ? themeColor : 'rgba(255, 255, 255, 0.7)'} 
		              />
		              <Ionicons name="chatbubble" size={20} color="white" className="ml-3" />
		              <Text className="text-white text-base font-medium ml-3">SMS Invitation</Text>
		            </Pressable>
		          )}
		          
		          {recipientContact.email && recipientContact.phone && (
		            <Pressable
		              onPress={() => setSelectedMethod('both')}
		              className={`flex-row items-center p-4 rounded-xl ${
		                selectedMethod === 'both' ? 'bg-white/20' : 'bg-white/5'
		              }`}
		            >
		              <Ionicons 
		                name={selectedMethod === 'both' ? 'radio-button-on' : 'radio-button-off'} 
		                size={24} 
		                color={selectedMethod === 'both' ? themeColor : 'rgba(255, 255, 255, 0.7)'} 
		              />
		              <Ionicons name="send" size={20} color="white" className="ml-3" />
		              <Text className="text-white text-base font-medium ml-3">Both Email & SMS</Text>
		            </Pressable>
		          )}
		        </View>
		      </View>
		      
		      {error && (
		        <View className="bg-red-500/20 border border-red-500/50 rounded-xl p-4">
		          <Text className="text-red-200 text-center">{error}</Text>
		        </View>
		      )}
		      
		      <Pressable
		        onPress={handleSendInvitation}
		        disabled={isLoading || !selectedMethod}
		        className={`rounded-xl py-4 items-center ${
		          isLoading || !selectedMethod ? 'bg-white/10' : 'bg-white/20'
		        }`}
		        style={{ backgroundColor: !isLoading && selectedMethod ? themeColorWithOpacity : undefined }}
		      >
		        {isLoading ? (
		          <ActivityIndicator color="white" />
		        ) : (
		          <Text className="text-white text-lg font-semibold">
		            Send Invitation 🚀
		          </Text>
		        )}
		      </Pressable>
		    </Animated.View>
		  );
		
		  const renderInvitationStatus = () => {
		    const getStepIcon = () => {
		      switch (invitationStep) {
		        case 'sending':
		          return <ActivityIndicator color={themeColor} size="large" />;
		        case 'sent':
		          return <Ionicons name="checkmark-circle" size={64} color={themeColor} />;
		        case 'success':
		          return <Ionicons name="heart" size={64} color={themeColor} />;
		        case 'error':
		          return <Ionicons name="alert-circle" size={64} color="#ff4444" />;
		        default:
		          return <Ionicons name="send" size={64} color={themeColor} />;
		      }
		    };
		    
		    const getStepMessage = () => {
		      switch (invitationStep) {
		        case 'sending':
		          return 'Sending your twin invitation...';
		        case 'sent':
		          return 'Invitation sent successfully!';
		        case 'success':
		          return 'Your invitation is on its way! 🌟';
		        case 'error':
		          return 'There was an issue sending the invitation.';
		        default:
		          return 'Preparing to send...';
		      }
		    };
		    
		    return (
		      <Animated.View
		        style={{
		          opacity: animatedValue,
		          transform: [{
		            scale: animatedValue.interpolate({
		              inputRange: [0, 1],
		              outputRange: [0.8, 1],
		            }),
		          }],
		        }}
		        className="flex-1 justify-center items-center px-8"
		      >
		        <View className="items-center mb-8">
		          {getStepIcon()}
		          <Text className="text-white text-2xl font-bold text-center mt-6">
		            {getStepMessage()}
		          </Text>
		          
		          {invitationStep === 'sent' && (
		            <Text className="text-white/70 text-center text-base mt-4">
		              Your twin will receive the invitation and can use it to connect with you.
		            </Text>
		          )}
		          
		          {invitationStep === 'error' && error && (
		            <Text className="text-red-200 text-center text-base mt-4">
		              {error}
		            </Text>
		          )}
		        </View>
		        
		        {(invitationStep === 'success' || invitationStep === 'error') && (
		          <Pressable
		            onPress={() => {
		              reset();
		              navigation.goBack();
		            }}
		            className="bg-white/20 rounded-xl py-3 px-8"
		          >
		            <Text className="text-white text-base font-semibold">
		              {invitationStep === 'success' ? 'Done' : 'Try Again'}
		            </Text>
		          </Pressable>
		        )}
		      </Animated.View>
		    );
		  };
		
		  const renderReceiveInvitation = () => {
		    if (currentInvitation) {
		      return (
		        <Animated.View
		          style={{
		            opacity: animatedValue,
		            transform: [{ translateY: animatedValue.interpolate({ inputRange: [0, 1], outputRange: [50, 0] }) }],
		          }}
		          className="flex-1 justify-center px-8"
		        >
		          <View className="items-center mb-12">
		            <View 
		              className="w-24 h-24 rounded-full items-center justify-center mb-6"
		              style={{ backgroundColor: getNeonAccentColorWithOpacity(currentInvitation.accentColor, 0.3) }}
		            >
		              <Ionicons name="heart" size={48} color={getNeonAccentColor(currentInvitation.accentColor)} />
		            </View>
		            
		            <Text className="text-white text-3xl font-bold text-center mb-4">
		              Twin Invitation 💫
		            </Text>
		            
		            <Text className="text-white/70 text-center text-lg mb-8">
		              {currentInvitation.inviterName} wants to connect with you!
		            </Text>
		          </View>
		
		          <View className="bg-white/10 rounded-2xl p-6 mb-8">
		            <View className="flex-row items-center mb-4">
		              <Ionicons name="person" size={24} color="white" />
		              <Text className="text-white text-lg font-semibold ml-3">
		                {currentInvitation.inviterName}
		              </Text>
		            </View>
		            
		            <View className="flex-row items-center mb-4">
		              <Ionicons name="people" size={24} color="white" />
		              <Text className="text-white text-lg ml-3 capitalize">
		                {currentInvitation.twinType} Twins
		              </Text>
		            </View>
		            
		            <View className="flex-row items-center mb-4">
		              <Ionicons name="color-palette" size={24} color={getNeonAccentColor(currentInvitation.accentColor)} />
		              <Text className="text-white text-lg ml-3 capitalize">
		                {currentInvitation.accentColor.replace('neon-', '')} Theme
		              </Text>
		            </View>
		            
		            <View className="flex-row items-center">
		              <Ionicons name="time" size={24} color="white" />
		              <Text className="text-white text-lg ml-3">
		                Expires {new Date(currentInvitation.expiresAt).toLocaleDateString()}
		              </Text>
		            </View>
		          </View>
		
		          <View className="space-y-4">
		            <Pressable
		              onPress={() => handleAcceptInvitation(currentInvitation)}
		              disabled={localState.isProcessing}
		              className="rounded-xl py-4 items-center"
		              style={{ backgroundColor: themeColorWithOpacity }}
		            >
		              {localState.isProcessing ? (
		                <ActivityIndicator color="white" />
		              ) : (
		                <Text className="text-white text-lg font-semibold">
		                  Accept Invitation ✨
		                </Text>
		              )}
		            </Pressable>
		            
		            <Pressable
		              onPress={() => handleDeclineInvitation(currentInvitation)}
		              disabled={localState.isProcessing}
		              className="bg-white/10 rounded-xl py-4 items-center"
		            >
		              <Text className="text-white text-lg">Decline</Text>
		            </Pressable>
		          </View>
		        </Animated.View>
		      );
		    }
		    
		    // Manual token entry fallback
		    return (
		      <Animated.View
		        style={{
		          opacity: animatedValue,
		          transform: [{ translateY: animatedValue.interpolate({ inputRange: [0, 1], outputRange: [50, 0] }) }],
		        }}
		        className="flex-1 justify-center px-8"
		      >
		        <View className="items-center mb-12">
		          <View className="w-24 h-24 rounded-full bg-white/20 items-center justify-center mb-6">
		            <Ionicons name="key" size={48} color="white" />
		          </View>
		          
		          <Text className="text-white text-3xl font-bold text-center mb-4">
		            Enter Invitation Code
		          </Text>
		          
		          <Text className="text-white/70 text-center text-lg mb-8">
		            Enter the code your twin shared with you
		          </Text>
		        </View>
		
		        <View className="bg-white/10 rounded-2xl p-6 mb-8">
		          <TextInput
		            value={localState.manualToken}
		            onChangeText={(text) => setLocalState(prev => ({ ...prev, manualToken: text.toUpperCase() }))}
		            placeholder="Enter invitation code"
		            placeholderTextColor="rgba(255, 255, 255, 0.5)"
		            className="bg-white/10 rounded-xl px-4 py-4 text-white text-lg text-center tracking-widest font-mono"
		            autoCapitalize="characters"
		            maxLength={64}
		            autoCorrect={false}
		          />
		        </View>
		        
		        {error && (
		          <View className="bg-red-500/20 border border-red-500/50 rounded-xl p-4 mb-4">
		            <Text className="text-red-200 text-center">{error}</Text>
		          </View>
		        )}
		
		        <Pressable
		          onPress={handleManualTokenEntry}
		          disabled={localState.isProcessing || !localState.manualToken.trim()}
		          className={`rounded-xl py-4 items-center ${
		            localState.isProcessing || !localState.manualToken.trim() ? 'bg-white/10' : 'bg-white/20'
		          }`}
		          style={{ 
		            backgroundColor: !localState.isProcessing && localState.manualToken.trim() ? themeColorWithOpacity : undefined 
		          }}
		        >
		          {localState.isProcessing ? (
		            <ActivityIndicator color="white" />
		          ) : (
		            <Text className="text-white text-lg font-semibold">
		              Process Invitation
		            </Text>
		          )}
		        </Pressable>
		      </Animated.View>
		    );
		  };
		
		  const renderContent = () => {
		    if (mode === 'send') {
		      if (invitationStep === 'sending' || invitationStep === 'sent' || invitationStep === 'success' || invitationStep === 'error') {
		        return renderInvitationStatus();
		      }
		      return (
		        <ScrollView className="flex-1" showsVerticalScrollIndicator={false}>
		          <View className="px-6 py-8">
		            {renderContactForm()}
		          </View>
		        </ScrollView>
		      );
		    }
		    
		    return renderReceiveInvitation();
		  };
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <KeyboardAvoidingView 
		          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
		          className="flex-1"
		        >
		          {/* Header */}
		          <View className="flex-row items-center justify-between px-6 py-4">
		            <Pressable
		              onPress={() => {
		                reset();
		                navigation.goBack();
		              }}
		              className="w-10 h-10 rounded-full bg-white/10 items-center justify-center"
		            >
		              <Ionicons name="arrow-back" size={20} color="white" />
		            </Pressable>
		            
		            <Text className="text-white text-lg font-semibold">
		              {mode === 'send' ? 'Send Invitation' : 'Invitation Received'}
		            </Text>
		            
		            <View className="w-10" />
		          </View>
		          
		          {renderContent()}
		        </KeyboardAvoidingView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/onboarding/ColorSelectionScreen.tsx'><![CDATA[
		import React, { useState, useRef, useEffect } from "react";
		import { View, Text, Pressable, ScrollView, Animated, Dimensions, ImageBackground } from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { ColorPicker } from "../../components/onboarding/ColorPicker";
		import { LinearGradient } from "expo-linear-gradient";
		import { Ionicons } from "@expo/vector-icons";
		import { useTwinStore, ThemeColor } from "../../state/twinStore";
		import { getNeonAccentColor, getNeonGradientColors } from "../../utils/neonColors";
		
		interface ColorSelectionScreenProps {
		  onContinue: () => void;
		  onBack: () => void;
		}
		
		const { width } = Dimensions.get('window');
		
		export const ColorSelectionScreen: React.FC<ColorSelectionScreenProps> = ({ 
		  onContinue, 
		  onBack 
		}) => {
		  const { userProfile, setUserProfile } = useTwinStore();
		  const [selectedColor, setSelectedColor] = useState<ThemeColor>(
		    userProfile?.accentColor || "neon-purple"
		  );
		  
		  const fadeAnim = useRef(new Animated.Value(0)).current;
		  const previewAnim = useRef(new Animated.Value(0.9)).current;
		  const pulseAnim = useRef(new Animated.Value(1)).current;
		
		  useEffect(() => {
		    Animated.parallel([
		      Animated.timing(fadeAnim, {
		        toValue: 1,
		        duration: 800,
		        useNativeDriver: true,
		      }),
		      Animated.timing(previewAnim, {
		        toValue: 1,
		        duration: 1000,
		        useNativeDriver: true,
		      }),
		    ]).start();
		
		    // Gentle pulse animation for selected color
		    const pulseAnimation = Animated.loop(
		      Animated.sequence([
		        Animated.timing(pulseAnim, {
		          toValue: 1.05,
		          duration: 1500,
		          useNativeDriver: true,
		        }),
		        Animated.timing(pulseAnim, {
		          toValue: 1,
		          duration: 1500,
		          useNativeDriver: true,
		        }),
		      ])
		    );
		    pulseAnimation.start();
		
		    return () => pulseAnimation.stop();
		  }, []);
		
		  const handleContinue = () => {
		    if (!userProfile) return;
		
		    setUserProfile({
		      ...userProfile,
		      accentColor: selectedColor,
		    });
		    onContinue();
		  };
		
		  const neonColors: { color: ThemeColor; name: string; description: string }[] = [
		    { color: "neon-pink", name: "Hot Pink", description: "Intuitive & Emotional" },
		    { color: "neon-blue", name: "Electric Blue", description: "Calm & Analytical" },
		    { color: "neon-green", name: "Bright Green", description: "Balanced & Growth" },
		    { color: "neon-yellow", name: "Neon Yellow", description: "Energetic & Creative" },
		    { color: "neon-purple", name: "Vibrant Purple", description: "Creative & Wise" },
		    { color: "neon-orange", name: "Bright Orange", description: "Bold & Passionate" },
		    { color: "neon-cyan", name: "Electric Cyan", description: "Clear & Focused" },
		    { color: "neon-red", name: "Bright Red", description: "Strong & Determined" },
		  ];
		
		  const renderPreviewElements = () => {
		    const accentColor = getNeonAccentColor(selectedColor);
		    const gradientColors = getNeonGradientColors(selectedColor);
		
		    return (
		      <View className="items-center space-y-4">
		        {/* Chat Bubble Preview */}
		        <View className="flex-row justify-end w-full max-w-sm">
		          <View 
		            className="px-4 py-3 rounded-2xl rounded-br-sm max-w-xs"
		            style={{ backgroundColor: accentColor + '40' }}
		          >
		            <Text className="text-white text-sm">
		              Hey twin! Love this color! 💫
		            </Text>
		          </View>
		        </View>
		
		        {/* Button Preview */}
		        <Pressable
		          className="px-8 py-3 rounded-full border-2"
		          style={{
		            backgroundColor: accentColor + '30',
		            borderColor: accentColor + '60',
		          }}
		        >
		          <Text className="text-white font-semibold">
		            Sample Button
		          </Text>
		        </Pressable>
		
		        {/* Accent Elements */}
		        <View className="flex-row space-x-3">
		          {gradientColors.map((color, index) => (
		            <View
		              key={index}
		              className="w-8 h-8 rounded-full"
		              style={{ backgroundColor: color + '80' }}
		            />
		          ))}
		        </View>
		      </View>
		    );
		  };
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <View className="flex-1">
		          {/* Header */}
		          <View className="flex-row items-center justify-between pt-4 pb-8 px-8">
		            <Pressable
		              onPress={onBack}
		              className="w-10 h-10 rounded-full bg-white/10 items-center justify-center"
		            >
		              <Ionicons name="chevron-back" size={20} color="white" />
		            </Pressable>
		            
		            <View className="flex-1 items-center">
		              <Text className="text-white/60 text-sm">Step 4 of 5</Text>
		              <View className="flex-row mt-2 space-x-1">
		                {[...Array(5)].map((_, i) => (
		                  <View 
		                    key={i} 
		                    className={`h-1 w-8 rounded-full ${
		                      i <= 3 ? 'bg-white' : 'bg-white/20'
		                    }`} 
		                  />
		                ))}
		              </View>
		            </View>
		            
		            <View className="w-10" />
		          </View>
		
		          <ScrollView className="flex-1 px-8" showsVerticalScrollIndicator={false}>
		            <Animated.View style={{ opacity: fadeAnim }}>
		              {/* Color Symbol */}
		              <Animated.View 
		                style={{ 
		                  transform: [{ scale: pulseAnim }]
		                }}
		                className="items-center mb-8"
		              >
		                <View className="relative">
		                  <View 
		                    className="w-20 h-20 rounded-full border-4 items-center justify-center"
		                    style={{ 
		                      borderColor: getNeonAccentColor(selectedColor) + '60',
		                      backgroundColor: getNeonAccentColor(selectedColor) + '20'
		                    }}
		                  >
		                    <Ionicons 
		                      name="color-palette" 
		                      size={32} 
		                      color={getNeonAccentColor(selectedColor)} 
		                    />
		                  </View>
		                  <View 
		                    className="absolute -inset-1 w-22 h-22 rounded-full border"
		                    style={{ borderColor: getNeonAccentColor(selectedColor) + '30' }}
		                  />
		                </View>
		              </Animated.View>
		
		              <Text className="text-white text-3xl font-bold text-center mb-4">
		                Your Color Theme
		              </Text>
		              
		              <Text className="text-white/70 text-base text-center mb-12 leading-6">
		                Choose a neon color you like. This will personalize your chat bubbles, buttons, and accents throughout the app.
		              </Text>
		
		              {/* Live Preview */}
		              <Animated.View 
		                style={{ transform: [{ scale: previewAnim }] }}
		                className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 mb-8 border border-white/20"
		              >
		                <Text className="text-white text-lg font-semibold text-center mb-4">
		                  Live Preview
		                </Text>
		                {renderPreviewElements()}
		              </Animated.View>
		
		              {/* Color Palette */}
		              <ColorPicker
		                colors={neonColors}
		                selectedColor={selectedColor}
		                onColorSelect={setSelectedColor}
		              />
		
		              {/* Color Meaning */}
		              <View className="bg-white/5 rounded-xl p-6 mt-8 mb-8 border border-white/10">
		                <View className="flex-row items-center mb-3">
		                  <View 
		                    className="w-6 h-6 rounded-full mr-3"
		                    style={{ backgroundColor: getNeonAccentColor(selectedColor) }}
		                  />
		                  <Text className="text-white text-lg font-semibold">
		                    {neonColors.find(c => c.color === selectedColor)?.name}
		                  </Text>
		                </View>
		                <Text className="text-white/70 text-base">
		                  {neonColors.find(c => c.color === selectedColor)?.description}
		                </Text>
		              </View>
		
		              {/* Color Note */}
		              <View className="bg-white/5 rounded-xl p-6 mb-8 border border-white/10">
		                <View className="flex-row items-start">
		                  <Ionicons name="sparkles" size={20} color="#ffd700" className="mr-3 mt-1" />
		                  <View className="flex-1">
		                    <Text className="text-white text-base font-medium mb-2">
		                      Color & You
		                    </Text>
		                    <Text className="text-white/60 text-sm leading-6">
		                      Your chosen color will appear throughout the app to personalize your experience. Your twin will see this color in your messages and profile, making it easy to recognize your content.
		                    </Text>
		                  </View>
		                </View>
		              </View>
		            </Animated.View>
		          </ScrollView>
		
		          {/* Continue Button */}
		          <View className="px-8 pb-8">
		            <Pressable
		              onPress={handleContinue}
		              className="rounded-full py-4 items-center border-2"
		              style={{
		                backgroundColor: getNeonAccentColor(selectedColor) + '30',
		                borderColor: getNeonAccentColor(selectedColor) + '60',
		              }}
		              android_ripple={{
		                color: getNeonAccentColor(selectedColor) + '40',
		                borderless: false
		              }}
		            >
		              <LinearGradient
		                colors={[
		                  getNeonAccentColor(selectedColor) + '40',
		                  getNeonAccentColor(selectedColor) + '20'
		                ]}
		                className="absolute inset-0 rounded-full"
		              />
		              <Text className="text-white text-lg font-semibold">
		                Continue with {neonColors.find(c => c.color === selectedColor)?.name}
		              </Text>
		            </Pressable>
		          </View>
		        </View>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/onboarding/PersonalDetailsScreen.tsx'><![CDATA[
		import React, { useState, useRef, useEffect } from "react";
		import { View, Text, Pressable, TextInput, ScrollView, Animated, ImageBackground } from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { LinearGradient } from "expo-linear-gradient";
		import { Ionicons } from "@expo/vector-icons";
		import { useTwinStore, TwinProfile, ThemeColor } from "../../state/twinStore";
		import { getZodiacSign } from "../../utils/zodiac";
		
		interface PersonalDetailsScreenProps {
		  onContinue: () => void;
		  onBack: () => void;
		}
		
		interface FormData {
		  name: string;
		  age: string;
		  gender: string;
		  sexualOrientation: string;
		  showSexualOrientation: boolean;
		  placeOfBirth: string;
		  timeOfBirth: string;
		}
		
		export const PersonalDetailsScreen: React.FC<PersonalDetailsScreenProps> = ({ 
		  onContinue, 
		  onBack 
		}) => {
		  const { userProfile, setUserProfile } = useTwinStore();
		  const [showOrientationPicker, setShowOrientationPicker] = useState(false);
		  const [formData, setFormData] = useState<FormData>({
		    name: userProfile?.name || "",
		    age: userProfile?.age?.toString() || "",
		    gender: userProfile?.gender || "",
		    sexualOrientation: userProfile?.sexualOrientation || "",
		    showSexualOrientation: userProfile?.showSexualOrientation ?? true,
		    placeOfBirth: userProfile?.placeOfBirth || "",
		    timeOfBirth: userProfile?.timeOfBirth || "",
		  });
		
		  const fadeAnim = useRef(new Animated.Value(0)).current;
		
		  useEffect(() => {
		    Animated.timing(fadeAnim, {
		      toValue: 1,
		      duration: 800,
		      useNativeDriver: true,
		    }).start();
		  }, []);
		
		  const genderOptions = ["Male", "Female", "Non-binary", "Other", "Prefer not to say"];
		  const orientationOptions = [
		    "Heterosexual", "Homosexual", "Bisexual", "Pansexual", 
		    "Asexual", "Demisexual", "Other", "Prefer not to say"
		  ];
		
		  const handleContinue = () => {
		    const age = parseInt(formData.age);
		    if (!formData.name.trim() || !formData.age.trim() || isNaN(age) || age < 13) {
		      return;
		    }
		
		    const updatedProfile: TwinProfile = {
		      id: userProfile?.id || "user-" + Date.now(),
		      name: formData.name.trim(),
		      age: age,
		      gender: formData.gender,
		      sexualOrientation: formData.sexualOrientation || undefined,
		      showSexualOrientation: formData.showSexualOrientation,
		      twinType: userProfile?.twinType || "identical",
		      birthDate: userProfile?.birthDate || new Date().toISOString(),
		      placeOfBirth: formData.placeOfBirth || undefined,
		      timeOfBirth: formData.timeOfBirth || undefined,
		      profilePicture: userProfile?.profilePicture,
		      accentColor: userProfile?.accentColor || "neon-purple",
		      isConnected: false,
		    };
		
		    const birthDateObj = new Date(updatedProfile.birthDate);
		    const month = birthDateObj.getMonth() + 1;
		    const day = birthDateObj.getDate();
		    updatedProfile.zodiacSign = getZodiacSign(month, day);
		
		    setUserProfile(updatedProfile);
		    onContinue();
		  };
		
		  const isFormValid = () => {
		    const age = parseInt(formData.age);
		    return formData.name.trim() && formData.age.trim() && !isNaN(age) && age >= 13 && formData.gender;
		  };
		
		  const renderSelector = (
		    label: string,
		    value: string,
		    options: string[],
		    onSelect: (value: string) => void,
		    isRequired: boolean = false
		  ) => (
		    <View className="mb-6">
		      <Text className="text-white text-lg mb-3 font-semibold">
		        {label} {isRequired && <Text className="text-red-300">*</Text>}
		      </Text>
		      <ScrollView 
		        horizontal 
		        showsHorizontalScrollIndicator={false}
		        className="flex-row"
		        contentContainerStyle={{ paddingRight: 20 }}
		      >
		        {options.map((option) => (
		          <Pressable
		            key={option}
		            onPress={() => onSelect(option)}
		            className={`mr-3 px-4 py-2 rounded-full border ${
		              value === option 
		                ? 'bg-white/20 border-white/50' 
		                : 'bg-white/5 border-white/20'
		            }`}
		            style={({ pressed }) => ({
		              opacity: pressed ? 0.8 : 1,
		            })}
		          >
		            <Text className={`${
		              value === option ? 'text-white' : 'text-white/70'
		            } font-medium`}>
		              {option}
		            </Text>
		          </Pressable>
		        ))}
		      </ScrollView>
		    </View>
		  );
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		          {/* Header */}
		          <View className="flex-row items-center justify-between pt-4 pb-8 px-8">
		            <Pressable
		              onPress={onBack}
		              className="w-10 h-10 rounded-full bg-white/10 items-center justify-center"
		            >
		              <Ionicons name="chevron-back" size={20} color="white" />
		            </Pressable>
		            
		            <View className="flex-1 items-center">
		              <Text className="text-white/60 text-sm">Step 2 of 5</Text>
		              <View className="flex-row mt-2 space-x-1">
		                {[...Array(5)].map((_, i) => (
		                  <View 
		                    key={i} 
		                    className={`h-1 w-8 rounded-full ${
		                      i <= 1 ? 'bg-white' : 'bg-white/20'
		                    }`} 
		                  />
		                ))}
		              </View>
		            </View>
		            
		            <View className="w-10" />
		          </View>
		
		        <ScrollView 
		          className="flex-1" 
		          showsVerticalScrollIndicator={true}
		          contentContainerStyle={{ paddingBottom: 100 }}
		          keyboardShouldPersistTaps="handled"
		          nestedScrollEnabled={true}
		        >
		          <View className="px-8">
		            <Animated.View style={{ opacity: fadeAnim }}>
		              {/* Profile Symbol */}
		              <View className="items-center mb-8">
		                <View className="relative">
		                  <View className="w-20 h-20 rounded-full border-2 border-white/30 items-center justify-center">
		                    <Ionicons name="person-circle" size={32} color="white" />
		                  </View>
		                  <View className="absolute -inset-1 w-22 h-22 rounded-full border border-white/10" />
		                </View>
		              </View>
		
		              <Text className="text-white text-3xl font-bold text-center mb-4">
		                Your Twinfo
		              </Text>
		              
		              <Text className="text-white/70 text-base text-center mb-12 leading-6">
		                Share the details that make you uniquely you. This information helps us personalize your twin experience.
		              </Text>
		
		              {/* Required Fields */}
		              <View className="mb-6">
		                <Text className="text-white text-lg mb-3 font-semibold">
		                  Full Name <Text className="text-red-300">*</Text>
		                </Text>
		                <TextInput
		                  value={formData.name}
		                  onChangeText={(text) => setFormData({ ...formData, name: text })}
		                  placeholder="Enter your full name"
		                  placeholderTextColor="rgba(255,255,255,0.4)"
		                  className="bg-white/10 backdrop-blur-sm rounded-xl px-4 py-4 text-white text-lg border border-white/20"
		                  autoCapitalize="words"
		                />
		              </View>
		
		              <View className="mb-6">
		                <Text className="text-white text-lg mb-3 font-semibold">
		                  Age <Text className="text-red-300">*</Text>
		                </Text>
		                <TextInput
		                  value={formData.age}
		                  onChangeText={(text) => setFormData({ ...formData, age: text.replace(/[^0-9]/g, '') })}
		                  placeholder="Enter your age"
		                  placeholderTextColor="rgba(255,255,255,0.4)"
		                  className="bg-white/10 backdrop-blur-sm rounded-xl px-4 py-4 text-white text-lg border border-white/20"
		                  keyboardType="numeric"
		                  maxLength={3}
		                />
		                {formData.age && parseInt(formData.age) < 13 && (
		                  <Text className="text-red-300 text-sm mt-1">
		                    You must be at least 13 years old to use Twinship
		                  </Text>
		                )}
		              </View>
		
		              {renderSelector(
		                "Gender",
		                formData.gender,
		                genderOptions,
		                (value) => setFormData({ ...formData, gender: value }),
		                true
		              )}
		
		              {/* Optional Sexual Orientation - Dropdown */}
		              <View className="mb-6">
		                <Text className="text-white text-lg mb-2 font-semibold">
		                  Sexual Orientation 
		                  <Text className="text-white/60 text-sm font-normal"> (Optional)</Text>
		                </Text>
		                <View className="bg-white/10 backdrop-blur-sm rounded-xl border border-white/20 overflow-hidden">
		                  <Pressable
		                    onPress={() => setShowOrientationPicker(!showOrientationPicker)}
		                    className="flex-row items-center justify-between px-4 py-4"
		                  >
		                    <Text className={formData.sexualOrientation ? "text-white text-base" : "text-white/60 text-base"}>
		                      {formData.sexualOrientation || "Select sexual orientation"}
		                    </Text>
		                    <Ionicons 
		                      name={showOrientationPicker ? "chevron-up" : "chevron-down"} 
		                      size={20} 
		                      color="rgba(255,255,255,0.7)" 
		                    />
		                  </Pressable>
		                  {showOrientationPicker && (
		                    <View className="bg-white/5 border-t border-white/10">
		                      <ScrollView 
		                        style={{ maxHeight: 200 }}
		                        showsVerticalScrollIndicator={true}
		                        nestedScrollEnabled={true}
		                      >
		                        {orientationOptions.map((option) => (
		                          <Pressable
		                            key={option}
		                            onPress={() => {
		                              setFormData({ ...formData, sexualOrientation: option });
		                              setShowOrientationPicker(false);
		                            }}
		                            className="px-4 py-3 border-b border-white/5"
		                            style={({ pressed }) => ({
		                              backgroundColor: pressed ? 'rgba(255,255,255,0.1)' : 'transparent'
		                            })}
		                          >
		                            <Text className="text-white/80 text-base">{option}</Text>
		                          </Pressable>
		                        ))}
		                      </ScrollView>
		                    </View>
		                  )}
		                </View>
		                
		                {formData.sexualOrientation && (
		                  <Pressable
		                    onPress={() => setFormData({ 
		                      ...formData, 
		                      showSexualOrientation: !formData.showSexualOrientation 
		                    })}
		                    className="flex-row items-center mt-3"
		                  >
		                    <View className={`w-6 h-6 rounded border-2 mr-3 items-center justify-center ${
		                      formData.showSexualOrientation 
		                        ? 'bg-white/20 border-white/50' 
		                        : 'border-white/30'
		                    }`}>
		                      {formData.showSexualOrientation && (
		                        <Ionicons name="checkmark" size={16} color="white" />
		                      )}
		                    </View>
		                    <Text className="text-white/70 flex-1">
		                      Display sexual orientation on my profile
		                    </Text>
		                  </Pressable>
		                )}
		              </View>
		
		              {/* Optional Astrology Fields */}
		              <View className="bg-white/5 rounded-xl p-4 mb-6 border border-white/10">
		                <Text className="text-white text-lg font-semibold mb-2">
		                  🌟 Astrology & Birth Info
		                </Text>
		                <Text className="text-white/60 text-sm mb-6">
		                  Optional information for enhanced compatibility insights
		                </Text>
		
		                <View className="mb-4">
		                  <Text className="text-white text-base mb-3">
		                    Place of Birth
		                  </Text>
		                  <TextInput
		                    value={formData.placeOfBirth}
		                    onChangeText={(text) => setFormData({ ...formData, placeOfBirth: text })}
		                    placeholder="e.g., New York, NY, USA"
		                    placeholderTextColor="rgba(255,255,255,0.4)"
		                    className="bg-white/10 backdrop-blur-sm rounded-xl px-4 py-3 text-white border border-white/20"
		                    autoCapitalize="words"
		                  />
		                </View>
		
		                <View>
		                  <Text className="text-white text-base mb-3">
		                    Time of Birth
		                  </Text>
		                  <TextInput
		                    value={formData.timeOfBirth}
		                    onChangeText={(text) => setFormData({ ...formData, timeOfBirth: text })}
		                    placeholder="e.g., 3:45 PM"
		                    placeholderTextColor="rgba(255,255,255,0.4)"
		                    className="bg-white/10 backdrop-blur-sm rounded-xl px-4 py-3 text-white border border-white/20"
		                  />
		                </View>
		              </View>
		              {/* Continue Button - Inside ScrollView */}
		              <View className="mt-8 mb-4">
		                <Pressable
		                  onPress={handleContinue}
		                  disabled={!isFormValid()}
		                  className={`rounded-full py-4 items-center border ${
		                    isFormValid() 
		                      ? 'bg-white/20 border-white/30' 
		                      : 'bg-white/5 border-white/10'
		                  }`}
		                  style={({ pressed }) => ({
		                    opacity: pressed ? 0.8 : 1,
		                    transform: [{ scale: pressed ? 0.98 : 1 }],
		                  })}
		                >
		                  <LinearGradient
		                    colors={isFormValid()
		                      ? ['rgba(255,255,255,0.3)', 'rgba(255,255,255,0.1)']
		                      : ['rgba(255,255,255,0.05)', 'rgba(255,255,255,0.02)']
		                    }
		                    className="absolute inset-0 rounded-full"
		                  />
		                  <Text className={`text-lg font-semibold ${
		                    isFormValid() ? 'text-white' : 'text-white/40'
		                  }`}>
		                    Continue
		                  </Text>
		                </Pressable>
		              </View>
		            </Animated.View>
		          </View>
		        </ScrollView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/onboarding/PhotoSetupScreen.tsx'><![CDATA[
		import React, { useState, useRef, useEffect } from "react";
		import { View, Text, Pressable, Image, Alert, Animated, ImageBackground } from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { LinearGradient } from "expo-linear-gradient";
		import { Ionicons } from "@expo/vector-icons";
		import * as ImagePicker from 'expo-image-picker';
		import { useTwinStore } from "../../state/twinStore";
		
		interface PhotoSetupScreenProps {
		  onContinue: () => void;
		  onBack: () => void;
		}
		
		export const PhotoSetupScreen: React.FC<PhotoSetupScreenProps> = ({ 
		  onContinue, 
		  onBack 
		}) => {
		  const [selectedImage, setSelectedImage] = useState<string | null>(null);
		  const { userProfile, setUserProfile } = useTwinStore();
		  
		  const fadeAnim = useRef(new Animated.Value(0)).current;
		  const scaleAnim = useRef(new Animated.Value(0.9)).current;
		
		  useEffect(() => {
		    Animated.parallel([
		      Animated.timing(fadeAnim, {
		        toValue: 1,
		        duration: 800,
		        useNativeDriver: true,
		      }),
		      Animated.timing(scaleAnim, {
		        toValue: 1,
		        duration: 800,
		        useNativeDriver: true,
		      }),
		    ]).start();
		  }, []);
		
		  const requestPermission = async () => {
		    const { status } = await ImagePicker.requestMediaLibraryPermissionsAsync();
		    if (status !== 'granted') {
		      Alert.alert(
		        'Permission Required',
		        'We need access to your photos to set up your profile picture.',
		        [{ text: 'OK' }]
		      );
		      return false;
		    }
		    return true;
		  };
		
		  const pickImageFromGallery = async () => {
		    const hasPermission = await requestPermission();
		    if (!hasPermission) return;
		
		    const result = await ImagePicker.launchImageLibraryAsync({
		      mediaTypes: ImagePicker.MediaTypeOptions.Images,
		      allowsEditing: true,
		      aspect: [1, 1],
		      quality: 0.8,
		    });
		
		    if (!result.canceled && result.assets[0]) {
		      setSelectedImage(result.assets[0].uri);
		    }
		  };
		
		  const takePhoto = async () => {
		    const { status } = await ImagePicker.requestCameraPermissionsAsync();
		    if (status !== 'granted') {
		      Alert.alert(
		        'Permission Required',
		        'We need camera access to take your profile picture.',
		        [{ text: 'OK' }]
		      );
		      return;
		    }
		
		    const result = await ImagePicker.launchCameraAsync({
		      allowsEditing: true,
		      aspect: [1, 1],
		      quality: 0.8,
		    });
		
		    if (!result.canceled && result.assets[0]) {
		      setSelectedImage(result.assets[0].uri);
		    }
		  };
		
		  const handleContinue = () => {
		    if (userProfile) {
		      setUserProfile({
		        ...userProfile,
		        profilePicture: selectedImage || undefined
		      });
		    } else {
		      // Create minimal profile to store the photo
		      const tempProfile: any = {
		        id: "temp-user-" + Date.now(),
		        profilePicture: selectedImage || undefined,
		        name: "",
		        age: 0,
		        gender: "",
		        twinType: "identical",
		        birthDate: new Date().toISOString(),
		        accentColor: "neon-purple",
		        isConnected: false,
		      };
		      setUserProfile(tempProfile);
		    }
		    onContinue();
		  };
		
		  const photoOptions = [
		    {
		      title: "Take Photo",
		      subtitle: "Use your camera",
		      icon: "camera" as const,
		      onPress: takePhoto,
		    },
		    {
		      title: "Choose from Gallery",
		      subtitle: "Select from your photos",
		      icon: "images" as const,
		      onPress: pickImageFromGallery,
		    }
		  ];
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <View className="flex-1 px-8">
		          {/* Header */}
		          <View className="flex-row items-center justify-between pt-4 pb-8">
		            <Pressable
		              onPress={onBack}
		              className="w-10 h-10 rounded-full bg-white/10 items-center justify-center"
		            >
		              <Ionicons name="chevron-back" size={20} color="white" />
		            </Pressable>
		            
		            <View className="flex-1 items-center">
		              <Text className="text-white/60 text-sm">Step 1 of 5</Text>
		              <View className="flex-row mt-2 space-x-1">
		                {[...Array(5)].map((_, i) => (
		                  <View 
		                    key={i} 
		                    className={`h-1 w-8 rounded-full ${
		                      i === 0 ? 'bg-white' : 'bg-white/20'
		                    }`} 
		                  />
		                ))}
		              </View>
		            </View>
		            
		            <View className="w-10" />
		          </View>
		
		          {/* Content */}
		          <Animated.View 
		            style={{
		              opacity: fadeAnim,
		              transform: [{ scale: scaleAnim }],
		            }}
		            className="flex-1 justify-center"
		          >
		            {/* Photo Symbol */}
		            <View className="items-center mb-8">
		              <View className="relative">
		                <View className="w-24 h-24 rounded-full border-2 border-white/30 items-center justify-center">
		                  <Ionicons name="person" size={32} color="white" />
		                </View>
		                <View className="absolute -inset-1 w-26 h-26 rounded-full border border-white/10" />
		              </View>
		            </View>
		
		            <Text className="text-white text-3xl font-bold text-center mb-4">
		              Profile Picture
		            </Text>
		            
		            <Text className="text-white/70 text-base text-center mb-12 leading-6">
		              Choose a photo that represents you. This helps your twin recognize you in the app.
		            </Text>
		
		            {/* Current Photo Preview */}
		            {selectedImage && (
		              <View className="items-center mb-8">
		                <View className="relative">
		                  <Image 
		                    source={{ uri: selectedImage }} 
		                    className="w-32 h-32 rounded-full"
		                  />
		                  <View className="absolute -inset-1 w-34 h-34 rounded-full border-2 border-white/50" />
		                  <View className="absolute -inset-2 w-36 h-36 rounded-full border border-white/20" />
		                </View>
		                <Text className="text-white/60 text-sm mt-4">Perfect! Your twin will love this.</Text>
		              </View>
		            )}
		
		            {/* Photo Options */}
		            <View className="space-y-4 mb-12">
		              {photoOptions.map((option, index) => (
		                <Pressable
		                  key={index}
		                  onPress={option.onPress}
		                  className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 border border-white/20"
		                  style={({ pressed }) => ({
		                    opacity: pressed ? 0.8 : 1,
		                    transform: [{ scale: pressed ? 0.98 : 1 }],
		                  })}
		                >
		                  <View className="flex-row items-center">
		                    <View className="w-12 h-12 rounded-full bg-white/10 items-center justify-center mr-4">
		                      <Ionicons name={option.icon} size={24} color="white" />
		                    </View>
		                    <View className="flex-1">
		                      <Text className="text-white text-lg font-semibold">
		                        {option.title}
		                      </Text>
		                      <Text className="text-white/60 text-sm">
		                        {option.subtitle}
		                      </Text>
		                    </View>
		                    <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.4)" />
		                  </View>
		                </Pressable>
		              ))}
		            </View>
		
		            {/* Skip Option */}
		            <View className="items-center mb-8">
		              <Pressable onPress={handleContinue}>
		                <Text className="text-white/60 text-sm underline">
		                  Skip for now (you can add this later)
		                </Text>
		              </Pressable>
		            </View>
		          </Animated.View>
		
		          {/* Continue Button */}
		          <View className="pb-8">
		            <Pressable
		              onPress={handleContinue}
		              disabled={!selectedImage}
		              className={`rounded-full py-4 items-center border ${
		                selectedImage 
		                  ? 'bg-white/20 border-white/30' 
		                  : 'bg-white/5 border-white/10'
		              }`}
		              style={({ pressed }) => ({
		                opacity: pressed ? 0.8 : 1,
		                transform: [{ scale: pressed ? 0.98 : 1 }],
		              })}
		            >
		              <LinearGradient
		                colors={selectedImage 
		                  ? ['rgba(255,255,255,0.3)', 'rgba(255,255,255,0.1)']
		                  : ['rgba(255,255,255,0.05)', 'rgba(255,255,255,0.02)']
		                }
		                className="absolute inset-0 rounded-full"
		              />
		              <Text className={`text-lg font-semibold ${
		                selectedImage ? 'text-white' : 'text-white/40'
		              }`}>
		                {selectedImage ? 'Continue' : 'Choose Photo to Continue'}
		              </Text>
		            </Pressable>
		          </View>
		        </View>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/onboarding/ProfileReviewScreen.tsx'><![CDATA[
		import React, { useState, useRef, useEffect } from "react";
		import { View, Text, Pressable, ScrollView, Image, Animated, ImageBackground } from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { LinearGradient } from "expo-linear-gradient";
		import { Ionicons } from "@expo/vector-icons";
		import { useTwinStore } from "../../state/twinStore";
		import { getNeonAccentColor } from "../../utils/neonColors";
		
		interface ProfileReviewScreenProps {
		  onComplete: () => void;
		  onBack: () => void;
		  onEdit: (step: number) => void;
		}
		
		export const ProfileReviewScreen: React.FC<ProfileReviewScreenProps> = ({ 
		  onComplete, 
		  onBack,
		  onEdit 
		}) => {
		  const { userProfile, setOnboarded } = useTwinStore();
		  const [isCompleting, setIsCompleting] = useState(false);
		  
		  const fadeAnim = useRef(new Animated.Value(0)).current;
		  const slideAnim = useRef(new Animated.Value(50)).current;
		  const completionAnim = useRef(new Animated.Value(0)).current;
		
		  useEffect(() => {
		    Animated.parallel([
		      Animated.timing(fadeAnim, {
		        toValue: 1,
		        duration: 800,
		        useNativeDriver: true,
		      }),
		      Animated.timing(slideAnim, {
		        toValue: 0,
		        duration: 1000,
		        useNativeDriver: true,
		      }),
		    ]).start();
		  }, []);
		
		  const handleComplete = async () => {
		    setIsCompleting(true);
		    
		    // Completion animation
		    Animated.sequence([
		      Animated.timing(completionAnim, {
		        toValue: 1,
		        duration: 800,
		        useNativeDriver: true,
		      }),
		      Animated.timing(completionAnim, {
		        toValue: 0,
		        duration: 400,
		        useNativeDriver: true,
		      }),
		    ]).start(() => {
		      setOnboarded(true);
		      onComplete();
		    });
		  };
		
		  if (!userProfile) {
		    return null;
		  }
		
		  const accentColor = getNeonAccentColor(userProfile.accentColor);
		
		  const profileSections = [
		    {
		      title: "Profile Photo",
		      value: userProfile.profilePicture ? "Photo selected" : "No photo",
		      editStep: 1,
		      icon: "camera" as const,
		    },
		    {
		      title: "Personal Details",
		      value: `${userProfile.name}, ${userProfile.age}, ${userProfile.gender}`,
		      editStep: 2,
		      icon: "person" as const,
		    },
		    {
		      title: "Twin Type",
		      value: userProfile.twinType.charAt(0).toUpperCase() + userProfile.twinType.slice(1),
		      editStep: 3,
		      icon: "people" as const,
		    },
		    {
		      title: "Theme Color",
		      value: userProfile.accentColor.replace('neon-', '').charAt(0).toUpperCase() + 
		             userProfile.accentColor.replace('neon-', '').slice(1),
		      editStep: 4,
		      icon: "color-palette" as const,
		    },
		  ];
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <View className="flex-1">
		          {/* Header */}
		          <View className="flex-row items-center justify-between pt-4 pb-8 px-8">
		            <Pressable
		              onPress={onBack}
		              className="w-10 h-10 rounded-full bg-white/10 items-center justify-center"
		              disabled={isCompleting}
		            >
		              <Ionicons name="chevron-back" size={20} color="white" />
		            </Pressable>
		            
		            <View className="flex-1 items-center">
		              <Text className="text-white/60 text-sm">Step 5 of 5</Text>
		              <View className="flex-row mt-2 space-x-1">
		                {[...Array(5)].map((_, i) => (
		                  <View 
		                    key={i} 
		                    className="h-1 w-8 rounded-full bg-white"
		                  />
		                ))}
		              </View>
		            </View>
		            
		            <View className="w-10" />
		          </View>
		
		          <ScrollView className="flex-1 px-8" showsVerticalScrollIndicator={false}>
		            <Animated.View 
		              style={{
		                opacity: fadeAnim,
		                transform: [{ translateY: slideAnim }],
		              }}
		            >
		              {/* Completion Symbol */}
		              <View className="items-center mb-8">
		                <View className="relative">
		                  <View 
		                    className="w-24 h-24 rounded-full border-4 items-center justify-center"
		                    style={{ 
		                      borderColor: accentColor + '60',
		                      backgroundColor: accentColor + '20'
		                    }}
		                  >
		                    {userProfile.profilePicture ? (
		                      <Image 
		                        source={{ uri: userProfile.profilePicture }} 
		                        className="w-20 h-20 rounded-full"
		                      />
		                    ) : (
		                      <Ionicons name="person" size={32} color={accentColor} />
		                    )}
		                  </View>
		                  <View 
		                    className="absolute -inset-2 w-28 h-28 rounded-full border"
		                    style={{ borderColor: accentColor + '30' }}
		                  />
		                  <View 
		                    className="absolute -inset-4 w-32 h-32 rounded-full border"
		                    style={{ borderColor: accentColor + '10' }}
		                  />
		                </View>
		              </View>
		
		              <Text className="text-white text-3xl font-bold text-center mb-4">
		                Profile Complete
		              </Text>
		              
		              <Text className="text-white/70 text-base text-center mb-12 leading-6">
		                Review your information below. Everything looks perfect? Let's begin your twin journey!
		              </Text>
		
		              {/* Profile Summary */}
		              <View className="space-y-4 mb-8">
		                {profileSections.map((section, index) => (
		                  <View 
		                    key={index}
		                    className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 border border-white/20"
		                  >
		                    <View className="flex-row items-center justify-between">
		                      <View className="flex-row items-center flex-1">
		                        <View 
		                          className="w-12 h-12 rounded-full items-center justify-center mr-4"
		                          style={{ backgroundColor: accentColor + '30' }}
		                        >
		                          <Ionicons 
		                            name={section.icon} 
		                            size={20} 
		                            color={accentColor}
		                          />
		                        </View>
		                        <View className="flex-1">
		                          <Text className="text-white text-lg font-semibold mb-1">
		                            {section.title}
		                          </Text>
		                          <Text className="text-white/70 text-sm">
		                            {section.value}
		                          </Text>
		                        </View>
		                      </View>
		                      
		                      <Pressable
		                        onPress={() => onEdit(section.editStep)}
		                        className="w-8 h-8 rounded-full bg-white/10 items-center justify-center"
		                        disabled={isCompleting}
		                      >
		                        <Ionicons name="pencil" size={14} color="rgba(255,255,255,0.6)" />
		                      </Pressable>
		                    </View>
		                  </View>
		                ))}
		              </View>
		
		              {/* Optional Information */}
		              {(userProfile.sexualOrientation || userProfile.placeOfBirth || userProfile.timeOfBirth) && (
		                <View className="bg-white/5 rounded-2xl p-6 mb-8 border border-white/10">
		                  <Text className="text-white text-lg font-semibold mb-4">
		                    ✨ Additional Details
		                  </Text>
		                  
		                  {userProfile.sexualOrientation && (
		                    <View className="flex-row justify-between items-center mb-3">
		                      <Text className="text-white/60 text-sm">Sexual Orientation</Text>
		                      <Text className="text-white text-sm">
		                        {userProfile.sexualOrientation}
		                        {!userProfile.showSexualOrientation && " (Private)"}
		                      </Text>
		                    </View>
		                  )}
		                  
		                  {userProfile.placeOfBirth && (
		                    <View className="flex-row justify-between items-center mb-3">
		                      <Text className="text-white/60 text-sm">Place of Birth</Text>
		                      <Text className="text-white text-sm">{userProfile.placeOfBirth}</Text>
		                    </View>
		                  )}
		                  
		                  {userProfile.timeOfBirth && (
		                    <View className="flex-row justify-between items-center">
		                      <Text className="text-white/60 text-sm">Time of Birth</Text>
		                      <Text className="text-white text-sm">{userProfile.timeOfBirth}</Text>
		                    </View>
		                  )}
		                </View>
		              )}
		
		              {/* Privacy Promise */}
		              <View className="bg-white/5 rounded-2xl p-6 mb-8 border border-white/10">
		                <View className="flex-row items-start">
		                  <Ionicons name="shield-checkmark" size={24} color="#4ade80" className="mr-4 mt-1" />
		                  <View className="flex-1">
		                    <Text className="text-white text-base font-semibold mb-2">
		                      Our Privacy Promise
		                    </Text>
		                    <Text className="text-white/60 text-sm leading-6">
		                      Your information is protected with the highest level of security and privacy. 
		                      Only you and your twin will have access to your shared space. 
		                      We never sell or share your personal data.
		                    </Text>
		                  </View>
		                </View>
		              </View>
		            </Animated.View>
		          </ScrollView>
		
		          {/* Complete Button */}
		          <View className="px-8 pb-8">
		            <Pressable
		              onPress={handleComplete}
		              disabled={isCompleting}
		              className="rounded-full py-4 items-center border-2 relative overflow-hidden"
		              style={{
		                backgroundColor: accentColor + '30',
		                borderColor: accentColor + '60',
		                opacity: isCompleting ? 0.8 : 1,
		              }}
		            >
		              <LinearGradient
		                colors={[
		                  accentColor + '40',
		                  accentColor + '20'
		                ]}
		                className="absolute inset-0 rounded-full"
		              />
		              
		              {/* Completion Animation Overlay */}
		              <Animated.View
		                style={{
		                  position: 'absolute',
		                  top: 0,
		                  left: 0,
		                  right: 0,
		                  bottom: 0,
		                  backgroundColor: accentColor + '80',
		                  opacity: completionAnim,
		                }}
		                className="rounded-full items-center justify-center"
		              >
		                <Ionicons name="checkmark-circle" size={32} color="white" />
		              </Animated.View>
		              
		              {isCompleting ? (
		                <View className="flex-row items-center">
		                  <View className="w-6 h-6 rounded-full border-2 border-white border-t-transparent animate-spin mr-3" />
		                  <Text className="text-white text-lg font-semibold">
		                    Setting up your account...
		                  </Text>
		                </View>
		              ) : (
		                <View className="flex-row items-center">
		                  <Ionicons name="sparkles" size={20} color="white" className="mr-3" />
		                  <Text className="text-white text-lg font-semibold">
		                    Begin Twin Journey
		                  </Text>
		                </View>
		              )}
		            </Pressable>
		          </View>
		        </View>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/onboarding/TwinTypeScreen.tsx'><![CDATA[
		import React, { useState, useRef, useEffect } from "react";
		import { View, Text, Pressable, ScrollView, Animated, TextInput, ImageBackground } from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { TwinTypeSelector } from "../../components/onboarding/TwinTypeSelector";
		import { LinearGradient } from "expo-linear-gradient";
		import { Ionicons } from "@expo/vector-icons";
		import { useTwinStore, TwinType } from "../../state/twinStore";
		
		interface TwinTypeScreenProps {
		  onContinue: () => void;
		  onBack: () => void;
		}
		
		export const TwinTypeScreen: React.FC<TwinTypeScreenProps> = ({ 
		  onContinue, 
		  onBack 
		}) => {
		  const { userProfile, setUserProfile } = useTwinStore();
		  const [selectedType, setSelectedType] = useState<TwinType | null>(
		    userProfile?.twinType || null
		  );
		  const [showInfo, setShowInfo] = useState(false);
		  const [otherTypeDescription, setOtherTypeDescription] = useState("");
		  const [twinDeceased, setTwinDeceased] = useState(false);
		  
		  const fadeAnim = useRef(new Animated.Value(0)).current;
		
		  useEffect(() => {
		    Animated.timing(fadeAnim, {
		      toValue: 1,
		      duration: 800,
		      useNativeDriver: true,
		    }).start();
		  }, []);
		
		  const handleContinue = () => {
		    if (!selectedType || !userProfile) return;
		    
		    // If "other" is selected but no description provided, don't continue
		    if (selectedType === "other" && !otherTypeDescription.trim()) return;
		
		    setUserProfile({
		      ...userProfile,
		      twinType: selectedType,
		      // Store additional twin type info for future use
		      otherTwinTypeDescription: selectedType === "other" ? otherTypeDescription.trim() : undefined,
		      twinDeceased: twinDeceased,
		    });
		    onContinue();
		  };
		
		  const twinTypes = [
		    {
		      type: "identical" as TwinType,
		      title: "Identical Twins",
		      subtitle: "Monozygotic • Same DNA",
		      description: "Formed from one fertilized egg that splits into two. You share 100% of your genetic material and are always the same biological sex.",
		      icon: "people" as const,
		      features: [
		        "Share identical DNA",
		        "Same biological sex",
		        "Often look very similar",
		        "May have stronger intuitive connection"
		      ]
		    },
		    {
		      type: "fraternal" as TwinType,
		      title: "Fraternal Twins",
		      subtitle: "Dizygotic • Different DNA",
		      description: "Formed from two separate fertilized eggs. You share about 50% of your genetic material, like regular siblings, but were born at the same time.",
		      icon: "people-outline" as const,
		      features: [
		        "Share ~50% of DNA",
		        "Can be different sexes",
		        "May look different",
		        "Unique twin bond regardless"
		      ]
		    },
		    {
		      type: "other" as TwinType,
		      title: "Other Twin Type",
		      subtitle: "Special circumstances",
		      description: "This includes semi-identical twins, conjoined twins who were separated, twins with different fathers, or other unique twin circumstances.",
		      icon: "heart" as const,
		      features: [
		        "Unique twin situation",
		        "Special bond regardless",
		        "Every twin story matters",
		        "Celebrated here equally"
		      ]
		    }
		  ];
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <View className="flex-1">
		          {/* Header */}
		          <View className="flex-row items-center justify-between pt-4 pb-8 px-8">
		            <Pressable
		              onPress={onBack}
		              className="w-10 h-10 rounded-full bg-white/10 items-center justify-center"
		            >
		              <Ionicons name="chevron-back" size={20} color="white" />
		            </Pressable>
		            
		            <View className="flex-1 items-center">
		              <Text className="text-white/60 text-sm">Step 3 of 5</Text>
		              <View className="flex-row mt-2 space-x-1">
		                {[...Array(5)].map((_, i) => (
		                  <View 
		                    key={i} 
		                    className={`h-1 w-8 rounded-full ${
		                      i <= 2 ? 'bg-white' : 'bg-white/20'
		                    }`} 
		                  />
		                ))}
		              </View>
		            </View>
		            
		            <Pressable
		              onPress={() => setShowInfo(!showInfo)}
		              className="w-10 h-10 rounded-full bg-white/10 items-center justify-center"
		            >
		              <Ionicons name="information-circle" size={20} color="white" />
		            </Pressable>
		          </View>
		
		          <ScrollView className="flex-1 px-8" showsVerticalScrollIndicator={false}>
		            <Animated.View style={{ opacity: fadeAnim }}>
		              {/* Twin Symbol */}
		              <View className="items-center mb-8">
		                <View className="relative">
		                  <View className="w-20 h-20 rounded-full border-2 border-white/30 items-center justify-center">
		                    <View className="flex-row">
		                      <View className="w-6 h-6 rounded-full bg-white/50 mr-1" />
		                      <View className="w-6 h-6 rounded-full bg-white/50" />
		                    </View>
		                  </View>
		                  <View className="absolute -inset-1 w-22 h-22 rounded-full border border-white/10" />
		                </View>
		              </View>
		
		              <Text className="text-white text-3xl font-bold text-center mb-4">
		                Your Twin Connection
		              </Text>
		              
		              <Text className="text-white/70 text-base text-center mb-12 leading-6">
		                Understanding your twin type helps us personalize your experience and connect you with relevant research and insights.
		              </Text>
		
		              {/* Information Panel */}
		              {showInfo && (
		                <Animated.View className="bg-white/10 backdrop-blur-sm rounded-2xl p-6 mb-8 border border-white/20">
		                  <Text className="text-white text-lg font-semibold mb-4">
		                    🧬 Twin Science Made Simple
		                  </Text>
		                  <Text className="text-white/70 text-sm leading-6">
		                    Twin type affects various aspects of your shared experience, from genetics to psychology. Research shows that identical twins often have stronger synchronized behaviors and may share more intuitive connections, while fraternal twins bring unique perspectives from their genetic diversity. Both types create special bonds that are stronger than ordinary sibling relationships.
		                  </Text>
		                </Animated.View>
		              )}
		
		              {/* Twin Type Options */}
		              <View className="space-y-4 mb-8">
		                {twinTypes.map((twinType) => (
		                  <TwinTypeSelector
		                    key={twinType.type}
		                    twinType={twinType}
		                    isSelected={selectedType === twinType.type}
		                    onSelect={(type) => setSelectedType(type)}
		                    showDetails={selectedType === twinType.type}
		                  />
		                ))}
		              </View>
		
		              {/* Other Twin Type Description */}
		              {selectedType === "other" && (
		                <View className="mb-8">
		                  <Text className="text-white text-lg mb-3 font-semibold">
		                    Please describe your twin type
		                  </Text>
		                  <TextInput
		                    value={otherTypeDescription}
		                    onChangeText={setOtherTypeDescription}
		                    placeholder="e.g., Semi-identical twins, twins with different fathers, etc."
		                    placeholderTextColor="rgba(255,255,255,0.4)"
		                    className="bg-white/10 backdrop-blur-sm rounded-xl px-4 py-4 text-white text-base border border-white/20"
		                    multiline
		                    numberOfLines={3}
		                    textAlignVertical="top"
		                    autoCapitalize="sentences"
		                  />
		                </View>
		              )}
		
		              {/* Deceased Twin Option - Very Sensitive */}
		              <View className="bg-white/5 rounded-xl p-6 mb-8 border border-white/10">
		                <Pressable
		                  onPress={() => setTwinDeceased(!twinDeceased)}
		                  className="flex-row items-start"
		                >
		                  <View className={`w-6 h-6 rounded border-2 mr-4 mt-0.5 items-center justify-center ${
		                    twinDeceased 
		                      ? 'bg-white/20 border-white/50' 
		                      : 'border-white/30'
		                  }`}>
		                    {twinDeceased && (
		                      <Ionicons name="checkmark" size={16} color="white" />
		                    )}
		                  </View>
		                  <View className="flex-1">
		                    <Text className="text-white text-base font-medium mb-2">
		                      My twin has passed away
		                    </Text>
		                    <Text className="text-white/70 text-sm leading-6 mb-3">
		                      We understand this is an incredibly difficult journey. Your twin connection remains sacred and meaningful, and we're honored to help you preserve those precious memories and celebrate the bond you shared.
		                    </Text>
		                    <View className="bg-amber-500/20 rounded-lg p-3 border border-amber-500/30">
		                      <Text className="text-amber-200 text-xs font-medium mb-1">
		                        💛 Special Features Coming Soon
		                      </Text>
		                      <Text className="text-amber-100/80 text-xs leading-5">
		                        We're thoughtfully developing dedicated memorial features, memory sharing tools, and grief support resources specifically for twins who have experienced loss. These will be available in a future update.
		                      </Text>
		                    </View>
		                  </View>
		                </Pressable>
		              </View>
		
		              {/* Reassurance */}
		              <View className="bg-white/5 rounded-xl p-6 mb-8 border border-white/10">
		                <View className="flex-row items-start">
		                  <Ionicons name="heart" size={20} color="#ff69b4" className="mr-3 mt-1" />
		                  <View className="flex-1">
		                    <Text className="text-white text-base font-medium mb-2">
		                      Every Twin Bond is Special
		                    </Text>
		                    <Text className="text-white/60 text-sm leading-6">
		                      Regardless of your twin type, your connection is unique and valuable. Twinship celebrates all forms of twinship and provides personalized experiences for every type of twin relationship.
		                    </Text>
		                  </View>
		                </View>
		              </View>
		            </Animated.View>
		          </ScrollView>
		
		          {/* Continue Button */}
		          <View className="px-8 pb-8">
		            <Pressable
		              onPress={handleContinue}
		              disabled={!selectedType || (selectedType === "other" && !otherTypeDescription.trim())}
		              className={`rounded-full py-4 items-center border ${
		                selectedType && !(selectedType === "other" && !otherTypeDescription.trim())
		                  ? 'bg-white/20 border-white/30' 
		                  : 'bg-white/5 border-white/10'
		              }`}
		              style={({ pressed }) => ({
		                opacity: pressed ? 0.8 : 1,
		                transform: [{ scale: pressed ? 0.98 : 1 }],
		              })}
		            >
		              <LinearGradient
		                colors={selectedType && !(selectedType === "other" && !otherTypeDescription.trim())
		                  ? ['rgba(255,255,255,0.3)', 'rgba(255,255,255,0.1)']
		                  : ['rgba(255,255,255,0.05)', 'rgba(255,255,255,0.02)']
		                }
		                className="absolute inset-0 rounded-full"
		              />
		              <Text className={`text-lg font-semibold ${
		                selectedType && !(selectedType === "other" && !otherTypeDescription.trim()) ? 'text-white' : 'text-white/40'
		              }`}>
		                Continue
		              </Text>
		            </Pressable>
		          </View>
		        </View>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/onboarding/WelcomeScreen.tsx'><![CDATA[
		import React, { useEffect, useRef } from "react";
		import { View, Text, Pressable, Animated, Dimensions, Image, ImageBackground } from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { LinearGradient } from "expo-linear-gradient";
		
		interface WelcomeScreenProps {
		  onContinue: () => void;
		}
		
		const { width, height } = Dimensions.get('window');
		
		export const WelcomeScreen: React.FC<WelcomeScreenProps> = ({ onContinue }) => {
		  const fadeAnim = useRef(new Animated.Value(0)).current;
		  const scaleAnim = useRef(new Animated.Value(0.9)).current;
		  const titleAnim = useRef(new Animated.Value(50)).current;
		  const subtitleAnim = useRef(new Animated.Value(30)).current;
		  const buttonAnim = useRef(new Animated.Value(20)).current;
		
		  useEffect(() => {
		    const sequence = Animated.sequence([
		      Animated.parallel([
		        Animated.timing(fadeAnim, {
		          toValue: 1,
		          duration: 1000,
		          useNativeDriver: true,
		        }),
		        Animated.timing(scaleAnim, {
		          toValue: 1,
		          duration: 1000,
		          useNativeDriver: true,
		        }),
		      ]),
		      Animated.timing(titleAnim, {
		        toValue: 0,
		        duration: 800,
		        useNativeDriver: true,
		      }),
		      Animated.timing(subtitleAnim, {
		        toValue: 0,
		        duration: 600,
		        useNativeDriver: true,
		      }),
		      Animated.timing(buttonAnim, {
		        toValue: 0,
		        duration: 400,
		        useNativeDriver: true,
		      }),
		    ]);
		    
		    sequence.start();
		  }, []);
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <View className="flex-1 justify-center items-center px-8">
		          {/* Twinship Logo */}
		          <Animated.View 
		            style={{
		              opacity: fadeAnim,
		              transform: [{ scale: scaleAnim }],
		            }}
		            className="mb-12"
		          >
		            <Image 
		              source={require('../../../assets/twinshipAppIcon.png')}
		              style={{ width: 200, height: 200 }}
		              resizeMode="contain"
		            />
		          </Animated.View>
		
		
		          {/* Continue Button with tagline */}
		          <Animated.View 
		            style={{ 
		              transform: [{ translateY: buttonAnim }] 
		            }}
		            className="w-full"
		          >
		            <Pressable
		              onPress={onContinue}
		              className="bg-white/20 backdrop-blur-sm rounded-full py-4 items-center mx-8 border border-white/30"
		              style={({ pressed }) => ([
		                {
		                  opacity: pressed ? 0.8 : 1,
		                  transform: [{ scale: pressed ? 0.98 : 1 }],
		                }
		              ])}
		            >
		              <LinearGradient
		                colors={['rgba(255,255,255,0.3)', 'rgba(255,255,255,0.1)']}
		                className="absolute inset-0 rounded-full"
		              />
		              <Text className="text-white text-lg font-semibold tracking-wide">
		                To twinfinity...and beyond!
		              </Text>
		            </Pressable>
		          </Animated.View>
		        </View>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/OnboardingScreen.tsx'><![CDATA[
		import React, { useState } from "react";
		import { View } from "react-native";
		import { useTwinStore } from "../state/twinStore";
		
		// Import all onboarding screens
		import { WelcomeScreen } from "./onboarding/WelcomeScreen";
		import { PhotoSetupScreen } from "./onboarding/PhotoSetupScreen";
		import { PersonalDetailsScreen } from "./onboarding/PersonalDetailsScreen";
		import { TwinTypeScreen } from "./onboarding/TwinTypeScreen";
		import { ColorSelectionScreen } from "./onboarding/ColorSelectionScreen";
		import { ProfileReviewScreen } from "./onboarding/ProfileReviewScreen";
		
		interface OnboardingScreenProps {
		  onComplete: () => void;
		}
		
		export const OnboardingScreen: React.FC<OnboardingScreenProps> = ({
		  onComplete,
		}) => {
		  const [currentStep, setCurrentStep] = useState(0);
		  const { userProfile } = useTwinStore();
		
		  const handleNext = () => {
		    setCurrentStep(prev => prev + 1);
		  };
		
		  const handleBack = () => {
		    setCurrentStep(prev => Math.max(0, prev - 1));
		  };
		
		  const handleEdit = (step: number) => {
		    setCurrentStep(step - 1); // Convert to 0-based index
		  };
		
		  const handleComplete = () => {
		    onComplete();
		  };
		
		  const screens = [
		    <WelcomeScreen key="welcome" onContinue={handleNext} />,
		    <PhotoSetupScreen key="photo" onContinue={handleNext} onBack={handleBack} />,
		    <PersonalDetailsScreen key="details" onContinue={handleNext} onBack={handleBack} />,
		    <TwinTypeScreen key="twintype" onContinue={handleNext} onBack={handleBack} />,
		    <ColorSelectionScreen key="color" onContinue={handleNext} onBack={handleBack} />,
		    <ProfileReviewScreen 
		      key="review" 
		      onComplete={handleComplete} 
		      onBack={handleBack} 
		      onEdit={handleEdit}
		    />,
		  ];
		
		  return (
		    <View className="flex-1">
		      {screens[currentStep]}
		    </View>
		  );
		};]]></file>
	<file path='screens/PairScreen.tsx'><![CDATA[
		import React, { useMemo, useState, useEffect } from "react";
		import { View, Text, Pressable, TextInput, ImageBackground } from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { useNavigation } from "@react-navigation/native";
		import { Ionicons } from "@expo/vector-icons";
		
		import { useTwinStore, useTempTwinStore, TwinProfile, TwinType, ThemeColor } from "../state/twinStore";
		import * as Clipboard from "expo-clipboard";
		import * as Haptics from "expo-haptics";
		import { v4 as uuidv4 } from "uuid";
		
		export const PairScreen = () => {
		  console.log("=== PairScreen component rendering ===");
		  const navigation = useNavigation<any>();
		  const { themeColor, shareCode, setShareCode, paired, setPaired, userProfile, twinProfile } = useTwinStore();
		  const { setConnectionStatus } = useTempTwinStore();
		  const [enteredCode, setEnteredCode] = useState("");
		  const [statusText, setStatusText] = useState("");
		  
		  console.log("Current state - enteredCode:", enteredCode, "paired:", paired, "statusText:", statusText);
		
		  const code = useMemo(() => {
		    if (shareCode) return shareCode;
		    const generated = uuidv4().split("-")[0].toUpperCase();
		    setShareCode(generated);
		    return generated;
		  }, [shareCode]);
		
		  const copyCode = async () => {
		    await Clipboard.setStringAsync(code);
		    setStatusText("Code copied. Share with your twin.");
		    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		  };
		
		  const ensureDevUser = (name: string = "Jordan") => {
		    const state = useTwinStore.getState();
		    if (!state.userProfile) {
		      const devUser: TwinProfile = {
		        id: "test-user-" + Date.now(),
		        name,
		        age: 26,
		        gender: "Non-binary",
		        twinType: "identical" as TwinType,
		        birthDate: new Date().toISOString(),
		        accentColor: "neon-purple" as ThemeColor,
		        isConnected: true,
		      };
		      state.setUserProfile(devUser);
		    }
		  };
		
		  const createDevPair = (meName: string, twinName: string) => {
		    console.log("createDevPair called with:", meName, twinName);
		    const state = useTwinStore.getState();
		    ensureDevUser(meName);
		    const me: TwinProfile = {
		      id: "test-user-" + Date.now(),
		      name: meName,
		      age: 26,
		      gender: "Non-binary",
		      twinType: "identical" as TwinType,
		      birthDate: new Date().toISOString(),
		      accentColor: "neon-purple" as ThemeColor,
		      isConnected: true,
		    };
		    state.setUserProfile(me);
		
		    const accent: ThemeColor = (meName === "Alex" ? "neon-pink" : "neon-purple") as ThemeColor;
		    const mockTwin: TwinProfile = {
		      id: "test-twin-" + Date.now(),
		      name: twinName,
		      age: 25,
		      gender: "Non-binary",
		      twinType: "identical" as TwinType,
		      birthDate: new Date().toISOString(),
		      accentColor: accent,
		      isConnected: true,
		      lastSeen: new Date().toISOString()
		    };
		
		    console.log("Created mock twin:", mockTwin);
		    state.setTwinProfile(mockTwin);
		    setPaired(true);
		    setConnectionStatus("connected");
		    setStatusText(`Connected to test twin: ${mockTwin.name}! 🎉`);
		    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		
		    setTimeout(() => {
		      const { useChatStore } = require('../state/chatStore');
		      const chatStore = useChatStore.getState();
		      chatStore.addMessage({
		        text: `Hey twin! I'm ${mockTwin.name}. This is a dev pairing.`,
		        senderId: mockTwin.id,
		        senderName: mockTwin.name,
		        type: 'text' as const,
		      });
		    }, 400);
		
		    setTimeout(() => {
		      console.log("About to navigate to TwinTalk from createDevPair");
		      navigation.navigate("TwinTalk");
		    }, 1000);
		  };
		
		  const createTestTwin = () => {
		    // Create a mock twin profile for testing
		    const mockTwin: TwinProfile = {
		      id: "test-twin-" + Date.now(),
		      name: userProfile?.name === "Alex" ? "Jordan" : "Alex",
		      age: userProfile?.age ? userProfile.age + Math.floor(Math.random() * 3) - 1 : 25,
		      gender: userProfile?.gender === "Male" ? "Female" : userProfile?.gender === "Female" ? "Male" : "Non-binary",
		      twinType: (userProfile?.twinType || "identical") as TwinType,
		      birthDate: userProfile?.birthDate || new Date().toISOString(),
		      accentColor: (userProfile?.accentColor === "neon-purple" ? "neon-pink" : "neon-purple") as ThemeColor,
		      isConnected: true,
		      lastSeen: new Date().toISOString()
		    };
		    
		    useTwinStore.getState().setTwinProfile(mockTwin);
		    setPaired(true);
		    setConnectionStatus("connected");
		    setStatusText(`Connected to test twin: ${mockTwin.name}! 🎉`);
		    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		    
		    // Send welcome message from test twin
		    setTimeout(() => {
		      const { useChatStore } = require('../state/chatStore');
		      const chatStore = useChatStore.getState();
		      
		      const welcomeMessage = {
		        id: Date.now().toString() + Math.random().toString(36),
		        text: `Hey twin! 👋 I'm your test twin ${mockTwin.name}. I'm here to chat and test all the amazing twin features with you! Try sending me a message - I'll respond with that magical twin telepathy! ✨💫`,
		        senderId: mockTwin.id,
		        senderName: mockTwin.name,
		        timestamp: new Date().toISOString(),
		        type: 'text' as const,
		        isDelivered: true,
		        isRead: false,
		        reactions: [],
		      };
		      
		      chatStore.addMessage(welcomeMessage);
		    }, 500);
		    
		    // Auto-navigate to Twin Talk after successful test pairing
		    setTimeout(() => {
		      navigation.navigate("TwinTalk");
		    }, 1500); // Short delay to show success message
		  };
		
		  const connect = async () => {
		    console.log("=== CONNECT FUNCTION CALLED ===");
		    console.log("enteredCode:", enteredCode);
		    console.log("enteredCode length:", enteredCode.length);
		    console.log("enteredCode type:", typeof enteredCode);
		    
		    // Simple test first - just update status text
		    setStatusText("Button clicked! Processing...");
		    
		    const cleaned = enteredCode.trim();
		    console.log("cleaned code:", cleaned);
		    console.log("cleaned code length:", cleaned.length);
		    
		    if (!cleaned) {
		      console.log("No code entered");
		      setStatusText("Enter your twin's code to connect.");
		      return;
		    }
		    
		    console.log("Cleaned code:", cleaned);
		    console.log("Checking if code is TEST:", cleaned.toUpperCase() === "TEST");
		    
		    // Special test codes for development
		    if (cleaned.toUpperCase() === "TEST") {
		      console.log("TEST code detected, creating dev pair");
		      setStatusText("TEST code detected! Creating dev pair...");
		      // Default: you as Jordan, twin as Alex
		      try {
		        createDevPair("Jordan", "Alex");
		      } catch (error) {
		        console.error("Error in createDevPair:", error);
		        setStatusText("Error creating dev pair: " + String(error));
		      }
		      return;
		    }
		    if (cleaned.toUpperCase() === "TESTTWIN") {
		      console.log("TESTTWIN code detected, creating dev pair");
		      setStatusText("TESTTWIN code detected! Creating dev pair...");
		      // Swap roles: you as Alex, twin as Jordan
		      try {
		        createDevPair("Alex", "Jordan");
		      } catch (error) {
		        console.error("Error in createDevPair:", error);
		        setStatusText("Error creating dev pair: " + String(error));
		      }
		      return;
		    }
		    
		    console.log("Regular code path, setting connected status");
		    // For MVP demo, accept any non-empty code
		    setPaired(true);
		    setConnectionStatus("connected");
		    setStatusText("Connected! You can start chatting.");
		    
		    try {
		      Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		    } catch (error) {
		      console.error("Haptics error:", error);
		    }
		    
		    // Auto-navigate to Twin Talk after successful pairing
		    setTimeout(() => {
		      console.log("Navigating to TwinTalk");
		      try {
		        navigation.navigate("TwinTalk");
		      } catch (error) {
		        console.error("Navigation error:", error);
		        setStatusText("Navigation error: " + String(error));
		      }
		    }, 1500); // Short delay to show success message
		  };
		
		  const disconnect = () => {
		    setPaired(false);
		    setConnectionStatus("disconnected");
		    setStatusText("Disconnected.");
		    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
		  };
		
		  // Auto-navigate to TwinTalk when successfully paired
		  useEffect(() => {
		    if (paired && userProfile && twinProfile) {
		      const timer = setTimeout(() => {
		        navigation.navigate("TwinTalk");
		      }, 1200); // Short delay to show success message
		      
		      return () => clearTimeout(timer);
		    }
		  }, [paired, userProfile, twinProfile, navigation]);
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <View className="flex-1 px-6">
		          {/* Header */}
		          <View className="flex-row items-center justify-between py-4">
		            <Pressable onPress={() => navigation.goBack()} className="w-10 h-10 rounded-full bg-white/10 items-center justify-center">
		              <Ionicons name="chevron-back" size={20} color="white" />
		            </Pressable>
		            <Text className="text-white text-xl font-bold flex-1 text-center">Pair with Your Twin</Text>
		            {paired && (
		              <Pressable onPress={disconnect} className="bg-white/10 rounded-full px-3 py-2">
		                <Text className="text-white">Disconnect</Text>
		              </Pressable>
		            )}
		          </View>
		
		          {/* Share Code */}
		          <View className="bg-white/10 rounded-xl p-6 mb-6 items-center">
		            <Text className="text-white/70">Your Share Code</Text>
		            <Text className="text-white text-4xl font-extrabold tracking-widest mt-2">{code}</Text>
		            <Pressable onPress={copyCode} className="mt-4 bg-white/20 px-4 py-2 rounded-full">
		              <Text className="text-white font-semibold">Copy Code</Text>
		            </Pressable>
		            <Text className="text-white/60 text-sm mt-3 text-center">
		              Ask your twin to enter this code on their device to connect.
		            </Text>
		          </View>
		
		          {/* Enter Twin Code */}
		          <View className="bg-white/10 rounded-xl p-6 mb-4">
		            <Text className="text-white text-lg font-semibold mb-3">Enter Twin's Code</Text>
		            <TextInput
		              value={enteredCode}
		              onChangeText={(text) => {
		                console.log("Text changed to:", text);
		                setEnteredCode(text);
		              }}
		              onSubmitEditing={() => {
		                console.log("Enter key pressed, calling connect");
		                connect();
		              }}
		              placeholder="e.g. 9F2C7A"
		              placeholderTextColor="rgba(255,255,255,0.5)"
		              className="bg-white/10 rounded-xl px-4 py-4 text-white text-lg tracking-widest"
		              autoCapitalize="characters"
		              maxLength={8}
		              returnKeyType="go"
		              blurOnSubmit={false}
		            />
		            <Pressable 
		              onPress={() => {
		                console.log("Continue button pressed!");
		                console.log("Current enteredCode:", enteredCode);
		                try {
		                  connect();
		                } catch (error) {
		                  console.error("Error in connect function:", error);
		                }
		              }}
		              onPressIn={() => console.log("Button press started")}
		              onPressOut={() => console.log("Button press ended")}
		              className="mt-4 bg-purple-500 rounded-xl py-3 items-center"
		              style={({ pressed }) => [
		                {
		                  opacity: pressed ? 0.8 : 1,
		                  transform: [{ scale: pressed ? 0.98 : 1 }],
		                  zIndex: 1000
		                }
		              ]}
		              hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
		            >
		              <Text className="text-white font-semibold">Continue</Text>
		            </Pressable>
		            {statusText.length > 0 && (
		              <Text className="text-white/70 text-center mt-3">{statusText}</Text>
		            )}
		          </View>
		
		          {/* Development Test Mode */}
		          <View className="bg-yellow-500/10 rounded-xl p-4 border border-yellow-500/30">
		            <Text className="text-yellow-200 text-sm font-medium mb-2">🧪 Development Mode</Text>
		            <Text className="text-yellow-100/80 text-xs leading-5">
		              For testing, enter "TEST" or "TESTTWIN" as the code to instantly connect with a mock twin profile.
		            </Text>
		          </View>
		
		          {/* Status */}
		          <View className="bg-white/5 rounded-xl p-4 mt-2">
		            <Text className="text-white/80">Status</Text>
		            <Text className="text-white text-lg mt-1">{paired ? "Connected" : "Not connected"}</Text>
		            <Text className="text-white/70 text-sm mt-2">
		              {userProfile?.name || "You"} ↔ {twinProfile?.name || "Your Twin"}
		            </Text>
		          </View>
		        </View>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/premium/PremiumDashboardScreen.tsx'><![CDATA[
		import React, { useState, useEffect } from 'react';
		import { View, Text, ScrollView, Pressable, Dimensions, ImageBackground } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { useNavigation } from '@react-navigation/native';
		import { Ionicons } from '@expo/vector-icons';
		import { LinearGradient } from 'expo-linear-gradient';
		
		// Premium components
		import { PremiumGatedContent } from '../../components/premium/PremiumGatedContent';
		import { PremiumStatusIndicator } from '../../components/premium/PremiumStatusIndicator';
		import { PremiumUpgradeButton } from '../../components/premium/PremiumBadge';
		
		// Hooks and utilities
		import { useAnalyticsPremium } from '../../hooks/usePremiumFeatures';
		import { pdfExportService } from '../../utils/pdfExportService';
		
		// Core imports
		import { useTwinStore } from '../../state/twinStore';
		import { useAssessmentStore } from '../../state/assessmentStore';
		import { getNeonAccentColor, getNeonGradientColors } from '../../utils/neonColors';
		
		const { width } = Dimensions.get('window');
		
		// Analytics Card Component
		const AnalyticsCard: React.FC<{
		  title: string;
		  value: string;
		  subtitle?: string;
		  icon: string;
		  color: string;
		  trend?: 'up' | 'down' | 'stable';
		  trendValue?: string;
		}> = ({ title, value, subtitle, icon, color, trend, trendValue }) => {
		  const getTrendIcon = () => {
		    switch (trend) {
		      case 'up': return 'trending-up';
		      case 'down': return 'trending-down';
		      default: return 'remove';
		    }
		  };
		
		  const getTrendColor = () => {
		    switch (trend) {
		      case 'up': return '#10b981';
		      case 'down': return '#ef4444';
		      default: return '#6b7280';
		    }
		  };
		
		  return (
		    <LinearGradient
		      colors={[`${color}20`, `${color}10`, 'transparent']}
		      className="rounded-2xl p-4 border"
		      style={{ borderColor: `${color}40` }}
		    >
		      <View className="flex-row items-center justify-between mb-2">
		        <Ionicons name={icon as any} size={24} color={color} />
		        {trend && trendValue && (
		          <View className="flex-row items-center">
		            <Ionicons name={getTrendIcon() as any} size={16} color={getTrendColor()} />
		            <Text className="text-xs font-bold ml-1" style={{ color: getTrendColor() }}>
		              {trendValue}
		            </Text>
		          </View>
		        )}
		      </View>
		      
		      <Text className="text-white text-2xl font-bold mb-1">{value}</Text>
		      <Text className="text-white text-sm font-medium mb-1">{title}</Text>
		      {subtitle && (
		        <Text className="text-gray-400 text-xs">{subtitle}</Text>
		      )}
		    </LinearGradient>
		  );
		};
		
		// Progress Ring Component
		const ProgressRing: React.FC<{
		  progress: number;
		  size: number;
		  strokeWidth: number;
		  color: string;
		  label: string;
		  value: string;
		}> = ({ progress, size, strokeWidth, color, label, value }) => {
		  const radius = (size - strokeWidth) / 2;
		  const circumference = 2 * Math.PI * radius;
		  const offset = circumference - (progress / 100) * circumference;
		
		  return (
		    <View className="items-center">
		      <View style={{ width: size, height: size }} className="relative">
		        <View className="absolute inset-0 items-center justify-center">
		          <Text className="text-white text-xl font-bold">{value}</Text>
		          <Text className="text-gray-400 text-xs">{label}</Text>
		        </View>
		        
		        {/* Background circle */}
		        <View
		          className="absolute rounded-full border"
		          style={{
		            width: size,
		            height: size,
		            borderWidth: strokeWidth,
		            borderColor: 'rgba(255,255,255,0.1)',
		          }}
		        />
		        
		        {/* Progress circle */}
		        <View
		          className="absolute rounded-full"
		          style={{
		            width: size,
		            height: size,
		            borderWidth: strokeWidth,
		            borderColor: color,
		            borderRadius: size / 2,
		            transform: [{ rotate: '-90deg' }],
		            borderTopColor: 'transparent',
		            borderRightColor: offset > circumference * 0.75 ? 'transparent' : color,
		            borderBottomColor: offset > circumference * 0.5 ? 'transparent' : color,
		            borderLeftColor: offset > circumference * 0.25 ? 'transparent' : color,
		          }}
		        />
		      </View>
		    </View>
		  );
		};
		
		export const PremiumDashboardScreen: React.FC = () => {
		  const navigation = useNavigation<any>();
		  const { userProfile, twinProfile } = useTwinStore();
		  const { getAllResults } = useAssessmentStore();
		  
		  const {
		    canViewAdvancedAnalytics,
		    canRetakeAssessments,
		    requireAdvancedAnalytics,
		    navigateToUpgrade
		  } = useAnalyticsPremium();
		  
		  const [selectedTimeframe, setSelectedTimeframe] = useState<'week' | 'month' | 'all'>('month');
		  
		  const themeColor = userProfile?.accentColor || 'neon-purple';
		  const neonColor = getNeonAccentColor(themeColor);
		  const [gradientStart, gradientMid] = getNeonGradientColors(themeColor);
		  
		  // Mock analytics data (in production, this would come from your analytics service)
		  const analyticsData = {
		    syncScore: 87,
		    communicationTrend: '+12%',
		    conflictResolution: 85,
		    growthScore: 92,
		    assessmentsCompleted: 3,
		    recommendationsFollowed: 8,
		    streakDays: 21,
		    twinCompatibility: 94
		  };
		
		  const handleRetakeAssessment = () => {
		    if (!canRetakeAssessments) {
		      navigateToUpgrade('unlimited_assessments', 'retake_button');
		      return;
		    }
		    navigation.navigate('AssessmentIntro');
		  };
		
		  const handleExportReport = async () => {
		    if (!canViewAdvancedAnalytics) {
		      navigateToUpgrade('twin_analytics', 'export_report');
		      return;
		    }
		    
		    // Implementation would export comprehensive analytics report
		    try {
		      const results = getAllResults();
		      if (results.length === 0) return;
		      
		      // Use latest results for export
		      const latestResults = results[0];
		      await pdfExportService.shareAssessmentPDF({
		        personalityScores: latestResults.personalityScores.reduce((acc, score) => {
		          acc[score.trait] = score.value;
		          return acc;
		        }, {} as Record<string, number>),
		        twinDynamics: {
		          syncScore: analyticsData.syncScore,
		          communicationTrend: analyticsData.communicationTrend,
		          conflictResolution: analyticsData.conflictResolution
		        },
		        recommendations: latestResults.recommendations.map(r => r.description),
		        timestamp: latestResults.timestamp,
		        userProfile: {
		          name: userProfile?.name || 'User',
		          twinType: userProfile?.twinType || 'unknown'
		        },
		        twinProfile: twinProfile ? { name: twinProfile.name } : undefined
		      });
		    } catch (error) {
		      console.error('Export failed:', error);
		    }
		  };
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <ScrollView className="flex-1 px-6">
		          {/* Header */}
		          <View className="flex-row items-center justify-between pt-4 pb-6">
		            <Pressable onPress={() => navigation.goBack()}>
		              <Ionicons name="arrow-back" size={24} color="white" />
		            </Pressable>
		            <View className="flex-1 items-center">
		              <Text className="text-white text-xl font-semibold">Twin Analytics</Text>
		              <PremiumStatusIndicator variant="minimal" />
		            </View>
		            <Pressable onPress={handleExportReport}>
		              <Ionicons name="share-outline" size={24} color="white" />
		            </Pressable>
		          </View>
		
		          {/* Timeframe Selector */}
		          <PremiumGatedContent
		            featureId="twin_analytics"
		            gateType="teaser"
		            onUpgradeRequest={() => navigateToUpgrade('twin_analytics', 'dashboard_main')}
		          >
		            <View className="flex-row bg-white/10 rounded-2xl p-1 mb-6">
		              {(['week', 'month', 'all'] as const).map((timeframe) => (
		                <Pressable
		                  key={timeframe}
		                  onPress={() => setSelectedTimeframe(timeframe)}
		                  className={`flex-1 py-2 rounded-xl ${
		                    selectedTimeframe === timeframe ? '' : ''
		                  }`}
		                  style={{
		                    backgroundColor: selectedTimeframe === timeframe ? neonColor : 'transparent'
		                  }}
		                >
		                  <Text
		                    className={`text-center font-semibold capitalize ${
		                      selectedTimeframe === timeframe ? 'text-black' : 'text-white'
		                    }`}
		                  >
		                    {timeframe === 'all' ? 'All Time' : `This ${timeframe}`}
		                  </Text>
		                </Pressable>
		              ))}
		            </View>
		
		            {/* Key Metrics Grid */}
		            <View className="grid grid-cols-2 gap-4 mb-6">
		              <View className="space-y-4">
		                <AnalyticsCard
		                  title="Twin Sync Score"
		                  value={`${analyticsData.syncScore}%`}
		                  subtitle="Overall connection strength"
		                  icon="heart"
		                  color={neonColor}
		                  trend="up"
		                  trendValue="+5%"
		                />
		                
		                <AnalyticsCard
		                  title="Communication"
		                  value="Strong"
		                  subtitle={`${analyticsData.communicationTrend} this month`}
		                  icon="chatbubbles"
		                  color="#10b981"
		                  trend="up"
		                  trendValue={analyticsData.communicationTrend}
		                />
		              </View>
		              
		              <View className="space-y-4">
		                <AnalyticsCard
		                  title="Growth Score"
		                  value={`${analyticsData.growthScore}%`}
		                  subtitle="Personal development"
		                  icon="trending-up"
		                  color="#3b82f6"
		                  trend="up"
		                  trendValue="+8%"
		                />
		                
		                <AnalyticsCard
		                  title="Conflict Resolution"
		                  value={`${analyticsData.conflictResolution}%`}
		                  subtitle="Healthy boundary setting"
		                  icon="shield-checkmark"
		                  color="#f59e0b"
		                  trend="stable"
		                  trendValue="0%"
		                />
		              </View>
		            </View>
		
		            {/* Progress Rings */}
		            <View className="bg-white/5 rounded-2xl p-6 mb-6">
		              <Text className="text-white text-lg font-semibold mb-6">Your Twin Journey</Text>
		              
		              <View className="flex-row justify-around">
		                <ProgressRing
		                  progress={analyticsData.twinCompatibility}
		                  size={100}
		                  strokeWidth={8}
		                  color={neonColor}
		                  label="Compatibility"
		                  value={`${analyticsData.twinCompatibility}%`}
		                />
		                
		                <ProgressRing
		                  progress={(analyticsData.streakDays / 30) * 100}
		                  size={100}
		                  strokeWidth={8}
		                  color="#10b981"
		                  label="Consistency"
		                  value={`${analyticsData.streakDays}d`}
		                />
		                
		                <ProgressRing
		                  progress={(analyticsData.recommendationsFollowed / 10) * 100}
		                  size={100}
		                  strokeWidth={8}
		                  color="#3b82f6"
		                  label="Growth"
		                  value={`${analyticsData.recommendationsFollowed}/10`}
		                />
		              </View>
		            </View>
		
		            {/* Recent Activity */}
		            <View className="bg-white/5 rounded-2xl p-6 mb-6">
		              <Text className="text-white text-lg font-semibold mb-4">Recent Activity</Text>
		              
		              <View className="space-y-3">
		                <View className="flex-row items-center">
		                  <View 
		                    className="w-10 h-10 rounded-full items-center justify-center mr-3"
		                    style={{ backgroundColor: `${neonColor}20` }}
		                  >
		                    <Ionicons name="analytics" size={20} color={neonColor} />
		                  </View>
		                  <View className="flex-1">
		                    <Text className="text-white font-medium">Assessment completed</Text>
		                    <Text className="text-gray-400 text-sm">2 days ago</Text>
		                  </View>
		                  <Text className="text-green-400 text-sm font-bold">+3 points</Text>
		                </View>
		                
		                <View className="flex-row items-center">
		                  <View 
		                    className="w-10 h-10 rounded-full items-center justify-center mr-3"
		                    style={{ backgroundColor: '#10b98120' }}
		                  >
		                    <Ionicons name="checkmark-circle" size={20} color="#10b981" />
		                  </View>
		                  <View className="flex-1">
		                    <Text className="text-white font-medium">Weekly exercise completed</Text>
		                    <Text className="text-gray-400 text-sm">5 days ago</Text>
		                  </View>
		                  <Text className="text-blue-400 text-sm font-bold">Streak +1</Text>
		                </View>
		                
		                <View className="flex-row items-center">
		                  <View 
		                    className="w-10 h-10 rounded-full items-center justify-center mr-3"
		                    style={{ backgroundColor: '#3b82f620' }}
		                  >
		                    <Ionicons name="people" size={20} color="#3b82f6" />
		                  </View>
		                  <View className="flex-1">
		                    <Text className="text-white font-medium">Twin comparison updated</Text>
		                    <Text className="text-gray-400 text-sm">1 week ago</Text>
		                  </View>
		                  <Text className="text-purple-400 text-sm font-bold">New insights</Text>
		                </View>
		              </View>
		            </View>
		
		            {/* Action Buttons */}
		            <View className="space-y-3 mb-8">
		              <Pressable
		                onPress={handleRetakeAssessment}
		                style={{ backgroundColor: neonColor }}
		                className="rounded-xl p-4"
		              >
		                <View className="flex-row items-center justify-center">
		                  <Ionicons name="refresh" size={20} color="black" />
		                  <Text className="text-black font-bold ml-2 text-lg">
		                    {canRetakeAssessments ? 'Retake Assessment' : 'Unlock Unlimited Retakes'}
		                  </Text>
		                </View>
		              </Pressable>
		              
		              <View className="flex-row space-x-3">
		                <Pressable 
		                  onPress={() => navigation.navigate('AssessmentRecommendations')}
		                  className="flex-1 bg-white/10 rounded-xl p-3"
		                >
		                  <Text className="text-white text-center font-medium">View Coaching</Text>
		                </Pressable>
		                
		                <Pressable 
		                  onPress={handleExportReport}
		                  className="flex-1 bg-white/10 rounded-xl p-3"
		                >
		                  <Text className="text-white text-center font-medium">Export Report</Text>
		                </Pressable>
		              </View>
		            </View>
		
		            {/* Insights Section */}
		            <View className="bg-white/5 rounded-2xl p-6 mb-6">
		              <Text className="text-white text-lg font-semibold mb-4">AI Insights</Text>
		              
		              <View className="space-y-4">
		                <View 
		                  className="p-4 rounded-xl border-l-4"
		                  style={{ 
		                    backgroundColor: 'rgba(0, 0, 0, 0.3)',
		                    borderLeftColor: neonColor 
		                  }}
		                >
		                  <Text 
		                    className="text-sm font-semibold mb-2"
		                    style={{ color: neonColor }}
		                  >
		                    💡 Strength Spotlight
		                  </Text>
		                  <Text className="text-white text-sm">
		                    Your communication scores have improved significantly this month. This suggests your twin bond is strengthening through better understanding and expression.
		                  </Text>
		                </View>
		                
		                <View 
		                  className="p-4 rounded-xl border-l-4"
		                  style={{ 
		                    backgroundColor: 'rgba(0, 0, 0, 0.3)',
		                    borderLeftColor: '#f59e0b' 
		                  }}
		                >
		                  <Text className="text-yellow-400 text-sm font-semibold mb-2">
		                    🎯 Growth Opportunity
		                  </Text>
		                  <Text className="text-white text-sm">
		                    Consider focusing on individual identity development. Balanced independence can actually strengthen your twin connection.
		                  </Text>
		                </View>
		                
		                <View 
		                  className="p-4 rounded-xl border-l-4"
		                  style={{ 
		                    backgroundColor: 'rgba(0, 0, 0, 0.3)',
		                    borderLeftColor: '#10b981' 
		                  }}
		                >
		                  <Text className="text-green-400 text-sm font-semibold mb-2">
		                    🌟 Recommendation
		                  </Text>
		                  <Text className="text-white text-sm">
		                    Your consistency streak is impressive! Try the "Twin Reflection" exercise this week to maintain momentum.
		                  </Text>
		                </View>
		              </View>
		            </View>
		          </PremiumGatedContent>
		        </ScrollView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/PsychicGamesHub.tsx'><![CDATA[
		import React, { useState } from 'react';
		import { View, Text, Pressable, ScrollView, Dimensions, ImageBackground } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { Ionicons } from '@expo/vector-icons';
		import { LinearGradient } from 'expo-linear-gradient';
		import Animated, {
		  useSharedValue,
		  useAnimatedStyle,
		  withSpring,
		  withDelay,
		  runOnJS
		} from 'react-native-reanimated';
		import * as Haptics from 'expo-haptics';
		
		import { SyncScoreDisplay } from '../components/games/SyncScoreDisplay';
		import { useTwinStore } from '../state/twinStore';
		import { useGameStore } from '../state/stores/games/gameStore';
		import { useGameConfig } from '../hooks/games/useGameConfig';
		import { getNeonAccentColor, getNeonAccentColorWithOpacity } from '../utils/neonColors';
		
		interface PsychicGamesHubProps {
		  navigation: any;
		}
		
		export const PsychicGamesHub: React.FC<PsychicGamesHubProps> = ({ navigation }) => {
		  const { width } = Dimensions.get('window');
		  const { userProfile, twinProfile } = useTwinStore();
		  const { syncMetrics, achievements, createGameSession } = useGameStore();
		  const { allGames } = useGameConfig();
		  
		  const themeColor = userProfile?.accentColor || 'neon-purple';
		  const accentColor = getNeonAccentColor(themeColor);
		  
		  const [selectedGame, setSelectedGame] = useState<string | null>(null);
		  const [isInviting, setIsInviting] = useState(false);
		  
		  const gameScales = allGames.map(() => useSharedValue(0));
		  const headerOpacity = useSharedValue(0);
		  const statsOpacity = useSharedValue(0);
		  
		  React.useEffect(() => {
		    // Staggered entrance animations
		    headerOpacity.value = withSpring(1, { damping: 15 });
		    statsOpacity.value = withDelay(200, withSpring(1, { damping: 15 }));
		    
		    gameScales.forEach((scale, index) => {
		      scale.value = withDelay(
		        400 + (index * 100),
		        withSpring(1, { damping: 20, stiffness: 200 })
		      );
		    });
		  }, []);
		  
		  const headerStyle = useAnimatedStyle(() => {
		    return {
		      opacity: headerOpacity.value,
		      transform: [{ translateY: withSpring(headerOpacity.value === 1 ? 0 : -20) }]
		    };
		  });
		  
		  const statsStyle = useAnimatedStyle(() => {
		    return {
		      opacity: statsOpacity.value,
		      transform: [{ scale: withSpring(statsOpacity.value) }]
		    };
		  });
		  
		  const startGame = async (gameType: string) => {
		    if (!twinProfile) {
		      // Show pairing required message
		      return;
		    }
		    
		    Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
		    setIsInviting(true);
		    
		    try {
		      // Create game session
		      const session = createGameSession(gameType as any, twinProfile.id);
		      
		      // Navigate to specific game screen
		      setTimeout(() => {
		        setIsInviting(false);
		        navigation.navigate(getGameScreenName(gameType), { sessionId: session.id });
		      }, 1000);
		      
		    } catch (error) {
		      console.error('Failed to start game:', error);
		      setIsInviting(false);
		    }
		  };
		  
		  const getGameScreenName = (gameType: string): string => {
		    switch (gameType) {
		      case 'cognitive_sync_maze': return 'CognitiveSyncMaze';
		      case 'emotional_resonance': return 'EmotionalResonanceMapping';
		      case 'temporal_decision': return 'TemporalDecisionSync';
		      case 'iconic_duo': return 'IconicDuoMatcher';
		      default: return 'CognitiveSyncMaze';
		    }
		  };
		  
		  const getDifficultyColor = (difficulty: string) => {
		    switch (difficulty) {
		      case 'easy': return '#10b981';
		      case 'medium': return '#f59e0b';
		      case 'hard': return '#ef4444';
		      default: return '#6b7280';
		    }
		  };
		  
		  const recentAchievements = achievements.filter((a: any) => a.unlocked).slice(0, 3);
		  
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <ScrollView className="flex-1 px-6" showsVerticalScrollIndicator={false}>
		          {/* Header */}
		          <Animated.View style={headerStyle} className="py-6">
		            <View className="flex-row items-center justify-between mb-4">
		              <Pressable
		                onPress={() => navigation.goBack()}
		                className="w-10 h-10 rounded-full bg-white/10 items-center justify-center"
		              >
		                <Ionicons name="arrow-back" size={20} color="white" />
		              </Pressable>
		              
		              <Text className="text-white text-2xl font-bold">Psychic Games</Text>
		              
		              <Pressable
		                onPress={() => navigation.navigate('GameStats')}
		                className="w-10 h-10 rounded-full bg-white/10 items-center justify-center"
		              >
		                <Ionicons name="stats-chart" size={20} color="white" />
		              </Pressable>
		            </View>
		            
		            <Text className="text-white/70 text-center">
		              Test your twin synchronicity through mystical games
		            </Text>
		          </Animated.View>
		          
		          {/* Twin Connection Status */}
		          {twinProfile ? (
		            <View className="bg-white/10 rounded-2xl p-4 mb-6 backdrop-blur">
		              <View className="flex-row items-center justify-between">
		                <View className="flex-row items-center">
		                  <View className="w-3 h-3 rounded-full bg-green-500 mr-3" />
		                  <View>
		                    <Text className="text-white font-semibold">
		                      Connected to {twinProfile.name}
		                    </Text>
		                    <Text className="text-white/70 text-sm">
		                      Ready for psychic games
		                    </Text>
		                  </View>
		                </View>
		                <Ionicons name="people" size={24} color={accentColor} />
		              </View>
		            </View>
		          ) : (
		            <View className="bg-white/10 rounded-2xl p-4 mb-6 backdrop-blur border border-yellow-500/30">
		              <View className="flex-row items-center">
		                <Ionicons name="warning" size={24} color="#f59e0b" />
		                <View className="ml-3 flex-1">
		                  <Text className="text-white font-semibold">
		                    Twin Connection Required
		                  </Text>
		                  <Text className="text-white/70 text-sm">
		                    Invite your twin to play psychic games together
		                  </Text>
		                </View>
		              </View>
		            </View>
		          )}
		          
		          {/* Sync Score Display */}
		          <Animated.View style={statsStyle} className="mb-8">
		            <SyncScoreDisplay 
		              metrics={syncMetrics} 
		              themeColor={themeColor}
		            />
		          </Animated.View>
		          
		          {/* Recent Achievements */}
		          {recentAchievements.length > 0 && (
		            <View className="mb-6">
		              <Text className="text-white text-lg font-semibold mb-3">
		                Recent Achievements
		              </Text>
		              <ScrollView horizontal showsHorizontalScrollIndicator={false}>
		                <View className="flex-row space-x-3">
		                  {recentAchievements.map((achievement: any, index: number) => (
		                    <View 
		                      key={achievement.id}
		                      className="bg-gradient-to-r from-yellow-500/20 to-orange-500/20 rounded-xl p-3 min-w-[120px]"
		                    >
		                      <Ionicons name={achievement.icon as any} size={24} color="#f59e0b" />
		                      <Text className="text-white font-semibold text-sm mt-1">
		                        {achievement.name}
		                      </Text>
		                    </View>
		                  ))}
		                </View>
		              </ScrollView>
		            </View>
		          )}
		          
		          {/* Games Grid */}
		          <View className="mb-6">
		            <Text className="text-white text-lg font-semibold mb-4">
		              Choose Your Psychic Challenge
		            </Text>
		            
		            <View className="space-y-4">
		              {allGames.map((game, index) => {
		                const gameStyle = useAnimatedStyle(() => {
		                  return {
		                    transform: [{ scale: gameScales[index].value }],
		                    opacity: gameScales[index].value
		                  };
		                });
		                
		                return (
		                  <Animated.View key={game.id} style={gameStyle}>
		                    <Pressable
		                      onPress={() => startGame(game.id as string)}
		                      disabled={!twinProfile || isInviting}
		                      className={`rounded-2xl p-6 ${
		                        !twinProfile ? 'opacity-50' : ''
		                      }`}
		                      style={{
		                        backgroundColor: getNeonAccentColorWithOpacity(themeColor, 0.1)
		                      }}
		                    >
		                      <View className="flex-row items-center">
		                        {/* Game Icon */}
		                        <View 
		                          className="w-16 h-16 rounded-xl items-center justify-center mr-4"
		                          style={{
		                            backgroundColor: getNeonAccentColorWithOpacity(themeColor, 0.3)
		                          }}
		                        >
		                          <Ionicons 
		                            name={game.icon as any} 
		                            size={32} 
		                            color={accentColor}
		                          />
		                        </View>
		                        
		                        {/* Game Info */}
		                        <View className="flex-1">
		                          <View className="flex-row items-center justify-between mb-2">
		                            <Text className="text-white text-xl font-semibold">
		                              {game.name}
		                            </Text>
		                            <View 
		                              className="px-3 py-1 rounded-full"
		                              style={{ backgroundColor: getDifficultyColor(game.difficulty) + '30' }}
		                            >
		                              <Text 
		                                className="text-xs font-semibold capitalize"
		                                style={{ color: getDifficultyColor(game.difficulty) }}
		                              >
		                                {game.difficulty}
		                              </Text>
		                            </View>
		                          </View>
		                          
		                          <Text className="text-white/70 text-sm leading-5 mb-3">
		                            {game.description}
		                          </Text>
		                          
		                          <View className="flex-row items-center justify-between">
		                            <Text className="text-white/60 text-xs">
		                              {(game.rounds ?? 1)} rounds  b b {game.timeLimit ?? 60}s per round
		                            </Text>
		                            <Ionicons 
		                              name="chevron-forward" 
		                              size={16} 
		                              color="rgba(255,255,255,0.6)" 
		                            />
		                          </View>
		                        </View>
		                      </View>
		                      
		                      {/* Game Stats */}
		                      {syncMetrics.gameTypeStats[game.id as any] && (
		                        <View className="mt-4 pt-4 border-t border-white/10">
		                          <View className="flex-row justify-between">
		                            <Text className="text-white/60 text-xs">
		                              Played: {syncMetrics.gameTypeStats[game.id as any].played}
		                            </Text>
		                            <Text className="text-white/60 text-xs">
		                              Success: {Math.round(syncMetrics.gameTypeStats[game.id as any].averageScore)}%
		                            </Text>
		                          </View>
		                        </View>
		                      )}
		                    </Pressable>
		                  </Animated.View>
		                );
		              })}
		            </View>
		          </View>
		          
		          {/* Loading State */}
		          {isInviting && (
		            <View className="absolute inset-0 bg-black/50 items-center justify-center">
		              <View className="bg-white/10 rounded-2xl p-8 items-center backdrop-blur">
		                <View className="w-12 h-12 border-4 border-white/30 border-t-white rounded-full animate-spin mb-4" />
		                <Text className="text-white text-lg font-semibold">
		                  Connecting with your twin...
		                </Text>
		                <Text className="text-white/70 text-center mt-2">
		                  Preparing the psychic channel
		                </Text>
		              </View>
		            </View>
		          )}
		          
		          {/* Bottom Padding */}
		          <View className="h-8" />
		        </ScrollView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/research/ConsentScreen.tsx'><![CDATA[
		import React, { useEffect } from 'react';
		import { View, Alert, ImageBackground } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { useNavigation, useRoute } from '@react-navigation/native';
		import { ConsentForm } from '../../components/research/ConsentForm';
		import { useResearchStore } from '../../state/researchStore';
		import { useTwinStore } from '../../state/twinStore';
		import { ConsentItem } from '../../types/research';
		
		export const ConsentScreen: React.FC = () => {
		  const navigation = useNavigation();
		  const route = useRoute();
		  const { studyId } = route.params as { studyId: string };
		  
		  const { userProfile } = useTwinStore();
		  const { 
		    selectedStudy, 
		    consentInProgress, 
		    error,
		    recordConsent,
		    joinStudy,
		    loadAvailableStudies,
		    selectStudy,
		    clearError
		  } = useResearchStore();
		
		  useEffect(() => {
		    // Load studies and select the current one
		    loadAvailableStudies().then(() => {
		      // Find and select the study
		      const studies = useResearchStore.getState().availableStudies;
		      const study = studies.find(s => s.id === studyId);
		      if (study) {
		        selectStudy(study);
		      } else {
		        Alert.alert('Study Not Found', 'The requested study could not be found.');
		        navigation.goBack();
		      }
		    });
		
		    return () => {
		      clearError();
		    };
		  }, [studyId]);
		
		  useEffect(() => {
		    if (error) {
		      Alert.alert('Error', error);
		    }
		  }, [error]);
		
		  const handleConsent = async (consentItems: ConsentItem[]) => {
		    if (!userProfile || !selectedStudy) return;
		
		    try {
		      // Record consent
		      await recordConsent(
		        userProfile.id,
		        selectedStudy.id,
		        consentItems,
		        'user_ip' // In production, get actual IP
		      );
		
		      // Join the study
		      await joinStudy(userProfile.id, selectedStudy.id);
		
		      Alert.alert(
		        'Welcome to the Study!',
		        `You have successfully joined "${selectedStudy.title}". Thank you for contributing to twin research!`,
		        [
		          {
		            text: 'View Dashboard',
		            onPress: () => navigation.navigate('ResearchDashboardScreen' as never)
		          },
		          {
		            text: 'Continue',
		            onPress: () => navigation.goBack()
		          }
		        ]
		      );
		    } catch (error) {
		      console.error('Error during consent process:', error);
		    }
		  };
		
		  const handleCancel = () => {
		    navigation.goBack();
		  };
		
		  if (!selectedStudy) {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1 justify-center items-center">
		          <View className="bg-white/10 rounded-xl p-6">
		            <Text className="text-white text-lg">Loading study information...</Text>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <ConsentForm
		          study={selectedStudy}
		          onConsent={handleConsent}
		          onCancel={handleCancel}
		          isLoading={consentInProgress}
		        />
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/research/ResearchDashboardScreen.tsx'><![CDATA[
		import React, { useEffect } from 'react';
		import { View, Text, ScrollView, Pressable, Alert, Share, ImageBackground } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { useNavigation } from '@react-navigation/native';
		import { Ionicons } from '@expo/vector-icons';
		import { useResearchStore } from '../../state/researchStore';
		import { useTwinStore } from '../../state/twinStore';
		
		export const ResearchDashboardScreen: React.FC = () => {
		  const navigation = useNavigation();
		  const { userProfile } = useTwinStore();
		  const {
		    dashboard,
		    insights,
		    participation,
		    isLoading,
		    error,
		    loadDashboard,
		    loadInsights,
		    exportData
		  } = useResearchStore();
		
		  useEffect(() => {
		    if (userProfile) {
		      loadDashboard(userProfile.id);
		      loadInsights(userProfile.id);
		    }
		  }, [userProfile]);
		
		  const handleExportData = async () => {
		    if (!userProfile) return;
		
		    Alert.alert(
		      'Export Your Data',
		      'This will create a complete export of your research participation data. Continue?',
		      [
		        { text: 'Cancel', style: 'cancel' },
		        {
		          text: 'Export',
		          onPress: async () => {
		            try {
		              const data = await exportData(userProfile.id);
		              const jsonData = JSON.stringify(data, null, 2);
		              
		              // In a real app, you might save to device or email
		              Share.share({
		                message: 'Your Twinship research data export',
		                title: 'Research Data Export'
		              });
		              
		              Alert.alert(
		                'Export Complete',
		                'Your data has been prepared for export. You can now share or save it.'
		              );
		            } catch (error) {
		              Alert.alert('Error', 'Failed to export data. Please try again.');
		            }
		          }
		        }
		      ]
		    );
		  };
		
		  const getImpactLevel = (score: number): { level: string; color: string; icon: string } => {
		    if (score >= 80) return { level: 'High Impact', color: '#10b981', icon: 'trending-up' };
		    if (score >= 50) return { level: 'Good Impact', color: '#3b82f6', icon: 'trending-up' };
		    if (score >= 20) return { level: 'Growing Impact', color: '#f59e0b', icon: 'trending-up' };
		    return { level: 'Starting Impact', color: '#6b7280', icon: 'trending-up' };
		  };
		
		  if (error) {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1 justify-center items-center p-6">
		          <View className="bg-red-500/20 border border-red-500/30 rounded-xl p-6">
		            <Text className="text-red-300 text-center text-lg mb-4">{error}</Text>
		            <Pressable
		              onPress={() => {
		                if (userProfile) {
		                  loadDashboard(userProfile.id);
		                  loadInsights(userProfile.id);
		                }
		              }}
		              className="bg-red-500 py-3 px-6 rounded-lg"
		            >
		              <Text className="text-white font-semibold text-center">Retry</Text>
		            </Pressable>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  if (isLoading || !dashboard) {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1 justify-center items-center">
		          <View className="bg-white/10 rounded-xl p-8">
		            <Text className="text-white text-lg text-center">Loading your dashboard...</Text>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  const impact = getImpactLevel(dashboard.impactMetrics.scientificImpact);
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <ScrollView className="flex-1 px-6">
		          {/* Header */}
		          <View className="py-6">
		            <Text className="text-white text-3xl font-bold text-center mb-2">
		              Research Dashboard
		            </Text>
		            <Text className="text-white/70 text-center text-lg">
		              Your contribution to twin science
		            </Text>
		          </View>
		
		          {/* Impact Overview */}
		          <View className="bg-white/10 rounded-xl p-6 mb-6">
		            <Text className="text-white text-xl font-semibold mb-4">Your Impact</Text>
		            
		            <View className="bg-white/5 rounded-lg p-4 mb-4">
		              <View className="flex-row items-center justify-between mb-2">
		                <Text className="text-white font-medium">Scientific Impact Score</Text>
		                <View className="flex-row items-center">
		                  <Ionicons name={impact.icon} size={20} color={impact.color} />
		                  <Text className="text-white font-bold text-lg ml-2">
		                    {dashboard.impactMetrics.scientificImpact}/100
		                  </Text>
		                </View>
		              </View>
		              <Text className="text-white/70 text-sm" style={{ color: impact.color }}>
		                {impact.level}
		              </Text>
		            </View>
		
		            <View className="flex-row justify-between">
		              <View className="flex-1 bg-white/5 rounded-lg p-4 mr-2">
		                <Text className="text-white font-semibold text-2xl">
		                  {dashboard.impactMetrics.dataPointsContributed}
		                </Text>
		                <Text className="text-white/70 text-sm">Data Points</Text>
		              </View>
		              
		              <View className="flex-1 bg-white/5 rounded-lg p-4 ml-2">
		                <Text className="text-white font-semibold text-2xl">
		                  {dashboard.impactMetrics.studiesSupported}
		                </Text>
		                <Text className="text-white/70 text-sm">Studies Supported</Text>
		              </View>
		            </View>
		          </View>
		
		          {/* Active Studies */}
		          <View className="mb-6">
		            <Text className="text-white text-xl font-semibold mb-4">Active Studies</Text>
		            
		            {dashboard.activeStudies.length > 0 ? (
		              <View className="space-y-4">
		                {dashboard.activeStudies.map((study) => (
		                  <View key={study.id} className="bg-white/10 rounded-xl p-6">
		                    <Text className="text-white text-lg font-semibold mb-2">
		                      {study.title}
		                    </Text>
		                    <Text className="text-white/70 text-sm mb-3">
		                      {study.description}
		                    </Text>
		                    
		                    <View className="flex-row items-center justify-between">
		                      <View className="flex-row items-center">
		                        <Ionicons name="time" size={16} color="rgba(255,255,255,0.7)" />
		                        <Text className="text-white/70 text-sm ml-2">{study.duration}</Text>
		                      </View>
		                      
		                      <View className="flex-row items-center">
		                        <Ionicons 
		                          name="checkmark-circle" 
		                          size={16} 
		                          color="#10b981" 
		                        />
		                        <Text className="text-green-300 text-sm ml-2">Contributing</Text>
		                      </View>
		                    </View>
		                  </View>
		                ))}
		              </View>
		            ) : (
		              <View className="bg-white/5 rounded-xl p-6">
		                <Text className="text-white/70 text-center">
		                  No active studies. Visit Research Participation to join studies.
		                </Text>
		                <Pressable
		                  onPress={() => navigation.navigate('ResearchParticipationScreen' as never)}
		                  className="bg-purple-500 py-3 rounded-lg mt-4"
		                >
		                  <Text className="text-white font-semibold text-center">
		                    Browse Studies
		                  </Text>
		                </Pressable>
		              </View>
		            )}
		          </View>
		
		          {/* Recent Insights */}
		          <View className="mb-6">
		            <Text className="text-white text-xl font-semibold mb-4">Latest Research Insights</Text>
		            
		            {insights.length > 0 ? (
		              <View className="space-y-4">
		                {insights.slice(0, 3).map((insight) => (
		                  <View key={insight.id} className="bg-white/10 rounded-xl p-6">
		                    <View className="flex-row items-start justify-between mb-3">
		                      <Text className="text-white text-lg font-semibold flex-1 mr-3">
		                        {insight.title}
		                      </Text>
		                      <View className={`px-2 py-1 rounded ${
		                        insight.significance === 'breakthrough' ? 'bg-green-500/20' :
		                        insight.significance === 'significant' ? 'bg-blue-500/20' :
		                        'bg-gray-500/20'
		                      }`}>
		                        <Text className={`text-xs font-medium ${
		                          insight.significance === 'breakthrough' ? 'text-green-300' :
		                          insight.significance === 'significant' ? 'text-blue-300' :
		                          'text-gray-300'
		                        }`}>
		                          {insight.significance}
		                        </Text>
		                      </View>
		                    </View>
		                    
		                    <Text className="text-white/70 text-sm mb-3">
		                      {insight.summary}
		                    </Text>
		                    
		                    <View className="space-y-2">
		                      {insight.findings.slice(0, 2).map((finding, index) => (
		                        <View key={index} className="flex-row items-start">
		                          <Ionicons name="bulb" size={14} color="#fbbf24" />
		                          <Text className="text-white/80 text-sm ml-2 flex-1">
		                            {finding}
		                          </Text>
		                        </View>
		                      ))}
		                    </View>
		                    
		                    <Text className="text-white/50 text-xs mt-3">
		                      Published {new Date(insight.publishedAt).toLocaleDateString()}
		                    </Text>
		                  </View>
		                ))}
		              </View>
		            ) : (
		              <View className="bg-white/5 rounded-xl p-6">
		                <Text className="text-white/70 text-center">
		                  Research insights will appear here as studies progress
		                </Text>
		              </View>
		            )}
		          </View>
		
		          {/* Recognition & Milestones */}
		          {(dashboard.recognitions.length > 0 || dashboard.upcomingMilestones.length > 0) && (
		            <View className="mb-6">
		              <Text className="text-white text-xl font-semibold mb-4">Recognition & Milestones</Text>
		              
		              {dashboard.recognitions.length > 0 && (
		                <View className="bg-gradient-to-r from-purple-500/20 to-pink-500/20 rounded-xl p-6 mb-4">
		                  <Text className="text-white font-semibold mb-3">Your Achievements</Text>
		                  <View className="flex-row flex-wrap gap-2">
		                    {dashboard.recognitions.map((recognition, index) => (
		                      <View key={index} className="bg-white/20 px-3 py-2 rounded-full">
		                        <Text className="text-white text-sm font-medium">
		                          🏆 {recognition}
		                        </Text>
		                      </View>
		                    ))}
		                  </View>
		                </View>
		              )}
		              
		              {dashboard.upcomingMilestones.length > 0 && (
		                <View className="bg-white/5 rounded-xl p-6">
		                  <Text className="text-white font-semibold mb-3">Upcoming Milestones</Text>
		                  <View className="space-y-2">
		                    {dashboard.upcomingMilestones.map((milestone, index) => (
		                      <View key={index} className="flex-row items-center">
		                        <Ionicons name="flag" size={16} color="#8b5cf6" />
		                        <Text className="text-white/80 text-sm ml-3">{milestone}</Text>
		                      </View>
		                    ))}
		                  </View>
		                </View>
		              )}
		            </View>
		          )}
		
		          {/* Data Management */}
		          <View className="mb-8">
		            <Text className="text-white text-xl font-semibold mb-4">Data Management</Text>
		            
		            <View className="bg-white/10 rounded-xl p-6">
		              <Text className="text-white font-medium mb-3">Your Data Rights</Text>
		              <Text className="text-white/70 text-sm mb-4">
		                You have full control over your research data. You can export, modify permissions, 
		                or withdraw from studies at any time.
		              </Text>
		              
		              <View className="space-y-3">
		                <Pressable
		                  onPress={handleExportData}
		                  className="bg-blue-500 py-3 rounded-lg"
		                >
		                  <View className="flex-row items-center justify-center">
		                    <Ionicons name="download" size={20} color="white" />
		                    <Text className="text-white font-semibold ml-2">
		                      Export My Data
		                    </Text>
		                  </View>
		                </Pressable>
		                
		                <Pressable
		                  onPress={() => navigation.navigate('ResearchParticipationScreen' as never)}
		                  className="bg-white/20 py-3 rounded-lg"
		                >
		                  <View className="flex-row items-center justify-center">
		                    <Ionicons name="settings" size={20} color="white" />
		                    <Text className="text-white font-semibold ml-2">
		                      Manage Participation
		                    </Text>
		                  </View>
		                </Pressable>
		              </View>
		            </View>
		          </View>
		        </ScrollView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/research/ResearchParticipationScreen.tsx'><![CDATA[
		import React, { useEffect } from 'react';
		import { View, Text, ScrollView, Pressable, Alert, ImageBackground } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { useNavigation } from '@react-navigation/native';
		import { Ionicons } from '@expo/vector-icons';
		import { useResearchStore } from '../../state/researchStore';
		import { useTwinStore } from '../../state/twinStore';
		import { ResearchStudy } from '../../types/research';
		
		export const ResearchParticipationScreen: React.FC = () => {
		  const navigation = useNavigation();
		  const { userProfile } = useTwinStore();
		  const {
		    availableStudies,
		    participation,
		    isLoading,
		    error,
		    loadAvailableStudies,
		    loadParticipation,
		    withdrawFromStudy
		  } = useResearchStore();
		
		  useEffect(() => {
		    if (userProfile) {
		      loadAvailableStudies();
		      loadParticipation(userProfile.id);
		    }
		  }, [userProfile]);
		
		  const handleJoinStudy = (study: ResearchStudy) => {
		    navigation.navigate('ConsentScreen' as never, { studyId: study.id } as never);
		  };
		
		  const handleWithdrawFromStudy = (studyId: string, studyTitle: string) => {
		    Alert.alert(
		      'Withdraw from Study',
		      `Are you sure you want to withdraw from "${studyTitle}"? This action cannot be undone.`,
		      [
		        { text: 'Cancel', style: 'cancel' },
		        {
		          text: 'Withdraw',
		          style: 'destructive',
		          onPress: () => showWithdrawalOptions(studyId)
		        }
		      ]
		    );
		  };
		
		  const showWithdrawalOptions = (studyId: string) => {
		    Alert.alert(
		      'Data Management',
		      'What would you like us to do with your contributed data?',
		      [
		        {
		          text: 'Delete All My Data',
		          onPress: () => processWithdrawal(studyId, 'delete')
		        },
		        {
		          text: 'Keep Anonymized Data',
		          onPress: () => processWithdrawal(studyId, 'anonymize')
		        },
		        {
		          text: 'Use in Aggregated Results',
		          onPress: () => processWithdrawal(studyId, 'retain_aggregated')
		        },
		        { text: 'Cancel', style: 'cancel' }
		      ]
		    );
		  };
		
		  const processWithdrawal = async (studyId: string, dataDisposition: 'delete' | 'anonymize' | 'retain_aggregated') => {
		    if (!userProfile) return;
		
		    try {
		      await withdrawFromStudy(
		        userProfile.id,
		        studyId,
		        'User requested withdrawal',
		        dataDisposition
		      );
		
		      Alert.alert(
		        'Withdrawal Processed',
		        'You have been successfully withdrawn from the study. Thank you for your contribution to research.',
		        [{ text: 'OK' }]
		      );
		    } catch (error) {
		      Alert.alert('Error', 'Failed to process withdrawal. Please try again.');
		    }
		  };
		
		  const getCategoryIcon = (category: ResearchStudy['category']) => {
		    switch (category) {
		      case 'synchronicity': return 'flash';
		      case 'psychology': return 'brain';
		      case 'genetics': return 'dna';
		      case 'behavior': return 'trending-up';
		      case 'communication': return 'chatbubbles';
		      default: return 'flask';
		    }
		  };
		
		  const getCategoryColor = (category: ResearchStudy['category']) => {
		    switch (category) {
		      case 'synchronicity': return '#8b5cf6';
		      case 'psychology': return '#06b6d4';
		      case 'genetics': return '#10b981';
		      case 'behavior': return '#f59e0b';
		      case 'communication': return '#ec4899';
		      default: return '#6b7280';
		    }
		  };
		
		  const isParticipating = (studyId: string) => {
		    return participation?.activeStudies.includes(studyId) || false;
		  };
		
		  if (error) {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1 justify-center items-center p-6">
		          <View className="bg-red-500/20 border border-red-500/30 rounded-xl p-6">
		            <Text className="text-red-300 text-center text-lg mb-4">{error}</Text>
		            <Pressable
		              onPress={() => {
		                if (userProfile) {
		                  loadAvailableStudies();
		                  loadParticipation(userProfile.id);
		                }
		              }}
		              className="bg-red-500 py-3 px-6 rounded-lg"
		            >
		              <Text className="text-white font-semibold text-center">Retry</Text>
		            </Pressable>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <ScrollView className="flex-1 px-6">
		          {/* Header */}
		          <View className="py-6">
		            <Text className="text-white text-3xl font-bold text-center mb-2">
		              Research Participation
		            </Text>
		            <Text className="text-white/70 text-center text-lg">
		              Contribute to groundbreaking twin research
		            </Text>
		          </View>
		
		          {/* Participation Status */}
		          {participation && (
		            <View className="bg-white/10 rounded-xl p-6 mb-6">
		              <Text className="text-white text-xl font-semibold mb-4">Your Participation</Text>
		              
		              <View className="space-y-3">
		                <View className="flex-row items-center justify-between">
		                  <Text className="text-white/70">Active Studies</Text>
		                  <Text className="text-white font-semibold">
		                    {participation.activeStudies.length}
		                  </Text>
		                </View>
		                
		                <View className="flex-row items-center justify-between">
		                  <Text className="text-white/70">Total Contributions</Text>
		                  <Text className="text-white font-semibold">
		                    {participation.dataContributions.length}
		                  </Text>
		                </View>
		                
		                <View className="flex-row items-center justify-between">
		                  <Text className="text-white/70">Research Since</Text>
		                  <Text className="text-white font-semibold">
		                    {new Date(participation.joinedAt).getFullYear()}
		                  </Text>
		                </View>
		              </View>
		
		              <Pressable
		                onPress={() => navigation.navigate('ResearchDashboardScreen' as never)}
		                className="bg-purple-500 py-3 rounded-lg mt-4"
		              >
		                <Text className="text-white font-semibold text-center">
		                  View Your Dashboard
		                </Text>
		              </Pressable>
		            </View>
		          )}
		
		          {/* Available Studies */}
		          <View className="mb-6">
		            <Text className="text-white text-xl font-semibold mb-4">Available Studies</Text>
		            
		            {isLoading ? (
		              <View className="bg-white/5 rounded-xl p-8 items-center">
		                <Text className="text-white/70">Loading studies...</Text>
		              </View>
		            ) : (
		              <View className="space-y-4">
		                {availableStudies.map((study) => (
		                  <View key={study.id} className="bg-white/10 rounded-xl p-6">
		                    {/* Study Header */}
		                    <View className="flex-row items-start justify-between mb-4">
		                      <View className="flex-1">
		                        <View className="flex-row items-center mb-2">
		                          <View 
		                            className="w-8 h-8 rounded-full items-center justify-center mr-3"
		                            style={{ backgroundColor: getCategoryColor(study.category) + '20' }}
		                          >
		                            <Ionicons 
		                              name={getCategoryIcon(study.category)} 
		                              size={16} 
		                              color={getCategoryColor(study.category)} 
		                            />
		                          </View>
		                          <Text className="text-white text-lg font-semibold flex-1">
		                            {study.title}
		                          </Text>
		                        </View>
		                        
		                        <Text className="text-white/70 text-sm leading-5 mb-3">
		                          {study.description}
		                        </Text>
		                      </View>
		                    </View>
		
		                    {/* Study Details */}
		                    <View className="space-y-2 mb-4">
		                      <View className="flex-row items-center justify-between">
		                        <View className="flex-row items-center">
		                          <Ionicons name="time" size={16} color="rgba(255,255,255,0.7)" />
		                          <Text className="text-white/70 text-sm ml-2">{study.duration}</Text>
		                        </View>
		                        
		                        <View className="flex-row items-center">
		                          <Ionicons name="people" size={16} color="rgba(255,255,255,0.7)" />
		                          <Text className="text-white/70 text-sm ml-2">
		                            {study.participants} participants
		                          </Text>
		                        </View>
		                      </View>
		
		                      <View className="flex-row items-center">
		                        <Ionicons name="business" size={16} color="rgba(255,255,255,0.7)" />
		                        <Text className="text-white/70 text-sm ml-2">{study.institution}</Text>
		                      </View>
		                    </View>
		
		                    {/* Compensation */}
		                    <View className="bg-purple-500/20 rounded-lg p-3 mb-4">
		                      <Text className="text-purple-300 text-sm font-medium mb-1">
		                        What you receive:
		                      </Text>
		                      <View className="space-y-1">
		                        {study.compensation.map((benefit, index) => (
		                          <Text key={index} className="text-purple-200 text-sm">
		                            • {benefit}
		                          </Text>
		                        ))}
		                      </View>
		                    </View>
		
		                    {/* Action Button */}
		                    {isParticipating(study.id) ? (
		                      <View className="space-y-2">
		                        <View className="bg-green-500/20 rounded-lg p-3">
		                          <View className="flex-row items-center justify-center">
		                            <Ionicons name="checkmark-circle" size={20} color="#10b981" />
		                            <Text className="text-green-300 font-semibold ml-2">
		                              Currently Participating
		                            </Text>
		                          </View>
		                        </View>
		                        
		                        <Pressable
		                          onPress={() => handleWithdrawFromStudy(study.id, study.title)}
		                          className="bg-red-500/20 border border-red-500/30 py-2 rounded-lg"
		                        >
		                          <Text className="text-red-300 font-medium text-center text-sm">
		                            Withdraw from Study
		                          </Text>
		                        </Pressable>
		                      </View>
		                    ) : (
		                      <Pressable
		                        onPress={() => handleJoinStudy(study)}
		                        className="bg-purple-500 py-3 rounded-lg"
		                      >
		                        <Text className="text-white font-semibold text-center">
		                          Learn More & Join
		                        </Text>
		                      </Pressable>
		                    )}
		                  </View>
		                ))}
		              </View>
		            )}
		          </View>
		
		          {/* Research Impact */}
		          <View className="bg-white/5 rounded-xl p-6 mb-8">
		            <Text className="text-white text-lg font-semibold mb-4">
		              Why Your Participation Matters
		            </Text>
		            
		            <View className="space-y-4">
		              <View className="flex-row items-start">
		                <View className="w-8 h-8 rounded-full bg-blue-500/20 items-center justify-center mr-4">
		                  <Ionicons name="bulb" size={16} color="#3b82f6" />
		                </View>
		                <View className="flex-1">
		                  <Text className="text-white font-medium mb-1">Advance Science</Text>
		                  <Text className="text-white/70 text-sm">
		                    Help researchers understand the unique bond between twins
		                  </Text>
		                </View>
		              </View>
		              
		              <View className="flex-row items-start">
		                <View className="w-8 h-8 rounded-full bg-green-500/20 items-center justify-center mr-4">
		                  <Ionicons name="people" size={16} color="#10b981" />
		                </View>
		                <View className="flex-1">
		                  <Text className="text-white font-medium mb-1">Help Other Twins</Text>
		                  <Text className="text-white/70 text-sm">
		                    Your data helps develop better support for twin relationships
		                  </Text>
		                </View>
		              </View>
		              
		              <View className="flex-row items-start">
		                <View className="w-8 h-8 rounded-full bg-purple-500/20 items-center justify-center mr-4">
		                  <Ionicons name="eye" size={16} color="#8b5cf6" />
		                </View>
		                <View className="flex-1">
		                  <Text className="text-white font-medium mb-1">Gain Insights</Text>
		                  <Text className="text-white/70 text-sm">
		                    Receive personalized insights about your twin connection
		                  </Text>
		                </View>
		              </View>
		              
		              <View className="flex-row items-start">
		                <View className="w-8 h-8 rounded-full bg-amber-500/20 items-center justify-center mr-4">
		                  <Ionicons name="shield-checkmark" size={16} color="#f59e0b" />
		                </View>
		                <View className="flex-1">
		                  <Text className="text-white font-medium mb-1">Full Privacy</Text>
		                  <Text className="text-white/70 text-sm">
		                    All data is anonymized and handled according to research ethics
		                  </Text>
		                </View>
		              </View>
		            </View>
		          </View>
		        </ScrollView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/ResearchScreen.tsx'><![CDATA[
		import React, { useState } from "react";
		import { View, Text, Pressable, ScrollView, Switch, ImageBackground } from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { useTwinStore } from "../state/twinStore";
		import { Ionicons } from "@expo/vector-icons";
		
		export const ResearchScreen = () => {
		  const { themeColor, researchParticipation, setResearchParticipation, twinType } = useTwinStore();
		  const [selectedStudies, setSelectedStudies] = useState<string[]>([]);
		
		  const researchStudies = [
		    {
		      id: "synchronicity",
		      title: "Twin Synchronicity Study",
		      description: "Help us understand how twins experience simultaneous thoughts, feelings, and actions.",
		      duration: "6 months",
		      compensation: "Research insights",
		      participants: 1247,
		    },
		    {
		      id: "emotional_connection",
		      title: "Emotional Mirroring Research",
		      description: "Study the emotional connections between twins across distances.",
		      duration: "3 months", 
		      compensation: "Early access to features",
		      participants: 892,
		    },
		    {
		      id: "genetic_behavior",
		      title: "Genetics & Behavior Correlation",
		      description: "Explore how genetic similarities influence behavioral patterns in twins.",
		      duration: "12 months",
		      compensation: "Personalized insights",
		      participants: 634,
		    },
		  ];
		
		  const toggleStudySelection = (studyId: string) => {
		    setSelectedStudies(prev => 
		      prev.includes(studyId) 
		        ? prev.filter(id => id !== studyId)
		        : [...prev, studyId]
		    );
		  };
		
		  const handleJoinResearch = () => {
		    setResearchParticipation(true);
		    // In a real app, this would send the selected studies to the backend
		  };
		
		  const handleLeaveResearch = () => {
		    setResearchParticipation(false);
		    setSelectedStudies([]);
		  };
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <ScrollView className="flex-1 px-6">
		          {/* Header */}
		          <View className="py-4">
		            <Text className="text-white text-2xl font-bold text-center">
		              Twin Research
		            </Text>
		            <Text className="text-white/70 text-center mt-2">
		              Contribute to groundbreaking twin studies
		            </Text>
		          </View>
		
		          {/* Current Status */}
		          <View className="bg-white/10 rounded-xl p-6 mb-6">
		            <View className="flex-row items-center justify-between mb-4">
		              <Text className="text-white text-xl font-semibold">Research Participation</Text>
		              <Switch
		                value={researchParticipation}
		                onValueChange={researchParticipation ? handleLeaveResearch : () => {}}
		                trackColor={{ false: "#374151", true: "#8b5cf6" }}
		                thumbColor={researchParticipation ? "#ffffff" : "#9ca3af"}
		              />
		            </View>
		            
		            <View className="flex-row items-center">
		              <Ionicons 
		                name={researchParticipation ? "checkmark-circle" : "close-circle"} 
		                size={24} 
		                color={researchParticipation ? "#10b981" : "#ef4444"} 
		              />
		              <Text className="text-white ml-3">
		                {researchParticipation ? "Currently participating" : "Not participating"}
		              </Text>
		            </View>
		            
		            {researchParticipation && (
		              <Text className="text-white/70 text-sm mt-2">
		                Thank you for contributing to twin research! Your data helps us understand the unique bond between twins.
		              </Text>
		            )}
		          </View>
		
		          {/* Twin Type Info */}
		          <View className="bg-white/5 rounded-xl p-4 mb-6">
		            <View className="flex-row items-center">
		              <Ionicons name="people" size={24} color="white" />
		              <Text className="text-white ml-3">
		                You are <Text className="font-semibold capitalize">{twinType || "unknown"}</Text> twins
		              </Text>
		            </View>
		            <Text className="text-white/70 text-sm mt-2 ml-9">
		              This information helps researchers categorize and analyze data appropriately.
		            </Text>
		          </View>
		
		          {/* Available Studies */}
		          <View className="mb-6">
		            <Text className="text-white text-xl font-semibold mb-4">Available Studies</Text>
		            
		            <View className="space-y-4">
		              {researchStudies.map((study) => (
		                <View key={study.id} className="bg-white/10 rounded-xl p-6">
		                  <View className="flex-row items-start justify-between mb-4">
		                    <View className="flex-1">
		                      <Text className="text-white text-lg font-semibold mb-2">
		                        {study.title}
		                      </Text>
		                      <Text className="text-white/70 text-sm leading-5 mb-3">
		                        {study.description}
		                      </Text>
		                      
		                      <View className="flex-row items-center space-x-4">
		                        <View className="flex-row items-center">
		                          <Ionicons name="time" size={16} color="rgba(255,255,255,0.7)" />
		                          <Text className="text-white/70 text-sm ml-1">{study.duration}</Text>
		                        </View>
		                        
		                        <View className="flex-row items-center">
		                          <Ionicons name="people" size={16} color="rgba(255,255,255,0.7)" />
		                          <Text className="text-white/70 text-sm ml-1">{study.participants} participants</Text>
		                        </View>
		                      </View>
		                      
		                      <View className="bg-purple-500/20 rounded-lg p-3 mt-3">
		                        <Text className="text-purple-300 text-sm font-medium">
		                          Compensation: {study.compensation}
		                        </Text>
		                      </View>
		                    </View>
		                  </View>
		                  
		                  {!researchParticipation && (
		                    <Pressable
		                      onPress={() => toggleStudySelection(study.id)}
		                      className={`flex-row items-center justify-center py-3 rounded-lg ${
		                        selectedStudies.includes(study.id)
		                          ? "bg-purple-500"
		                          : "bg-white/20"
		                      }`}
		                    >
		                      <Ionicons 
		                        name={selectedStudies.includes(study.id) ? "checkmark" : "add"} 
		                        size={20} 
		                        color="white" 
		                      />
		                      <Text className="text-white font-semibold ml-2">
		                        {selectedStudies.includes(study.id) ? "Selected" : "Select Study"}
		                      </Text>
		                    </Pressable>
		                  )}
		                  
		                  {researchParticipation && (
		                    <View className="bg-green-500/20 rounded-lg p-3">
		                      <View className="flex-row items-center justify-center">
		                        <Ionicons name="checkmark-circle" size={20} color="#10b981" />
		                        <Text className="text-green-300 font-semibold ml-2">Participating</Text>
		                      </View>
		                    </View>
		                  )}
		                </View>
		              ))}
		            </View>
		          </View>
		
		          {/* Join Research Button */}
		          {!researchParticipation && selectedStudies.length > 0 && (
		            <View className="mb-8">
		              <Pressable
		                onPress={handleJoinResearch}
		                className="bg-purple-500 py-4 rounded-xl items-center"
		              >
		                <Text className="text-white text-lg font-semibold">
		                  Join Research ({selectedStudies.length} studies)
		                </Text>
		              </Pressable>
		              
		              <Text className="text-white/50 text-sm text-center mt-4">
		                By joining, you agree to share anonymized data to help advance twin research.
		                You can opt out at any time.
		              </Text>
		            </View>
		          )}
		
		          {/* Research Benefits */}
		          <View className="bg-white/5 rounded-xl p-6 mb-8">
		            <Text className="text-white text-lg font-semibold mb-4">Why Participate?</Text>
		            
		            <View className="space-y-3">
		              <View className="flex-row items-start">
		                <Ionicons name="bulb" size={20} color="#fbbf24" />
		                <Text className="text-white/70 text-sm ml-3 flex-1">
		                  Contribute to groundbreaking research on twin connections and synchronicity
		                </Text>
		              </View>
		              
		              <View className="flex-row items-start">
		                <Ionicons name="shield-checkmark" size={20} color="#10b981" />
		                <Text className="text-white/70 text-sm ml-3 flex-1">
		                  All data is anonymized and securely stored following research ethics guidelines
		                </Text>
		              </View>
		              
		              <View className="flex-row items-start">
		                <Ionicons name="gift" size={20} color="#8b5cf6" />
		                <Text className="text-white/70 text-sm ml-3 flex-1">
		                  Receive personalized insights about your twin connection
		                </Text>
		              </View>
		              
		              <View className="flex-row items-start">
		                <Ionicons name="people" size={20} color="#3b82f6" />
		                <Text className="text-white/70 text-sm ml-3 flex-1">
		                  Help other twins understand their unique bonds better
		                </Text>
		              </View>
		            </View>
		          </View>
		        </ScrollView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/SettingsScreen_Premium.tsx'><![CDATA[
		import React, { useState } from "react";
		import { View, Text, Pressable, Alert, ScrollView } from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { useNavigation } from "@react-navigation/native";
		import { Ionicons } from "@expo/vector-icons";
		
		// Premium imports
		import { PremiumStatusIndicator } from "../components/premium/PremiumStatusIndicator";
		import { PremiumUpgradeButton } from "../components/premium/PremiumBadge";
		import { PremiumOnly } from "../components/premium/PremiumGatedContent";
		import { usePremiumFeatures } from "../hooks/usePremiumFeatures";
		import { subscriptionService } from "../services/subscriptionService";
		
		// Existing imports
		import { useTwinStore } from "../state/twinStore";
		import { useSubscriptionStore } from "../state/subscriptionStore";
		import { getNeonAccentColor } from "../utils/neonColors";
		
		export const SettingsScreen = () => {
		  const navigation = useNavigation<any>();
		  const { 
		    userProfile, 
		    twinProfile, 
		    signOut, 
		    researchParticipation, 
		    setResearchParticipation, 
		    notificationsEnabled, 
		    setNotificationsEnabled 
		  } = useTwinStore();
		  
		  const {
		    subscriptionInfo,
		    isRestoring,
		    mockRestore
		  } = useSubscriptionStore();
		  
		  const {
		    isSubscriptionActive,
		    navigateToUpgrade
		  } = usePremiumFeatures();
		  
		  const [isRestoringPurchases, setIsRestoringPurchases] = useState(false);
		  
		  const themeColor = userProfile?.accentColor || "neon-purple";
		  const neonColor = getNeonAccentColor(themeColor);
		
		  const handleSignOut = () => {
		    Alert.alert(
		      "Twinconnect",
		      "Are you sure you want to twinconnect? You'll need to complete the setup process again to re-establish twinsync.",
		      [
		        { text: "Cancel", style: "cancel" },
		        { 
		          text: "Twinconnect", 
		          style: "destructive", 
		          onPress: () => {
		            signOut();
		            Alert.alert("Twinconnected", "You have been successfully twinconnected.");
		          }
		        }
		      ]
		    );
		  };
		
		  const handleRestorePurchases = async () => {
		    try {
		      setIsRestoringPurchases(true);
		      await mockRestore();
		      
		      if (subscriptionInfo.isActive) {
		        Alert.alert(
		          "Purchases Restored!",
		          "Your premium subscription has been restored successfully."
		        );
		      } else {
		        Alert.alert(
		          "No Purchases Found",
		          "We couldn't find any previous purchases to restore."
		        );
		      }
		    } catch (error: any) {
		      Alert.alert("Restore Failed", error.message || "Please try again later");
		    } finally {
		      setIsRestoringPurchases(false);
		    }
		  };
		
		  const handleManageSubscription = () => {
		    if (isSubscriptionActive) {
		      Alert.alert(
		        "Manage Subscription",
		        "To manage your subscription, go to your device's App Store settings.",
		        [
		          { text: "Cancel", style: "cancel" },
		          { 
		            text: "Open Settings", 
		            onPress: () => {
		              // In a real app, this would open the device's subscription settings
		              Alert.alert("Info", "This would open your device's subscription management settings.");
		            }
		          }
		        ]
		      );
		    } else {
		      navigateToUpgrade(undefined, 'settings_manage');
		    }
		  };
		
		  const formatDate = (dateString: string) => {
		    return new Date(dateString).toLocaleDateString();
		  };
		
		  const formatSubscriptionDate = (dateString?: string) => {
		    return dateString ? new Date(dateString).toLocaleDateString() : 'N/A';
		  };
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <ScrollView className="flex-1 px-6">
		          {/* Header */}
		          <View className="py-4">
		            <Text className="text-white text-2xl font-bold text-center">
		              Twinsettings
		            </Text>
		            <Text className="text-white/70 text-center mt-2">
		              Manage your twincredible account and preferences
		            </Text>
		          </View>
		
		          {/* Premium Status Section */}
		          <View className="mb-6">
		            <PremiumStatusIndicator
		              variant="full"
		              showUpgradeButton={!isSubscriptionActive}
		              onUpgradePress={() => navigateToUpgrade(undefined, 'settings_status')}
		            />
		          </View>
		
		          {/* Subscription Management - Only show if premium */}
		          <PremiumOnly featureId="detailed_results">
		            <View className="bg-white/10 rounded-xl p-6 mb-6">
		              <Text className="text-white text-lg font-semibold mb-4">Subscription</Text>
		              
		              <View className="space-y-3">
		                <View className="flex-row items-center justify-between">
		                  <Text className="text-white">Plan</Text>
		                  <Text className="text-white font-medium capitalize">
		                    {subscriptionInfo.plan} Plan
		                  </Text>
		                </View>
		                
		                <View className="flex-row items-center justify-between">
		                  <Text className="text-white">Status</Text>
		                  <View className="flex-row items-center">
		                    <View 
		                      className="w-2 h-2 rounded-full mr-2"
		                      style={{ backgroundColor: subscriptionInfo.isActive ? '#10b981' : '#ef4444' }}
		                    />
		                    <Text 
		                      className="font-medium"
		                      style={{ color: subscriptionInfo.isActive ? '#10b981' : '#ef4444' }}
		                    >
		                      {subscriptionInfo.status}
		                    </Text>
		                  </View>
		                </View>
		                
		                {subscriptionInfo.expiryDate && (
		                  <View className="flex-row items-center justify-between">
		                    <Text className="text-white">
		                      {subscriptionInfo.willRenew ? 'Renews' : 'Expires'}
		                    </Text>
		                    <Text className="text-white/70">
		                      {formatSubscriptionDate(subscriptionInfo.expiryDate)}
		                    </Text>
		                  </View>
		                )}
		                
		                <View className="pt-3 border-t border-white/10">
		                  <Pressable
		                    onPress={handleManageSubscription}
		                    className="flex-row items-center justify-between"
		                  >
		                    <Text className="text-white">Manage Subscription</Text>
		                    <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		                  </Pressable>
		                </View>
		              </View>
		            </View>
		          </PremiumOnly>
		
		          {/* User Profile Section */}
		          {userProfile && (
		            <View className="bg-white/10 rounded-xl p-6 mb-6">
		              <Text className="text-white text-lg font-semibold mb-4">Your Twinprofile</Text>
		              
		              <View className="space-y-3">
		                <View className="flex-row items-center">
		                  <Ionicons name="person" size={20} color="white" />
		                  <Text className="text-white ml-3">{userProfile.name}</Text>
		                </View>
		                
		                <View className="flex-row items-center">
		                  <Ionicons name="calendar" size={20} color="white" />
		                  <Text className="text-white ml-3">Age: {userProfile.age}</Text>
		                </View>
		                
		                <View className="flex-row items-center">
		                  <Ionicons name="transgender" size={20} color="white" />
		                  <Text className="text-white ml-3">Gender: {userProfile.gender}</Text>
		                </View>
		                
		                <View className="flex-row items-center">
		                  <Ionicons name="people" size={20} color="white" />
		                  <Text className="text-white ml-3 capitalize">{userProfile.twinType} Twin</Text>
		                </View>
		                
		                <View className="flex-row items-center">
		                  <Ionicons name="gift" size={20} color="white" />
		                  <Text className="text-white ml-3">Birthday: {formatDate(userProfile.birthDate)}</Text>
		                </View>
		                
		                <View className="flex-row items-center">
		                  <View 
		                    className="w-5 h-5 rounded-full mr-3"
		                    style={{ backgroundColor: getNeonAccentColor(userProfile.accentColor) }}
		                  />
		                  <Text className="text-white">Your Accent Color</Text>
		                </View>
		              </View>
		            </View>
		          )}
		
		          {/* Twin Connection Section */}
		          {twinProfile && (
		            <View className="bg-white/10 rounded-xl p-6 mb-6">
		              <Text className="text-white text-lg font-semibold mb-4">Twinconnection Status</Text>
		              
		              <View className="space-y-3">
		                <View className="flex-row items-center">
		                  <Ionicons name="heart" size={20} color="white" />
		                  <Text className="text-white ml-3">{twinProfile.name}</Text>
		                </View>
		                
		                <View className="flex-row items-center">
		                  <View 
		                    className="w-5 h-5 rounded-full mr-3"
		                    style={{ backgroundColor: getNeonAccentColor(twinProfile.accentColor) }}
		                  />
		                  <Text className="text-white">Twin's Accent Color</Text>
		                </View>
		                
		                <View className="flex-row items-center">
		                  <View className={`w-3 h-3 rounded-full mr-3 ${twinProfile.isConnected ? 'bg-green-500' : 'bg-red-500'}`} />
		                  <Text className="text-white">{twinProfile.isConnected ? 'Twinsync Active' : 'Twinconnection Lost'}</Text>
		                </View>
		              </View>
		            </View>
		          )}
		
		          {/* Premium Features Access - Quick Links */}
		          <View className="bg-white/10 rounded-xl p-6 mb-6">
		            <Text className="text-white text-lg font-semibold mb-4">Premium Features</Text>
		            
		            <View className="space-y-4">
		              <Pressable 
		                onPress={() => navigation.navigate('Premium', { source: 'settings' })}
		                className="flex-row items-center justify-between"
		              >
		                <View className="flex-row items-center">
		                  <Ionicons name="star" size={20} color={neonColor} />
		                  <Text className="text-white ml-3">
		                    {isSubscriptionActive ? 'Premium Dashboard' : 'Upgrade to Premium'}
		                  </Text>
		                </View>
		                <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		              </Pressable>
		              
		              <Pressable 
		                onPress={() => navigation.navigate('PremiumFeatures')}
		                className="flex-row items-center justify-between"
		              >
		                <View className="flex-row items-center">
		                  <Ionicons name="list" size={20} color="white" />
		                  <Text className="text-white ml-3">View All Features</Text>
		                </View>
		                <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		              </Pressable>
		              
		              <Pressable 
		                onPress={handleRestorePurchases}
		                disabled={isRestoringPurchases}
		                className="flex-row items-center justify-between"
		              >
		                <View className="flex-row items-center">
		                  <Ionicons 
		                    name="refresh" 
		                    size={20} 
		                    color={isRestoringPurchases ? "#6b7280" : "white"} 
		                  />
		                  <Text className={`ml-3 ${isRestoringPurchases ? 'text-gray-400' : 'text-white'}`}>
		                    {isRestoringPurchases ? 'Restoring...' : 'Restore Purchases'}
		                  </Text>
		                </View>
		                <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		              </Pressable>
		            </View>
		          </View>
		
		          {/* App Settings */}
		          <View className="bg-white/10 rounded-xl p-6 mb-6">
		            <Text className="text-white text-lg font-semibold mb-4">Twincredible Settings</Text>
		            
		            <View className="space-y-4">
		              <Pressable
		                onPress={() => setNotificationsEnabled(!notificationsEnabled)}
		                className="flex-row items-center justify-between"
		              >
		                <View className="flex-row items-center">
		                  <Ionicons name="notifications" size={20} color="white" />
		                  <Text className="text-white ml-3">Twinspirations</Text>
		                </View>
		                <Ionicons 
		                  name={notificationsEnabled ? "toggle" : "toggle-outline"} 
		                  size={24} 
		                  color={notificationsEnabled ? neonColor : "rgba(255,255,255,0.5)"} 
		                />
		              </Pressable>
		              
		              <Pressable
		                onPress={() => setResearchParticipation(!researchParticipation)}
		                className="flex-row items-center justify-between"
		              >
		                <View className="flex-row items-center">
		                  <Ionicons name="flask" size={20} color="white" />
		                  <Text className="text-white ml-3">Twinquiry Participation</Text>
		                </View>
		                <Ionicons 
		                  name={researchParticipation ? "toggle" : "toggle-outline"} 
		                  size={24} 
		                  color={researchParticipation ? neonColor : "rgba(255,255,255,0.5)"} 
		                />
		              </Pressable>
		            </View>
		          </View>
		
		          {/* Account Actions */}
		          <View className="bg-white/10 rounded-xl p-6 mb-6">
		            <Text className="text-white text-lg font-semibold mb-4">Twincredible Account</Text>
		            
		            <View className="space-y-4">
		              <Pressable className="flex-row items-center">
		                <Ionicons name="create" size={20} color="white" />
		                <Text className="text-white ml-3">Edit Twinprofile</Text>
		                <View className="flex-1" />
		                <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		              </Pressable>
		              
		              <Pressable className="flex-row items-center">
		                <Ionicons name="help-circle" size={20} color="white" />
		                <Text className="text-white ml-3">Twincredible Support</Text>
		                <View className="flex-1" />
		                <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		              </Pressable>
		              
		              <Pressable className="flex-row items-center">
		                <Ionicons name="document-text" size={20} color="white" />
		                <Text className="text-white ml-3">Twincredible Privacy</Text>
		                <View className="flex-1" />
		                <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		              </Pressable>
		              
		              <Pressable className="flex-row items-center">
		                <Ionicons name="information-circle" size={20} color="white" />
		                <Text className="text-white ml-3">About Twinship</Text>
		                <View className="flex-1" />
		                <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		              </Pressable>
		            </View>
		          </View>
		
		          {/* Upgrade CTA for Free Users */}
		          {!isSubscriptionActive && (
		            <View className="bg-gradient-to-r from-purple-600/20 to-pink-600/20 rounded-xl p-6 mb-6 border border-purple-500/30">
		              <View className="items-center">
		                <Ionicons name="star" size={32} color={neonColor} />
		                <Text className="text-white text-xl font-bold text-center mt-2">
		                  Unlock Premium Features
		                </Text>
		                <Text className="text-gray-300 text-center mt-2 mb-4">
		                  Get detailed insights, coaching plans, and unlimited assessments
		                </Text>
		                <PremiumUpgradeButton
		                  featureId="detailed_results"
		                  onUpgrade={() => navigateToUpgrade(undefined, 'settings_cta')}
		                  text="Upgrade Now"
		                />
		              </View>
		            </View>
		          )}
		
		          {/* Sign Out Button */}
		          <View className="bg-white/10 rounded-xl p-6 mb-8">
		            <Pressable
		              onPress={handleSignOut}
		              className="flex-row items-center justify-center py-2"
		            >
		              <Ionicons name="log-out" size={20} color="#ff4444" />
		              <Text className="text-red-400 ml-3 text-lg font-semibold">Twinconnect</Text>
		            </Pressable>
		          </View>
		        </ScrollView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/SettingsScreen.tsx'><![CDATA[
		import React, { useState } from "react";
		import { View, Text, Pressable, Alert, ScrollView, TextInput, Modal, ImageBackground } from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { useNavigation } from "@react-navigation/native";
		import { useTwinStore } from "../state/twinStore";
		import { Ionicons } from "@expo/vector-icons";
		import { getNeonAccentColor } from "../utils/neonColors";
		
		export const SettingsScreen = () => {
		  const navigation = useNavigation<any>();
		  const { userProfile, twinProfile, signOut, researchParticipation, setResearchParticipation, notificationsEnabled, setNotificationsEnabled, setUserProfile } = useTwinStore();
		  const themeColor = userProfile?.accentColor || "neon-purple";
		  
		  const [editingField, setEditingField] = useState<string | null>(null);
		  const [tempValue, setTempValue] = useState("");
		  const [showLocationSettings, setShowLocationSettings] = useState(false);
		
		  const handleSignOut = () => {
		    Alert.alert(
		      "Twinconnect",
		      "Are you sure you want to twinconnect? You'll need to complete the setup process again to re-establish twinsync.",
		      [
		        { text: "Cancel", style: "cancel" },
		        { 
		          text: "Twinconnect", 
		          style: "destructive", 
		          onPress: () => {
		            signOut();
		            Alert.alert("Twinconnected", "You have been successfully twinconnected.");
		          }
		        }
		      ]
		    );
		  };
		
		  const formatDate = (dateString: string) => {
		    return new Date(dateString).toLocaleDateString();
		  };
		
		  const startEditing = (field: string, currentValue: string) => {
		    setEditingField(field);
		    setTempValue(currentValue);
		  };
		
		  const saveEdit = () => {
		    if (!userProfile || !editingField) return;
		    
		    const updatedProfile = { ...userProfile };
		    switch (editingField) {
		      case 'name':
		        updatedProfile.name = tempValue;
		        break;
		      case 'age':
		        const age = parseInt(tempValue);
		        if (!isNaN(age) && age > 0 && age < 150) {
		          updatedProfile.age = age;
		        } else {
		          Alert.alert("Invalid Age", "Please enter a valid age between 1 and 149");
		          return;
		        }
		        break;
		    }
		    
		    setUserProfile(updatedProfile);
		    setEditingField(null);
		    setTempValue("");
		  };
		
		  const cancelEdit = () => {
		    setEditingField(null);
		    setTempValue("");
		  };
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <ScrollView className="flex-1 px-6">
		          {/* Header */}
		          <View className="flex-row items-center justify-between py-4">
		            <Pressable onPress={() => navigation.goBack()} className="w-10 h-10 rounded-full bg-white/10 items-center justify-center">
		              <Ionicons name="chevron-back" size={20} color="white" />
		            </Pressable>
		            <View className="flex-1">
		              <Text className="text-white text-2xl font-bold text-center">
		                Twinsettings
		              </Text>
		              <Text className="text-white/70 text-center mt-2">
		                Manage your twincredible account and preferences
		              </Text>
		            </View>
		            <View className="w-10" />
		          </View>
		
		          {/* User Profile Section */}
		          {userProfile && (
		            <View className="bg-white/10 rounded-xl p-6 mb-6">
		              <Text className="text-white text-lg font-semibold mb-4">Your Twinprofile</Text>
		              
		              <View className="space-y-4">
		                {/* Editable Name */}
		                <View className="flex-row items-center justify-between">
		                  <View className="flex-row items-center flex-1">
		                    <Ionicons name="person" size={20} color="white" />
		                    {editingField === 'name' ? (
		                      <View className="flex-1 ml-3 flex-row items-center">
		                        <TextInput
		                          value={tempValue}
		                          onChangeText={setTempValue}
		                          className="text-white flex-1 bg-white/20 rounded-lg px-3 py-2 mr-2"
		                          placeholder="Enter name"
		                          placeholderTextColor="rgba(255,255,255,0.5)"
		                        />
		                        <Pressable onPress={saveEdit} className="bg-green-500/30 rounded-lg p-2 mr-1">
		                          <Ionicons name="checkmark" size={16} color="white" />
		                        </Pressable>
		                        <Pressable onPress={cancelEdit} className="bg-red-500/30 rounded-lg p-2">
		                          <Ionicons name="close" size={16} color="white" />
		                        </Pressable>
		                      </View>
		                    ) : (
		                      <Text className="text-white ml-3 flex-1">{userProfile.name}</Text>
		                    )}
		                  </View>
		                  {editingField !== 'name' && (
		                    <Pressable onPress={() => startEditing('name', userProfile.name)} className="ml-3">
		                      <Ionicons name="pencil" size={18} color="rgba(255,255,255,0.7)" />
		                    </Pressable>
		                  )}
		                </View>
		                
		                {/* Editable Age */}
		                <View className="flex-row items-center justify-between">
		                  <View className="flex-row items-center flex-1">
		                    <Ionicons name="calendar" size={20} color="white" />
		                    {editingField === 'age' ? (
		                      <View className="flex-1 ml-3 flex-row items-center">
		                        <TextInput
		                          value={tempValue}
		                          onChangeText={setTempValue}
		                          className="text-white flex-1 bg-white/20 rounded-lg px-3 py-2 mr-2"
		                          placeholder="Enter age"
		                          placeholderTextColor="rgba(255,255,255,0.5)"
		                          keyboardType="numeric"
		                        />
		                        <Pressable onPress={saveEdit} className="bg-green-500/30 rounded-lg p-2 mr-1">
		                          <Ionicons name="checkmark" size={16} color="white" />
		                        </Pressable>
		                        <Pressable onPress={cancelEdit} className="bg-red-500/30 rounded-lg p-2">
		                          <Ionicons name="close" size={16} color="white" />
		                        </Pressable>
		                      </View>
		                    ) : (
		                      <Text className="text-white ml-3 flex-1">Age: {userProfile.age}</Text>
		                    )}
		                  </View>
		                  {editingField !== 'age' && (
		                    <Pressable onPress={() => startEditing('age', userProfile.age.toString())} className="ml-3">
		                      <Ionicons name="pencil" size={18} color="rgba(255,255,255,0.7)" />
		                    </Pressable>
		                  )}
		                </View>
		                
		                <View className="flex-row items-center">
		                  <Ionicons name="transgender" size={20} color="white" />
		                  <Text className="text-white ml-3">Gender: {userProfile.gender}</Text>
		                </View>
		                
		                <View className="flex-row items-center">
		                  <Ionicons name="people" size={20} color="white" />
		                  <Text className="text-white ml-3 capitalize">{userProfile.twinType} Twin</Text>
		                </View>
		                
		                <View className="flex-row items-center">
		                  <Ionicons name="gift" size={20} color="white" />
		                  <Text className="text-white ml-3">Birthday: {formatDate(userProfile.birthDate)}</Text>
		                </View>
		                
		                <View className="flex-row items-center">
		                  <View 
		                    className="w-5 h-5 rounded-full mr-3"
		                    style={{ backgroundColor: getNeonAccentColor(userProfile.accentColor) }}
		                  />
		                  <Text className="text-white">Your Accent Color</Text>
		                </View>
		              </View>
		            </View>
		          )}
		
		          {/* Twin Connection Section */}
		          {twinProfile && (
		            <View className="bg-white/10 rounded-xl p-6 mb-6">
		              <Text className="text-white text-lg font-semibold mb-4">Twinconnection Status</Text>
		              
		              <View className="space-y-3">
		                <View className="flex-row items-center">
		                  <Ionicons name="heart" size={20} color="white" />
		                  <Text className="text-white ml-3">{twinProfile.name}</Text>
		                </View>
		                
		                <View className="flex-row items-center">
		                  <View 
		                    className="w-5 h-5 rounded-full mr-3"
		                    style={{ backgroundColor: getNeonAccentColor(twinProfile.accentColor) }}
		                  />
		                  <Text className="text-white">Twin's Accent Color</Text>
		                </View>
		                
		                <View className="flex-row items-center">
		                  <View className={`w-3 h-3 rounded-full mr-3 ${twinProfile.isConnected ? 'bg-green-500' : 'bg-red-500'}`} />
		                  <Text className="text-white">{twinProfile.isConnected ? 'Twinsync Active' : 'Twinconnection Lost'}</Text>
		                </View>
		              </View>
		            </View>
		          )}
		
		          {/* App Settings */}
		          <View className="bg-white/10 rounded-xl p-6 mb-6">
		            <Text className="text-white text-lg font-semibold mb-4">Twincredible Settings</Text>
		            
		            <View className="space-y-4">
		              <Pressable
		                onPress={() => setNotificationsEnabled(!notificationsEnabled)}
		                className="flex-row items-center justify-between"
		              >
		                <View className="flex-row items-center">
		                  <Ionicons name="notifications" size={20} color="white" />
		                  <Text className="text-white ml-3">Twinspirations</Text>
		                </View>
		                <Ionicons 
		                  name={notificationsEnabled ? "toggle" : "toggle-outline"} 
		                  size={24} 
		                  color={notificationsEnabled ? getNeonAccentColor(themeColor) : "rgba(255,255,255,0.5)"} 
		                />
		              </Pressable>
		              
		              <Pressable
		                onPress={() => setResearchParticipation(!researchParticipation)}
		                className="flex-row items-center justify-between"
		              >
		                <View className="flex-row items-center">
		                  <Ionicons name="flask" size={20} color="white" />
		                  <Text className="text-white ml-3">Twinquiry Participation</Text>
		                </View>
		                <Ionicons 
		                  name={researchParticipation ? "toggle" : "toggle-outline"} 
		                  size={24} 
		                  color={researchParticipation ? getNeonAccentColor(themeColor) : "rgba(255,255,255,0.5)"} 
		                />
		              </Pressable>
		
		              <Pressable
		                onPress={() => setShowLocationSettings(true)}
		                className="flex-row items-center justify-between"
		              >
		                <View className="flex-row items-center">
		                  <Ionicons name="location" size={20} color="white" />
		                  <Text className="text-white ml-3">Location Sharing</Text>
		                </View>
		                <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		              </Pressable>
		            </View>
		          </View>
		
		          {/* Account Actions */}
		          <View className="bg-white/10 rounded-xl p-6 mb-6">
		            <Text className="text-white text-lg font-semibold mb-4">Twincredible Account</Text>
		            
		            <View className="space-y-4">
		              <Pressable className="flex-row items-center">
		                <Ionicons name="help-circle" size={20} color="white" />
		                <Text className="text-white ml-3">Twincredible Support</Text>
		                <View className="flex-1" />
		                <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		              </Pressable>
		              
		              <Pressable className="flex-row items-center">
		                <Ionicons name="document-text" size={20} color="white" />
		                <Text className="text-white ml-3">Twincredible Privacy</Text>
		                <View className="flex-1" />
		                <Ionicons name="chevron-forward" size={20} color="rgba(255,255,255,0.7)" />
		              </Pressable>
		            </View>
		          </View>
		
		          {/* Sign Out Button */}
		          <View className="bg-white/10 rounded-xl p-6 mb-8">
		            <Pressable
		              onPress={handleSignOut}
		              className="flex-row items-center justify-center py-2"
		            >
		              <Ionicons name="log-out" size={20} color="#ff4444" />
		              <Text className="text-red-400 ml-3 text-lg font-semibold">Twinconnect</Text>
		            </Pressable>
		          </View>
		        </ScrollView>
		
		        {/* Location Settings Modal */}
		        <Modal
		          visible={showLocationSettings}
		          animationType="slide"
		          transparent={true}
		        >
		          <View className="flex-1 bg-black/50 justify-end">
		            <View className="bg-white/95 rounded-t-3xl p-6 max-h-96">
		              <View className="flex-row items-center justify-between mb-6">
		                <Text className="text-black text-xl font-bold">Location Sharing</Text>
		                <Pressable onPress={() => setShowLocationSettings(false)}>
		                  <Ionicons name="close" size={24} color="black" />
		                </Pressable>
		              </View>
		              
		              <View className="space-y-4">
		                <Pressable className="flex-row items-center justify-between p-4 bg-gray-100 rounded-xl">
		                  <View className="flex-row items-center">
		                    <Ionicons name="location" size={20} color="#666" />
		                    <Text className="text-black ml-3">Share Location with Twin</Text>
		                  </View>
		                  <Ionicons name="toggle-outline" size={24} color="#666" />
		                </Pressable>
		                
		                <Pressable className="flex-row items-center justify-between p-4 bg-gray-100 rounded-xl">
		                  <View className="flex-row items-center">
		                    <Ionicons name="eye" size={20} color="#666" />
		                    <Text className="text-black ml-3">See Twin's Location</Text>
		                  </View>
		                  <Ionicons name="toggle-outline" size={24} color="#666" />
		                </Pressable>
		                
		                <Text className="text-gray-600 text-sm text-center mt-4 leading-5">
		                  Location sharing allows you and your twin to see each other's real-time location on a map. This helps you stay connected and aware of each other's whereabouts.
		                </Text>
		              </View>
		            </View>
		          </View>
		        </Modal>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/stories/CreateStoryScreen.tsx'><![CDATA[
		import React, { useState } from 'react';
		import { View, Text, Pressable, Alert, ImageBackground } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { Ionicons } from '@expo/vector-icons';
		import { StoryEditor } from '../../components/stories/StoryEditor';
		import { useTwinStore } from '../../state/twinStore';
		import { useStoryStore } from '../../state/stores/stories/storyStore';
		
		interface CreateStoryScreenProps {
		  navigation: any;
		  route?: {
		    params?: {
		      draftId?: string;
		    };
		  };
		}
		
		export const CreateStoryScreen: React.FC<CreateStoryScreenProps> = ({ navigation, route }) => {
		  const [isSaving, setIsSaving] = useState(false);
		  const { userProfile } = useTwinStore();
		  const { addStory, drafts, currentDraft, setCurrentDraft, deleteDraft } = useStoryStore();
		  
		  const draftId = route?.params?.draftId;
		  const draft = draftId ? drafts.find(d => d.id === draftId) : currentDraft;
		
		  const handleSave = async (storyData: any) => {
		    setIsSaving(true);
		    
		    try {
		      // Add the story
		      addStory(storyData);
		      
		      // Clean up draft if it exists
		      if (draft?.id) {
		        deleteDraft(draft.id);
		      }
		      if (currentDraft) {
		        setCurrentDraft(null);
		      }
		      
		      // Show success message
		      Alert.alert(
		        'Story Created!',
		        'Your story has been saved successfully.',
		        [
		          {
		            text: 'View Story',
		            onPress: () => {
		              navigation.replace('StoryDetail', { storyId: 'latest' });
		            }
		          },
		          {
		            text: 'Create Another',
		            onPress: () => {
		              navigation.replace('CreateStory');
		            }
		          },
		          {
		            text: 'Back to Stories',
		            style: 'default',
		            onPress: () => {
		              navigation.goBack();
		            }
		          }
		        ],
		        { cancelable: false }
		      );
		      
		    } catch (error) {
		      console.error('Error saving story:', error);
		      Alert.alert(
		        'Save Failed',
		        'There was an error saving your story. Please try again.',
		        [{ text: 'OK' }]
		      );
		    } finally {
		      setIsSaving(false);
		    }
		  };
		
		  const handleCancel = () => {
		    if (currentDraft || draft) {
		      Alert.alert(
		        'Save Draft?',
		        'Do you want to save your progress as a draft before leaving?',
		        [
		          {
		            text: 'Discard',
		            style: 'destructive',
		            onPress: () => {
		              if (currentDraft) {
		                setCurrentDraft(null);
		              }
		              navigation.goBack();
		            }
		          },
		          {
		            text: 'Save Draft',
		            onPress: () => {
		              // Draft is auto-saved by the StoryEditor component
		              navigation.goBack();
		            }
		          },
		          {
		            text: 'Keep Editing',
		            style: 'cancel'
		          }
		        ]
		      );
		    } else {
		      navigation.goBack();
		    }
		  };
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        {/* Header */}
		        <View className="flex-row items-center justify-between px-6 py-4 border-b border-white/10">
		          <Pressable 
		            onPress={handleCancel}
		            className="flex-row items-center"
		          >
		            <Ionicons name="arrow-back" size={24} color="white" />
		            <Text className="text-white text-lg font-medium ml-2">Cancel</Text>
		          </Pressable>
		          
		          <Text className="text-white text-xl font-semibold">
		            {draft ? 'Edit Draft' : 'New Story'}
		          </Text>
		          
		          <View className="w-20" /> {/* Spacer for centering */}
		        </View>
		
		        {/* Loading Overlay */}
		        {isSaving && (
		          <View className="absolute inset-0 bg-black/50 items-center justify-center z-50">
		            <View className="bg-white/10 rounded-2xl p-8 items-center border border-white/20">
		              <View className="animate-spin mb-4">
		                <Ionicons name="sync" size={32} color="white" />
		              </View>
		              <Text className="text-white text-lg font-semibold">Saving Story...</Text>
		              <Text className="text-white/70 text-sm mt-1">Please wait while we save your story</Text>
		            </View>
		          </View>
		        )}
		
		        {/* Story Editor */}
		        <StoryEditor
		          draft={draft}
		          onSave={handleSave}
		          onCancel={handleCancel}
		          autoSave={true}
		        />
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/stories/StoriesScreen.tsx'><![CDATA[
		import React, { useState, useEffect } from 'react';
		import { View, Text, Pressable, ScrollView, TextInput, RefreshControl, Dimensions, ImageBackground } from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { Ionicons } from '@expo/vector-icons';
		import { LinearGradient } from 'expo-linear-gradient';
		import { StoryCard } from '../../components/stories/StoryCard';
		import { useTwinStore } from '../../state/twinStore';
		import { useStoryStore } from '../../state/stores/stories/storyStore';
		import { StoryCategory } from '../../types/stories';
		
		interface StoriesScreenProps {
		  navigation: any;
		}
		
		const { width: screenWidth } = Dimensions.get('window');
		
		const CATEGORY_FILTERS: { key: StoryCategory | 'all'; label: string; icon: string; color: string }[] = [
		  { key: 'all', label: 'All', icon: 'albums', color: '#8A2BE2' },
		  { key: 'childhood', label: 'Childhood', icon: 'happy', color: '#FFB347' },
		  { key: 'milestones', label: 'Milestones', icon: 'trophy', color: '#FFD700' },
		  { key: 'adventures', label: 'Adventures', icon: 'map', color: '#32CD32' },
		  { key: 'synchronicity', label: 'Twin Sync', icon: 'radio', color: '#FF1493' },
		  { key: 'achievements', label: 'Achievements', icon: 'star', color: '#8A2BE2' },
		  { key: 'memories', label: 'Memories', icon: 'heart', color: '#FF69B4' },
		];
		
		export const StoriesScreen: React.FC<StoriesScreenProps> = ({ navigation }) => {
		  const [refreshing, setRefreshing] = useState(false);
		  const [showSearch, setShowSearch] = useState(false);
		  const { userProfile } = useTwinStore();
		  const {
		    filteredStories,
		    selectedCategory,
		    searchText,
		    isCreatingStory,
		    setSelectedCategory,
		    setSearchText,
		    applyFilters,
		    clearFilters,
		    getStoryStats,
		    getRecentStories,
		  } = useStoryStore();
		
		  const stats = getStoryStats();
		  const recentStories = getRecentStories(5);
		  const displayStories = showSearch || searchText || selectedCategory !== 'all' 
		    ? filteredStories 
		    : recentStories;
		
		  useEffect(() => {
		    applyFilters();
		  }, []);
		
		  const handleRefresh = async () => {
		    setRefreshing(true);
		    applyFilters();
		    setTimeout(() => setRefreshing(false), 1000);
		  };
		
		  const navigateToCreateStory = () => {
		    navigation.navigate('CreateStory');
		  };
		
		  const navigateToStoryDetail = (storyId: string) => {
		    navigation.navigate('StoryDetail', { storyId });
		  };
		
		  const navigateToTimeline = () => {
		    // Navigate to timeline view (to be implemented)
		    console.log('Navigate to timeline');
		  };
		
		  const StatsCard: React.FC = () => (
		    <LinearGradient
		      colors={['rgba(255,255,255,0.15)', 'rgba(255,255,255,0.05)']}
		      className="rounded-2xl p-4 mb-6 border border-white/20"
		    >
		      <Text className="text-white font-semibold text-lg mb-3">Your Story Journey</Text>
		      <View className="flex-row items-center justify-between">
		        <View className="items-center">
		          <Text className="text-white text-2xl font-bold">{stats.totalStories}</Text>
		          <Text className="text-white/60 text-sm">Total Stories</Text>
		        </View>
		        <View className="items-center">
		          <Text className="text-white text-2xl font-bold">{stats.storiesThisMonth}</Text>
		          <Text className="text-white/60 text-sm">This Month</Text>
		        </View>
		        <View className="items-center">
		          <Text className="text-white text-2xl font-bold">{stats.milestoneCount}</Text>
		          <Text className="text-white/60 text-sm">Milestones</Text>
		        </View>
		        <Pressable onPress={navigateToTimeline} className="items-center">
		          <View className="bg-purple-500/30 rounded-full p-2">
		            <Ionicons name="timeline" size={20} color="#8A2BE2" />
		          </View>
		          <Text className="text-purple-400 text-xs mt-1">Timeline</Text>
		        </Pressable>
		      </View>
		    </LinearGradient>
		  );
		
		  const CategoryFilter: React.FC = () => (
		    <View className="mb-6">
		      <ScrollView 
		        horizontal 
		        showsHorizontalScrollIndicator={false}
		        contentContainerStyle={{ paddingHorizontal: 4 }}
		      >
		        {CATEGORY_FILTERS.map((filter) => (
		          <Pressable
		            key={filter.key}
		            onPress={() => setSelectedCategory(filter.key)}
		            className={`mr-3 ${selectedCategory === filter.key ? 'opacity-100' : 'opacity-70'}`}
		          >
		            <LinearGradient
		              colors={
		                selectedCategory === filter.key
		                  ? [filter.color + '40', filter.color + '20']
		                  : ['rgba(255,255,255,0.1)', 'rgba(255,255,255,0.05)']
		              }
		              className={`rounded-xl px-4 py-2 flex-row items-center border ${
		                selectedCategory === filter.key ? 'border-opacity-60' : 'border-white/10'
		              }`}
		              style={{ borderColor: selectedCategory === filter.key ? filter.color : undefined }}
		            >
		              <Ionicons 
		                name={filter.icon as any} 
		                size={18} 
		                color={selectedCategory === filter.key ? filter.color : 'rgba(255,255,255,0.7)'} 
		              />
		              <Text 
		                className={`ml-2 font-medium ${
		                  selectedCategory === filter.key ? 'text-white' : 'text-white/70'
		                }`}
		              >
		                {filter.label}
		              </Text>
		            </LinearGradient>
		          </Pressable>
		        ))}
		      </ScrollView>
		    </View>
		  );
		
		  const SearchBar: React.FC = () => (
		    showSearch ? (
		      <View className="mb-6">
		        <View className="flex-row items-center bg-white/10 rounded-xl px-4 py-3 border border-white/20">
		          <Ionicons name="search" size={20} color="rgba(255,255,255,0.6)" />
		          <TextInput
		            value={searchText}
		            onChangeText={setSearchText}
		            placeholder="Search your stories..."
		            placeholderTextColor="rgba(255,255,255,0.5)"
		            className="flex-1 text-white ml-3"
		            autoFocus
		          />
		          {searchText.length > 0 && (
		            <Pressable onPress={() => setSearchText('')} className="ml-2">
		              <Ionicons name="close-circle" size={20} color="rgba(255,255,255,0.6)" />
		            </Pressable>
		          )}
		        </View>
		        {(searchText || selectedCategory !== 'all') && (
		          <Pressable 
		            onPress={clearFilters}
		            className="mt-2 flex-row items-center justify-center"
		          >
		            <Text className="text-blue-400 text-sm">Clear filters</Text>
		          </Pressable>
		        )}
		      </View>
		    ) : null
		  );
		
		  const EmptyState: React.FC = () => (
		    <View className="items-center py-12">
		      <LinearGradient
		        colors={['rgba(138, 43, 226, 0.2)', 'rgba(138, 43, 226, 0.05)']}
		        className="rounded-full p-8 mb-6"
		      >
		        <Ionicons name="book-outline" size={64} color="rgba(138, 43, 226, 0.8)" />
		      </LinearGradient>
		      <Text className="text-white text-xl font-semibold mb-2 text-center">
		        {searchText || selectedCategory !== 'all' 
		          ? 'No stories found' 
		          : 'Start Your Story Journey'}
		      </Text>
		      <Text className="text-white/60 text-center mb-6 px-8 leading-6">
		        {searchText || selectedCategory !== 'all'
		          ? 'Try adjusting your search or filters to find the stories you\'re looking for.'
		          : 'Document your twin journey with photos, videos, and memories. Create your first story and start building your digital scrapbook.'}
		      </Text>
		      {!(searchText || selectedCategory !== 'all') && (
		        <Pressable
		          onPress={navigateToCreateStory}
		          className="bg-purple-500 rounded-xl px-6 py-3 flex-row items-center"
		        >
		          <Ionicons name="add" size={20} color="white" />
		          <Text className="text-white font-semibold ml-2">Create First Story</Text>
		        </Pressable>
		      )}
		    </View>
		  );
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <View className="flex-1">
		          {/* Header */}
		          <View className="flex-row items-center justify-between px-6 py-4">
		            <View className="flex-1">
		              <Text className="text-white text-2xl font-bold">Twin Stories</Text>
		              <Text className="text-white/70 text-sm">
		                Your shared journey together
		              </Text>
		            </View>
		            
		            <View className="flex-row items-center space-x-3">
		              <Pressable
		                onPress={() => setShowSearch(!showSearch)}
		                className="bg-white/10 rounded-full p-3 border border-white/20"
		              >
		                <Ionicons 
		                  name={showSearch ? "close" : "search"} 
		                  size={20} 
		                  color="white" 
		                />
		              </Pressable>
		              
		              <Pressable
		                onPress={navigateToCreateStory}
		                className="bg-purple-500 rounded-full p-3"
		              >
		                <Ionicons name="add" size={20} color="white" />
		              </Pressable>
		            </View>
		          </View>
		
		          <ScrollView
		            className="flex-1 px-6"
		            showsVerticalScrollIndicator={false}
		            refreshControl={
		              <RefreshControl
		                refreshing={refreshing}
		                onRefresh={handleRefresh}
		                tintColor="white"
		                colors={['#8A2BE2']}
		              />
		            }
		          >
		            {/* Search Bar */}
		            <SearchBar />
		
		            {/* Stats Card - Only show when not searching/filtering */}
		            {!showSearch && searchText === '' && selectedCategory === 'all' && stats.totalStories > 0 && (
		              <StatsCard />
		            )}
		
		            {/* Category Filter */}
		            <CategoryFilter />
		
		            {/* Stories List */}
		            {displayStories.length === 0 ? (
		              <EmptyState />
		            ) : (
		              <View className="pb-6">
		                {/* Section Header */}
		                {!showSearch && searchText === '' && selectedCategory === 'all' && (
		                  <View className="flex-row items-center justify-between mb-4">
		                    <Text className="text-white text-lg font-semibold">Recent Stories</Text>
		                    {stats.totalStories > 5 && (
		                      <Pressable onPress={() => setShowSearch(true)}>
		                        <Text className="text-purple-400 text-sm">View all</Text>
		                      </Pressable>
		                    )}
		                  </View>
		                )}
		                
		                {displayStories.map((story) => (
		                  <StoryCard
		                    key={story.id}
		                    story={story}
		                    onPress={() => navigateToStoryDetail(story.id)}
		                    showActions={true}
		                  />
		                ))}
		              </View>
		            )}
		          </ScrollView>
		        </View>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/stories/StoryDetailScreen.tsx'><![CDATA[
		import React, { useState, useEffect } from 'react';
		import { 
		  View, 
		  Text, 
		  Pressable, 
		  ScrollView, 
		  Image, 
		  Dimensions,
		  Alert,
		  TextInput,
		  KeyboardAvoidingView,
		  Platform,
		  ImageBackground
		} from 'react-native';
		import { SafeAreaView } from 'react-native-safe-area-context';
		import { Ionicons } from '@expo/vector-icons';
		import { LinearGradient } from 'expo-linear-gradient';
		import { useTwinStore } from '../../state/twinStore';
		import { useStoryStore } from '../../state/stores/stories/storyStore';
		import { Story, StoryCategory } from '../../types/stories';
		
		interface StoryDetailScreenProps {
		  navigation: any;
		  route: {
		    params: {
		      storyId: string;
		    };
		  };
		}
		
		const { width: screenWidth } = Dimensions.get('window');
		
		export const StoryDetailScreen: React.FC<StoryDetailScreenProps> = ({ navigation, route }) => {
		  const { storyId } = route.params;
		  const [currentMediaIndex, setCurrentMediaIndex] = useState(0);
		  const [showComments, setShowComments] = useState(false);
		  const [newComment, setNewComment] = useState('');
		  const [isEditing, setIsEditing] = useState(false);
		
		  const { userProfile, twinProfile } = useTwinStore();
		  const { 
		    stories, 
		    likeStory, 
		    unlikeStory, 
		    favoriteStory, 
		    unfavoriteStory,
		    shareStory,
		    unshareStory,
		    addComment,
		    deleteStory,
		    viewStory
		  } = useStoryStore();
		
		  const story = storyId === 'latest' 
		    ? stories[0] 
		    : stories.find(s => s.id === storyId);
		
		  const currentUserId = userProfile?.id || '';
		  const isAuthor = story?.authorId === currentUserId;
		  const isLiked = story?.likes.includes(currentUserId) || false;
		  const isFavorited = story?.favorites.includes(currentUserId) || false;
		
		  useEffect(() => {
		    if (story && currentUserId) {
		      viewStory(story.id, currentUserId);
		    }
		  }, [story, currentUserId]);
		
		  if (!story) {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1 items-center justify-center">
		          <Ionicons name="book-outline" size={64} color="rgba(255,255,255,0.5)" />
		          <Text className="text-white text-xl font-semibold mt-4">Story not found</Text>
		          <Pressable
		            onPress={() => navigation.goBack()}
		            className="bg-purple-500 rounded-xl px-6 py-3 mt-6"
		          >
		            <Text className="text-white font-semibold">Go Back</Text>
		          </Pressable>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  const getCategoryIcon = (category: StoryCategory): string => {
		    switch (category) {
		      case 'childhood': return 'happy-outline';
		      case 'milestones': return 'trophy-outline';
		      case 'adventures': return 'map-outline';
		      case 'synchronicity': return 'radio-outline';
		      case 'achievements': return 'star-outline';
		      case 'memories': return 'heart-outline';
		      default: return 'book-outline';
		    }
		  };
		
		  const getCategoryColor = (category: StoryCategory): string => {
		    switch (category) {
		      case 'childhood': return '#FFB347';
		      case 'milestones': return '#FFD700';
		      case 'adventures': return '#32CD32';
		      case 'synchronicity': return '#FF1493';
		      case 'achievements': return '#8A2BE2';
		      case 'memories': return '#FF69B4';
		      default: return '#87CEEB';
		    }
		  };
		
		  const formatDate = (timestamp: string) => {
		    return new Date(timestamp).toLocaleDateString('en-US', {
		      year: 'numeric',
		      month: 'long',
		      day: 'numeric',
		      hour: '2-digit',
		      minute: '2-digit',
		    });
		  };
		
		  const handleLike = () => {
		    if (isLiked) {
		      unlikeStory(story.id, currentUserId);
		    } else {
		      likeStory(story.id, currentUserId);
		    }
		  };
		
		  const handleFavorite = () => {
		    if (isFavorited) {
		      unfavoriteStory(story.id, currentUserId);
		    } else {
		      favoriteStory(story.id, currentUserId);
		    }
		  };
		
		  const handleShare = () => {
		    if (story.isShared) {
		      unshareStory(story.id);
		    } else if (twinProfile) {
		      shareStory(story.id, twinProfile.id);
		    }
		  };
		
		  const handleDelete = () => {
		    Alert.alert(
		      'Delete Story',
		      'Are you sure you want to delete this story? This action cannot be undone.',
		      [
		        { text: 'Cancel', style: 'cancel' },
		        { 
		          text: 'Delete', 
		          style: 'destructive',
		          onPress: () => {
		            deleteStory(story.id);
		            navigation.goBack();
		          }
		        }
		      ]
		    );
		  };
		
		  const handleAddComment = () => {
		    if (newComment.trim()) {
		      addComment(story.id, currentUserId, newComment.trim());
		      setNewComment('');
		    }
		  };
		
		  const MediaViewer: React.FC = () => {
		    if (story.media.length === 0) return null;
		
		    const currentMedia = story.media[currentMediaIndex];
		
		    return (
		      <View className="mb-6">
		        <View className="relative">
		          {currentMedia.type === 'photo' ? (
		            <Image
		              source={{ uri: currentMedia.uri }}
		              className="w-full h-80 rounded-2xl"
		              resizeMode="cover"
		            />
		          ) : currentMedia.type === 'video' ? (
		            <View className="w-full h-80 bg-black/20 rounded-2xl items-center justify-center">
		              <Ionicons name="play-circle" size={80} color="rgba(255,255,255,0.8)" />
		              {currentMedia.duration && (
		                <Text className="text-white mt-2">
		                  {Math.floor(currentMedia.duration / 60)}:{(currentMedia.duration % 60).toString().padStart(2, '0')}
		                </Text>
		              )}
		            </View>
		          ) : (
		            <View className="w-full h-32 bg-purple-500/20 rounded-2xl items-center justify-center">
		              <Ionicons name="mic" size={40} color="rgba(255,255,255,0.8)" />
		              <Text className="text-white/80 mt-2">Audio Note</Text>
		              {currentMedia.duration && (
		                <Text className="text-white/60 text-sm">
		                  {Math.floor(currentMedia.duration / 60)}:{(currentMedia.duration % 60).toString().padStart(2, '0')}
		                </Text>
		              )}
		            </View>
		          )}
		
		          {/* Media Navigation */}
		          {story.media.length > 1 && (
		            <>
		              {currentMediaIndex > 0 && (
		                <Pressable
		                  onPress={() => setCurrentMediaIndex(currentMediaIndex - 1)}
		                  className="absolute left-4 top-1/2 -translate-y-2 bg-black/50 rounded-full p-2"
		                >
		                  <Ionicons name="chevron-back" size={24} color="white" />
		                </Pressable>
		              )}
		              
		              {currentMediaIndex < story.media.length - 1 && (
		                <Pressable
		                  onPress={() => setCurrentMediaIndex(currentMediaIndex + 1)}
		                  className="absolute right-4 top-1/2 -translate-y-2 bg-black/50 rounded-full p-2"
		                >
		                  <Ionicons name="chevron-forward" size={24} color="white" />
		                </Pressable>
		              )}
		
		              {/* Media Counter */}
		              <View className="absolute bottom-4 right-4 bg-black/60 rounded-full px-3 py-1">
		                <Text className="text-white text-sm">
		                  {currentMediaIndex + 1} / {story.media.length}
		                </Text>
		              </View>
		            </>
		          )}
		        </View>
		
		        {/* Media Thumbnails */}
		        {story.media.length > 1 && (
		          <ScrollView 
		            horizontal 
		            showsHorizontalScrollIndicator={false}
		            className="mt-4"
		            contentContainerStyle={{ paddingHorizontal: 4 }}
		          >
		            {story.media.map((media, index) => (
		              <Pressable
		                key={media.id}
		                onPress={() => setCurrentMediaIndex(index)}
		                className={`mr-2 rounded-lg overflow-hidden ${
		                  index === currentMediaIndex ? 'opacity-100 border-2 border-white' : 'opacity-60'
		                }`}
		                style={{ width: 60, height: 60 }}
		              >
		                {media.type === 'photo' ? (
		                  <Image
		                    source={{ uri: media.uri }}
		                    className="w-full h-full"
		                    resizeMode="cover"
		                  />
		                ) : media.type === 'video' ? (
		                  <View className="w-full h-full bg-black/20 items-center justify-center">
		                    <Ionicons name="play" size={20} color="white" />
		                  </View>
		                ) : (
		                  <View className="w-full h-full bg-purple-500/20 items-center justify-center">
		                    <Ionicons name="mic" size={16} color="white" />
		                  </View>
		                )}
		              </Pressable>
		            ))}
		          </ScrollView>
		        )}
		      </View>
		    );
		  };
		
		  const CommentsSection: React.FC = () => (
		    <View>
		      <View className="flex-row items-center justify-between mb-4">
		        <Text className="text-white text-lg font-semibold">
		          Comments ({story.comments.length})
		        </Text>
		        <Pressable onPress={() => setShowComments(!showComments)}>
		          <Ionicons 
		            name={showComments ? "chevron-up" : "chevron-down"} 
		            size={24} 
		            color="rgba(255,255,255,0.7)" 
		          />
		        </Pressable>
		      </View>
		
		      {showComments && (
		        <>
		          {/* Add Comment */}
		          <View className="bg-white/10 rounded-xl p-4 mb-4 border border-white/20">
		            <TextInput
		              value={newComment}
		              onChangeText={setNewComment}
		              placeholder="Add a comment..."
		              placeholderTextColor="rgba(255,255,255,0.5)"
		              className="text-white mb-3"
		              multiline
		              numberOfLines={3}
		            />
		            <Pressable
		              onPress={handleAddComment}
		              disabled={!newComment.trim()}
		              className={`self-end px-4 py-2 rounded-xl ${
		                newComment.trim() ? 'bg-purple-500' : 'bg-white/20'
		              }`}
		            >
		              <Text className="text-white font-medium">Post</Text>
		            </Pressable>
		          </View>
		
		          {/* Comments List */}
		          {story.comments.map((comment) => (
		            <View key={comment.id} className="bg-white/5 rounded-xl p-4 mb-3">
		              <View className="flex-row items-start">
		                <View className="bg-purple-500/30 rounded-full w-8 h-8 items-center justify-center mr-3">
		                  <Text className="text-white text-sm font-bold">
		                    {comment.authorId === currentUserId ? 'Y' : 'T'}
		                  </Text>
		                </View>
		                <View className="flex-1">
		                  <View className="flex-row items-center mb-1">
		                    <Text className="text-white font-medium">
		                      {comment.authorId === currentUserId ? 'You' : twinProfile?.name || 'Twin'}
		                    </Text>
		                    <Text className="text-white/50 text-xs ml-2">
		                      {formatDate(comment.timestamp)}
		                    </Text>
		                    {comment.isEdited && (
		                      <Text className="text-white/40 text-xs ml-1">(edited)</Text>
		                    )}
		                  </View>
		                  <Text className="text-white/90">{comment.content}</Text>
		                </View>
		              </View>
		            </View>
		          ))}
		
		          {story.comments.length === 0 && (
		            <Text className="text-white/60 text-center py-8">
		              No comments yet. Be the first to share your thoughts!
		            </Text>
		          )}
		        </>
		      )}
		    </View>
		  );
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        {/* Header */}
		        <View className="flex-row items-center justify-between px-6 py-4">
		          <Pressable onPress={() => navigation.goBack()}>
		            <Ionicons name="arrow-back" size={24} color="white" />
		          </Pressable>
		          
		          <View className="flex-row items-center space-x-3">
		            {isAuthor && (
		              <Pressable
		                onPress={() => navigation.navigate('EditStory', { storyId: story.id })}
		                className="p-2"
		              >
		                <Ionicons name="pencil" size={20} color="rgba(255,255,255,0.7)" />
		              </Pressable>
		            )}
		            
		            <Pressable className="p-2">
		              <Ionicons name="share-outline" size={20} color="rgba(255,255,255,0.7)" />
		            </Pressable>
		            
		            {isAuthor && (
		              <Pressable onPress={handleDelete} className="p-2">
		                <Ionicons name="trash-outline" size={20} color="rgba(255, 99, 99, 0.8)" />
		              </Pressable>
		            )}
		          </View>
		        </View>
		
		        <KeyboardAvoidingView 
		          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
		          className="flex-1"
		        >
		          <ScrollView className="flex-1 px-6" showsVerticalScrollIndicator={false}>
		            {/* Story Header */}
		            <View className="mb-6">
		              <View className="flex-row items-center mb-3">
		                {/* Category Badge */}
		                <View 
		                  className="rounded-full p-2 mr-3"
		                  style={{ backgroundColor: getCategoryColor(story.category) + '30' }}
		                >
		                  <Ionicons 
		                    name={getCategoryIcon(story.category) as any} 
		                    size={20} 
		                    color={getCategoryColor(story.category)} 
		                  />
		                </View>
		
		                {/* Milestone Star */}
		                {story.milestone && (
		                  <View className="bg-yellow-400/30 rounded-full p-1 mr-3">
		                    <Ionicons name="star" size={18} color="#FFD700" />
		                  </View>
		                )}
		
		                {/* Share Status */}
		                {story.isShared && (
		                  <View className="bg-green-500/30 rounded-full px-3 py-1">
		                    <Text className="text-green-300 text-xs font-medium">Shared</Text>
		                  </View>
		                )}
		              </View>
		
		              <Text className="text-white text-2xl font-bold mb-2">
		                {story.title}
		              </Text>
		
		              <View className="flex-row items-center text-white/60">
		                <Text className="text-white/60 text-sm">
		                  {formatDate(story.timestamp)}
		                </Text>
		                {story.location && (
		                  <>
		                    <Text className="text-white/40 mx-2">•</Text>
		                    <Ionicons name="location" size={14} color="rgba(255,255,255,0.6)" />
		                    <Text className="text-white/60 text-sm ml-1">
		                      {story.location.placeName || 'Location tagged'}
		                    </Text>
		                  </>
		                )}
		              </View>
		            </View>
		
		            {/* Media Viewer */}
		            <MediaViewer />
		
		            {/* Story Content */}
		            <View className="mb-6">
		              <Text className="text-white text-lg leading-7">
		                {story.content}
		              </Text>
		            </View>
		
		            {/* Tags */}
		            {story.tags.length > 0 && (
		              <View className="flex-row flex-wrap mb-6">
		                {story.tags.map((tag, index) => (
		                  <View key={index} className="bg-blue-500/20 rounded-full px-3 py-1 mr-2 mb-2">
		                    <Text className="text-blue-300 text-sm">#{tag}</Text>
		                  </View>
		                ))}
		              </View>
		            )}
		
		            {/* Milestone Info */}
		            {story.milestone && (
		              <LinearGradient
		                colors={['rgba(255, 215, 0, 0.15)', 'rgba(255, 215, 0, 0.05)']}
		                className="rounded-2xl p-6 mb-6 border border-yellow-400/30"
		              >
		                <View className="flex-row items-center mb-3">
		                  <Ionicons name="star" size={24} color="#FFD700" />
		                  <Text className="text-yellow-300 font-semibold text-lg ml-3">
		                    {story.milestone.type.charAt(0).toUpperCase() + story.milestone.type.slice(1)} Milestone
		                  </Text>
		                </View>
		                <Text className="text-yellow-200/90 text-base leading-6 mb-2">
		                  {story.milestone.significance}
		                </Text>
		                {story.milestone.date && (
		                  <Text className="text-yellow-200/70 text-sm">
		                    Date: {new Date(story.milestone.date).toLocaleDateString()}
		                  </Text>
		                )}
		              </LinearGradient>
		            )}
		
		            {/* Story Stats & Actions */}
		            <LinearGradient
		              colors={['rgba(255,255,255,0.1)', 'rgba(255,255,255,0.05)']}
		              className="rounded-2xl p-6 mb-6 border border-white/20"
		            >
		              <View className="flex-row items-center justify-between mb-4">
		                <View className="flex-row items-center space-x-6">
		                  {/* Like */}
		                  <Pressable onPress={handleLike} className="flex-row items-center">
		                    <Ionicons 
		                      name={isLiked ? "heart" : "heart-outline"} 
		                      size={24} 
		                      color={isLiked ? "#FF1493" : "rgba(255,255,255,0.7)"} 
		                    />
		                    <Text className="text-white/80 ml-2">{story.likes.length}</Text>
		                  </Pressable>
		
		                  {/* Comments */}
		                  <Pressable 
		                    onPress={() => setShowComments(!showComments)}
		                    className="flex-row items-center"
		                  >
		                    <Ionicons name="chatbubble-outline" size={24} color="rgba(255,255,255,0.7)" />
		                    <Text className="text-white/80 ml-2">{story.comments.length}</Text>
		                  </Pressable>
		
		                  {/* Views */}
		                  <View className="flex-row items-center">
		                    <Ionicons name="eye-outline" size={24} color="rgba(255,255,255,0.5)" />
		                    <Text className="text-white/60 ml-2">{story.views.length}</Text>
		                  </View>
		                </View>
		
		                <View className="flex-row items-center space-x-3">
		                  {/* Share with Twin */}
		                  {isAuthor && twinProfile && (
		                    <Pressable onPress={handleShare}>
		                      <Ionicons 
		                        name={story.isShared ? "people" : "person-add-outline"} 
		                        size={24} 
		                        color={story.isShared ? "#10B981" : "rgba(255,255,255,0.7)"} 
		                      />
		                    </Pressable>
		                  )}
		
		                  {/* Favorite */}
		                  <Pressable onPress={handleFavorite}>
		                    <Ionicons 
		                      name={isFavorited ? "bookmark" : "bookmark-outline"} 
		                      size={24} 
		                      color={isFavorited ? "#FFD700" : "rgba(255,255,255,0.7)"} 
		                    />
		                  </Pressable>
		                </View>
		              </View>
		            </LinearGradient>
		
		            {/* Comments Section */}
		            <CommentsSection />
		
		            <View className="h-6" /> {/* Bottom spacing */}
		          </ScrollView>
		        </KeyboardAvoidingView>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='screens/TwintuitionScreen.tsx'><![CDATA[
		import React, { useState } from "react";
		import { View, Text, Pressable, ScrollView, TextInput, ImageBackground } from "react-native";
		import { SafeAreaView } from "react-native-safe-area-context";
		import { useTwinStore } from "../state/twinStore";
		import { Ionicons } from "@expo/vector-icons";
		import { useNavigation } from "@react-navigation/native";
		import * as Notifications from "expo-notifications";
		import * as Haptics from "expo-haptics";
		
		export const TwintuitionScreen = () => {
		  const navigation = useNavigation<any>();
		  const { themeColor, twintuitionAlerts, addTwintuitionAlert, markAlertAsRead, twinProfile } = useTwinStore();
		  const [showCreateAlert, setShowCreateAlert] = useState(false);
		  const [alertMessage, setAlertMessage] = useState("");
		  const [selectedType, setSelectedType] = useState<"feeling" | "thought" | "action">("feeling");
		
		  const handleCreateAlert = async () => {
		    if (!alertMessage.trim()) return;
		
		    addTwintuitionAlert({
		      message: alertMessage.trim(),
		      type: selectedType,
		      isRead: false,
		    });
		
		    // Haptics feedback
		    Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		
		    // Schedule a local notification to simulate your twin receiving/responding
		    try {
		      await Notifications.requestPermissionsAsync();
		      await Notifications.scheduleNotificationAsync({
		        content: {
		          title: "Twintuition sent",
		          body: `Shared with ${twinProfile?.name || "your twin"}`,
		        },
		        trigger: null,
		      });
		    } catch (e) {}
		
		    setAlertMessage("");
		    setShowCreateAlert(false);
		  };
		
		  const formatTime = (timestamp: string) => {
		    const date = new Date(timestamp);
		    const now = new Date();
		    const diffInHours = (now.getTime() - date.getTime()) / (1000 * 60 * 60);
		
		    if (diffInHours < 1) {
		      return "Just now";
		    } else if (diffInHours < 24) {
		      return `${Math.floor(diffInHours)}h ago`;
		    } else {
		      return date.toLocaleDateString();
		    }
		  };
		
		  const getTypeIcon = (type: string) => {
		    switch (type) {
		      case "feeling": return "heart";
		      case "thought": return "bulb";
		      case "action": return "flash";
		      default: return "flash";
		    }
		  };
		
		  const getTypeColor = (type: string) => {
		    switch (type) {
		      case "feeling": return "bg-pink-500/30";
		      case "thought": return "bg-yellow-500/30";
		      case "action": return "bg-purple-500/30";
		      default: return "bg-purple-500/30";
		    }
		  };
		
		  if (showCreateAlert) {
		    return (
		      <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		        <SafeAreaView className="flex-1">
		          <View className="flex-1 px-6">
		            {/* Header */}
		            <View className="flex-row items-center justify-between py-4">
		              <Pressable onPress={() => setShowCreateAlert(false)}>
		                <Ionicons name="arrow-back" size={24} color="white" />
		              </Pressable>
		              <Text className="text-white text-xl font-semibold">New Twintuition</Text>
		              <View className="w-6" />
		            </View>
		
		            <ScrollView className="flex-1">
		              {/* Type Selection */}
		              <View className="mb-6">
		                <Text className="text-white text-lg font-semibold mb-4">What type of connection?</Text>
		                <View className="space-y-3">
		                  {[
		                    { key: "feeling" as const, name: "Feeling", icon: "heart", description: "Emotional connection" },
		                    { key: "thought" as const, name: "Thought", icon: "bulb", description: "Mental synchronicity" },
		                    { key: "action" as const, name: "Action", icon: "flash", description: "Behavioral mirroring" },
		                  ].map((type) => (
		                    <Pressable
		                      key={type.key}
		                      onPress={() => setSelectedType(type.key)}
		                      className={`p-4 rounded-xl border-2 ${
		                        selectedType === type.key
		                          ? "bg-white/20 border-white/50"
		                          : "bg-white/5 border-white/20"
		                      }`}
		                    >
		                      <View className="flex-row items-center">
		                        <View className={`p-3 rounded-full mr-4 ${getTypeColor(type.key)}`}>
		                          <Ionicons name={type.icon as any} size={20} color="white" />
		                        </View>
		                        <View className="flex-1">
		                          <Text className="text-white text-lg font-semibold">{type.name}</Text>
		                          <Text className="text-white/70 text-sm">{type.description}</Text>
		                        </View>
		                        <Ionicons
		                          name={selectedType === type.key ? "radio-button-on" : "radio-button-off"}
		                          size={24}
		                          color="white"
		                        />
		                      </View>
		                    </Pressable>
		                  ))}
		                </View>
		              </View>
		
		              {/* Message Input */}
		              <View className="mb-6">
		                <Text className="text-white text-lg font-semibold mb-4">Describe your twintuition</Text>
		                <View className="bg-white/10 rounded-xl p-4">
		                  <TextInput
		                    value={alertMessage}
		                    onChangeText={setAlertMessage}
		                    placeholder="I have a feeling that my twin is..."
		                    placeholderTextColor="rgba(255,255,255,0.5)"
		                    className="text-white text-base"
		                    multiline
		                    numberOfLines={4}
		                    maxLength={200}
		                  />
		                </View>
		                <Text className="text-white/50 text-sm mt-2 text-right">
		                  {alertMessage.length}/200
		                </Text>
		              </View>
		
		              {/* Send Button */}
		              <Pressable
		                onPress={handleCreateAlert}
		                className={`py-4 rounded-xl items-center ${
		                  alertMessage.trim() ? "bg-purple-500" : "bg-white/20"
		                }`}
		                disabled={!alertMessage.trim()}
		              >
		                <Text className="text-white text-lg font-semibold">
		                  Send Twintuition Alert
		                </Text>
		              </Pressable>
		            </ScrollView>
		          </View>
		        </SafeAreaView>
		      </ImageBackground>
		    );
		  }
		
		  return (
		    <ImageBackground source={require("../../assets/galaxybackground.png")} style={{ flex: 1 }}>
		      <SafeAreaView className="flex-1">
		        <View className="flex-1 px-6">
		          {/* Header */}
		          <View className="flex-row items-center justify-between py-4">
		            <Pressable onPress={() => navigation.goBack()} className="w-10 h-10 rounded-full bg-white/10 items-center justify-center">
		              <Ionicons name="chevron-back" size={20} color="white" />
		            </Pressable>
		            <Text className="text-white text-2xl font-bold">Twintuition</Text>
		            <Pressable
		              onPress={() => setShowCreateAlert(true)}
		              className="bg-purple-500 rounded-full p-2"
		            >
		              <Ionicons name="add" size={24} color="white" />
		            </Pressable>
		          </View>
		
		          <Text className="text-white/70 text-center mb-6">
		            Feel your twin's energy across any distance
		          </Text>
		
		          {/* Alerts List */}
		          <ScrollView className="flex-1">
		            {twintuitionAlerts.length === 0 ? (
		              <View className="bg-white/5 rounded-xl p-8 items-center mt-8">
		                <Ionicons name="flash-outline" size={64} color="rgba(255,255,255,0.3)" />
		                <Text className="text-white/70 text-lg text-center mt-4">
		                  No twintuition alerts yet
		                </Text>
		                <Text className="text-white/50 text-center mt-2">
		                  Create your first alert to start sensing your twin's energy
		                </Text>
		              </View>
		            ) : (
		              <View className="space-y-4">
		                {twintuitionAlerts.map((alert) => (
		                  <Pressable
		                    key={alert.id}
		                    onPress={() => markAlertAsRead(alert.id)}
		                    className={`p-4 rounded-xl ${
		                      alert.isRead ? "bg-white/5" : "bg-white/15 border border-purple-400/50"
		                    }`}
		                  >
		                    <View className="flex-row items-start">
		                      <View className={`p-2 rounded-full mr-3 ${getTypeColor(alert.type)}`}>
		                        <Ionicons 
		                          name={getTypeIcon(alert.type) as any} 
		                          size={16} 
		                          color="white" 
		                        />
		                      </View>
		                      
		                      <View className="flex-1">
		                        <View className="flex-row items-center justify-between mb-2">
		                          <Text className="text-white/70 text-sm capitalize">
		                            {alert.type} • {formatTime(alert.timestamp)}
		                          </Text>
		                          {!alert.isRead && (
		                            <View className="w-2 h-2 bg-purple-400 rounded-full" />
		                          )}
		                        </View>
		                        
		                        <Text className="text-white text-base leading-5">
		                          {alert.message}
		                        </Text>
		                        
		                        <View className="flex-row items-center mt-3 pt-3 border-t border-white/10">
		                          <View className="bg-white/20 rounded-full w-6 h-6 items-center justify-center mr-2">
		                            <Text className="text-white text-xs font-bold">
		                              {twinProfile?.name?.charAt(0) || "T"}
		                            </Text>
		                          </View>
		                          <Text className="text-white/50 text-sm">
		                            Sent to {twinProfile?.name || "your twin"}
		                          </Text>
		                        </View>
		                      </View>
		                    </View>
		                  </Pressable>
		                ))}
		              </View>
		            )}
		          </ScrollView>
		        </View>
		      </SafeAreaView>
		    </ImageBackground>
		  );
		};]]></file>
	<file path='services/chatService.ts'><![CDATA[
		import EventEmitter from 'eventemitter3';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import * as Notifications from 'expo-notifications';
		import { ChatMessage, TypingIndicator, TwintuitionMoment } from '../types/chat';
		import { useChatStore } from '../state/chatStore';
		import { useTwinStore } from '../state/twinStore';
		
		// Mock WebSocket implementation for real-time communication
		// In production, replace with Firebase Realtime Database or Socket.io
		class MockWebSocket extends EventEmitter {
		  private connected = false;
		  private reconnectAttempts = 0;
		  private maxReconnectAttempts = 5;
		  private reconnectDelay = 1000;
		
		  connect() {
		    this.connected = true;
		    this.emit('connected');
		    console.log('Chat WebSocket connected');
		  }
		
		  disconnect() {
		    this.connected = false;
		    this.emit('disconnected');
		    console.log('Chat WebSocket disconnected');
		  }
		
		  send(data: any) {
		    if (!this.connected) {
		      this.emit('error', new Error('Not connected'));
		      return;
		    }
		
		    // Simulate network delay
		    setTimeout(() => {
		      this.emit('message', data);
		    }, Math.random() * 500 + 100);
		  }
		
		  reconnect() {
		    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
		      this.emit('error', new Error('Max reconnection attempts reached'));
		      return;
		    }
		
		    this.reconnectAttempts++;
		    this.emit('reconnecting', this.reconnectAttempts);
		
		    setTimeout(() => {
		      this.connect();
		      this.reconnectAttempts = 0;
		    }, this.reconnectDelay * this.reconnectAttempts);
		  }
		}
		
		class ChatService {
		  private ws: MockWebSocket;
		  private offlineQueue: ChatMessage[] = [];
		  private typingTimeout: NodeJS.Timeout | null = null;
		  private twintuitionTimer: NodeJS.Timeout | null = null;
		
		  constructor() {
		    this.ws = new MockWebSocket();
		    this.setupEventListeners();
		    this.loadOfflineMessages();
		  }
		
		  private setupEventListeners() {
		    this.ws.on('connected', () => {
		      useChatStore.getState().setConnection({ status: 'connected' });
		      this.processOfflineQueue();
		    });
		
		    this.ws.on('disconnected', () => {
		      useChatStore.getState().setConnection({ status: 'disconnected' });
		    });
		
		    this.ws.on('reconnecting', (attempt) => {
		      useChatStore.getState().setConnection({ status: 'reconnecting' });
		    });
		
		    this.ws.on('message', (data) => {
		      this.handleIncomingMessage(data);
		    });
		
		    this.ws.on('typing', (data: TypingIndicator) => {
		      useChatStore.getState().setTypingIndicator(data);
		      
		      // Clear typing indicator after 3 seconds
		      if (this.typingTimeout) clearTimeout(this.typingTimeout);
		      this.typingTimeout = setTimeout(() => {
		        useChatStore.getState().setTypingIndicator(null);
		      }, 3000);
		    });
		  }
		
		  connect() {
		    useChatStore.getState().setConnection({ status: 'connecting' });
		    setTimeout(() => this.ws.connect(), 1000);
		  }
		
		  disconnect() {
		    this.ws.disconnect();
		  }
		
		  async sendMessage(message: Omit<ChatMessage, 'id' | 'timestamp' | 'isDelivered' | 'isRead'>) {
		    const chatStore = useChatStore.getState();
		    const newMessage: ChatMessage = {
		      ...message,
		      id: Date.now().toString() + Math.random().toString(36),
		      timestamp: new Date().toISOString(),
		      isDelivered: false,
		      isRead: false,
		      reactions: [],
		    };
		
		    // Add to store immediately (optimistic update)
		    chatStore.addMessage({
		      ...message,
		    });
		
		    try {
		      if (this.ws.connected) {
		        this.ws.send({
		          type: 'message',
		          data: newMessage,
		        });
		        
		        // Simulate delivery confirmation
		        setTimeout(() => {
		          chatStore.markAsDelivered(newMessage.id);
		        }, 1000);
		      } else {
		        // Queue for offline sending
		        this.offlineQueue.push(newMessage);
		        await this.saveOfflineMessages();
		      }
		    } catch (error) {
		      console.error('Failed to send message:', error);
		      this.offlineQueue.push(newMessage);
		      await this.saveOfflineMessages();
		    }
		
		    // Check for twintuition moments
		    this.checkForTwintuition(newMessage);
		    
		    // Auto-respond if paired with test twin
		    this.handleTestTwinAutoResponse(newMessage);
		  }
		
		  sendTypingIndicator(isTyping: boolean) {
		    if (!this.ws.connected) return;
		
		    const userProfile = useTwinStore.getState().userProfile;
		    if (!userProfile) return;
		
		    if (isTyping) {
		      this.ws.send({
		        type: 'typing',
		        data: {
		          userId: userProfile.id,
		          userName: userProfile.name,
		          timestamp: new Date().toISOString(),
		        },
		      });
		    } else {
		      this.ws.send({
		        type: 'stop_typing',
		        data: {
		          userId: userProfile.id,
		        },
		      });
		    }
		  }
		
		  async sendReaction(messageId: string, emoji: string) {
		    const userProfile = useTwinStore.getState().userProfile;
		    if (!userProfile) return;
		
		    const chatStore = useChatStore.getState();
		    chatStore.addReaction(messageId, emoji, userProfile.id, userProfile.name);
		
		    if (this.ws.connected) {
		      this.ws.send({
		        type: 'reaction',
		        data: {
		          messageId,
		          emoji,
		          userId: userProfile.id,
		          userName: userProfile.name,
		        },
		      });
		    }
		  }
		
		  private handleIncomingMessage(data: any) {
		    const chatStore = useChatStore.getState();
		
		    switch (data.type) {
		      case 'message':
		        chatStore.addMessage(data.data);
		        this.sendPushNotification(data.data);
		        chatStore.incrementUnreadCount();
		        break;
		      
		      case 'message_delivered':
		        chatStore.markAsDelivered(data.messageId);
		        break;
		        
		      case 'message_read':
		        chatStore.markAsRead(data.messageId);
		        break;
		        
		      case 'reaction':
		        chatStore.addReaction(
		          data.data.messageId,
		          data.data.emoji,
		          data.data.userId,
		          data.data.userName
		        );
		        break;
		        
		      case 'typing':
		        chatStore.setTypingIndicator(data.data);
		        break;
		        
		      case 'stop_typing':
		        chatStore.setTypingIndicator(null);
		        break;
		    }
		  }
		
		  private async processOfflineQueue() {
		    const queue = [...this.offlineQueue];
		    this.offlineQueue = [];
		
		    for (const message of queue) {
		      try {
		        this.ws.send({
		          type: 'message',
		          data: message,
		        });
		        
		        // Mark as delivered
		        setTimeout(() => {
		          useChatStore.getState().markAsDelivered(message.id);
		        }, 1000);
		      } catch (error) {
		        console.error('Failed to send queued message:', error);
		        this.offlineQueue.push(message);
		      }
		    }
		
		    await this.saveOfflineMessages();
		  }
		
		  private async saveOfflineMessages() {
		    try {
		      await AsyncStorage.setItem(
		        'offline_messages',
		        JSON.stringify(this.offlineQueue)
		      );
		    } catch (error) {
		      console.error('Failed to save offline messages:', error);
		    }
		  }
		
		  private async loadOfflineMessages() {
		    try {
		      const stored = await AsyncStorage.getItem('offline_messages');
		      if (stored) {
		        this.offlineQueue = JSON.parse(stored);
		      }
		    } catch (error) {
		      console.error('Failed to load offline messages:', error);
		    }
		  }
		
		  private checkForTwintuition(message: ChatMessage) {
		    // Simple twintuition detection based on common keywords/phrases
		    const twintuitionKeywords = [
		      'thinking the same',
		      'was just about to say',
		      'exactly what I was thinking',
		      'read my mind',
		      'telepathy',
		      'intuition',
		      'feeling the same',
		    ];
		
		    const messageText = message.text.toLowerCase();
		    const hasTwintuitionKeyword = twintuitionKeywords.some(keyword =>
		      messageText.includes(keyword)
		    );
		
		    if (hasTwintuitionKeyword) {
		      const chatStore = useChatStore.getState();
		      chatStore.addTwintuitionMoment({
		        message: 'Twin telepathy moment detected! 🔮',
		        type: 'intuition',
		        confidence: Math.random() * 0.3 + 0.7, // 70-100% confidence
		      });
		
		      // Send twintuition notification
		      this.sendTwintuitionNotification();
		    }
		  }
		
		  private async sendPushNotification(message: ChatMessage) {
		    try {
		      await Notifications.scheduleNotificationAsync({
		        content: {
		          title: `${message.senderName} sent a message`,
		          body: message.text.length > 50 ? message.text.substring(0, 50) + '...' : message.text,
		          data: { messageId: message.id, screen: 'TwinTalk' },
		        },
		        trigger: null, // Send immediately
		      });
		    } catch (error) {
		      console.error('Failed to send push notification:', error);
		    }
		  }
		
		  private async sendTwintuitionNotification() {
		    try {
		      await Notifications.scheduleNotificationAsync({
		        content: {
		          title: 'Twintuition Alert! 🔮',
		          body: 'You and your twin are having a psychic moment!',
		          data: { type: 'twintuition', screen: 'Twintuition' },
		        },
		        trigger: null,
		      });
		    } catch (error) {
		      console.error('Failed to send twintuition notification:', error);
		    }
		  }
		
		  // Voice message support
		  async sendVoiceMessage(uri: string, duration: number) {
		    const userProfile = useTwinStore.getState().userProfile;
		    if (!userProfile) return;
		
		    await this.sendMessage({
		      text: `🎵 Voice message (${Math.floor(duration)}s)`,
		      senderId: userProfile.id,
		      senderName: userProfile.name,
		      type: 'text', // In a real app, you'd have a 'voice' type
		      accentColor: userProfile.accentColor,
		    });
		  }
		
		  // Quick response
		  async sendQuickResponse(responseText: string) {
		    const userProfile = useTwinStore.getState().userProfile;
		    if (!userProfile) return;
		
		    await this.sendMessage({
		      text: responseText,
		      senderId: userProfile.id,
		      senderName: userProfile.name,
		      type: 'text',
		      accentColor: userProfile.accentColor,
		    });
		  }
		
		  // Handle auto-responses from test twin
		  private handleTestTwinAutoResponse(userMessage: ChatMessage) {
		    const { twinProfile } = useTwinStore.getState();
		    
		    // Only respond if paired with test twin and user sent the message
		    if (!twinProfile || !twinProfile.id.startsWith('test-twin-')) return;
		    if (userMessage.senderId === twinProfile.id) return; // Don't respond to twin's own messages
		    
		    // Generate random response after 2-5 seconds
		    const delay = 2000 + Math.random() * 3000;
		    
		    setTimeout(() => {
		      this.sendTestTwinResponse(userMessage);
		    }, delay);
		  }
		
		  private sendTestTwinResponse(userMessage: ChatMessage) {
		    const { twinProfile } = useTwinStore.getState();
		    if (!twinProfile) return;
		
		    const responses = [
		      "I was just thinking about that! 🤯",
		      "Wow, we're so in sync right now! ✨",
		      "I literally felt that message before you sent it 😱",
		      "This is exactly what I needed to hear today 💫",
		      "I'm getting such strong twintuition vibes! ⚡",
		      "Our connection is unreal sometimes 🌟",
		      "I was about to text you the same thing! 😂",
		      "The twin telepathy is strong today 🧠➡️🧠",
		      "I love how we always understand each other 💜",
		      "This is why we're twins! 👯‍♀️",
		      "I'm feeling that twin energy! 🔮",
		      "We're like two minds, one soul ❤️",
		      "I can't believe how connected we are! 🌙",
		      "That gave me chills! In the best way ⭐",
		      "You always know exactly what to say 😊"
		    ];
		
		    // Pick a response based on message content and add some intelligence
		    let response = responses[Math.floor(Math.random() * responses.length)];
		    
		    // More specific responses based on keywords
		    const messageText = userMessage.text.toLowerCase();
		    if (messageText.includes('hi') || messageText.includes('hello') || messageText.includes('hey')) {
		      const greetings = [
		        `Hey twin! I just felt you were about to message me! 😊`,
		        `Hi! I was literally thinking about you right now! 💫`,
		        `Hello beautiful soul! The twintuition is strong today ✨`
		      ];
		      response = greetings[Math.floor(Math.random() * greetings.length)];
		    } else if (messageText.includes('love') || messageText.includes('miss')) {
		      const loveResponses = [
		        `I love you too, twin! Our bond is unbreakable 💕`,
		        `I miss you so much! Can't wait to see you again 🥰`,
		        `Sending you all my twin love right back! ❤️✨`
		      ];
		      response = loveResponses[Math.floor(Math.random() * loveResponses.length)];
		    } else if (messageText.includes('test') || messageText.includes('working')) {
		      const testResponses = [
		        `Yes! This test twin feature is working perfectly! 🎉`,
		        `I'm your virtual twin and ready to chat! 🤖✨`,
		        `Test twin mode activated! I'm here for you! 👯‍♀️`
		      ];
		      response = testResponses[Math.floor(Math.random() * testResponses.length)];
		    }
		
		    // Simulate typing indicator first
		    useChatStore.getState().setTypingIndicator({
		      userId: twinProfile.id,
		      userName: twinProfile.name,
		      timestamp: new Date().toISOString(),
		    });
		
		    // Send response after typing delay
		    setTimeout(() => {
		      useChatStore.getState().setTypingIndicator(null);
		      
		      const testTwinMessage: ChatMessage = {
		        id: Date.now().toString() + Math.random().toString(36),
		        text: response,
		        senderId: twinProfile.id,
		        senderName: twinProfile.name,
		        timestamp: new Date().toISOString(),
		        type: 'text',
		        isDelivered: true,
		        isRead: false,
		        reactions: [],
		      };
		
		      useChatStore.getState().addMessage(testTwinMessage);
		    }, 1000 + Math.random() * 2000); // 1-3 seconds typing time
		  }
		
		  // Mark all messages as read
		  markAllAsRead() {
		    const chatStore = useChatStore.getState();
		    const unreadMessages = chatStore.getUnreadMessages();
		    
		    unreadMessages.forEach(message => {
		      chatStore.markAsRead(message.id);
		      
		      // Notify twin that messages were read
		      if (this.ws.connected) {
		        this.ws.send({
		          type: 'message_read',
		          messageId: message.id,
		        });
		      }
		    });
		    
		    chatStore.resetUnreadCount();
		  }
		}
		
		// Singleton instance
		export const chatService = new ChatService();
		
		// Auto-connect when app starts
		chatService.connect();]]></file>
	<file path='services/encryptionService.ts'><![CDATA[
		/**
		 * Encryption Service - End-to-end encryption for sensitive assessment data
		 * Provides AES encryption with secure key management and integrity verification
		 */
		
		import * as Crypto from 'expo-crypto';
		import * as SecureStore from 'expo-secure-store';
		
		export interface EncryptionResult {
		  encrypted: string;
		  iv: string;
		  tag: string;
		  algorithm: string;
		  keyVersion: string;
		}
		
		export interface DecryptionOptions {
		  encrypted: string;
		  iv: string;
		  tag: string;
		  algorithm: string;
		  keyVersion: string;
		}
		
		class EncryptionServiceClass {
		  private readonly ALGORITHM = 'aes-256-gcm';
		  private readonly KEY_VERSION = 'v1';
		  private readonly MASTER_KEY_ALIAS = 'assessment_master_key';
		  private readonly IV_LENGTH = 12; // 96 bits for GCM
		  private readonly TAG_LENGTH = 16; // 128 bits
		  
		  private masterKey: string | null = null;
		  private initialized = false;
		
		  /**
		   * Initialize encryption service with master key generation/retrieval
		   */
		  async initialize(): Promise<void> {
		    if (this.initialized) return;
		
		    try {
		      // Try to retrieve existing master key
		      this.masterKey = await SecureStore.getItemAsync(this.MASTER_KEY_ALIAS);
		      
		      if (!this.masterKey) {
		        // Generate new master key
		        this.masterKey = await this.generateMasterKey();
		        await SecureStore.setItemAsync(this.MASTER_KEY_ALIAS, this.masterKey);
		      }
		      
		      this.initialized = true;
		    } catch (error) {
		      throw new Error(`Failed to initialize encryption service: ${error}`);
		    }
		  }
		
		  /**
		   * Encrypt sensitive data with AES-256-GCM
		   */
		  async encrypt(plaintext: string): Promise<string> {
		    await this.ensureInitialized();
		    
		    try {
		      // Generate random IV
		      const iv = await Crypto.getRandomBytesAsync(this.IV_LENGTH);
		      const ivHex = this.arrayBufferToHex(iv);
		      
		      // Create encryption key from master key and IV
		      const encryptionKey = await this.deriveKey(this.masterKey!, ivHex);
		      
		      // Encrypt the data
		      const encryptedBuffer = await this.encryptWithKey(plaintext, encryptionKey, iv);
		      const encryptedHex = this.arrayBufferToHex(encryptedBuffer.encrypted);
		      const tagHex = this.arrayBufferToHex(encryptedBuffer.tag);
		      
		      const result: EncryptionResult = {
		        encrypted: encryptedHex,
		        iv: ivHex,
		        tag: tagHex,
		        algorithm: this.ALGORITHM,
		        keyVersion: this.KEY_VERSION,
		      };
		      
		      // Return base64 encoded result for storage
		      return btoa(JSON.stringify(result));
		      
		    } catch (error) {
		      throw new Error(`Encryption failed: ${error}`);
		    }
		  }
		
		  /**
		   * Decrypt data encrypted with encrypt method
		   */
		  async decrypt(encryptedData: string): Promise<string> {
		    await this.ensureInitialized();
		    
		    try {
		      // Parse encrypted data structure
		      const encryptionResult: EncryptionResult = JSON.parse(atob(encryptedData));
		      
		      // Validate encryption metadata
		      if (encryptionResult.algorithm !== this.ALGORITHM) {
		        throw new Error(`Unsupported algorithm: ${encryptionResult.algorithm}`);
		      }
		      
		      if (encryptionResult.keyVersion !== this.KEY_VERSION) {
		        throw new Error(`Unsupported key version: ${encryptionResult.keyVersion}`);
		      }
		      
		      // Reconstruct encryption components
		      const iv = this.hexToArrayBuffer(encryptionResult.iv);
		      const encrypted = this.hexToArrayBuffer(encryptionResult.encrypted);
		      const tag = this.hexToArrayBuffer(encryptionResult.tag);
		      
		      // Derive decryption key
		      const decryptionKey = await this.deriveKey(this.masterKey!, encryptionResult.iv);
		      
		      // Decrypt the data
		      const plaintext = await this.decryptWithKey({
		        encrypted: encryptionResult.encrypted,
		        iv: encryptionResult.iv,
		        tag: encryptionResult.tag,
		        algorithm: encryptionResult.algorithm,
		        keyVersion: encryptionResult.keyVersion,
		      }, decryptionKey);
		      
		      return plaintext;
		      
		    } catch (error) {
		      throw new Error(`Decryption failed: ${error}`);
		    }
		  }
		
		  /**
		   * Generate secure hash for data integrity verification
		   */
		  async generateHash(data: string): Promise<string> {
		    const hash = await Crypto.digestStringAsync(
		      Crypto.CryptoDigestAlgorithm.SHA256,
		      data,
		      { encoding: Crypto.CryptoEncoding.HEX }
		    );
		    return hash;
		  }
		
		  /**
		   * Verify data integrity using hash
		   */
		  async verifyHash(data: string, expectedHash: string): Promise<boolean> {
		    const actualHash = await this.generateHash(data);
		    return actualHash === expectedHash;
		  }
		
		  /**
		   * Generate cryptographically secure random string
		   */
		  async generateSecureRandom(length: number = 32): Promise<string> {
		    const bytes = await Crypto.getRandomBytesAsync(length);
		    return this.arrayBufferToHex(bytes);
		  }
		
		  /**
		   * Generate assessment-specific encryption key
		   */
		  async generateAssessmentKey(assessmentId: string, userId: string): Promise<string> {
		    await this.ensureInitialized();
		    
		    const keyMaterial = `${this.masterKey}:${assessmentId}:${userId}:${this.KEY_VERSION}`;
		    const derivedKey = await Crypto.digestStringAsync(
		      Crypto.CryptoDigestAlgorithm.SHA256,
		      keyMaterial,
		      { encoding: Crypto.CryptoEncoding.HEX }
		    );
		    
		    return derivedKey;
		  }
		
		  /**
		   * Encrypt assessment data with assessment-specific key
		   */
		  async encryptAssessmentData(
		    data: any,
		    assessmentId: string,
		    userId: string
		  ): Promise<string> {
		    const assessmentKey = await this.generateAssessmentKey(assessmentId, userId);
		    const plaintext = JSON.stringify(data);
		    
		    // Create temporary encryption service with assessment key
		    const tempService = new EncryptionServiceClass();
		    tempService.masterKey = assessmentKey;
		    tempService.initialized = true;
		    
		    return tempService.encrypt(plaintext);
		  }
		
		  /**
		   * Decrypt assessment data with assessment-specific key
		   */
		  async decryptAssessmentData(
		    encryptedData: string,
		    assessmentId: string,
		    userId: string
		  ): Promise<any> {
		    const assessmentKey = await this.generateAssessmentKey(assessmentId, userId);
		    
		    // Create temporary encryption service with assessment key
		    const tempService = new EncryptionServiceClass();
		    tempService.masterKey = assessmentKey;
		    tempService.initialized = true;
		    
		    const plaintext = await tempService.decrypt(encryptedData);
		    return JSON.parse(plaintext);
		  }
		
		  /**
		   * Rotate master key (for security maintenance)
		   */
		  async rotateMasterKey(): Promise<void> {
		    const newMasterKey = await this.generateMasterKey();
		    await SecureStore.setItemAsync(this.MASTER_KEY_ALIAS, newMasterKey);
		    this.masterKey = newMasterKey;
		  }
		
		  /**
		   * Clear all encryption keys (for user logout/data deletion)
		   */
		  async clearKeys(): Promise<void> {
		    try {
		      await SecureStore.deleteItemAsync(this.MASTER_KEY_ALIAS);
		      this.masterKey = null;
		      this.initialized = false;
		    } catch (error) {
		      console.warn('Failed to clear encryption keys:', error);
		    }
		  }
		
		  /**
		   * Get encryption service status
		   */
		  getStatus(): {
		    initialized: boolean;
		    hasKey: boolean;
		    algorithm: string;
		    keyVersion: string;
		  } {
		    return {
		      initialized: this.initialized,
		      hasKey: this.masterKey !== null,
		      algorithm: this.ALGORITHM,
		      keyVersion: this.KEY_VERSION,
		    };
		  }
		
		  // Private methods
		  private async ensureInitialized(): Promise<void> {
		    if (!this.initialized) {
		      await this.initialize();
		    }
		  }
		
		  private async generateMasterKey(): Promise<string> {
		    const keyBytes = await Crypto.getRandomBytesAsync(32); // 256 bits
		    return this.arrayBufferToHex(keyBytes);
		  }
		
		  private async deriveKey(masterKey: string, salt: string): Promise<CryptoKey> {
		    // In a real implementation, you would use PBKDF2 or similar
		    // This is a simplified version for the demo
		    const keyMaterial = masterKey + salt;
		    const hash = await Crypto.digestStringAsync(
		      Crypto.CryptoDigestAlgorithm.SHA256,
		      keyMaterial,
		      { encoding: Crypto.CryptoEncoding.HEX }
		    );
		    
		    // Convert hash to CryptoKey (simplified)
		    const keyBuffer = this.hexToArrayBuffer(hash.slice(0, 64)); // 256 bits
		    
		    // In React Native, we'll simulate CryptoKey behavior
		    return keyBuffer as any;
		  }
		
		  private async encryptWithKey(
		    plaintext: string,
		    key: CryptoKey,
		    iv: ArrayBuffer
		  ): Promise<{ encrypted: ArrayBuffer; tag: ArrayBuffer }> {
		    // Simplified encryption for demo - in production use WebCrypto or native crypto
		    const encoder = new TextEncoder();
		    const data = encoder.encode(plaintext);
		    
		    // This is a mock implementation - in production, use proper AES-GCM
		    const encrypted = new Uint8Array(data.length);
		    const tag = new Uint8Array(16);
		    
		    // Simple XOR encryption for demo (NOT secure for production)
		    const keyBytes = new Uint8Array(key as ArrayBuffer);
		    const ivBytes = new Uint8Array(iv);
		    
		    for (let i = 0; i < data.length; i++) {
		      encrypted[i] = data[i] ^ keyBytes[i % keyBytes.length] ^ ivBytes[i % ivBytes.length];
		    }
		    
		    // Generate mock tag
		    for (let i = 0; i < 16; i++) {
		      tag[i] = keyBytes[i] ^ ivBytes[i % ivBytes.length];
		    }
		    
		    return {
		      encrypted: encrypted.buffer,
		      tag: tag.buffer,
		    };
		  }
		
		  private async decryptWithKey(
		    options: DecryptionOptions,
		    key: CryptoKey
		  ): Promise<string> {
		    // Simplified decryption for demo - in production use WebCrypto or native crypto
		    const encrypted = this.hexToArrayBuffer(options.encrypted);
		    const iv = this.hexToArrayBuffer(options.iv);
		    const tag = this.hexToArrayBuffer(options.tag);
		    
		    const encryptedBytes = new Uint8Array(encrypted);
		    const keyBytes = new Uint8Array(key as ArrayBuffer);
		    const ivBytes = new Uint8Array(iv);
		    
		    // Verify tag (simplified)
		    const expectedTag = new Uint8Array(16);
		    for (let i = 0; i < 16; i++) {
		      expectedTag[i] = keyBytes[i] ^ ivBytes[i % ivBytes.length];
		    }
		    
		    const actualTag = new Uint8Array(tag);
		    for (let i = 0; i < 16; i++) {
		      if (expectedTag[i] !== actualTag[i]) {
		        throw new Error('Authentication tag verification failed');
		      }
		    }
		    
		    // Decrypt data (reverse XOR)
		    const decrypted = new Uint8Array(encryptedBytes.length);
		    for (let i = 0; i < encryptedBytes.length; i++) {
		      decrypted[i] = encryptedBytes[i] ^ keyBytes[i % keyBytes.length] ^ ivBytes[i % ivBytes.length];
		    }
		    
		    const decoder = new TextDecoder();
		    return decoder.decode(decrypted);
		  }
		
		  private arrayBufferToHex(buffer: ArrayBuffer): string {
		    const bytes = new Uint8Array(buffer);
		    return Array.from(bytes)
		      .map(byte => byte.toString(16).padStart(2, '0'))
		      .join('');
		  }
		
		  private hexToArrayBuffer(hex: string): ArrayBuffer {
		    const bytes = new Uint8Array(hex.length / 2);
		    for (let i = 0; i < hex.length; i += 2) {
		      bytes[i / 2] = parseInt(hex.slice(i, i + 2), 16);
		    }
		    return bytes.buffer;
		  }
		}
		
		// Singleton instance
		export const EncryptionService = new EncryptionServiceClass();
		
		// Initialize on import
		EncryptionService.initialize().catch(error => {
		  console.error('Failed to initialize encryption service:', error);
		});]]></file>
	<file path='services/invitationService.ts'><![CDATA[
		import * as MailComposer from 'expo-mail-composer';
		import * as SMS from 'expo-sms';
		import * as Crypto from 'expo-crypto';
		import * as Linking from 'expo-linking';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import { Alert } from 'react-native';
		import { TwinProfile, ThemeColor, TwinType } from '../state/twinStore';
		
		export interface Invitation {
		  id: string;
		  inviterName: string;
		  inviterEmail?: string;
		  inviterPhone?: string;
		  recipientEmail?: string;
		  recipientPhone?: string;
		  token: string;
		  status: 'pending' | 'sent' | 'delivered' | 'accepted' | 'declined' | 'expired';
		  createdAt: string;
		  expiresAt: string;
		  twinType: TwinType;
		  accentColor: ThemeColor;
		  deepLink?: string;
		  attemptCount: number;
		  lastAttemptAt?: string;
		  metadata?: {
		    deviceInfo?: string;
		    appVersion?: string;
		    platform?: string;
		  };
		}
		
		export interface InvitationAnalytics {
		  totalSent: number;
		  totalAccepted: number;
		  totalDeclined: number;
		  totalExpired: number;
		  acceptanceRate: number;
		  averageResponseTime: number;
		  recentInvitations: Invitation[];
		}
		
		class InvitationService {
		  private static instance: InvitationService;
		  private readonly STORAGE_KEY = 'twinship_invitations';
		  private readonly TOKEN_LENGTH = 32;
		  private readonly EXPIRY_HOURS = 168; // 7 days
		  private readonly MAX_ATTEMPTS = 3;
		  private readonly RATE_LIMIT_WINDOW = 3600000; // 1 hour in milliseconds
		  private readonly MAX_INVITES_PER_HOUR = 5;
		
		  private constructor() {}
		
		  static getInstance(): InvitationService {
		    if (!InvitationService.instance) {
		      InvitationService.instance = new InvitationService();
		    }
		    return InvitationService.instance;
		  }
		
		  /**
		   * Generate a cryptographically secure invitation token
		   */
		  private async generateSecureToken(): Promise<string> {
		    const randomBytes = await Crypto.getRandomBytesAsync(this.TOKEN_LENGTH);
		    return Array.from(randomBytes)
		      .map(byte => byte.toString(16).padStart(2, '0'))
		      .join('')
		      .toUpperCase();
		  }
		
		  /**
		   * Create a deep link for invitation acceptance
		   */
		  private createDeepLink(token: string): string {
		    const baseUrl = Linking.createURL('');
		    return `${baseUrl}invitation/${token}`;
		  }
		
		  /**
		   * Validate invitation token format and security
		   */
		  private validateToken(token: string): boolean {
		    const tokenRegex = /^[0-9A-F]{64}$/;
		    return tokenRegex.test(token);
		  }
		
		  /**
		   * Check rate limiting for invitation sending
		   */
		  private async checkRateLimit(): Promise<boolean> {
		    try {
		      const invitations = await this.getStoredInvitations();
		      const oneHourAgo = new Date(Date.now() - this.RATE_LIMIT_WINDOW);
		      
		      const recentInvitations = invitations.filter(
		        inv => new Date(inv.createdAt) > oneHourAgo
		      );
		      
		      return recentInvitations.length < this.MAX_INVITES_PER_HOUR;
		    } catch (error) {
		      console.error('Error checking rate limit:', error);
		      return false;
		    }
		  }
		
		  /**
		   * Store invitations locally with encryption support
		   */
		  private async storeInvitations(invitations: Invitation[]): Promise<void> {
		    try {
		      const data = JSON.stringify(invitations);
		      await AsyncStorage.setItem(this.STORAGE_KEY, data);
		    } catch (error) {
		      console.error('Failed to store invitations:', error);
		      throw new Error('Failed to save invitation data');
		    }
		  }
		
		  /**
		   * Retrieve stored invitations
		   */
		  private async getStoredInvitations(): Promise<Invitation[]> {
		    try {
		      const data = await AsyncStorage.getItem(this.STORAGE_KEY);
		      return data ? JSON.parse(data) : [];
		    } catch (error) {
		      console.error('Failed to retrieve invitations:', error);
		      return [];
		    }
		  }
		
		  /**
		   * Clean up expired invitations
		   */
		  private async cleanupExpiredInvitations(): Promise<void> {
		    try {
		      const invitations = await this.getStoredInvitations();
		      const now = new Date();
		      
		      const validInvitations = invitations.filter(inv => {
		        const expiryDate = new Date(inv.expiresAt);
		        const isExpired = now > expiryDate;
		        
		        if (isExpired && inv.status === 'pending') {
		          inv.status = 'expired';
		        }
		        
		        // Keep recent invitations for analytics (last 30 days)
		        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
		        return new Date(inv.createdAt) > thirtyDaysAgo;
		      });
		      
		      await this.storeInvitations(validInvitations);
		    } catch (error) {
		      console.error('Failed to cleanup expired invitations:', error);
		    }
		  }
		
		  /**
		   * Create a new invitation
		   */
		  async createInvitation(
		    inviterProfile: TwinProfile,
		    recipientContact: { email?: string; phone?: string }
		  ): Promise<Invitation> {
		    // Rate limiting check
		    const canSend = await this.checkRateLimit();
		    if (!canSend) {
		      throw new Error('Rate limit exceeded. Please wait before sending another invitation.');
		    }
		
		    // Validation
		    if (!recipientContact.email && !recipientContact.phone) {
		      throw new Error('Either email or phone number is required');
		    }
		
		    if (recipientContact.email && !this.isValidEmail(recipientContact.email)) {
		      throw new Error('Invalid email address format');
		    }
		
		    if (recipientContact.phone && !this.isValidPhoneNumber(recipientContact.phone)) {
		      throw new Error('Invalid phone number format');
		    }
		
		    const token = await this.generateSecureToken();
		    const now = new Date();
		    const expiresAt = new Date(now.getTime() + this.EXPIRY_HOURS * 60 * 60 * 1000);
		
		    const invitation: Invitation = {
		      id: `inv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
		      inviterName: inviterProfile.name,
		      inviterEmail: undefined, // Don't store inviter's contact info for privacy
		      inviterPhone: undefined,
		      recipientEmail: recipientContact.email,
		      recipientPhone: recipientContact.phone,
		      token,
		      status: 'pending',
		      createdAt: now.toISOString(),
		      expiresAt: expiresAt.toISOString(),
		      twinType: inviterProfile.twinType,
		      accentColor: inviterProfile.accentColor,
		      deepLink: this.createDeepLink(token),
		      attemptCount: 0,
		      metadata: {
		        appVersion: '1.0.0', // Should be dynamic
		        platform: 'mobile',
		      },
		    };
		
		    // Store the invitation
		    const invitations = await this.getStoredInvitations();
		    invitations.push(invitation);
		    await this.storeInvitations(invitations);
		
		    return invitation;
		  }
		
		  /**
		   * Send email invitation
		   */
		  async sendEmailInvitation(invitation: Invitation): Promise<boolean> {
		    try {
		      if (!invitation.recipientEmail) {
		        throw new Error('No email address provided');
		      }
		
		      const isAvailable = await MailComposer.isAvailableAsync();
		      if (!isAvailable) {
		        throw new Error('Email composer is not available on this device');
		      }
		
		      const subject = `🌟 Your Twin Wants to Connect on Twinship!`;
		      const htmlBody = this.generateEmailTemplate(invitation);
		      const body = this.generatePlainTextEmail(invitation);
		
		      const result = await MailComposer.composeAsync({
		        recipients: [invitation.recipientEmail],
		        subject,
		        body,
		        isHtml: false, // We'll use plain text for better compatibility
		      });
		
		      if (result.status === MailComposer.MailComposerStatus.SENT) {
		        await this.updateInvitationStatus(invitation.id, 'sent');
		        return true;
		      } else if (result.status === MailComposer.MailComposerStatus.SAVED) {
		        // User saved as draft - still count as attempt
		        await this.updateInvitationStatus(invitation.id, 'pending');
		        return false;
		      } else {
		        return false;
		      }
		    } catch (error) {
		      console.error('Failed to send email invitation:', error);
		      await this.incrementAttemptCount(invitation.id);
		      throw error;
		    }
		  }
		
		  /**
		   * Send SMS invitation
		   */
		  async sendSMSInvitation(invitation: Invitation): Promise<boolean> {
		    try {
		      if (!invitation.recipientPhone) {
		        throw new Error('No phone number provided');
		      }
		
		      const isAvailable = await SMS.isAvailableAsync();
		      if (!isAvailable) {
		        throw new Error('SMS is not available on this device');
		      }
		
		      const message = this.generateSMSTemplate(invitation);
		
		      const result = await SMS.sendSMSAsync(
		        [invitation.recipientPhone],
		        message
		      );
		
		      if (result.result === SMS.SMSResult.SENT) {
		        await this.updateInvitationStatus(invitation.id, 'sent');
		        return true;
		      } else {
		        return false;
		      }
		    } catch (error) {
		      console.error('Failed to send SMS invitation:', error);
		      await this.incrementAttemptCount(invitation.id);
		      throw error;
		    }
		  }
		
		  /**
		   * Validate and accept invitation using token
		   */
		  async acceptInvitation(token: string): Promise<{
		    success: boolean;
		    invitation?: Invitation;
		    error?: string;
		  }> {
		    try {
		      if (!this.validateToken(token)) {
		        return { success: false, error: 'Invalid invitation token format' };
		      }
		
		      const invitations = await this.getStoredInvitations();
		      const invitation = invitations.find(inv => inv.token === token);
		
		      if (!invitation) {
		        return { success: false, error: 'Invitation not found' };
		      }
		
		      if (invitation.status === 'accepted') {
		        return { success: false, error: 'Invitation has already been accepted' };
		      }
		
		      if (invitation.status === 'declined') {
		        return { success: false, error: 'Invitation has been declined' };
		      }
		
		      if (invitation.status === 'expired' || new Date() > new Date(invitation.expiresAt)) {
		        await this.updateInvitationStatus(invitation.id, 'expired');
		        return { success: false, error: 'Invitation has expired' };
		      }
		
		      await this.updateInvitationStatus(invitation.id, 'accepted');
		      return { success: true, invitation };
		    } catch (error) {
		      console.error('Failed to accept invitation:', error);
		      return { success: false, error: 'Failed to process invitation' };
		    }
		  }
		
		  /**
		   * Decline invitation
		   */
		  async declineInvitation(token: string): Promise<boolean> {
		    try {
		      const invitations = await this.getStoredInvitations();
		      const invitation = invitations.find(inv => inv.token === token);
		
		      if (!invitation) {
		        return false;
		      }
		
		      await this.updateInvitationStatus(invitation.id, 'declined');
		      return true;
		    } catch (error) {
		      console.error('Failed to decline invitation:', error);
		      return false;
		    }
		  }
		
		  /**
		   * Get invitation by token
		   */
		  async getInvitationByToken(token: string): Promise<Invitation | null> {
		    try {
		      const invitations = await this.getStoredInvitations();
		      return invitations.find(inv => inv.token === token) || null;
		    } catch (error) {
		      console.error('Failed to get invitation by token:', error);
		      return null;
		    }
		  }
		
		  /**
		   * Get all invitations for analytics
		   */
		  async getInvitationAnalytics(): Promise<InvitationAnalytics> {
		    try {
		      const invitations = await this.getStoredInvitations();
		      
		      const totalSent = invitations.filter(inv => inv.status === 'sent' || inv.status === 'accepted' || inv.status === 'declined').length;
		      const totalAccepted = invitations.filter(inv => inv.status === 'accepted').length;
		      const totalDeclined = invitations.filter(inv => inv.status === 'declined').length;
		      const totalExpired = invitations.filter(inv => inv.status === 'expired').length;
		      
		      const acceptanceRate = totalSent > 0 ? (totalAccepted / totalSent) * 100 : 0;
		      
		      // Calculate average response time for accepted invitations
		      const acceptedInvitations = invitations.filter(inv => inv.status === 'accepted');
		      const responseTimes = acceptedInvitations.map(inv => {
		        const created = new Date(inv.createdAt).getTime();
		        const updated = new Date(inv.lastAttemptAt || inv.createdAt).getTime();
		        return updated - created;
		      });
		      
		      const averageResponseTime = responseTimes.length > 0 
		        ? responseTimes.reduce((sum, time) => sum + time, 0) / responseTimes.length
		        : 0;
		      
		      // Get recent invitations (last 7 days)
		      const sevenDaysAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
		      const recentInvitations = invitations
		        .filter(inv => new Date(inv.createdAt) > sevenDaysAgo)
		        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
		        .slice(0, 10);
		
		      return {
		        totalSent,
		        totalAccepted,
		        totalDeclined,
		        totalExpired,
		        acceptanceRate,
		        averageResponseTime,
		        recentInvitations,
		      };
		    } catch (error) {
		      console.error('Failed to get invitation analytics:', error);
		      return {
		        totalSent: 0,
		        totalAccepted: 0,
		        totalDeclined: 0,
		        totalExpired: 0,
		        acceptanceRate: 0,
		        averageResponseTime: 0,
		        recentInvitations: [],
		      };
		    }
		  }
		
		  /**
		   * Retry sending failed invitation
		   */
		  async retryInvitation(invitationId: string, method: 'email' | 'sms'): Promise<boolean> {
		    try {
		      const invitations = await this.getStoredInvitations();
		      const invitation = invitations.find(inv => inv.id === invitationId);
		
		      if (!invitation) {
		        throw new Error('Invitation not found');
		      }
		
		      if (invitation.attemptCount >= this.MAX_ATTEMPTS) {
		        throw new Error('Maximum retry attempts exceeded');
		      }
		
		      if (new Date() > new Date(invitation.expiresAt)) {
		        throw new Error('Invitation has expired');
		      }
		
		      if (method === 'email') {
		        return await this.sendEmailInvitation(invitation);
		      } else {
		        return await this.sendSMSInvitation(invitation);
		      }
		    } catch (error) {
		      console.error('Failed to retry invitation:', error);
		      throw error;
		    }
		  }
		
		  /**
		   * Update invitation status
		   */
		  private async updateInvitationStatus(invitationId: string, status: Invitation['status']): Promise<void> {
		    try {
		      const invitations = await this.getStoredInvitations();
		      const index = invitations.findIndex(inv => inv.id === invitationId);
		      
		      if (index !== -1) {
		        invitations[index].status = status;
		        invitations[index].lastAttemptAt = new Date().toISOString();
		        await this.storeInvitations(invitations);
		      }
		    } catch (error) {
		      console.error('Failed to update invitation status:', error);
		    }
		  }
		
		  /**
		   * Increment attempt count
		   */
		  private async incrementAttemptCount(invitationId: string): Promise<void> {
		    try {
		      const invitations = await this.getStoredInvitations();
		      const index = invitations.findIndex(inv => inv.id === invitationId);
		      
		      if (index !== -1) {
		        invitations[index].attemptCount += 1;
		        invitations[index].lastAttemptAt = new Date().toISOString();
		        await this.storeInvitations(invitations);
		      }
		    } catch (error) {
		      console.error('Failed to increment attempt count:', error);
		    }
		  }
		
		  /**
		   * Generate email template
		   */
		  private generatePlainTextEmail(invitation: Invitation): string {
		    return `🌟 Twin Connection Invitation 🌟
		
		Hi there!
		
		${invitation.inviterName} has invited you to connect on Twinship - the digital space designed exclusively for twins!
		
		Twinship helps twins strengthen their unique bond through private communication, fun games, and research-grade personality assessments. It's a special place where your twin connection can flourish.
		
		✨ What awaits you:
		• Private "Twin Talk" messaging with your twin
		• "Twintuition" alerts for those psychic moments
		• Fun games to test your synchronicity
		• Personality assessments built specifically for twins
		• A safe space to explore your twin identity
		
		🔗 Accept this invitation:
		${invitation.deepLink}
		
		Or enter this invitation code in the Twinship app:
		${invitation.token}
		
		⏰ This invitation expires on ${new Date(invitation.expiresAt).toLocaleDateString()}
		
		Download Twinship from your app store and enter the code above to begin your twin journey!
		
		With love and twin magic,
		The Twinship Team 💜
		
		---
		This invitation is personal and should not be shared. If you're not ${invitation.inviterName}'s twin, please disregard this message.`;
		  }
		
		  /**
		   * Generate HTML email template (for future use)
		   */
		  private generateEmailTemplate(invitation: Invitation): string {
		    // HTML template would go here for richer email formatting
		    return this.generatePlainTextEmail(invitation);
		  }
		
		  /**
		   * Generate SMS template
		   */
		  private generateSMSTemplate(invitation: Invitation): string {
		    return `🌟 ${invitation.inviterName} invited you to Twinship! A space for twins to connect, chat & explore your unique bond. Accept: ${invitation.deepLink} or use code: ${invitation.token} (expires ${new Date(invitation.expiresAt).toLocaleDateString()})`;
		  }
		
		  /**
		   * Validate email format
		   */
		  private isValidEmail(email: string): boolean {
		    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
		    return emailRegex.test(email);
		  }
		
		  /**
		   * Validate phone number format (basic validation)
		   */
		  private isValidPhoneNumber(phone: string): boolean {
		    const phoneRegex = /^[+]?[1-9]\d{1,14}$/;
		    return phoneRegex.test(phone.replace(/[\s()-]/g, ''));
		  }
		
		  /**
		   * Initialize service and cleanup old data
		   */
		  async initialize(): Promise<void> {
		    try {
		      await this.cleanupExpiredInvitations();
		    } catch (error) {
		      console.error('Failed to initialize invitation service:', error);
		    }
		  }
		
		  /**
		   * Clear all invitation data (for testing/reset purposes)
		   */
		  async clearAllData(): Promise<void> {
		    try {
		      await AsyncStorage.removeItem(this.STORAGE_KEY);
		    } catch (error) {
		      console.error('Failed to clear invitation data:', error);
		    }
		  }
		}
		
		export const invitationService = InvitationService.getInstance();
		export default invitationService;]]></file>
	<file path='services/researchService.ts'><![CDATA[
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import { useTwinStore } from '../state/twinStore';
		import { 
		  ResearchStudy, 
		  ConsentRecord, 
		  ResearchParticipation, 
		  DataContribution,
		  ResearchInsight,
		  AggregatedFindings,
		  ParticipantDashboard,
		  ResearchDataType,
		  WithdrawalRequest
		} from '../types/research';
		import { AssessmentResults } from '../types/assessment';
		
		class ResearchService {
		  private readonly STORAGE_KEYS = {
		    CONSENT_RECORDS: '@research_consent_records',
		    PARTICIPATION: '@research_participation',
		    CONTRIBUTIONS: '@research_contributions',
		    INSIGHTS: '@research_insights',
		    PREFERENCES: '@research_preferences'
		  };
		
		  // Mock data for demonstration - in production, this would come from API
		  private mockStudies: ResearchStudy[] = [
		    {
		      id: 'twin-sync-2024',
		      title: 'Twin Synchronicity & Intuition Study',
		      description: 'Investigating psychic connections and synchronicity between twins',
		      fullDescription: 'This comprehensive study explores the phenomenon of twin telepathy, synchronicity, and intuitive connections. We analyze communication patterns, simultaneous experiences, and predictive behaviors between twin pairs.',
		      duration: '12 months',
		      compensation: ['Research insights', 'Early feature access', 'Scientific publications acknowledgment'],
		      participants: 1247,
		      status: 'recruiting',
		      category: 'synchronicity',
		      requirements: ['Both twins must participate', 'Regular app usage', 'Complete assessments'],
		      ethicsApproval: 'IRB-2024-TWIN-001',
		      leadResearcher: 'Dr. Sarah Chen, PhD',
		      institution: 'Stanford Twin Research Institute',
		      consentVersion: 2,
		      dataTypes: [
		        {
		          type: 'games',
		          description: 'Psychic game results and response patterns',
		          anonymizationLevel: 'full',
		          retentionPeriod: '7 years',
		          sharingScope: 'academic'
		        },
		        {
		          type: 'communication',
		          description: 'Chat timing and synchronicity patterns (content excluded)',
		          anonymizationLevel: 'full',
		          retentionPeriod: '5 years',
		          sharingScope: 'academic'
		        }
		      ],
		      benefits: ['Contributing to twin psychology research', 'Understanding your twin connection', 'Access to anonymized comparison data']
		    },
		    {
		      id: 'emotional-mirror-2024',
		      title: 'Emotional Mirroring & Empathy Study',
		      description: 'Understanding emotional connections and empathic responses between twins',
		      fullDescription: 'This study examines how twins experience and share emotions across distances, investigating the neurological and psychological basis of twin empathy.',
		      duration: '6 months',
		      compensation: ['Personalized empathy insights', 'Emotional intelligence reports', 'Research participation certificate'],
		      participants: 892,
		      status: 'active',
		      category: 'psychology',
		      requirements: ['Complete personality assessments', 'Regular mood tracking', 'Geographic separation data'],
		      ethicsApproval: 'IRB-2024-TWIN-002',
		      leadResearcher: 'Dr. Michael Rodriguez, PhD',
		      institution: 'UC Berkeley Psychology Department',
		      consentVersion: 1,
		      dataTypes: [
		        {
		          type: 'assessment',
		          description: 'Personality and emotional assessment results',
		          anonymizationLevel: 'pseudonymized',
		          retentionPeriod: '10 years',
		          sharingScope: 'academic'
		        },
		        {
		          type: 'behavioral',
		          description: 'App usage patterns and emotional triggers',
		          anonymizationLevel: 'full',
		          retentionPeriod: '5 years',
		          sharingScope: 'internal'
		        }
		      ],
		      benefits: ['Understanding emotional patterns', 'Improving twin communication', 'Contributing to empathy research']
		    }
		  ];
		
		  async getAvailableStudies(): Promise<ResearchStudy[]> {
		    // In production, this would fetch from API
		    return this.mockStudies.filter(study => study.status === 'recruiting' || study.status === 'active');
		  }
		
		  async getStudyDetails(studyId: string): Promise<ResearchStudy | null> {
		    return this.mockStudies.find(study => study.id === studyId) || null;
		  }
		
		  async recordConsent(
		    userId: string, 
		    studyId: string, 
		    consentItems: ConsentRecord['consentedTo'],
		    ipAddress?: string
		  ): Promise<ConsentRecord> {
		    const study = await this.getStudyDetails(studyId);
		    if (!study) {
		      throw new Error('Study not found');
		    }
		
		    const consentRecord: ConsentRecord = {
		      id: `consent_${userId}_${studyId}_${Date.now()}`,
		      userId,
		      studyId,
		      consentVersion: study.consentVersion,
		      consentedAt: new Date().toISOString(),
		      consentedTo: consentItems,
		      ipAddress,
		      location: 'user_location' // In production, get from geolocation with permission
		    };
		
		    // Store consent record
		    const existingRecords = await this.getConsentRecords(userId);
		    const updatedRecords = [...existingRecords, consentRecord];
		    await AsyncStorage.setItem(
		      `${this.STORAGE_KEYS.CONSENT_RECORDS}_${userId}`,
		      JSON.stringify(updatedRecords)
		    );
		
		    return consentRecord;
		  }
		
		  async getConsentRecords(userId: string): Promise<ConsentRecord[]> {
		    try {
		      const data = await AsyncStorage.getItem(`${this.STORAGE_KEYS.CONSENT_RECORDS}_${userId}`);
		      return data ? JSON.parse(data) : [];
		    } catch (error) {
		      console.error('Error getting consent records:', error);
		      return [];
		    }
		  }
		
		  async joinStudy(userId: string, studyId: string): Promise<void> {
		    const participation = await this.getParticipation(userId);
		    
		    if (!participation.activeStudies.includes(studyId)) {
		      participation.activeStudies.push(studyId);
		      participation.totalStudies = Math.max(participation.totalStudies, participation.activeStudies.length);
		      
		      await this.updateParticipation(userId, participation);
		    }
		  }
		
		  async withdrawFromStudy(
		    userId: string, 
		    studyId: string, 
		    reason: string, 
		    dataDisposition: WithdrawalRequest['dataDisposition']
		  ): Promise<WithdrawalRequest> {
		    const withdrawal: WithdrawalRequest = {
		      id: `withdrawal_${userId}_${studyId}_${Date.now()}`,
		      studyId,
		      requestedAt: new Date().toISOString(),
		      reason,
		      dataDisposition,
		      status: 'pending'
		    };
		
		    // Remove from active studies
		    const participation = await this.getParticipation(userId);
		    participation.activeStudies = participation.activeStudies.filter(id => id !== studyId);
		    participation.withdrawalRequests.push(withdrawal);
		    
		    await this.updateParticipation(userId, participation);
		
		    return withdrawal;
		  }
		
		  async getParticipation(userId: string): Promise<ResearchParticipation> {
		    try {
		      const data = await AsyncStorage.getItem(`${this.STORAGE_KEYS.PARTICIPATION}_${userId}`);
		      
		      if (data) {
		        return JSON.parse(data);
		      }
		      
		      // Return default participation
		      return {
		        userId,
		        activeStudies: [],
		        totalStudies: 0,
		        joinedAt: new Date().toISOString(),
		        dataContributions: [],
		        insights: [],
		        preferences: {
		          dataSharing: {
		            fullAnonymization: true,
		            academicSharing: true,
		            publicResults: false,
		            commercialUse: false
		          },
		          communication: {
		            updates: true,
		            insights: true,
		            publications: false,
		            surveys: true
		          },
		          participation: {
		            maxStudies: 3,
		            preferredCategories: [],
		            timeCommitment: 'moderate'
		          }
		        },
		        withdrawalRequests: []
		      };
		    } catch (error) {
		      console.error('Error getting participation:', error);
		      throw error;
		    }
		  }
		
		  async updateParticipation(userId: string, participation: ResearchParticipation): Promise<void> {
		    try {
		      await AsyncStorage.setItem(
		        `${this.STORAGE_KEYS.PARTICIPATION}_${userId}`,
		        JSON.stringify(participation)
		      );
		    } catch (error) {
		      console.error('Error updating participation:', error);
		      throw error;
		    }
		  }
		
		  async contributeAssessmentData(
		    userId: string, 
		    assessmentResults: AssessmentResults
		  ): Promise<void> {
		    const participation = await this.getParticipation(userId);
		    
		    // Create contributions for each active study that accepts assessment data
		    for (const studyId of participation.activeStudies) {
		      const study = await this.getStudyDetails(studyId);
		      if (study?.dataTypes.some(dt => dt.type === 'assessment')) {
		        const contribution: DataContribution = {
		          id: `contrib_${userId}_${studyId}_${Date.now()}`,
		          studyId,
		          dataType: 'assessment',
		          contributedAt: new Date().toISOString(),
		          dataPoints: assessmentResults.subscaleScores.length,
		          anonymizedId: this.generateAnonymizedId(userId, studyId),
		          status: 'pending'
		        };
		        
		        participation.dataContributions.push(contribution);
		      }
		    }
		    
		    await this.updateParticipation(userId, participation);
		  }
		
		  async contributeBehavioralData(
		    userId: string, 
		    behaviorType: string, 
		    dataPoints: number
		  ): Promise<void> {
		    const participation = await this.getParticipation(userId);
		    
		    for (const studyId of participation.activeStudies) {
		      const study = await this.getStudyDetails(studyId);
		      if (study?.dataTypes.some(dt => dt.type === 'behavioral')) {
		        const contribution: DataContribution = {
		          id: `contrib_${userId}_${studyId}_${Date.now()}`,
		          studyId,
		          dataType: 'behavioral',
		          contributedAt: new Date().toISOString(),
		          dataPoints,
		          anonymizedId: this.generateAnonymizedId(userId, studyId),
		          status: 'pending'
		        };
		        
		        participation.dataContributions.push(contribution);
		      }
		    }
		    
		    await this.updateParticipation(userId, participation);
		  }
		
		  async getParticipantDashboard(userId: string): Promise<ParticipantDashboard> {
		    const participation = await this.getParticipation(userId);
		    const activeStudies = await Promise.all(
		      participation.activeStudies.map(id => this.getStudyDetails(id))
		    );
		    
		    const totalContributions = participation.dataContributions.length;
		    const publicationsEnabled = Math.floor(totalContributions / 100); // Mock calculation
		    
		    return {
		      totalContributions,
		      activeStudies: activeStudies.filter(Boolean) as ResearchStudy[],
		      recentInsights: participation.insights.slice(0, 5),
		      impactMetrics: {
		        dataPointsContributed: participation.dataContributions.reduce(
		          (sum, contrib) => sum + contrib.dataPoints, 
		          0
		        ),
		        studiesSupported: participation.totalStudies,
		        publicationsEnabled,
		        scientificImpact: Math.min(publicationsEnabled * 10, 100)
		      },
		      upcomingMilestones: [
		        `Contribute to ${Math.ceil(totalContributions / 10) * 10} data points`,
		        'Complete 6-month participation milestone',
		        'Unlock advanced insights dashboard'
		      ],
		      recognitions: publicationsEnabled > 0 ? [
		        'Research Contributor Badge',
		        'Twin Science Supporter',
		        ...(publicationsEnabled > 2 ? ['Veteran Researcher'] : [])
		      ] : []
		    };
		  }
		
		  async getResearchInsights(userId: string): Promise<ResearchInsight[]> {
		    const participation = await this.getParticipation(userId);
		    
		    // Mock insights - in production, these would come from actual research results
		    const mockInsights: ResearchInsight[] = [
		      {
		        id: 'insight_1',
		        studyId: 'twin-sync-2024',
		        title: 'Twin Synchronicity Patterns Identified',
		        summary: 'Research reveals strong correlations between twin pairs in simultaneous experiences',
		        findings: [
		          'Identical twins show 73% synchronicity in emotional states',
		          'Geographic distance has minimal impact on twin connection strength',
		          'Synchronicity events peak during significant life changes'
		        ],
		        relevantToUser: participation.activeStudies.includes('twin-sync-2024'),
		        publishedAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
		        significance: 'significant'
		      }
		    ];
		    
		    return mockInsights.filter(insight => 
		      participation.activeStudies.includes(insight.studyId)
		    );
		  }
		
		  private generateAnonymizedId(userId: string, studyId: string): string {
		    // In production, use proper cryptographic hashing
		    const hash = btoa(`${userId}_${studyId}_${Date.now()}`);
		    return hash.replace(/[^a-zA-Z0-9]/g, '').substring(0, 16);
		  }
		
		  async deleteAllUserData(userId: string): Promise<void> {
		    const keys = [
		      `${this.STORAGE_KEYS.CONSENT_RECORDS}_${userId}`,
		      `${this.STORAGE_KEYS.PARTICIPATION}_${userId}`,
		      `${this.STORAGE_KEYS.CONTRIBUTIONS}_${userId}`,
		      `${this.STORAGE_KEYS.INSIGHTS}_${userId}`,
		      `${this.STORAGE_KEYS.PREFERENCES}_${userId}`
		    ];
		    
		    await Promise.all(keys.map(key => AsyncStorage.removeItem(key)));
		  }
		
		  async exportUserData(userId: string): Promise<object> {
		    const [consent, participation] = await Promise.all([
		      this.getConsentRecords(userId),
		      this.getParticipation(userId)
		    ]);
		    
		    return {
		      userId,
		      exportedAt: new Date().toISOString(),
		      consentRecords: consent,
		      participation,
		      dataRights: {
		        canWithdraw: true,
		        canExport: true,
		        canDelete: true,
		        canModify: true
		      }
		    };
		  }
		}
		
		export const researchService = new ResearchService();]]></file>
	<file path='services/storageService.ts'><![CDATA[
		/**
		 * Storage Service - Unified storage interface for assessment data
		 * Provides encryption, compression, and multi-tier storage management
		 */
		
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import { MMKV } from 'react-native-mmkv';
		import * as FileSystem from 'expo-file-system';
		import * as SecureStore from 'expo-secure-store';
		import { EncryptionService } from './encryptionService';
		
		// Storage tiers for different data types and sensitivity levels
		const standardStorage = new MMKV({ id: 'assessment-standard' });
		const secureStorage = new MMKV({ 
		  id: 'assessment-secure',
		  encryptionKey: 'assessment-secure-key' // In production, use device keychain
		});
		const tempStorage = new MMKV({ id: 'assessment-temp' });
		
		export interface StorageOptions {
		  encrypt?: boolean;
		  compress?: boolean;
		  tier?: 'standard' | 'secure' | 'temp' | 'persistent';
		  ttl?: number; // Time to live in milliseconds
		  backup?: boolean;
		}
		
		export interface StorageItem {
		  key: string;
		  value: any;
		  metadata: {
		    createdAt: string;
		    updatedAt: string;
		    accessCount: number;
		    lastAccessed: string;
		    encrypted: boolean;
		    compressed: boolean;
		    size: number;
		    ttl?: number;
		    expiresAt?: string;
		  };
		}
		
		export class StorageService {
		  private static instance: StorageService;
		  private compressionThreshold = 1024; // Compress data larger than 1KB
		  private cleanupInterval: NodeJS.Timeout | null = null;
		
		  constructor() {
		    this.startCleanupTimer();
		  }
		
		  static getInstance(): StorageService {
		    if (!StorageService.instance) {
		      StorageService.instance = new StorageService();
		    }
		    return StorageService.instance;
		  }
		
		  /**
		   * Store data with automatic tier selection and optimization
		   */
		  async set(key: string, value: any, options: StorageOptions = {}): Promise<void> {
		    const {
		      encrypt = false,
		      compress = true,
		      tier = 'standard',
		      ttl,
		      backup = false
		    } = options;
		
		    let processedValue = value;
		    let metadata: StorageItem['metadata'] = {
		      createdAt: new Date().toISOString(),
		      updatedAt: new Date().toISOString(),
		      accessCount: 0,
		      lastAccessed: new Date().toISOString(),
		      encrypted: encrypt,
		      compressed: false,
		      size: 0,
		    };
		
		    // Serialize data
		    const serialized = typeof value === 'string' ? value : JSON.stringify(value);
		    metadata.size = serialized.length;
		
		    // Apply compression if needed
		    if (compress && serialized.length > this.compressionThreshold) {
		      try {
		        processedValue = await this.compressData(serialized);
		        metadata.compressed = true;
		      } catch (error) {
		        console.warn('Compression failed, storing uncompressed:', error);
		        processedValue = serialized;
		      }
		    } else {
		      processedValue = serialized;
		    }
		
		    // Apply encryption if requested
		    if (encrypt) {
		      try {
		        processedValue = await EncryptionService.encrypt(processedValue);
		        metadata.encrypted = true;
		      } catch (error) {
		        throw new Error(`Encryption failed: ${error}`);
		      }
		    }
		
		    // Set TTL if provided
		    if (ttl) {
		      metadata.ttl = ttl;
		      metadata.expiresAt = new Date(Date.now() + ttl).toISOString();
		    }
		
		    const storageItem: StorageItem = {
		      key,
		      value: processedValue,
		      metadata
		    };
		
		    // Store in appropriate tier
		    await this.storeInTier(key, storageItem, tier);
		
		    // Create backup if requested
		    if (backup && tier !== 'temp') {
		      await this.createBackup(key, storageItem);
		    }
		  }
		
		  /**
		   * Retrieve data with automatic decryption and decompression
		   */
		  async get(key: string, tier: StorageOptions['tier'] = 'standard'): Promise<any> {
		    const item = await this.getFromTier(key, tier);
		    if (!item) return null;
		
		    // Check expiration
		    if (item.metadata.expiresAt && new Date(item.metadata.expiresAt) < new Date()) {
		      await this.remove(key, tier);
		      return null;
		    }
		
		    let processedValue = item.value;
		
		    // Decrypt if needed
		    if (item.metadata.encrypted) {
		      try {
		        processedValue = await EncryptionService.decrypt(processedValue);
		      } catch (error) {
		        throw new Error(`Decryption failed: ${error}`);
		      }
		    }
		
		    // Decompress if needed
		    if (item.metadata.compressed) {
		      try {
		        processedValue = await this.decompressData(processedValue);
		      } catch (error) {
		        console.warn('Decompression failed:', error);
		      }
		    }
		
		    // Update access metadata
		    item.metadata.accessCount++;
		    item.metadata.lastAccessed = new Date().toISOString();
		    await this.storeInTier(key, item, tier);
		
		    // Parse JSON if it's not already an object
		    try {
		      return typeof processedValue === 'string' ? JSON.parse(processedValue) : processedValue;
		    } catch {
		      return processedValue;
		    }
		  }
		
		  /**
		   * Store in secure tier with encryption
		   */
		  async setSecure(key: string, value: any, options: Omit<StorageOptions, 'tier' | 'encrypt'> = {}): Promise<void> {
		    await this.set(key, value, { ...options, tier: 'secure', encrypt: true });
		  }
		
		  /**
		   * Get from secure tier with decryption
		   */
		  async getSecure(key: string): Promise<any> {
		    return this.get(key, 'secure');
		  }
		
		  /**
		   * Store in persistent storage (device storage)
		   */
		  async setPersistent(key: string, value: any, options: StorageOptions = {}): Promise<void> {
		    await this.set(key, value, { ...options, tier: 'persistent' });
		  }
		
		  /**
		   * Get from persistent storage
		   */
		  async getPersistent(key: string): Promise<any> {
		    return this.get(key, 'persistent');
		  }
		
		  /**
		   * Remove data from storage
		   */
		  async remove(key: string, tier: StorageOptions['tier'] = 'standard'): Promise<void> {
		    switch (tier) {
		      case 'secure':
		        secureStorage.delete(key);
		        break;
		      case 'temp':
		        tempStorage.delete(key);
		        break;
		      case 'persistent':
		        await AsyncStorage.removeItem(key);
		        break;
		      default:
		        standardStorage.delete(key);
		    }
		  }
		
		  /**
		   * Remove from secure storage
		   */
		  async removeSecure(key: string): Promise<void> {
		    await this.remove(key, 'secure');
		  }
		
		  /**
		   * Clear all data from a specific tier
		   */
		  async clearTier(tier: StorageOptions['tier']): Promise<void> {
		    switch (tier) {
		      case 'secure':
		        secureStorage.clearAll();
		        break;
		      case 'temp':
		        tempStorage.clearAll();
		        break;
		      case 'persistent':
		        await AsyncStorage.clear();
		        break;
		      default:
		        standardStorage.clearAll();
		    }
		  }
		
		  /**
		   * Get storage statistics
		   */
		  async getStats(): Promise<{
		    totalItems: number;
		    totalSize: number;
		    tierStats: Record<string, { items: number; size: number }>;
		    expiredItems: number;
		  }> {
		    const stats = {
		      totalItems: 0,
		      totalSize: 0,
		      tierStats: {
		        standard: { items: 0, size: 0 },
		        secure: { items: 0, size: 0 },
		        temp: { items: 0, size: 0 },
		        persistent: { items: 0, size: 0 },
		      },
		      expiredItems: 0,
		    };
		
		    // Count MMKV storage
		    const mmkvStorages = {
		      standard: standardStorage,
		      secure: secureStorage,
		      temp: tempStorage,
		    };
		
		    Object.entries(mmkvStorages).forEach(([tierName, storage]) => {
		      const keys = storage.getAllKeys();
		      keys.forEach(key => {
		        try {
		          const item = JSON.parse(storage.getString(key) || '{}') as StorageItem;
		          stats.tierStats[tierName].items++;
		          stats.tierStats[tierName].size += item.metadata.size;
		          
		          if (item.metadata.expiresAt && new Date(item.metadata.expiresAt) < new Date()) {
		            stats.expiredItems++;
		          }
		        } catch {
		          // Skip corrupted items
		        }
		      });
		    });
		
		    // Count AsyncStorage (persistent)
		    try {
		      const asyncKeys = await AsyncStorage.getAllKeys();
		      const assessmentKeys = asyncKeys.filter(key => key.startsWith('assessment'));
		      
		      for (const key of assessmentKeys) {
		        const value = await AsyncStorage.getItem(key);
		        if (value) {
		          stats.tierStats.persistent.items++;
		          stats.tierStats.persistent.size += value.length;
		        }
		      }
		    } catch {
		      // Handle AsyncStorage errors
		    }
		
		    // Calculate totals
		    Object.values(stats.tierStats).forEach(tierStat => {
		      stats.totalItems += tierStat.items;
		      stats.totalSize += tierStat.size;
		    });
		
		    return stats;
		  }
		
		  /**
		   * Clean up expired items
		   */
		  async cleanup(): Promise<{ removed: number; freed: number }> {
		    let removed = 0;
		    let freed = 0;
		
		    const storages = {
		      standard: standardStorage,
		      secure: secureStorage,
		      temp: tempStorage,
		    };
		
		    for (const [tierName, storage] of Object.entries(storages)) {
		      const keys = storage.getAllKeys();
		      
		      for (const key of keys) {
		        try {
		          const itemStr = storage.getString(key);
		          if (!itemStr) continue;
		          
		          const item = JSON.parse(itemStr) as StorageItem;
		          
		          if (item.metadata.expiresAt && new Date(item.metadata.expiresAt) < new Date()) {
		            storage.delete(key);
		            removed++;
		            freed += item.metadata.size;
		          }
		        } catch {
		          // Remove corrupted items
		          storage.delete(key);
		          removed++;
		        }
		      }
		    }
		
		    return { removed, freed };
		  }
		
		  /**
		   * Export all assessment data
		   */
		  async exportAll(): Promise<{
		    standard: Record<string, any>;
		    secure: Record<string, any>;
		    persistent: Record<string, any>;
		    metadata: {
		      exportedAt: string;
		      totalItems: number;
		      totalSize: number;
		    };
		  }> {
		    const exportData = {
		      standard: {},
		      secure: {},
		      persistent: {},
		      metadata: {
		        exportedAt: new Date().toISOString(),
		        totalItems: 0,
		        totalSize: 0,
		      },
		    };
		
		    // Export from MMKV storages (excluding temp)
		    const storages = {
		      standard: standardStorage,
		      secure: secureStorage,
		    };
		
		    for (const [tierName, storage] of Object.entries(storages)) {
		      const keys = storage.getAllKeys();
		      
		      for (const key of keys) {
		        try {
		          const value = await this.get(key, tierName as any);
		          if (value) {
		            exportData[tierName][key] = value;
		            exportData.metadata.totalItems++;
		          }
		        } catch (error) {
		          console.warn(`Failed to export ${key} from ${tierName}:`, error);
		        }
		      }
		    }
		
		    // Export from AsyncStorage
		    try {
		      const asyncKeys = await AsyncStorage.getAllKeys();
		      const assessmentKeys = asyncKeys.filter(key => key.startsWith('assessment'));
		      
		      for (const key of assessmentKeys) {
		        const value = await AsyncStorage.getItem(key);
		        if (value) {
		          try {
		            exportData.persistent[key] = JSON.parse(value);
		            exportData.metadata.totalItems++;
		            exportData.metadata.totalSize += value.length;
		          } catch {
		            exportData.persistent[key] = value;
		          }
		        }
		      }
		    } catch (error) {
		      console.warn('Failed to export from AsyncStorage:', error);
		    }
		
		    return exportData;
		  }
		
		  // Private methods
		  private async storeInTier(key: string, item: StorageItem, tier: StorageOptions['tier']): Promise<void> {
		    const serialized = JSON.stringify(item);
		    
		    switch (tier) {
		      case 'secure':
		        secureStorage.set(key, serialized);
		        break;
		      case 'temp':
		        tempStorage.set(key, serialized);
		        break;
		      case 'persistent':
		        await AsyncStorage.setItem(key, serialized);
		        break;
		      default:
		        standardStorage.set(key, serialized);
		    }
		  }
		
		  private async getFromTier(key: string, tier: StorageOptions['tier']): Promise<StorageItem | null> {
		    let serialized: string | null = null;
		    
		    switch (tier) {
		      case 'secure':
		        serialized = secureStorage.getString(key) || null;
		        break;
		      case 'temp':
		        serialized = tempStorage.getString(key) || null;
		        break;
		      case 'persistent':
		        serialized = await AsyncStorage.getItem(key);
		        break;
		      default:
		        serialized = standardStorage.getString(key) || null;
		    }
		
		    if (!serialized) return null;
		    
		    try {
		      return JSON.parse(serialized) as StorageItem;
		    } catch {
		      return null;
		    }
		  }
		
		  private async compressData(data: string): Promise<string> {
		    // Simple compression using string manipulation
		    // In production, consider using a proper compression library
		    return btoa(data);
		  }
		
		  private async decompressData(data: string): Promise<string> {
		    try {
		      return atob(data);
		    } catch {
		      return data; // Return as-is if decompression fails
		    }
		  }
		
		  private async createBackup(key: string, item: StorageItem): Promise<void> {
		    const backupDir = `${FileSystem.documentDirectory}assessment_backups/`;
		    
		    try {
		      // Ensure backup directory exists
		      const dirInfo = await FileSystem.getInfoAsync(backupDir);
		      if (!dirInfo.exists) {
		        await FileSystem.makeDirectoryAsync(backupDir, { intermediates: true });
		      }
		
		      const backupPath = `${backupDir}${key}.backup`;
		      await FileSystem.writeAsStringAsync(backupPath, JSON.stringify(item));
		    } catch (error) {
		      console.warn('Failed to create backup:', error);
		    }
		  }
		
		  private startCleanupTimer(): void {
		    // Run cleanup every hour
		    this.cleanupInterval = setInterval(async () => {
		      try {
		        await this.cleanup();
		      } catch (error) {
		        console.warn('Cleanup failed:', error);
		      }
		    }, 60 * 60 * 1000);
		  }
		
		  /**
		   * Stop cleanup timer (useful for testing or app shutdown)
		   */
		  stopCleanup(): void {
		    if (this.cleanupInterval) {
		      clearInterval(this.cleanupInterval);
		      this.cleanupInterval = null;
		    }
		  }
		}
		
		// Singleton instance
		export const storageService = StorageService.getInstance();
		
		// Convenience methods
		export const {
		  set,
		  get,
		  setSecure,
		  getSecure,
		  setPersistent,
		  getPersistent,
		  remove,
		  removeSecure,
		  clearTier,
		  getStats,
		  cleanup,
		  exportAll,
		} = storageService;]]></file>
	<file path='services/stories/mediaService.ts'><![CDATA[
		import * as FileSystem from 'expo-file-system';
		import { manipulateAsync, SaveFormat } from 'expo-image-manipulator';
		import { StoryMedia, MediaType } from '../../types/stories';
		
		export class MediaService {
		  private static storageDirectory = FileSystem.documentDirectory + 'stories/media/';
		
		  static async initializeStorage(): Promise<void> {
		    try {
		      const dirInfo = await FileSystem.getInfoAsync(this.storageDirectory);
		      if (!dirInfo.exists) {
		        await FileSystem.makeDirectoryAsync(this.storageDirectory, { intermediates: true });
		      }
		    } catch (error) {
		      console.error('Failed to initialize media storage:', error);
		      throw new Error('Failed to initialize media storage');
		    }
		  }
		
		  static async compressImage(uri: string, quality: number = 0.8): Promise<string> {
		    try {
		      const compressed = await manipulateAsync(
		        uri,
		        [{ resize: { width: 1080 } }], // Resize to max width of 1080px
		        {
		          compress: quality,
		          format: SaveFormat.JPEG,
		        }
		      );
		      return compressed.uri;
		    } catch (error) {
		      console.error('Failed to compress image:', error);
		      return uri; // Return original URI if compression fails
		    }
		  }
		
		  static async saveMediaToStorage(
		    media: StoryMedia,
		    storyId: string
		  ): Promise<{ localUri: string; size: number }> {
		    await this.initializeStorage();
		
		    try {
		      const filename = `${storyId}_${media.id}.${this.getFileExtension(media.mimeType)}`;
		      const localUri = this.storageDirectory + filename;
		
		      // Compress image if needed
		      let sourceUri = media.uri;
		      if (media.type === 'photo' && !media.compressed) {
		        sourceUri = await this.compressImage(media.uri, 0.8);
		      }
		
		      // Copy file to local storage
		      await FileSystem.copyAsync({
		        from: sourceUri,
		        to: localUri,
		      });
		
		      // Get file size
		      const fileInfo = await FileSystem.getInfoAsync(localUri);
		      const size = fileInfo.exists ? fileInfo.size || 0 : 0;
		
		      return { localUri, size };
		    } catch (error) {
		      console.error('Failed to save media to storage:', error);
		      throw new Error('Failed to save media file');
		    }
		  }
		
		  static async deleteMediaFromStorage(localUri: string): Promise<void> {
		    try {
		      const fileInfo = await FileSystem.getInfoAsync(localUri);
		      if (fileInfo.exists) {
		        await FileSystem.deleteAsync(localUri);
		      }
		    } catch (error) {
		      console.error('Failed to delete media file:', error);
		    }
		  }
		
		  static async generateThumbnail(videoUri: string): Promise<string | undefined> {
		    try {
		      // Note: This would require expo-av VideoThumbnails or similar
		      // For now, return undefined as thumbnail generation is not implemented
		      // In a real implementation, you would use expo-video-thumbnails
		      return undefined;
		    } catch (error) {
		      console.error('Failed to generate video thumbnail:', error);
		      return undefined;
		    }
		  }
		
		  static getFileExtension(mimeType: string): string {
		    const extensions: { [key: string]: string } = {
		      'image/jpeg': 'jpg',
		      'image/png': 'png',
		      'image/gif': 'gif',
		      'image/webp': 'webp',
		      'video/mp4': 'mp4',
		      'video/mov': 'mov',
		      'video/quicktime': 'mov',
		      'audio/mp3': 'mp3',
		      'audio/m4a': 'm4a',
		      'audio/wav': 'wav',
		      'audio/aac': 'aac',
		    };
		    return extensions[mimeType] || 'bin';
		  }
		
		  static formatFileSize(bytes: number): string {
		    if (bytes === 0) return '0 Bytes';
		    
		    const k = 1024;
		    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
		    const i = Math.floor(Math.log(bytes) / Math.log(k));
		    
		    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
		  }
		
		  static async getStorageStats(): Promise<{
		    totalFiles: number;
		    totalSize: number;
		    formattedSize: string;
		  }> {
		    try {
		      await this.initializeStorage();
		      const files = await FileSystem.readDirectoryAsync(this.storageDirectory);
		      
		      let totalSize = 0;
		      for (const file of files) {
		        const filePath = this.storageDirectory + file;
		        const fileInfo = await FileSystem.getInfoAsync(filePath);
		        if (fileInfo.exists && fileInfo.size) {
		          totalSize += fileInfo.size;
		        }
		      }
		
		      return {
		        totalFiles: files.length,
		        totalSize,
		        formattedSize: this.formatFileSize(totalSize),
		      };
		    } catch (error) {
		      console.error('Failed to get storage stats:', error);
		      return {
		        totalFiles: 0,
		        totalSize: 0,
		        formattedSize: '0 Bytes',
		      };
		    }
		  }
		
		  static async cleanupOrphanedFiles(activeMediaIds: string[]): Promise<void> {
		    try {
		      await this.initializeStorage();
		      const files = await FileSystem.readDirectoryAsync(this.storageDirectory);
		      
		      for (const file of files) {
		        const filePath = this.storageDirectory + file;
		        
		        // Extract media ID from filename (format: storyId_mediaId.ext)
		        const parts = file.split('_');
		        if (parts.length >= 2) {
		          const mediaIdWithExt = parts[1];
		          const mediaId = mediaIdWithExt.split('.')[0];
		          
		          if (!activeMediaIds.includes(mediaId)) {
		            await FileSystem.deleteAsync(filePath);
		            console.log(`Cleaned up orphaned file: ${file}`);
		          }
		        }
		      }
		    } catch (error) {
		      console.error('Failed to cleanup orphaned files:', error);
		    }
		  }
		
		  static async exportMedia(media: StoryMedia[], storyTitle: string): Promise<string[]> {
		    try {
		      const exportedFiles: string[] = [];
		      const exportDirectory = FileSystem.documentDirectory + 'exports/';
		      
		      // Create export directory
		      const dirInfo = await FileSystem.getInfoAsync(exportDirectory);
		      if (!dirInfo.exists) {
		        await FileSystem.makeDirectoryAsync(exportDirectory, { intermediates: true });
		      }
		
		      for (const mediaItem of media) {
		        const extension = this.getFileExtension(mediaItem.mimeType);
		        const exportFilename = `${storyTitle}_${mediaItem.id}.${extension}`;
		        const exportPath = exportDirectory + exportFilename;
		
		        await FileSystem.copyAsync({
		          from: mediaItem.uri,
		          to: exportPath,
		        });
		
		        exportedFiles.push(exportPath);
		      }
		
		      return exportedFiles;
		    } catch (error) {
		      console.error('Failed to export media:', error);
		      throw new Error('Failed to export media files');
		    }
		  }
		
		  static validateMediaFile(uri: string, type: MediaType, maxSizeInMB: number = 50): boolean {
		    // Basic validation - in a real implementation, you would check file size and format
		    if (!uri) return false;
		    
		    // Check URI format
		    if (!uri.startsWith('file://') && !uri.startsWith('content://')) {
		      return false;
		    }
		
		    return true;
		  }
		
		  static getMediaTypeFromMimeType(mimeType: string): MediaType {
		    if (mimeType.startsWith('image/')) return 'photo';
		    if (mimeType.startsWith('video/')) return 'video';
		    if (mimeType.startsWith('audio/')) return 'audio';
		    return 'photo'; // Default fallback
		  }
		
		  static async getMediaDuration(uri: string, type: MediaType): Promise<number | undefined> {
		    // Note: This would require expo-av or similar for actual implementation
		    // For now, return undefined as duration detection is not implemented
		    if (type === 'video' || type === 'audio') {
		      // In a real implementation, you would use expo-av to get media duration
		      return undefined;
		    }
		    return undefined;
		  }
		}]]></file>
	<file path='services/stories/migrationService.ts'><![CDATA[
		import { useTwinStore } from '../../state/twinStore';
		import { useStoryStore } from '../../state/stores/stories/storyStore';
		import { Story as LegacyStory } from '../../state/twinStore';
		import { Story, StoryCategory, StoryMilestone } from '../../types/stories';
		import { StoryService } from './storyService';
		
		export class MigrationService {
		  static async migrateLegacyStories(): Promise<{
		    migrated: number;
		    errors: string[];
		  }> {
		    const errors: string[] = [];
		    let migrated = 0;
		
		    try {
		      // Get legacy stories from twinStore
		      const { stories: legacyStories } = useTwinStore.getState();
		      const { addStory } = useStoryStore.getState();
		
		      if (!legacyStories || legacyStories.length === 0) {
		        return { migrated: 0, errors: [] };
		      }
		
		      for (const legacyStory of legacyStories) {
		        try {
		          const migratedStory = this.convertLegacyStory(legacyStory);
		          addStory(migratedStory);
		          migrated++;
		        } catch (error) {
		          errors.push(`Failed to migrate story "${legacyStory.title}": ${error}`);
		        }
		      }
		
		      // Clear legacy stories after successful migration
		      if (migrated > 0) {
		        // Note: This would clear the legacy stories from twinStore
		        // You might want to keep them for backup purposes
		        console.log(`Successfully migrated ${migrated} stories`);
		      }
		
		      return { migrated, errors };
		    } catch (error) {
		      errors.push(`Migration failed: ${error}`);
		      return { migrated, errors };
		    }
		  }
		
		  private static convertLegacyStory(legacyStory: LegacyStory): Omit<Story, 'id' | 'timestamp' | 'lastModified' | 'collaborations' | 'comments' | 'likes' | 'favorites' | 'views'> {
		    // Convert legacy story to new story format
		    const category: StoryCategory = this.inferCategory(legacyStory.title, legacyStory.content);
		    
		    // Create milestone data if the legacy story was marked as a milestone
		    let milestone: StoryMilestone | undefined;
		    if (legacyStory.milestone) {
		      milestone = {
		        type: 'custom',
		        date: legacyStory.timestamp,
		        significance: `Milestone from ${new Date(legacyStory.timestamp).toLocaleDateString()}`,
		      };
		    }
		
		    // Convert legacy photos to new media format
		    const media = (legacyStory.photos || []).map((photoUri, index) => ({
		      id: `legacy_${legacyStory.id}_photo_${index}`,
		      type: 'photo' as const,
		      uri: photoUri,
		      mimeType: 'image/jpeg',
		      size: 0, // Size unknown for legacy photos
		      compressed: false,
		    }));
		
		    // Extract tags from content (simple implementation)
		    const tags = this.extractTagsFromContent(legacyStory.content);
		
		    return {
		      title: legacyStory.title,
		      content: legacyStory.content,
		      category,
		      tags,
		      media,
		      milestone,
		      authorId: 'legacy_user', // This should be replaced with actual user ID
		      isShared: legacyStory.isShared || false,
		      isPrivate: false,
		      sharedWith: legacyStory.isShared ? ['twin'] : [],
		      sharePermissions: 'view',
		    };
		  }
		
		  private static inferCategory(title: string, content: string): StoryCategory {
		    const text = (title + ' ' + content).toLowerCase();
		    
		    // Simple keyword-based category inference
		    if (text.includes('birthday') || text.includes('birth') || text.includes('born')) {
		      return 'milestones';
		    }
		    if (text.includes('childhood') || text.includes('young') || text.includes('kid')) {
		      return 'childhood';
		    }
		    if (text.includes('travel') || text.includes('adventure') || text.includes('trip')) {
		      return 'adventures';
		    }
		    if (text.includes('sync') || text.includes('telepathy') || text.includes('intuition') || text.includes('connection')) {
		      return 'synchronicity';
		    }
		    if (text.includes('achievement') || text.includes('accomplish') || text.includes('success') || text.includes('award')) {
		      return 'achievements';
		    }
		    
		    // Default to memories
		    return 'memories';
		  }
		
		  private static extractTagsFromContent(content: string): string[] {
		    const tags: string[] = [];
		    
		    // Simple keyword extraction for common twin-related terms
		    const keywords = [
		      'twin', 'twins', 'sister', 'brother', 'family', 'childhood', 'memory', 'memories',
		      'birthday', 'celebration', 'milestone', 'achievement', 'adventure', 'travel',
		      'school', 'friends', 'connection', 'bond', 'sync', 'telepathy', 'intuition'
		    ];
		
		    const textLower = content.toLowerCase();
		    keywords.forEach(keyword => {
		      if (textLower.includes(keyword) && !tags.includes(keyword)) {
		        tags.push(keyword);
		      }
		    });
		
		    // Limit to 5 tags
		    return tags.slice(0, 5);
		  }
		
		  static async checkMigrationNeeded(): Promise<boolean> {
		    try {
		      const { stories: legacyStories } = useTwinStore.getState();
		      const { stories: newStories } = useStoryStore.getState();
		      
		      // If we have legacy stories but no new stories, migration is needed
		      return (legacyStories?.length || 0) > 0 && newStories.length === 0;
		    } catch (error) {
		      console.error('Failed to check migration status:', error);
		      return false;
		    }
		  }
		
		  static async createMigrationBackup(): Promise<string | null> {
		    try {
		      const { stories: legacyStories } = useTwinStore.getState();
		      
		      if (!legacyStories || legacyStories.length === 0) {
		        return null;
		      }
		
		      const backup = {
		        version: 'legacy',
		        timestamp: new Date().toISOString(),
		        legacyStories,
		      };
		
		      const backupJson = JSON.stringify(backup, null, 2);
		      const backupPath = `${FileSystem.documentDirectory}legacy_stories_backup_${Date.now()}.json`;
		      
		      await FileSystem.writeAsStringAsync(backupPath, backupJson);
		      return backupPath;
		    } catch (error) {
		      console.error('Failed to create migration backup:', error);
		      return null;
		    }
		  }
		
		  static getMigrationSummary(legacyStories: LegacyStory[]): {
		    totalStories: number;
		    withPhotos: number;
		    milestones: number;
		    sharedStories: number;
		    estimatedCategories: { [key in StoryCategory]: number };
		  } {
		    let withPhotos = 0;
		    let milestones = 0;
		    let sharedStories = 0;
		    const estimatedCategories: { [key in StoryCategory]: number } = {
		      childhood: 0,
		      milestones: 0,
		      adventures: 0,
		      synchronicity: 0,
		      achievements: 0,
		      memories: 0,
		      other: 0,
		    };
		
		    legacyStories.forEach(story => {
		      if (story.photos && story.photos.length > 0) withPhotos++;
		      if (story.milestone) milestones++;
		      if (story.isShared) sharedStories++;
		      
		      const category = this.inferCategory(story.title, story.content);
		      estimatedCategories[category]++;
		    });
		
		    return {
		      totalStories: legacyStories.length,
		      withPhotos,
		      milestones,
		      sharedStories,
		      estimatedCategories,
		    };
		  }
		}
		
		// Import FileSystem for backup functionality
		import * as FileSystem from 'expo-file-system';]]></file>
	<file path='services/stories/storyService.ts'><![CDATA[
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import { Story, StoryDraft, StoryFilter, StoryStats } from '../../types/stories';
		import { MediaService } from './mediaService';
		
		const STORIES_STORAGE_KEY = 'twin_stories';
		const DRAFTS_STORAGE_KEY = 'twin_story_drafts';
		
		export class StoryService {
		  static async saveStories(stories: Story[]): Promise<void> {
		    try {
		      await AsyncStorage.setItem(STORIES_STORAGE_KEY, JSON.stringify(stories));
		    } catch (error) {
		      console.error('Failed to save stories:', error);
		      throw new Error('Failed to save stories to storage');
		    }
		  }
		
		  static async loadStories(): Promise<Story[]> {
		    try {
		      const storiesJson = await AsyncStorage.getItem(STORIES_STORAGE_KEY);
		      if (storiesJson) {
		        return JSON.parse(storiesJson);
		      }
		      return [];
		    } catch (error) {
		      console.error('Failed to load stories:', error);
		      return [];
		    }
		  }
		
		  static async saveDrafts(drafts: StoryDraft[]): Promise<void> {
		    try {
		      await AsyncStorage.setItem(DRAFTS_STORAGE_KEY, JSON.stringify(drafts));
		    } catch (error) {
		      console.error('Failed to save drafts:', error);
		      throw new Error('Failed to save drafts to storage');
		    }
		  }
		
		  static async loadDrafts(): Promise<StoryDraft[]> {
		    try {
		      const draftsJson = await AsyncStorage.getItem(DRAFTS_STORAGE_KEY);
		      if (draftsJson) {
		        return JSON.parse(draftsJson);
		      }
		      return [];
		    } catch (error) {
		      console.error('Failed to load drafts:', error);
		      return [];
		    }
		  }
		
		  static async exportStoryData(story: Story): Promise<{ 
		    story: Omit<Story, 'media'>;
		    mediaFiles: string[];
		  }> {
		    try {
		      // Export media files
		      const mediaFiles = await MediaService.exportMedia(story.media, story.title);
		      
		      // Create story data without media URIs (since they're exported separately)
		      const { media, ...storyWithoutMedia } = story;
		      
		      return {
		        story: storyWithoutMedia,
		        mediaFiles,
		      };
		    } catch (error) {
		      console.error('Failed to export story:', error);
		      throw new Error('Failed to export story data');
		    }
		  }
		
		  static async generateStoryBackup(): Promise<string> {
		    try {
		      const stories = await this.loadStories();
		      const drafts = await this.loadDrafts();
		      
		      const backup = {
		        version: '1.0',
		        timestamp: new Date().toISOString(),
		        stories,
		        drafts,
		      };
		
		      const backupJson = JSON.stringify(backup, null, 2);
		      const backupPath = `${FileSystem.documentDirectory}twin_stories_backup_${Date.now()}.json`;
		      
		      await FileSystem.writeAsStringAsync(backupPath, backupJson);
		      return backupPath;
		    } catch (error) {
		      console.error('Failed to generate backup:', error);
		      throw new Error('Failed to generate story backup');
		    }
		  }
		
		  static async restoreFromBackup(backupPath: string): Promise<{
		    storiesRestored: number;
		    draftsRestored: number;
		  }> {
		    try {
		      const backupData = await FileSystem.readAsStringAsync(backupPath);
		      const backup = JSON.parse(backupData);
		      
		      if (backup.version !== '1.0') {
		        throw new Error('Unsupported backup version');
		      }
		
		      const stories: Story[] = backup.stories || [];
		      const drafts: StoryDraft[] = backup.drafts || [];
		
		      await this.saveStories(stories);
		      await this.saveDrafts(drafts);
		
		      return {
		        storiesRestored: stories.length,
		        draftsRestored: drafts.length,
		      };
		    } catch (error) {
		      console.error('Failed to restore backup:', error);
		      throw new Error('Failed to restore from backup');
		    }
		  }
		
		  static generateStoryId(): string {
		    return Date.now().toString() + Math.random().toString(36).substr(2, 9);
		  }
		
		  static validateStory(story: Partial<Story>): string[] {
		    const errors: string[] = [];
		
		    if (!story.title?.trim()) {
		      errors.push('Story title is required');
		    }
		
		    if (!story.content?.trim()) {
		      errors.push('Story content is required');
		    }
		
		    if (story.title && story.title.length > 200) {
		      errors.push('Story title must be less than 200 characters');
		    }
		
		    if (story.content && story.content.length > 10000) {
		      errors.push('Story content must be less than 10,000 characters');
		    }
		
		    if (story.tags && story.tags.length > 20) {
		      errors.push('Maximum 20 tags allowed');
		    }
		
		    if (story.media && story.media.length > 20) {
		      errors.push('Maximum 20 media files allowed');
		    }
		
		    return errors;
		  }
		
		  static async searchStories(
		    stories: Story[],
		    query: string,
		    filters?: StoryFilter
		  ): Promise<Story[]> {
		    let results = [...stories];
		
		    // Text search
		    if (query.trim()) {
		      const searchTerms = query.toLowerCase().split(' ').filter(term => term.length > 0);
		      results = results.filter(story => {
		        const searchableText = [
		          story.title,
		          story.content,
		          ...story.tags,
		          story.milestone?.significance || '',
		          story.location?.address || '',
		          story.location?.placeName || '',
		        ].join(' ').toLowerCase();
		
		        return searchTerms.every(term => searchableText.includes(term));
		      });
		    }
		
		    // Apply filters
		    if (filters) {
		      if (filters.categories?.length) {
		        results = results.filter(story => filters.categories!.includes(story.category));
		      }
		
		      if (filters.tags?.length) {
		        results = results.filter(story =>
		          story.tags.some(tag => filters.tags!.includes(tag))
		        );
		      }
		
		      if (filters.dateRange) {
		        const start = new Date(filters.dateRange.start);
		        const end = new Date(filters.dateRange.end);
		        results = results.filter(story => {
		          const storyDate = new Date(story.timestamp);
		          return storyDate >= start && storyDate <= end;
		        });
		      }
		
		      if (filters.milestoneOnly) {
		        results = results.filter(story => !!story.milestone);
		      }
		
		      if (filters.sharedOnly) {
		        results = results.filter(story => story.isShared);
		      }
		
		      if (filters.authorId) {
		        results = results.filter(story => story.authorId === filters.authorId);
		      }
		
		      if (filters.hasMedia) {
		        results = results.filter(story => story.media.length > 0);
		      }
		    }
		
		    return results;
		  }
		
		  static calculateStoryStats(stories: Story[]): StoryStats {
		    const now = new Date();
		    const thisMonth = new Date(now.getFullYear(), now.getMonth(), 1);
		
		    return {
		      totalStories: stories.length,
		      storiesThisMonth: stories.filter(s => new Date(s.timestamp) >= thisMonth).length,
		      categoryCounts: stories.reduce((counts, story) => {
		        counts[story.category] = (counts[story.category] || 0) + 1;
		        return counts;
		      }, {} as any),
		      totalMedia: stories.reduce((sum, story) => sum + story.media.length, 0),
		      totalViews: stories.reduce((sum, story) => sum + story.views.length, 0),
		      totalLikes: stories.reduce((sum, story) => sum + story.likes.length, 0),
		      collaborationCount: stories.reduce((sum, story) => sum + story.collaborations.length, 0),
		      milestoneCount: stories.filter(s => !!s.milestone).length,
		    };
		  }
		
		  static sortStories(stories: Story[], sortBy: 'newest' | 'oldest' | 'popular' | 'title'): Story[] {
		    const sorted = [...stories];
		    
		    switch (sortBy) {
		      case 'newest':
		        return sorted.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
		      
		      case 'oldest':
		        return sorted.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
		      
		      case 'popular':
		        return sorted.sort((a, b) => {
		          const aPopularity = a.likes.length + a.views.length + a.comments.length;
		          const bPopularity = b.likes.length + b.views.length + b.comments.length;
		          return bPopularity - aPopularity;
		        });
		      
		      case 'title':
		        return sorted.sort((a, b) => a.title.localeCompare(b.title));
		      
		      default:
		        return sorted;
		    }
		  }
		
		  static async cleanupExpiredDrafts(maxAge: number = 30 * 24 * 60 * 60 * 1000): Promise<number> {
		    try {
		      const drafts = await this.loadDrafts();
		      const now = Date.now();
		      
		      const validDrafts = drafts.filter(draft => {
		        const draftAge = now - new Date(draft.lastSaved).getTime();
		        return draftAge < maxAge;
		      });
		
		      if (validDrafts.length !== drafts.length) {
		        await this.saveDrafts(validDrafts);
		        return drafts.length - validDrafts.length;
		      }
		
		      return 0;
		    } catch (error) {
		      console.error('Failed to cleanup expired drafts:', error);
		      return 0;
		    }
		  }
		}
		
		// Import FileSystem for backup functionality
		import * as FileSystem from 'expo-file-system';]]></file>
	<file path='services/subscriptionService.ts'><![CDATA[
		import { Platform } from "react-native";
		import { SubscriptionProduct, PurchaseResult, RestorePurchasesResult, SUBSCRIPTION_PRODUCTS } from "../types/premium/subscription";
		
		/**
		 * Subscription Service
		 * 
		 * This service provides an abstraction layer for subscription management.
		 * Currently implements mock functionality for development.
		 * Production implementation should use RevenueCat SDK.
		 */
		
		class SubscriptionService {
		  private isInitialized: boolean = false;
		  private mockProducts: SubscriptionProduct[] = SUBSCRIPTION_PRODUCTS;
		
		  /**
		   * Initialize the subscription service
		   */
		  async initialize(): Promise<boolean> {
		    try {
		      console.log("Initializing subscription service...");
		      
		      // In production, initialize RevenueCat here:
		      // await Purchases.setup("your_api_key", appUserId);
		      // await Purchases.setDebugLogsEnabled(true);
		      
		      this.isInitialized = true;
		      return true;
		    } catch (error) {
		      console.error("Failed to initialize subscription service:", error);
		      return false;
		    }
		  }
		
		  /**
		   * Get available products
		   */
		  async getProducts(): Promise<SubscriptionProduct[]> {
		    if (!this.isInitialized) {
		      await this.initialize();
		    }
		
		    try {
		      // In production, fetch from RevenueCat:
		      // const offerings = await Purchases.getOfferings();
		      // return this.parseRevenueCatProducts(offerings);
		      
		      // Mock implementation
		      return this.mockProducts;
		    } catch (error) {
		      console.error("Failed to get products:", error);
		      return [];
		    }
		  }
		
		  /**
		   * Purchase a product
		   */
		  async purchaseProduct(productId: string): Promise<PurchaseResult> {
		    if (!this.isInitialized) {
		      await this.initialize();
		    }
		
		    try {
		      console.log(`Attempting to purchase: ${productId}`);
		      
		      // In production, use RevenueCat:
		      // const result = await Purchases.purchasePackage(package);
		      // return this.parseRevenueCatPurchase(result);
		      
		      // Mock implementation
		      await new Promise(resolve => setTimeout(resolve, 2000));
		      
		      const product = this.mockProducts.find(p => p.id === productId);
		      if (!product) {
		        return { success: false, error: "Product not found" };
		      }
		
		      return {
		        success: true,
		        productId,
		        transactionId: `mock_txn_${Date.now()}`
		      };
		    } catch (error: any) {
		      console.error("Purchase failed:", error);
		      
		      if (error.code === "1" || error.message?.includes("cancelled")) {
		        return { success: false, userCancelled: true };
		      }
		      
		      return {
		        success: false,
		        error: error.message || "Purchase failed"
		      };
		    }
		  }
		
		  /**
		   * Restore purchases
		   */
		  async restorePurchases(): Promise<RestorePurchasesResult> {
		    if (!this.isInitialized) {
		      await this.initialize();
		    }
		
		    try {
		      console.log("Restoring purchases...");
		      
		      // In production, use RevenueCat:
		      // const result = await Purchases.restorePurchases();
		      // return this.parseRevenueCatRestore(result);
		      
		      // Mock implementation
		      await new Promise(resolve => setTimeout(resolve, 1500));
		      
		      const hasValidPurchase = Math.random() > 0.3; // 70% chance of finding purchase
		      
		      return {
		        success: true,
		        restoredPurchases: hasValidPurchase ? 1 : 0
		      };
		    } catch (error: any) {
		      console.error("Restore failed:", error);
		      return {
		        success: false,
		        restoredPurchases: 0,
		        error: error.message || "Restore failed"
		      };
		    }
		  }
		
		  /**
		   * Get current subscription status
		   */
		  async getCurrentSubscription(): Promise<any> {
		    if (!this.isInitialized) {
		      await this.initialize();
		    }
		
		    try {
		      // In production, use RevenueCat:
		      // const customerInfo = await Purchases.getCustomerInfo();
		      // return this.parseRevenueCatCustomerInfo(customerInfo);
		      
		      // Mock implementation
		      return null; // No active subscription
		    } catch (error) {
		      console.error("Failed to get current subscription:", error);
		      return null;
		    }
		  }
		
		  /**
		   * Check if user has active subscription
		   */
		  async hasActiveSubscription(): Promise<boolean> {
		    const subscription = await this.getCurrentSubscription();
		    return subscription?.isActive || false;
		  }
		
		  /**
		   * Get subscription expiry date
		   */
		  async getExpiryDate(): Promise<string | null> {
		    const subscription = await this.getCurrentSubscription();
		    return subscription?.expiryDate || null;
		  }
		
		  // Private helper methods for RevenueCat integration
		  private parseRevenueCatProducts(offerings: any): SubscriptionProduct[] {
		    // TODO: Implement RevenueCat offerings parsing
		    return [];
		  }
		
		  private parseRevenueCatPurchase(result: any): PurchaseResult {
		    // TODO: Implement RevenueCat purchase result parsing
		    return { success: false };
		  }
		
		  private parseRevenueCatRestore(result: any): RestorePurchasesResult {
		    // TODO: Implement RevenueCat restore result parsing
		    return { success: false, restoredPurchases: 0 };
		  }
		
		  private parseRevenueCatCustomerInfo(customerInfo: any): any {
		    // TODO: Implement RevenueCat customer info parsing
		    return null;
		  }
		}
		
		export const subscriptionService = new SubscriptionService();]]></file>
	<file path='services/syncService.ts'><![CDATA[
		/**
		 * Sync Service - Cloud synchronization for twin pair data merging
		 * Handles secure twin data sharing and privacy-preserving analytics
		 */
		
		import NetInfo from '@react-native-community/netinfo';
		import {
		  AssessmentResults,
		  TwinPairData,
		  PairAnalytics,
		  PrivacyConsent,
		  SyncStatus,
		} from '../types/assessment/types';
		import { EncryptionService } from './encryptionService';
		import { storageService } from './storageService';
		
		export interface CloudProvider {
		  name: string;
		  apiUrl: string;
		  authenticate: () => Promise<string>;
		  uploadData: (data: any, metadata: any) => Promise<string>;
		  downloadData: (id: string) => Promise<any>;
		  deleteData: (id: string) => Promise<void>;
		  findPairs: (criteria: any) => Promise<any[]>;
		}
		
		export interface SyncOptions {
		  forceSync?: boolean;
		  cloudProvider?: string;
		  encryptCloud?: boolean;
		  includeAnalytics?: boolean;
		  maxRetries?: number;
		}
		
		export interface PairMatchingCriteria {
		  shareCode?: string;
		  email?: string;
		  phone?: string;
		  twinType?: string;
		  birthDate?: string;
		  similarityThreshold?: number;
		}
		
		class SyncServiceClass {
		  private providers: Map<string, CloudProvider> = new Map();
		  private syncQueue: Array<{ type: string; data: any; options: SyncOptions }> = [];
		  private syncing = false;
		  private retryDelays = [1000, 2000, 5000, 10000, 30000]; // Exponential backoff
		
		  constructor() {
		    this.initializeProviders();
		    this.startSyncWorker();
		  }
		
		  /**
		   * Register cloud provider
		   */
		  registerProvider(name: string, provider: CloudProvider): void {
		    this.providers.set(name, provider);
		  }
		
		  /**
		   * Sync assessment results to cloud for pair matching
		   */
		  async syncAssessmentResults(
		    results: AssessmentResults,
		    options: SyncOptions = {}
		  ): Promise<void> {
		    // Check privacy consent
		    if (!results.privacyConsent.twinDataMerging) {
		      console.log('Skipping sync - no consent for twin data merging');
		      return;
		    }
		
		    // Check network connectivity
		    const netState = await NetInfo.fetch();
		    if (!netState.isConnected) {
		      console.log('No network connection - queuing for later sync');
		      this.queueSync('assessment_results', results, options);
		      return;
		    }
		
		    try {
		      await this.performSync('assessment_results', results, options);
		      
		      // Mark as synced
		      results.synced = true;
		      await storageService.setSecure(`results_${results.id}`, results);
		      
		    } catch (error) {
		      console.error('Failed to sync assessment results:', error);
		      this.queueSync('assessment_results', results, options);
		      throw error;
		    }
		  }
		
		  /**
		   * Find and create twin pairs based on matching criteria
		   */
		  async findTwinPairs(
		    criteria: PairMatchingCriteria,
		    providerName = 'supabase'
		  ): Promise<TwinPairData[]> {
		    const provider = this.providers.get(providerName);
		    if (!provider) throw new Error(`Provider ${providerName} not found`);
		
		    try {
		      const authToken = await provider.authenticate();
		      const matches = await provider.findPairs(criteria);
		      
		      return matches.map(match => this.createTwinPair(match));
		    } catch (error) {
		      console.error('Failed to find twin pairs:', error);
		      throw error;
		    }
		  }
		
		  /**
		   * Merge twin pair data and generate analytics
		   */
		  async mergePairData(
		    pairId: string,
		    twin1Results: AssessmentResults,
		    twin2Results: AssessmentResults
		  ): Promise<PairAnalytics> {
		    // Verify both twins consented to data merging
		    if (!twin1Results.privacyConsent.twinDataMerging || 
		        !twin2Results.privacyConsent.twinDataMerging) {
		      throw new Error('Both twins must consent to data merging');
		    }
		
		    // Generate privacy-preserving analytics
		    const analytics = await this.calculatePairAnalytics(twin1Results, twin2Results);
		    
		    // Store analytics securely
		    await storageService.setSecure(`pair_analytics_${pairId}`, analytics);
		    
		    return analytics;
		  }
		
		  /**
		   * Get sync status for assessment data
		   */
		  async getSyncStatus(): Promise<SyncStatus> {
		    const pendingItems = this.syncQueue.length;
		    const lastSyncAttempt = await storageService.get('last_sync_attempt');
		    const lastSuccessfulSync = await storageService.get('last_successful_sync');
		    const syncErrors = await storageService.get('sync_errors') || [];
		    
		    return {
		      lastSyncAttempt,
		      lastSuccessfulSync,
		      pendingChanges: pendingItems,
		      syncErrors: syncErrors.slice(-5), // Keep last 5 errors
		      needsResolution: syncErrors.length > 0 || pendingItems > 10,
		    };
		  }
		
		  /**
		   * Force sync all pending data
		   */
		  async forceSyncAll(options: SyncOptions = {}): Promise<void> {
		    const netState = await NetInfo.fetch();
		    if (!netState.isConnected) {
		      throw new Error('No network connection available');
		    }
		
		    this.syncing = true;
		    const errors: Error[] = [];
		    
		    try {
		      // Process sync queue
		      while (this.syncQueue.length > 0) {
		        const item = this.syncQueue.shift()!;
		        try {
		          await this.performSync(item.type, item.data, { ...item.options, ...options });
		        } catch (error) {
		          errors.push(error as Error);
		          console.error(`Failed to sync ${item.type}:`, error);
		        }
		      }
		      
		      // Sync pending results from storage
		      const results = await storageService.getSecure('assessment_results') || {};
		      for (const [resultId, result] of Object.entries(results)) {
		        if (!(result as AssessmentResults).synced) {
		          try {
		            await this.syncAssessmentResults(result as AssessmentResults, options);
		          } catch (error) {
		            errors.push(error as Error);
		          }
		        }
		      }
		      
		      await storageService.set('last_successful_sync', new Date().toISOString());
		      
		    } finally {
		      this.syncing = false;
		      
		      if (errors.length > 0) {
		        await storageService.set('sync_errors', errors.map(e => e.message));
		        throw new Error(`Sync completed with ${errors.length} errors`);
		      }
		    }
		  }
		
		  /**
		   * Delete cloud data for privacy compliance
		   */
		  async deleteCloudData(userId: string, providerName = 'supabase'): Promise<void> {
		    const provider = this.providers.get(providerName);
		    if (!provider) throw new Error(`Provider ${providerName} not found`);
		
		    try {
		      const authToken = await provider.authenticate();
		      await provider.deleteData(userId);
		    } catch (error) {
		      console.error('Failed to delete cloud data:', error);
		      throw error;
		    }
		  }
		
		  /**
		   * Export anonymized data for research
		   */
		  async exportAnonymizedData(
		    assessmentResults: AssessmentResults[],
		    includeAnalytics = false
		  ): Promise<any> {
		    const anonymizedData = assessmentResults
		      .filter(result => result.privacyConsent.anonymizedSharing)
		      .map(result => this.anonymizeResults(result));
		    
		    const exportPackage = {
		      data: anonymizedData,
		      metadata: {
		        exportedAt: new Date().toISOString(),
		        totalRecords: anonymizedData.length,
		        privacyLevel: 'anonymized',
		        includesAnalytics: includeAnalytics,
		      },
		    };
		    
		    if (includeAnalytics) {
		      // Add anonymized pair analytics if available
		      const pairAnalytics = await this.getAnonymizedPairAnalytics();
		      exportPackage['pairAnalytics'] = pairAnalytics;
		    }
		    
		    return exportPackage;
		  }
		
		  // Private methods
		  private initializeProviders(): void {
		    // Supabase provider
		    this.registerProvider('supabase', {
		      name: 'Supabase',
		      apiUrl: process.env.EXPO_PUBLIC_SUPABASE_URL || '',
		      authenticate: async () => {
		        // Implement Supabase authentication
		        return 'supabase_auth_token';
		      },
		      uploadData: async (data, metadata) => {
		        // Implement Supabase data upload
		        console.log('Uploading to Supabase:', metadata);
		        return 'upload_id';
		      },
		      downloadData: async (id) => {
		        // Implement Supabase data download
		        console.log('Downloading from Supabase:', id);
		        return {};
		      },
		      deleteData: async (id) => {
		        // Implement Supabase data deletion
		        console.log('Deleting from Supabase:', id);
		      },
		      findPairs: async (criteria) => {
		        // Implement Supabase pair matching
		        console.log('Finding pairs in Supabase:', criteria);
		        return [];
		      },
		    });
		
		    // Firebase provider
		    this.registerProvider('firebase', {
		      name: 'Firebase',
		      apiUrl: process.env.EXPO_PUBLIC_FIREBASE_URL || '',
		      authenticate: async () => {
		        // Implement Firebase authentication
		        return 'firebase_auth_token';
		      },
		      uploadData: async (data, metadata) => {
		        // Implement Firebase data upload
		        console.log('Uploading to Firebase:', metadata);
		        return 'upload_id';
		      },
		      downloadData: async (id) => {
		        // Implement Firebase data download
		        console.log('Downloading from Firebase:', id);
		        return {};
		      },
		      deleteData: async (id) => {
		        // Implement Firebase data deletion
		        console.log('Deleting from Firebase:', id);
		      },
		      findPairs: async (criteria) => {
		        // Implement Firebase pair matching
		        console.log('Finding pairs in Firebase:', criteria);
		        return [];
		      },
		    });
		  }
		
		  private queueSync(type: string, data: any, options: SyncOptions): void {
		    this.syncQueue.push({ type, data, options });
		    
		    // Limit queue size to prevent memory issues
		    if (this.syncQueue.length > 100) {
		      this.syncQueue.shift(); // Remove oldest item
		    }
		  }
		
		  private async performSync(
		    type: string,
		    data: any,
		    options: SyncOptions
		  ): Promise<void> {
		    const providerName = options.cloudProvider || 'supabase';
		    const provider = this.providers.get(providerName);
		    
		    if (!provider) throw new Error(`Provider ${providerName} not found`);
		
		    let processedData = data;
		    
		    // Apply encryption if requested
		    if (options.encryptCloud !== false) {
		      processedData = await EncryptionService.encrypt(JSON.stringify(data));
		    }
		    
		    const metadata = {
		      type,
		      timestamp: new Date().toISOString(),
		      encrypted: options.encryptCloud !== false,
		      version: '1.0',
		    };
		    
		    const maxRetries = options.maxRetries || 3;
		    let lastError: Error | null = null;
		    
		    for (let attempt = 0; attempt < maxRetries; attempt++) {
		      try {
		        const authToken = await provider.authenticate();
		        await provider.uploadData(processedData, metadata);
		        
		        await storageService.set('last_sync_attempt', new Date().toISOString());
		        return; // Success
		        
		      } catch (error) {
		        lastError = error as Error;
		        
		        if (attempt < maxRetries - 1) {
		          const delay = this.retryDelays[Math.min(attempt, this.retryDelays.length - 1)];
		          await new Promise(resolve => setTimeout(resolve, delay));
		        }
		      }
		    }
		    
		    throw lastError || new Error('Sync failed after all retries');
		  }
		
		  private createTwinPair(matchData: any): TwinPairData {
		    return {
		      pairId: matchData.id,
		      twin1Id: matchData.twin1Id,
		      twin2Id: matchData.twin2Id,
		      pairedAt: new Date().toISOString(),
		      bothConsented: true,
		      sharedAssessments: [],
		      privacyLevel: 'twin_only',
		    };
		  }
		
		  private async calculatePairAnalytics(
		    twin1Results: AssessmentResults,
		    twin2Results: AssessmentResults
		  ): Promise<PairAnalytics> {
		    const similarityScores = {};
		    const complementarityScores = {};
		    
		    // Calculate category-wise similarity
		    twin1Results.scores.forEach(score1 => {
		      const score2 = twin2Results.scores.find(s => s.category === score1.category);
		      if (score2) {
		        const similarity = 1 - Math.abs(score1.normalizedScore - score2.normalizedScore) / 100;
		        similarityScores[score1.category] = similarity;
		        complementarityScores[score1.category] = Math.abs(score1.normalizedScore - score2.normalizedScore) / 100;
		      }
		    });
		    
		    const overallCompatibility = Object.values(similarityScores as Record<string, number>)
		      .reduce((sum: number, score: number) => sum + score, 0) / Object.keys(similarityScores).length;
		    
		    return {
		      similarityScores,
		      complementarityScores,
		      overallCompatibility,
		      uniqueTraits: {
		        twin1: this.extractUniqueTraits(twin1Results.scores),
		        twin2: this.extractUniqueTraits(twin2Results.scores),
		      },
		      sharedTraits: this.extractSharedTraits(twin1Results.scores, twin2Results.scores),
		      growthOpportunities: this.identifyGrowthOpportunities(twin1Results.scores, twin2Results.scores),
		      strengthAreas: this.identifyStrengthAreas(twin1Results.scores, twin2Results.scores),
		      lastUpdated: new Date().toISOString(),
		    };
		  }
		
		  private extractUniqueTraits(scores: any[]): string[] {
		    return scores
		      .filter(score => score.normalizedScore > 80)
		      .map(score => `High ${score.category}`);
		  }
		
		  private extractSharedTraits(scores1: any[], scores2: any[]): string[] {
		    const shared = [];
		    
		    scores1.forEach(score1 => {
		      const score2 = scores2.find(s => s.category === score1.category);
		      if (score2 && Math.abs(score1.normalizedScore - score2.normalizedScore) < 20) {
		        shared.push(`Similar ${score1.category}`);
		      }
		    });
		    
		    return shared;
		  }
		
		  private identifyGrowthOpportunities(scores1: any[], scores2: any[]): string[] {
		    const opportunities = [];
		    
		    scores1.forEach(score1 => {
		      const score2 = scores2.find(s => s.category === score1.category);
		      if (score2) {
		        if (score1.normalizedScore < 40 && score2.normalizedScore > 60) {
		          opportunities.push(`Twin 1: Learn ${score1.category} from Twin 2`);
		        } else if (score2.normalizedScore < 40 && score1.normalizedScore > 60) {
		          opportunities.push(`Twin 2: Learn ${score1.category} from Twin 1`);
		        }
		      }
		    });
		    
		    return opportunities;
		  }
		
		  private identifyStrengthAreas(scores1: any[], scores2: any[]): string[] {
		    const strengths = [];
		    
		    scores1.forEach(score1 => {
		      const score2 = scores2.find(s => s.category === score1.category);
		      if (score2 && score1.normalizedScore > 70 && score2.normalizedScore > 70) {
		        strengths.push(`Mutual strength in ${score1.category}`);
		      }
		    });
		    
		    return strengths;
		  }
		
		  private anonymizeResults(results: AssessmentResults): any {
		    return {
		      id: this.generateAnonymousId(),
		      templateId: results.templateId,
		      completedAt: results.completedAt,
		      scores: results.scores.map(score => ({
		        category: score.category,
		        normalizedScore: Math.round(score.normalizedScore / 10) * 10, // Round to nearest 10
		        confidence: Math.round(score.confidence * 10) / 10,
		      })),
		      overallScore: results.overallScore ? Math.round(results.overallScore / 10) * 10 : null,
		      demographics: {
		        ageRange: this.anonymizeAge(results.userId), // Would need age data
		        region: 'anonymized',
		      },
		    };
		  }
		
		  private async getAnonymizedPairAnalytics(): Promise<any[]> {
		    // Retrieve and anonymize pair analytics
		    return [];
		  }
		
		  private generateAnonymousId(): string {
		    return 'anon_' + Math.random().toString(36).substr(2, 9);
		  }
		
		  private anonymizeAge(userId: string): string {
		    // This would use actual age data to create age ranges
		    return '25-34'; // Example
		  }
		
		  private startSyncWorker(): void {
		    // Background sync worker
		    setInterval(async () => {
		      if (!this.syncing && this.syncQueue.length > 0) {
		        const netState = await NetInfo.fetch();
		        if (netState.isConnected) {
		          try {
		            await this.forceSyncAll({ maxRetries: 1 });
		          } catch (error) {
		            console.log('Background sync failed:', error);
		          }
		        }
		      }
		    }, 30000); // Check every 30 seconds
		  }
		}
		
		// Singleton instance
		export const SyncService = new SyncServiceClass();]]></file>
	<file path='services/telemetryService.ts'><![CDATA[
		/**
		 * Privacy-First Telemetry Service for Assessment Norming
		 * Collects anonymous usage data to improve psychological assessment quality
		 */
		
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import { nanoid } from 'nanoid';
		import * as Crypto from 'expo-crypto';
		import { 
		  BaseTelemetryEvent,
		  TelemetryEventType,
		  TelemetryConfig,
		  TelemetryBatch,
		  AnonymousSession,
		  QuestionTelemetryEvent,
		  SectionTelemetryEvent,
		  AssessmentTelemetryEvent,
		  AnomalyTelemetryEvent,
		  PerformanceTelemetryEvent,
		  TelemetryPrivacyLevel,
		  AnomalyType
		} from '../types/telemetry';
		import { AssessmentCategory, LikertScale } from '../types/assessment';
		
		class TelemetryService {
		  private config: TelemetryConfig;
		  private currentSession: AnonymousSession | null = null;
		  private eventQueue: BaseTelemetryEvent[] = [];
		  private batchTimer: NodeJS.Timeout | null = null;
		  private isInitialized = false;
		
		  constructor() {
		    this.config = {
		      enabled: false,
		      privacyLevel: 'anonymous',
		      collectPerformanceMetrics: true,
		      collectAnomalyData: true,
		      collectNormingData: true,
		      batchSize: 50,
		      maxRetries: 3,
		      retentionDays: 90,
		      encryptionEnabled: true,
		      consentRequired: true,
		      anonymizationDelay: 300000, // 5 minutes
		    };
		  }
		
		  /**
		   * Initialize telemetry service with user consent
		   */
		  async initialize(userConsent: boolean = false, config?: Partial<TelemetryConfig>): Promise<void> {
		    try {
		      // Load stored config and consent
		      const storedConsent = await AsyncStorage.getItem('telemetry_consent');
		      const storedConfig = await AsyncStorage.getItem('telemetry_config');
		
		      if (storedConfig) {
		        this.config = { ...this.config, ...JSON.parse(storedConfig) };
		      }
		
		      if (config) {
		        this.config = { ...this.config, ...config };
		        await AsyncStorage.setItem('telemetry_config', JSON.stringify(this.config));
		      }
		
		      // Enable only if user has consented
		      this.config.enabled = userConsent || storedConsent === 'true';
		
		      if (this.config.enabled) {
		        await this.startSession();
		        this.scheduleBatchProcessing();
		      }
		
		      this.isInitialized = true;
		    } catch (error) {
		      console.error('Failed to initialize telemetry service:', error);
		    }
		  }
		
		  /**
		   * Update user consent for telemetry
		   */
		  async updateConsent(consent: boolean): Promise<void> {
		    try {
		      await AsyncStorage.setItem('telemetry_consent', consent.toString());
		      this.config.enabled = consent;
		
		      if (consent && !this.currentSession) {
		        await this.startSession();
		        this.scheduleBatchProcessing();
		      } else if (!consent) {
		        await this.endSession();
		        this.clearEventQueue();
		      }
		    } catch (error) {
		      console.error('Failed to update telemetry consent:', error);
		    }
		  }
		
		  /**
		   * Start a new anonymous session
		   */
		  private async startSession(): Promise<void> {
		    if (!this.config.enabled) return;
		
		    try {
		      const sessionId = await this.generateSecureId();
		      const deviceFingerprint = await this.generateDeviceFingerprint();
		
		      this.currentSession = {
		        sessionId,
		        startTime: new Date().toISOString(),
		        deviceFingerprint,
		        consentedForNorming: true,
		        consentedForResearch: true,
		        dataQualityScore: 1.0,
		        flagged: false,
		        exclusionReasons: [],
		      };
		
		      // Store session temporarily for crash recovery
		      await AsyncStorage.setItem('current_telemetry_session', JSON.stringify(this.currentSession));
		    } catch (error) {
		      console.error('Failed to start telemetry session:', error);
		    }
		  }
		
		  /**
		   * End current session
		   */
		  private async endSession(): Promise<void> {
		    if (!this.currentSession) return;
		
		    try {
		      this.currentSession.endTime = new Date().toISOString();
		      
		      // Send final session event
		      await this.trackEvent('assessment_completed', {
		        totalTimeSpent: Date.now() - new Date(this.currentSession.startTime).getTime(),
		        dataQualityScore: this.currentSession.dataQualityScore,
		      });
		
		      // Process remaining events
		      await this.processBatch(true);
		
		      // Schedule session data anonymization
		      setTimeout(async () => {
		        await AsyncStorage.removeItem('current_telemetry_session');
		      }, this.config.anonymizationDelay);
		
		      this.currentSession = null;
		    } catch (error) {
		      console.error('Failed to end telemetry session:', error);
		    }
		  }
		
		  /**
		   * Track question-level telemetry
		   */
		  async trackQuestionEvent(
		    type: 'question_viewed' | 'question_answered' | 'question_revised',
		    data: {
		      questionId: string;
		      questionCategory: AssessmentCategory;
		      questionIndex: number;
		      sectionId: string;
		      timeOnQuestion: number;
		      responseValue?: LikertScale | string | number;
		      revisionCount?: number;
		      confidenceLevel?: number;
		    }
		  ): Promise<void> {
		    if (!this.isEnabled()) return;
		
		    const event: QuestionTelemetryEvent = {
		      ...this.createBaseEvent(type),
		      questionId: data.questionId,
		      questionCategory: data.questionCategory,
		      questionIndex: data.questionIndex,
		      sectionId: data.sectionId,
		      timeOnQuestion: data.timeOnQuestion,
		      responseValue: data.responseValue && typeof data.responseValue === 'string' && data.responseValue.includes('sensitive') 
		        ? undefined 
		        : data.responseValue,
		      revisionCount: data.revisionCount || 0,
		      confidenceLevel: data.confidenceLevel,
		      responsePatternHash: data.responseValue ? 'hashed_' + (await this.hashValue(data.responseValue.toString())).substring(0, 8) : undefined,
		    };
		
		    await this.queueEvent(event);
		
		    // Check for anomalies in real-time
		    await this.checkQuestionAnomalies(event);
		  }
		
		  /**
		   * Track section completion
		   */
		  async trackSectionCompletion(data: {
		    sectionId: string;
		    sectionCategory: AssessmentCategory;
		    questionsInSection: number;
		    timeInSection: number;
		    completionRate: number;
		    averageConfidence?: number;
		    revisionsInSection: number;
		  }): Promise<void> {
		    if (!this.isEnabled()) return;
		
		    const event: SectionTelemetryEvent = {
		      ...this.createBaseEvent('section_completed'),
		      sectionId: data.sectionId,
		      sectionCategory: data.sectionCategory,
		      questionsInSection: data.questionsInSection,
		      timeInSection: data.timeInSection,
		      completionRate: data.completionRate,
		      averageConfidence: data.averageConfidence,
		      revisionsInSection: data.revisionsInSection,
		    };
		
		    await this.queueEvent(event);
		  }
		
		  /**
		   * Track assessment-level events
		   */
		  async trackAssessmentEvent(
		    type: 'assessment_started' | 'assessment_completed' | 'assessment_abandoned',
		    data: {
		      assessmentVersion: string;
		      totalQuestions: number;
		      completedQuestions: number;
		      totalTimeSpent: number;
		      totalRevisions: number;
		      abandonmentPoint?: {
		        sectionId: string;
		        questionIndex: number;
		        timeSpent: number;
		      };
		    }
		  ): Promise<void> {
		    if (!this.isEnabled()) return;
		
		    const event: AssessmentTelemetryEvent = {
		      ...this.createBaseEvent(type),
		      assessmentVersion: data.assessmentVersion,
		      totalQuestions: data.totalQuestions,
		      completedQuestions: data.completedQuestions,
		      totalTimeSpent: data.totalTimeSpent,
		      completionRate: data.completedQuestions / data.totalQuestions,
		      averageResponseTime: data.totalTimeSpent / Math.max(data.completedQuestions, 1),
		      totalRevisions: data.totalRevisions,
		      abandonmentPoint: data.abandonmentPoint,
		    };
		
		    await this.queueEvent(event);
		
		    // Check for assessment-level anomalies
		    await this.checkAssessmentAnomalies(event);
		  }
		
		  /**
		   * Track anomaly detection
		   */
		  async trackAnomaly(
		    anomalyType: AnomalyType,
		    data: {
		      severity: 'low' | 'medium' | 'high' | 'critical';
		      detectionAlgorithm: string;
		      contextData: any;
		      actionTaken: 'flagged' | 'excluded' | 'requires_review' | 'auto_corrected';
		    }
		  ): Promise<void> {
		    if (!this.isEnabled()) return;
		
		    const event: AnomalyTelemetryEvent = {
		      ...this.createBaseEvent('anomaly_detected'),
		      anomalyType,
		      severity: data.severity,
		      detectionAlgorithm: data.detectionAlgorithm,
		      contextData: data.contextData,
		      actionTaken: data.actionTaken,
		    };
		
		    await this.queueEvent(event);
		
		    // Update session quality score
		    if (this.currentSession) {
		      const severityImpact = { low: 0.05, medium: 0.1, high: 0.2, critical: 0.5 };
		      this.currentSession.dataQualityScore = Math.max(
		        0,
		        this.currentSession.dataQualityScore - severityImpact[data.severity]
		      );
		
		      if (data.severity === 'critical') {
		        this.currentSession.flagged = true;
		        this.currentSession.exclusionReasons.push(`Critical anomaly: ${anomalyType}`);
		      }
		    }
		  }
		
		  /**
		   * Track performance metrics
		   */
		  async trackPerformance(
		    metricName: string,
		    metricValue: number,
		    context: Record<string, any> = {}
		  ): Promise<void> {
		    if (!this.isEnabled() || !this.config.collectPerformanceMetrics) return;
		
		    const event: PerformanceTelemetryEvent = {
		      ...this.createBaseEvent('performance_metric'),
		      metricName,
		      metricValue,
		      context: {
		        appVersion: '1.0.0', // Should come from app config
		        ...context,
		      },
		    };
		
		    await this.queueEvent(event);
		  }
		
		  /**
		   * Generic event tracking
		   */
		  private async trackEvent(type: TelemetryEventType, data: any): Promise<void> {
		    if (!this.isEnabled()) return;
		
		    const event = {
		      ...this.createBaseEvent(type),
		      ...data,
		    };
		
		    await this.queueEvent(event);
		  }
		
		  /**
		   * Queue event for batch processing
		   */
		  private async queueEvent(event: BaseTelemetryEvent): Promise<void> {
		    try {
		      this.eventQueue.push(event);
		
		      // Process batch if queue is full
		      if (this.eventQueue.length >= this.config.batchSize) {
		        await this.processBatch();
		      }
		
		      // Store queue for crash recovery
		      await AsyncStorage.setItem('telemetry_queue', JSON.stringify(this.eventQueue));
		    } catch (error) {
		      console.error('Failed to queue telemetry event:', error);
		    }
		  }
		
		  /**
		   * Process queued events in batches
		   */
		  private async processBatch(force: boolean = false): Promise<void> {
		    if (this.eventQueue.length === 0) return;
		    if (!force && this.eventQueue.length < this.config.batchSize) return;
		
		    try {
		      const events = this.eventQueue.splice(0, this.config.batchSize);
		      const batch = await this.createBatch(events);
		
		      // Send batch to analytics endpoint (implementation depends on backend)
		      await this.sendBatch(batch);
		
		      // Update stored queue
		      await AsyncStorage.setItem('telemetry_queue', JSON.stringify(this.eventQueue));
		    } catch (error) {
		      console.error('Failed to process telemetry batch:', error);
		      // Re-queue failed events for retry
		      this.eventQueue.unshift(...this.eventQueue);
		    }
		  }
		
		  /**
		   * Create telemetry batch
		   */
		  private async createBatch(events: BaseTelemetryEvent[]): Promise<TelemetryBatch> {
		    const batchId = await this.generateSecureId();
		    const batchData = JSON.stringify(events);
		    const checksum = await this.calculateChecksum(batchData);
		
		    const batch: TelemetryBatch = {
		      batchId,
		      timestamp: new Date().toISOString(),
		      events,
		      checksum,
		      compressed: false, // Could implement compression
		      encrypted: this.config.encryptionEnabled,
		      privacyLevel: this.config.privacyLevel,
		    };
		
		    return batch;
		  }
		
		  /**
		   * Send batch to analytics endpoint
		   */
		  private async sendBatch(batch: TelemetryBatch): Promise<void> {
		    // This would integrate with your backend analytics service
		    // For now, we'll store locally for demonstration
		    try {
		      const existingBatches = await AsyncStorage.getItem('telemetry_batches');
		      const batches = existingBatches ? JSON.parse(existingBatches) : [];
		      
		      batches.push({
		        batchId: batch.batchId,
		        timestamp: batch.timestamp,
		        eventCount: batch.events.length,
		        privacyLevel: batch.privacyLevel,
		        processed: false,
		      });
		
		      // Keep only recent batches (for local storage management)
		      const recentBatches = batches.slice(-100);
		      await AsyncStorage.setItem('telemetry_batches', JSON.stringify(recentBatches));
		
		      console.log(`Telemetry batch ${batch.batchId} processed with ${batch.events.length} events`);
		    } catch (error) {
		      throw new Error(`Failed to send telemetry batch: ${error}`);
		    }
		  }
		
		  /**
		   * Check for question-level anomalies
		   */
		  private async checkQuestionAnomalies(event: QuestionTelemetryEvent): Promise<void> {
		    const anomalies: { type: AnomalyType; severity: string; reason: string }[] = [];
		
		    // Check for unusually fast responses
		    if (event.timeOnQuestion < 1000) { // Less than 1 second
		      anomalies.push({
		        type: 'too_fast_completion',
		        severity: 'medium',
		        reason: `Question answered in ${event.timeOnQuestion}ms`,
		      });
		    }
		
		    // Check for excessive revisions
		    if (event.revisionCount > 5) {
		      anomalies.push({
		        type: 'excessive_revisions',
		        severity: 'low',
		        reason: `Question revised ${event.revisionCount} times`,
		      });
		    }
		
		    // Track anomalies
		    for (const anomaly of anomalies) {
		      await this.trackAnomaly(anomaly.type, {
		        severity: anomaly.severity as any,
		        detectionAlgorithm: 'real_time_question_analysis',
		        contextData: {
		          questionId: event.questionId,
		          timeOnQuestion: event.timeOnQuestion,
		          revisionCount: event.revisionCount,
		          reason: anomaly.reason,
		        },
		        actionTaken: 'flagged',
		      });
		    }
		  }
		
		  /**
		   * Check for assessment-level anomalies
		   */
		  private async checkAssessmentAnomalies(event: AssessmentTelemetryEvent): Promise<void> {
		    const anomalies: { type: AnomalyType; severity: string; reason: string }[] = [];
		
		    // Check for straight-line responding (if completion is too fast)
		    if (event.type === 'assessment_completed' && event.averageResponseTime < 2000) {
		      anomalies.push({
		        type: 'straight_line_responding',
		        severity: 'high',
		        reason: `Average response time ${event.averageResponseTime}ms suggests minimal consideration`,
		      });
		    }
		
		    // Check for completion rate patterns
		    if (event.type === 'assessment_abandoned' && event.completionRate < 0.1) {
		      anomalies.push({
		        type: 'suspicious_timing',
		        severity: 'low',
		        reason: 'Very early abandonment may indicate bot behavior',
		      });
		    }
		
		    // Track anomalies
		    for (const anomaly of anomalies) {
		      await this.trackAnomaly(anomaly.type, {
		        severity: anomaly.severity as any,
		        detectionAlgorithm: 'assessment_pattern_analysis',
		        contextData: {
		          assessmentVersion: event.assessmentVersion,
		          completionRate: event.completionRate,
		          averageResponseTime: event.averageResponseTime,
		          reason: anomaly.reason,
		        },
		        actionTaken: 'flagged',
		      });
		    }
		  }
		
		  /**
		   * Schedule batch processing
		   */
		  private scheduleBatchProcessing(): void {
		    if (this.batchTimer) {
		      clearInterval(this.batchTimer);
		    }
		
		    // Process batches every 30 seconds
		    this.batchTimer = setInterval(async () => {
		      await this.processBatch();
		    }, 30000);
		  }
		
		  /**
		   * Create base event structure
		   */
		  private createBaseEvent(type: TelemetryEventType): BaseTelemetryEvent {
		    return {
		      id: nanoid(),
		      type,
		      timestamp: new Date().toISOString(),
		      sessionId: this.currentSession?.sessionId || 'no-session',
		      privacyLevel: this.config.privacyLevel,
		    };
		  }
		
		  /**
		   * Generate cryptographically secure ID
		   */
		  private async generateSecureId(): Promise<string> {
		    const randomBytes = await Crypto.getRandomBytesAsync(16);
		    return Array.from(randomBytes, byte => byte.toString(16).padStart(2, '0')).join('');
		  }
		
		  /**
		   * Generate device fingerprint (privacy-safe)
		   */
		  private async generateDeviceFingerprint(): Promise<string> {
		    // Create a hash of non-identifying device characteristics
		    const characteristics = [
		      'react-native', // Platform
		      '1.0.0', // App version
		      Date.now().toString().substring(0, 8), // Rough timestamp for session grouping
		    ].join('|');
		
		    return await this.hashValue(characteristics);
		  }
		
		  /**
		   * Hash sensitive values for privacy
		   */
		  private async hashValue(value: string): Promise<string> {
		    return await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, value);
		  }
		
		  /**
		   * Calculate checksum for data integrity
		   */
		  private async calculateChecksum(data: string): Promise<string> {
		    return await Crypto.digestStringAsync(Crypto.CryptoDigestAlgorithm.SHA256, data);
		  }
		
		  /**
		   * Check if telemetry is enabled and properly initialized
		   */
		  private isEnabled(): boolean {
		    return this.isInitialized && this.config.enabled && this.currentSession !== null;
		  }
		
		  /**
		   * Clear event queue
		   */
		  private clearEventQueue(): void {
		    this.eventQueue = [];
		    AsyncStorage.removeItem('telemetry_queue');
		  }
		
		  /**
		   * Get current configuration
		   */
		  getConfig(): TelemetryConfig {
		    return { ...this.config };
		  }
		
		  /**
		   * Get current session info (anonymized)
		   */
		  getSessionInfo(): Partial<AnonymousSession> | null {
		    if (!this.currentSession) return null;
		
		    return {
		      sessionId: this.currentSession.sessionId,
		      startTime: this.currentSession.startTime,
		      dataQualityScore: this.currentSession.dataQualityScore,
		      flagged: this.currentSession.flagged,
		    };
		  }
		
		  /**
		   * Cleanup on app termination
		   */
		  async cleanup(): Promise<void> {
		    if (this.batchTimer) {
		      clearInterval(this.batchTimer);
		      this.batchTimer = null;
		    }
		
		    await this.processBatch(true);
		    await this.endSession();
		  }
		}
		
		export const telemetryService = new TelemetryService();
		export default telemetryService;]]></file>
	<file path='services/twintuitionService.ts'><![CDATA[
		import * as Notifications from 'expo-notifications';
		import * as Location from 'expo-location';
		import { useTwinStore, TwintuitionAlert } from '../state/twinStore';
		import { BehaviorEvent, SyncEvent, TwintuitionConfig } from '../types/twintuition';
		import { analyzePatterns, detectSynchronicity } from '../utils/behaviorAnalytics';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		
		// Configure notification behavior
		Notifications.setNotificationHandler({
		  handleNotification: async () => ({
		    shouldShowAlert: true,
		    shouldPlaySound: true,
		    shouldSetBadge: false,
		  }),
		});
		
		class TwintuitionService {
		  private static instance: TwintuitionService;
		  private behaviorBuffer: BehaviorEvent[] = [];
		  private isInitialized = false;
		  private config: TwintuitionConfig = {
		    sensitivity: 0.7,
		    timeWindowMinutes: 15,
		    enableLocationSync: false,
		    enableMoodSync: true,
		    enableActionSync: true,
		    minConfidenceThreshold: 0.6,
		  };
		
		  static getInstance(): TwintuitionService {
		    if (!TwintuitionService.instance) {
		      TwintuitionService.instance = new TwintuitionService();
		    }
		    return TwintuitionService.instance;
		  }
		
		  async initialize(): Promise<void> {
		    if (this.isInitialized) return;
		
		    try {
		      // Request notification permissions
		      const { status } = await Notifications.requestPermissionsAsync();
		      if (status !== 'granted') {
		        console.warn('Notification permissions not granted');
		      }
		
		      // Load configuration
		      await this.loadConfig();
		
		      // Set up background task for behavior analysis
		      this.setupBackgroundProcessing();
		
		      // Register notification categories
		      await this.setupNotificationCategories();
		
		      this.isInitialized = true;
		      console.log('TwintuitionService initialized');
		    } catch (error) {
		      console.error('Failed to initialize TwintuitionService:', error);
		    }
		  }
		
		  private async loadConfig(): Promise<void> {
		    try {
		      const storedConfig = await AsyncStorage.getItem('twintuition-config');
		      if (storedConfig) {
		        this.config = { ...this.config, ...JSON.parse(storedConfig) };
		      }
		    } catch (error) {
		      console.error('Failed to load config:', error);
		    }
		  }
		
		  async updateConfig(newConfig: Partial<TwintuitionConfig>): Promise<void> {
		    this.config = { ...this.config, ...newConfig };
		    try {
		      await AsyncStorage.setItem('twintuition-config', JSON.stringify(this.config));
		    } catch (error) {
		      console.error('Failed to save config:', error);
		    }
		  }
		
		  private async setupNotificationCategories(): Promise<void> {
		    await Notifications.setNotificationCategoryAsync('twintuition', [
		      {
		        identifier: 'view',
		        buttonTitle: 'View Details',
		        options: { opensAppToForeground: true },
		      },
		      {
		        identifier: 'dismiss',
		        buttonTitle: 'Dismiss',
		        options: { opensAppToForeground: false },
		      },
		    ]);
		  }
		
		  private setupBackgroundProcessing(): void {
		    // Process behavior buffer every 30 seconds
		    setInterval(() => {
		      this.processBehaviorBuffer();
		    }, 30000);
		  }
		
		  async trackBehavior(event: Omit<BehaviorEvent, 'id' | 'timestamp'>): Promise<void> {
		    const behaviorEvent: BehaviorEvent = {
		      ...event,
		      id: `behavior_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
		      timestamp: new Date().toISOString(),
		    };
		
		    this.behaviorBuffer.push(behaviorEvent);
		
		    // Keep buffer size manageable
		    if (this.behaviorBuffer.length > 100) {
		      this.behaviorBuffer = this.behaviorBuffer.slice(-100);
		    }
		
		    // Store behavior data locally with privacy protection
		    await this.storeBehaviorEvent(behaviorEvent);
		
		    // Check for immediate synchronicity if we have twin behavior
		    if (behaviorEvent.twinId) {
		      await this.checkImmediateSynchronicity(behaviorEvent);
		    }
		  }
		
		  private async storeBehaviorEvent(event: BehaviorEvent): Promise<void> {
		    try {
		      const key = `behavior_${new Date().toISOString().split('T')[0]}`;
		      const existingData = await AsyncStorage.getItem(key);
		      const events = existingData ? JSON.parse(existingData) : [];
		      
		      events.push({
		        ...event,
		        // Remove sensitive data for storage
		        location: event.location ? 'REDACTED' : undefined,
		      });
		      
		      // Keep only last 50 events per day
		      if (events.length > 50) {
		        events.splice(0, events.length - 50);
		      }
		      
		      await AsyncStorage.setItem(key, JSON.stringify(events));
		    } catch (error) {
		      console.error('Failed to store behavior event:', error);
		    }
		  }
		
		  private async checkImmediateSynchronicity(event: BehaviorEvent): Promise<void> {
		    const recentEvents = this.behaviorBuffer.filter(
		      e => {
		        const timeDiff = new Date().getTime() - new Date(e.timestamp).getTime();
		        return timeDiff <= this.config.timeWindowMinutes * 60 * 1000;
		      }
		    );
		
		    const syncEvent = await detectSynchronicity(event, recentEvents, this.config);
		    if (syncEvent) {
		      await this.triggerTwintuitionAlert(syncEvent);
		    }
		  }
		
		  private async processBehaviorBuffer(): Promise<void> {
		    if (this.behaviorBuffer.length < 2) return;
		
		    try {
		      const patterns = await analyzePatterns(this.behaviorBuffer, this.config);
		      
		      for (const pattern of patterns) {
		        if (pattern.confidence >= this.config.minConfidenceThreshold) {
		          await this.triggerTwintuitionAlert({
		            type: pattern.type,
		            confidence: pattern.confidence,
		            description: pattern.description,
		            involvedEvents: pattern.events,
		            detectedAt: new Date().toISOString(),
		          });
		        }
		      }
		    } catch (error) {
		      console.error('Error processing behavior buffer:', error);
		    }
		  }
		
		  private async triggerTwintuitionAlert(syncEvent: SyncEvent): Promise<void> {
		    const store = useTwinStore.getState();
		    if (!store.notificationsEnabled || !store.paired) return;
		
		    const alertMessage = this.generateAlertMessage(syncEvent);
		    const alertType = this.mapSyncTypeToAlertType(syncEvent.type);
		
		    // Add to store
		    store.addTwintuitionAlert({
		      message: alertMessage,
		      type: alertType,
		      isRead: false,
		    });
		
		    // Send push notification
		    await this.sendPushNotification({
		      title: '✨ Twintuition Alert',
		      body: alertMessage,
		      data: {
		        type: 'twintuition',
		        syncType: syncEvent.type,
		        confidence: syncEvent.confidence.toString(),
		      },
		    });
		
		    // Track analytics (anonymized)
		    await this.trackAnalytics({
		      event: 'twintuition_alert_triggered',
		      properties: {
		        syncType: syncEvent.type,
		        confidence: Math.round(syncEvent.confidence * 100),
		        timeOfDay: new Date().getHours(),
		      },
		    });
		  }
		
		  private generateAlertMessage(syncEvent: SyncEvent): string {
		    const messages = {
		      simultaneous_action: [
		        "Your twin just performed the same action as you!",
		        "Psychic sync detected - you're both doing the same thing!",
		        "Twin connection alert: simultaneous behavior detected!",
		      ],
		      mood_synchronization: [
		        "You and your twin are feeling the same emotions right now",
		        "Emotional sync detected - your twin is vibing with you!",
		        "Your twin's mood matches yours perfectly",
		      ],
		      app_synchronization: [
		        "Your twin opened the app at the same time as you!",
		        "Psychic connection: you both reached for the app simultaneously",
		        "Twin telepathy moment - you're both here!",
		      ],
		      location_synchronization: [
		        "You and your twin are in similar locations",
		        "Geographic sync detected with your twin",
		        "Location connection: you're both nearby!",
		      ],
		      temporal_pattern: [
		        "You and your twin have matching daily patterns",
		        "Synchronized life rhythms detected",
		        "Your twin is living in sync with you!",
		      ],
		    };
		
		    const typeMessages = messages[syncEvent.type] || ["Something magical happened with your twin!"];
		    const randomMessage = typeMessages[Math.floor(Math.random() * typeMessages.length)];
		    
		    return `${randomMessage} (${Math.round(syncEvent.confidence * 100)}% confidence)`;
		  }
		
		  private mapSyncTypeToAlertType(syncType: string): 'feeling' | 'thought' | 'action' {
		    switch (syncType) {
		      case 'mood_synchronization':
		        return 'feeling';
		      case 'app_synchronization':
		      case 'temporal_pattern':
		        return 'thought';
		      default:
		        return 'action';
		    }
		  }
		
		  private async sendPushNotification(notification: {
		    title: string;
		    body: string;
		    data?: any;
		  }): Promise<void> {
		    try {
		      await Notifications.scheduleNotificationAsync({
		        content: {
		          title: notification.title,
		          body: notification.body,
		          data: notification.data || {},
		          categoryIdentifier: 'twintuition',
		          sound: 'default',
		        },
		        trigger: null, // Send immediately
		      });
		    } catch (error) {
		      console.error('Failed to send push notification:', error);
		    }
		  }
		
		  private async trackAnalytics(event: { event: string; properties: any }): Promise<void> {
		    try {
		      // Store analytics locally for privacy
		      const analyticsData = await AsyncStorage.getItem('twintuition-analytics') || '[]';
		      const analytics = JSON.parse(analyticsData);
		      
		      analytics.push({
		        ...event,
		        timestamp: new Date().toISOString(),
		      });
		      
		      // Keep only last 100 events
		      if (analytics.length > 100) {
		        analytics.splice(0, analytics.length - 100);
		      }
		      
		      await AsyncStorage.setItem('twintuition-analytics', JSON.stringify(analytics));
		    } catch (error) {
		      console.error('Failed to track analytics:', error);
		    }
		  }
		
		  // Public API methods
		  async requestLocationPermission(): Promise<boolean> {
		    try {
		      const { status } = await Location.requestForegroundPermissionsAsync();
		      return status === 'granted';
		    } catch {
		      return false;
		    }
		  }
		
		  async trackAppOpen(): Promise<void> {
		    const location = this.config.enableLocationSync 
		      ? await this.getCurrentLocation() 
		      : undefined;
		
		    await this.trackBehavior({
		      type: 'app_interaction',
		      action: 'open_app',
		      context: {},
		      location,
		      userId: useTwinStore.getState().userProfile?.id || 'anonymous',
		      twinId: useTwinStore.getState().twinProfile?.id,
		    });
		  }
		
		  async trackMessage(message: string): Promise<void> {
		    const emotion = await this.analyzeMessageEmotion(message);
		    
		    await this.trackBehavior({
		      type: 'communication',
		      action: 'send_message',
		      context: {
		        messageLength: message.length,
		        emotion,
		        hasEmojis: /[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/u.test(message),
		      },
		      userId: useTwinStore.getState().userProfile?.id || 'anonymous',
		      twinId: useTwinStore.getState().twinProfile?.id,
		    });
		  }
		
		  async trackMoodUpdate(mood: string, intensity: number): Promise<void> {
		    await this.trackBehavior({
		      type: 'mood_update',
		      action: 'set_mood',
		      context: {
		        mood,
		        intensity,
		      },
		      userId: useTwinStore.getState().userProfile?.id || 'anonymous',
		      twinId: useTwinStore.getState().twinProfile?.id,
		    });
		  }
		
		  private async getCurrentLocation(): Promise<{ latitude: number; longitude: number } | undefined> {
		    try {
		      const location = await Location.getCurrentPositionAsync({
		        accuracy: Location.Accuracy.Balanced,
		      });
		      return {
		        latitude: location.coords.latitude,
		        longitude: location.coords.longitude,
		      };
		    } catch {
		      return undefined;
		    }
		  }
		
		  private async analyzeMessageEmotion(message: string): Promise<string> {
		    // Simple emotion analysis based on keywords and emojis
		    const emotions = {
		      happy: ['😊', '😄', '😃', '🥰', '😍', 'happy', 'joy', 'great', 'awesome', 'love'],
		      sad: ['😢', '😭', '☹️', '😞', 'sad', 'down', 'upset', 'hurt', 'crying'],
		      excited: ['🤩', '🎉', '🥳', '✨', 'excited', 'amazing', 'incredible', 'wow'],
		      anxious: ['😰', '😟', '😥', 'worried', 'anxious', 'nervous', 'stress'],
		      angry: ['😠', '😡', '🤬', 'angry', 'mad', 'furious', 'annoyed'],
		    };
		
		    for (const [emotion, keywords] of Object.entries(emotions)) {
		      for (const keyword of keywords) {
		        if (message.toLowerCase().includes(keyword.toLowerCase())) {
		          return emotion;
		        }
		      }
		    }
		
		    return 'neutral';
		  }
		
		  // Method to get synchronicity history for analytics
		  async getSyncHistory(days: number = 7): Promise<TwintuitionAlert[]> {
		    const store = useTwinStore.getState();
		    const cutoffDate = new Date();
		    cutoffDate.setDate(cutoffDate.getDate() - days);
		
		    return store.twintuitionAlerts.filter(
		      alert => new Date(alert.timestamp) >= cutoffDate
		    );
		  }
		
		  // Method to calculate twin sync score
		  async getTwinSyncScore(): Promise<{ score: number; breakdown: any }> {
		    const history = await this.getSyncHistory(30);
		    const totalAlerts = history.length;
		    const highConfidenceAlerts = history.filter(
		      alert => alert.message.includes('90%') || alert.message.includes('95%') || alert.message.includes('100%')
		    ).length;
		
		    const score = Math.min(100, (totalAlerts * 2) + (highConfidenceAlerts * 5));
		    
		    return {
		      score,
		      breakdown: {
		        totalSyncEvents: totalAlerts,
		        highConfidenceEvents: highConfidenceAlerts,
		        averagePerWeek: Math.round(totalAlerts / 4.33),
		        strongestConnection: history.length > 0 ? 'Active' : 'Building',
		      },
		    };
		  }
		}
		
		export default TwintuitionService;
		export const twintuitionService = TwintuitionService.getInstance();]]></file>
	<file path='state/assessmentStore.ts'><![CDATA[
		import { create } from 'zustand';
		import { persist, createJSONStorage } from 'zustand/middleware';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import {
		  AssessmentSession,
		  AssessmentResponse,
		  AssessmentResults,
		  LikertScale,
		  AssessmentItem
		} from '../types/assessment';
		import assessmentItemBank from '../data/assessmentItemBank.json';
		import { generateAssessmentReport, handleMissingData } from '../utils/assessmentScoring';
		
		interface AssessmentState {
		  // Current session
		  currentSession: AssessmentSession | null;
		  
		  // All sessions (for history)
		  sessions: AssessmentSession[];
		  
		  // Assessment results
		  results: AssessmentResults[];
		  
		  // Pair analytics (when both twins complete)
		  pairResults: any | null;
		  
		  // UI state
		  currentQuestionIndex: number;
		  isLoading: boolean;
		  error: string | null;
		  
		  // Premium state
		  isPremium: boolean;
		  hasSeenTeaser: boolean;
		  
		  // Actions
		  startAssessment: (userId: string, twinId?: string) => void;
		  saveResponse: (itemId: string, value: LikertScale) => void;
		  navigateToQuestion: (index: number) => void;
		  submitAssessment: () => Promise<AssessmentResults | null>;
		  resumeAssessment: (sessionId: string) => void;
		  clearCurrentSession: () => void;
		  
		  // Premium actions
		  setPremiumStatus: (isPremium: boolean) => void;
		  markTeaserSeen: () => void;
		  
		  // Getters
		  getCurrentQuestion: () => AssessmentItem | null;
		  getProgress: () => number;
		  canSubmit: () => boolean;
		  getSessionById: (sessionId: string) => AssessmentSession | undefined;
		  getResultsById: (sessionId: string) => AssessmentResults | undefined;
		}
		
		// Flatten all items from categories into a single array
		const getAllItems = (): AssessmentItem[] => {
		  const items: AssessmentItem[] = [];
		  Object.values(assessmentItemBank.categories).forEach(category => {
		    items.push(...category.items);
		  });
		  return items;
		};
		
		const allItems = getAllItems();
		const TOTAL_QUESTIONS = allItems.length;
		const MIN_COMPLETION_RATE = 0.7; // 70% minimum for valid results
		
		export const useAssessmentStore = create<AssessmentState>()(
		  persist(
		    (set, get) => ({
		      // Initial state
		      currentSession: null,
		      sessions: [],
		      results: [],
		      pairResults: null,
		      currentQuestionIndex: 0,
		      isLoading: false,
		      error: null,
		      isPremium: false,
		      hasSeenTeaser: false,
		
		      // Start new assessment
		      startAssessment: (userId: string, twinId?: string) => {
		        const sessionId = `session_${Date.now()}_${userId}`;
		        const newSession: AssessmentSession = {
		          id: sessionId,
		          userId,
		          twinId,
		          startDate: new Date().toISOString(),
		          responses: [],
		          currentProgress: 0,
		          isComplete: false
		        };
		
		        set({
		          currentSession: newSession,
		          currentQuestionIndex: 0,
		          error: null
		        });
		
		        // Also add to sessions array
		        set(state => ({
		          sessions: [...state.sessions, newSession]
		        }));
		      },
		
		      // Save response and auto-advance
		      saveResponse: (itemId: string, value: LikertScale) => {
		        const { currentSession, currentQuestionIndex } = get();
		        
		        if (!currentSession) {
		          set({ error: 'No active assessment session' });
		          return;
		        }
		
		        // Create response
		        const response: AssessmentResponse = {
		          itemId,
		          value,
		          timestamp: new Date().toISOString()
		        };
		
		        // Update session with new response
		        const updatedResponses = currentSession.responses.filter(r => r.itemId !== itemId);
		        updatedResponses.push(response);
		        
		        const progress = (updatedResponses.length / TOTAL_QUESTIONS) * 100;
		        
		        const updatedSession: AssessmentSession = {
		          ...currentSession,
		          responses: updatedResponses,
		          currentProgress: progress
		        };
		
		        // Update current session and sessions array
		        set(state => ({
		          currentSession: updatedSession,
		          sessions: state.sessions.map(s => 
		            s.id === updatedSession.id ? updatedSession : s
		          ),
		          currentQuestionIndex: Math.min(currentQuestionIndex + 1, TOTAL_QUESTIONS - 1),
		          error: null
		        }));
		
		        // Auto-save to AsyncStorage happens via Zustand persist
		      },
		
		      // Navigate to specific question
		      navigateToQuestion: (index: number) => {
		        if (index >= 0 && index < TOTAL_QUESTIONS) {
		          set({ currentQuestionIndex: index });
		        }
		      },
		
		      // Submit assessment and calculate results
		      submitAssessment: async () => {
		        const { currentSession, isPremium } = get();
		        
		        if (!currentSession) {
		          set({ error: 'No active assessment session' });
		          return null;
		        }
		
		        set({ isLoading: true, error: null });
		
		        try {
		          // Validate completion rate
		          const validation = handleMissingData(
		            currentSession.responses,
		            TOTAL_QUESTIONS
		          );
		
		          if (!validation.isValid) {
		            set({ 
		              error: validation.message,
		              isLoading: false 
		            });
		            return null;
		          }
		
		          // Generate assessment report
		          const results = generateAssessmentReport(
		            currentSession.responses,
		            currentSession.id,
		            currentSession.userId,
		            currentSession.twinId
		          );
		
		          // Mark session as complete
		          const completedSession: AssessmentSession = {
		            ...currentSession,
		            completionDate: new Date().toISOString(),
		            isComplete: true,
		            currentProgress: 100
		          };
		
		          // Update state
		          set(state => ({
		            currentSession: null,
		            sessions: state.sessions.map(s => 
		              s.id === completedSession.id ? completedSession : s
		            ),
		            results: [...state.results, results],
		            currentQuestionIndex: 0,
		            isLoading: false,
		            error: null
		          }));
		
		          // Return results for navigation
		          return results;
		
		        } catch (error) {
		          set({ 
		            error: 'Failed to calculate assessment results',
		            isLoading: false 
		          });
		          return null;
		        }
		      },
		
		      // Resume existing assessment
		      resumeAssessment: (sessionId: string) => {
		        const session = get().sessions.find(s => s.id === sessionId);
		        
		        if (!session || session.isComplete) {
		          set({ error: 'Cannot resume this assessment' });
		          return;
		        }
		
		        // Find the next unanswered question
		        const answeredItemIds = session.responses.map(r => r.itemId);
		        const nextQuestionIndex = allItems.findIndex(item => 
		          !answeredItemIds.includes(item.id)
		        );
		
		        set({
		          currentSession: session,
		          currentQuestionIndex: nextQuestionIndex >= 0 ? nextQuestionIndex : 0,
		          error: null
		        });
		      },
		
		      // Clear current session
		      clearCurrentSession: () => {
		        set({
		          currentSession: null,
		          currentQuestionIndex: 0,
		          error: null
		        });
		      },
		
		      // Premium status
		      setPremiumStatus: (isPremium: boolean) => {
		        set({ isPremium });
		      },
		
		      markTeaserSeen: () => {
		        set({ hasSeenTeaser: true });
		      },
		
		      // Getters
		      getCurrentQuestion: () => {
		        const { currentQuestionIndex } = get();
		        return allItems[currentQuestionIndex] || null;
		      },
		
		      getProgress: () => {
		        const { currentSession } = get();
		        if (!currentSession) return 0;
		        return currentSession.currentProgress;
		      },
		
		      canSubmit: () => {
		        const { currentSession } = get();
		        if (!currentSession) return false;
		        
		        const completionRate = (currentSession.responses.length / TOTAL_QUESTIONS) * 100;
		        return completionRate >= (MIN_COMPLETION_RATE * 100);
		      },
		
		      getSessionById: (sessionId: string) => {
		        return get().sessions.find(s => s.id === sessionId);
		      },
		
		      getResultsById: (sessionId: string) => {
		        return get().results.find(r => r.sessionId === sessionId);
		      }
		    }),
		    {
		      name: 'assessment-storage',
		      storage: createJSONStorage(() => AsyncStorage),
		      partialize: (state) => ({
		        sessions: state.sessions,
		        results: state.results,
		        isPremium: state.isPremium,
		        hasSeenTeaser: state.hasSeenTeaser
		      })
		    }
		  )
		);]]></file>
	<file path='state/chatStore.ts'><![CDATA[
		import { create } from 'zustand';
		import { persist, createJSONStorage } from 'zustand/middleware';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import { ChatMessage, TypingIndicator, ChatConnection, TwintuitionMoment } from '../types/chat';
		import { ThemeColor } from './twinStore';
		
		interface ChatState {
		  // Messages
		  messages: ChatMessage[];
		  unsentMessages: ChatMessage[];
		  
		  // Connection
		  connection: ChatConnection;
		  typingIndicator: TypingIndicator | null;
		  
		  // Twintuition
		  twintuitionMoments: TwintuitionMoment[];
		  
		  // UI State
		  isVoiceRecording: boolean;
		  showQuickResponses: boolean;
		  selectedMessageId: string | null;
		  
		  // Actions
		  addMessage: (message: Omit<ChatMessage, 'id' | 'timestamp' | 'isDelivered' | 'isRead'>) => void;
		  updateMessage: (messageId: string, updates: Partial<ChatMessage>) => void;
		  deleteMessage: (messageId: string) => void;
		  markAsRead: (messageId: string) => void;
		  markAsDelivered: (messageId: string) => void;
		  addReaction: (messageId: string, emoji: string, userId: string, userName: string) => void;
		  removeReaction: (messageId: string, emoji: string, userId: string) => void;
		  
		  // Connection
		  setConnection: (connection: Partial<ChatConnection>) => void;
		  setTypingIndicator: (indicator: TypingIndicator | null) => void;
		  incrementUnreadCount: () => void;
		  resetUnreadCount: () => void;
		  
		  // Twintuition
		  addTwintuitionMoment: (moment: Omit<TwintuitionMoment, 'id' | 'timestamp'>) => void;
		  
		  // UI
		  setVoiceRecording: (recording: boolean) => void;
		  setShowQuickResponses: (show: boolean) => void;
		  setSelectedMessage: (messageId: string | null) => void;
		  
		  // Utilities
		  getUnreadMessages: () => ChatMessage[];
		  getMessagesByDate: (date: string) => ChatMessage[];
		  searchMessages: (query: string) => ChatMessage[];
		  clearChat: () => void;
		}
		
		export const useChatStore = create<ChatState>()(
		  persist(
		    (set, get) => ({
		      // Initial state
		      messages: [],
		      unsentMessages: [],
		      connection: {
		        status: 'disconnected',
		        unreadCount: 0,
		      },
		      typingIndicator: null,
		      twintuitionMoments: [],
		      isVoiceRecording: false,
		      showQuickResponses: false,
		      selectedMessageId: null,
		
		      // Message actions
		      addMessage: (messageData) => {
		        const message: ChatMessage = {
		          ...messageData,
		          id: Date.now().toString() + Math.random().toString(36),
		          timestamp: new Date().toISOString(),
		          isDelivered: false,
		          isRead: false,
		          reactions: [],
		        };
		
		        set((state) => ({
		          messages: [...state.messages, message],
		        }));
		      },
		
		      updateMessage: (messageId, updates) => {
		        set((state) => ({
		          messages: state.messages.map((msg) =>
		            msg.id === messageId ? { ...msg, ...updates } : msg
		          ),
		        }));
		      },
		
		      deleteMessage: (messageId) => {
		        set((state) => ({
		          messages: state.messages.filter((msg) => msg.id !== messageId),
		        }));
		      },
		
		      markAsRead: (messageId) => {
		        set((state) => ({
		          messages: state.messages.map((msg) =>
		            msg.id === messageId ? { ...msg, isRead: true } : msg
		          ),
		        }));
		      },
		
		      markAsDelivered: (messageId) => {
		        set((state) => ({
		          messages: state.messages.map((msg) =>
		            msg.id === messageId ? { ...msg, isDelivered: true } : msg
		          ),
		        }));
		      },
		
		      addReaction: (messageId, emoji, userId, userName) => {
		        set((state) => ({
		          messages: state.messages.map((msg) => {
		            if (msg.id === messageId) {
		              const existingReaction = msg.reactions?.find(
		                (r) => r.emoji === emoji && r.userId === userId
		              );
		              if (!existingReaction) {
		                return {
		                  ...msg,
		                  reactions: [
		                    ...(msg.reactions || []),
		                    {
		                      emoji,
		                      userId,
		                      userName,
		                      timestamp: new Date().toISOString(),
		                    },
		                  ],
		                };
		              }
		            }
		            return msg;
		          }),
		        }));
		      },
		
		      removeReaction: (messageId, emoji, userId) => {
		        set((state) => ({
		          messages: state.messages.map((msg) => {
		            if (msg.id === messageId) {
		              return {
		                ...msg,
		                reactions: msg.reactions?.filter(
		                  (r) => !(r.emoji === emoji && r.userId === userId)
		                ) || [],
		              };
		            }
		            return msg;
		          }),
		        }));
		      },
		
		      // Connection actions
		      setConnection: (connectionUpdates) => {
		        set((state) => ({
		          connection: { ...state.connection, ...connectionUpdates },
		        }));
		      },
		
		      setTypingIndicator: (indicator) => {
		        set({ typingIndicator: indicator });
		      },
		
		      incrementUnreadCount: () => {
		        set((state) => ({
		          connection: {
		            ...state.connection,
		            unreadCount: state.connection.unreadCount + 1,
		          },
		        }));
		      },
		
		      resetUnreadCount: () => {
		        set((state) => ({
		          connection: { ...state.connection, unreadCount: 0 },
		        }));
		      },
		
		      // Twintuition actions
		      addTwintuitionMoment: (momentData) => {
		        const moment: TwintuitionMoment = {
		          ...momentData,
		          id: Date.now().toString(),
		          timestamp: new Date().toISOString(),
		        };
		
		        set((state) => ({
		          twintuitionMoments: [moment, ...state.twintuitionMoments],
		        }));
		      },
		
		      // UI actions
		      setVoiceRecording: (recording) => {
		        set({ isVoiceRecording: recording });
		      },
		
		      setShowQuickResponses: (show) => {
		        set({ showQuickResponses: show });
		      },
		
		      setSelectedMessage: (messageId) => {
		        set({ selectedMessageId: messageId });
		      },
		
		      // Utility functions
		      getUnreadMessages: () => {
		        return get().messages.filter((msg) => !msg.isRead);
		      },
		
		      getMessagesByDate: (date) => {
		        return get().messages.filter((msg) =>
		          msg.timestamp.startsWith(date)
		        );
		      },
		
		      searchMessages: (query) => {
		        const lowerQuery = query.toLowerCase();
		        return get().messages.filter((msg) =>
		          msg.text.toLowerCase().includes(lowerQuery) ||
		          msg.senderName.toLowerCase().includes(lowerQuery)
		        );
		      },
		
		      clearChat: () => {
		        set({
		          messages: [],
		          unsentMessages: [],
		          twintuitionMoments: [],
		          selectedMessageId: null,
		        });
		      },
		    }),
		    {
		      name: 'chat-storage',
		      storage: createJSONStorage(() => AsyncStorage),
		      partialize: (state) => ({
		        messages: state.messages,
		        twintuitionMoments: state.twintuitionMoments,
		        connection: {
		          unreadCount: state.connection.unreadCount,
		          lastSeen: state.connection.lastSeen,
		        },
		      }),
		    }
		  )
		);]]></file>
	<file path='state/invitationStore.ts'><![CDATA[
		import { create } from 'zustand';
		import { persist, createJSONStorage } from 'zustand/middleware';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import invitationService, { Invitation, InvitationAnalytics } from '../services/invitationService';
		import { TwinProfile } from './twinStore';
		
		interface InvitationState {
		  // Current invitation being processed
		  currentInvitation: Invitation | null;
		  
		  // UI State
		  isLoading: boolean;
		  error: string | null;
		  
		  // Invitation process state
		  invitationStep: 'contact' | 'method' | 'sending' | 'sent' | 'success' | 'error';
		  selectedMethod: 'email' | 'sms' | 'both' | null;
		  recipientContact: {
		    email?: string;
		    phone?: string;
		    name?: string;
		  };
		  
		  // Analytics and history
		  analytics: InvitationAnalytics | null;
		  recentInvitations: Invitation[];
		  
		  // Deep link handling
		  pendingInvitationToken: string | null;
		  deepLinkData: {
		    token?: string;
		    processed?: boolean;
		    timestamp?: number;
		  } | null;
		  
		  // Actions
		  setCurrentInvitation: (invitation: Invitation | null) => void;
		  setLoading: (loading: boolean) => void;
		  setError: (error: string | null) => void;
		  setInvitationStep: (step: InvitationState['invitationStep']) => void;
		  setSelectedMethod: (method: InvitationState['selectedMethod']) => void;
		  setRecipientContact: (contact: InvitationState['recipientContact']) => void;
		  
		  // Invitation flow actions
		  createAndSendInvitation: (
		    inviterProfile: TwinProfile,
		    recipientContact: { email?: string; phone?: string; name?: string },
		    method: 'email' | 'sms' | 'both'
		  ) => Promise<boolean>;
		  
		  processIncomingInvitation: (token: string) => Promise<{
		    success: boolean;
		    invitation?: Invitation;
		    error?: string;
		  }>;
		  
		  acceptInvitation: (token: string) => Promise<boolean>;
		  declineInvitation: (token: string) => Promise<boolean>;
		  
		  // Analytics and management
		  refreshAnalytics: () => Promise<void>;
		  retryFailedInvitation: (invitationId: string, method: 'email' | 'sms') => Promise<boolean>;
		  
		  // Deep link management
		  setPendingInvitationToken: (token: string | null) => void;
		  setDeepLinkData: (data: InvitationState['deepLinkData']) => void;
		  clearDeepLinkData: () => void;
		  
		  // Reset and cleanup
		  reset: () => void;
		  clearError: () => void;
		}
		
		export const useInvitationStore = create<InvitationState>()(
		  persist(
		    (set, get) => ({
		      // Initial state
		      currentInvitation: null,
		      isLoading: false,
		      error: null,
		      invitationStep: 'contact',
		      selectedMethod: null,
		      recipientContact: {},
		      analytics: null,
		      recentInvitations: [],
		      pendingInvitationToken: null,
		      deepLinkData: null,
		      
		      // Basic setters
		      setCurrentInvitation: (invitation) => set({ currentInvitation: invitation }),
		      
		      setLoading: (loading) => set({ isLoading: loading }),
		      
		      setError: (error) => set({ error }),
		      
		      clearError: () => set({ error: null }),
		      
		      setInvitationStep: (step) => set({ invitationStep: step }),
		      
		      setSelectedMethod: (method) => set({ selectedMethod: method }),
		      
		      setRecipientContact: (contact) => {
		        const currentContact = get().recipientContact;
		        set({ recipientContact: { ...currentContact, ...contact } });
		      },
		      
		      setPendingInvitationToken: (token) => set({ pendingInvitationToken: token }),
		      
		      setDeepLinkData: (data) => set({ deepLinkData: data }),
		      
		      clearDeepLinkData: () => set({ deepLinkData: null }),
		      
		      // Main invitation creation and sending flow
		      createAndSendInvitation: async (inviterProfile, recipientContact, method) => {
		        const { setLoading, setError, setInvitationStep, setCurrentInvitation } = get();
		        
		        try {
		          setLoading(true);
		          setError(null);
		          setInvitationStep('sending');
		          
		          // Create invitation
		          const invitation = await invitationService.createInvitation(
		            inviterProfile,
		            { email: recipientContact.email, phone: recipientContact.phone }
		          );
		          
		          setCurrentInvitation(invitation);
		          
		          let emailSuccess = false;
		          let smsSuccess = false;
		          let hasErrors = false;
		          const errors: string[] = [];
		          
		          // Send via email if requested
		          if ((method === 'email' || method === 'both') && invitation.recipientEmail) {
		            try {
		              emailSuccess = await invitationService.sendEmailInvitation(invitation);
		              if (!emailSuccess) {
		                errors.push('Email invitation could not be sent');
		              }
		            } catch (error) {
		              errors.push(`Email error: ${error instanceof Error ? error.message : 'Unknown error'}`);
		              hasErrors = true;
		            }
		          }
		          
		          // Send via SMS if requested
		          if ((method === 'sms' || method === 'both') && invitation.recipientPhone) {
		            try {
		              smsSuccess = await invitationService.sendSMSInvitation(invitation);
		              if (!smsSuccess) {
		                errors.push('SMS invitation could not be sent');
		              }
		            } catch (error) {
		              errors.push(`SMS error: ${error instanceof Error ? error.message : 'Unknown error'}`);
		              hasErrors = true;
		            }
		          }
		          
		          // Determine final result
		          const success = emailSuccess || smsSuccess;
		          
		          if (success) {
		            setInvitationStep('sent');
		            if (errors.length > 0) {
		              setError(`Partially sent: ${errors.join(', ')}`);
		            }
		            
		            // Auto-transition to success after a delay
		            setTimeout(() => {
		              const currentState = get();
		              if (currentState.invitationStep === 'sent') {
		                currentState.setInvitationStep('success');
		              }
		            }, 2000);
		            
		            return true;
		          } else {
		            setInvitationStep('error');
		            setError(errors.join(', ') || 'Failed to send invitation');
		            return false;
		          }
		          
		        } catch (error) {
		          setInvitationStep('error');
		          const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
		          setError(errorMessage);
		          return false;
		        } finally {
		          setLoading(false);
		        }
		      },
		      
		      // Process incoming invitation (from deep link or manual entry)
		      processIncomingInvitation: async (token) => {
		        const { setLoading, setError, setCurrentInvitation } = get();
		        
		        try {
		          setLoading(true);
		          setError(null);
		          
		          const result = await invitationService.acceptInvitation(token);
		          
		          if (result.success && result.invitation) {
		            setCurrentInvitation(result.invitation);
		            return { success: true, invitation: result.invitation };
		          } else {
		            setError(result.error || 'Failed to process invitation');
		            return { success: false, error: result.error };
		          }
		          
		        } catch (error) {
		          const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
		          setError(errorMessage);
		          return { success: false, error: errorMessage };
		        } finally {
		          setLoading(false);
		        }
		      },
		      
		      // Accept invitation
		      acceptInvitation: async (token) => {
		        const { setLoading, setError } = get();
		        
		        try {
		          setLoading(true);
		          setError(null);
		          
		          const result = await invitationService.acceptInvitation(token);
		          
		          if (result.success) {
		            // Refresh analytics to reflect the acceptance
		            get().refreshAnalytics();
		            return true;
		          } else {
		            setError(result.error || 'Failed to accept invitation');
		            return false;
		          }
		          
		        } catch (error) {
		          const errorMessage = error instanceof Error ? error.message : 'Failed to accept invitation';
		          setError(errorMessage);
		          return false;
		        } finally {
		          setLoading(false);
		        }
		      },
		      
		      // Decline invitation
		      declineInvitation: async (token) => {
		        const { setLoading, setError } = get();
		        
		        try {
		          setLoading(true);
		          setError(null);
		          
		          const success = await invitationService.declineInvitation(token);
		          
		          if (success) {
		            // Refresh analytics to reflect the decline
		            get().refreshAnalytics();
		            return true;
		          } else {
		            setError('Failed to decline invitation');
		            return false;
		          }
		          
		        } catch (error) {
		          const errorMessage = error instanceof Error ? error.message : 'Failed to decline invitation';
		          setError(errorMessage);
		          return false;
		        } finally {
		          setLoading(false);
		        }
		      },
		      
		      // Refresh analytics data
		      refreshAnalytics: async () => {
		        try {
		          const analytics = await invitationService.getInvitationAnalytics();
		          set({ 
		            analytics,
		            recentInvitations: analytics.recentInvitations 
		          });
		        } catch (error) {
		          console.error('Failed to refresh invitation analytics:', error);
		        }
		      },
		      
		      // Retry failed invitation
		      retryFailedInvitation: async (invitationId, method) => {
		        const { setLoading, setError } = get();
		        
		        try {
		          setLoading(true);
		          setError(null);
		          
		          const success = await invitationService.retryInvitation(invitationId, method);
		          
		          if (success) {
		            // Refresh analytics and current invitation if it matches
		            await get().refreshAnalytics();
		            return true;
		          } else {
		            setError('Failed to retry invitation');
		            return false;
		          }
		          
		        } catch (error) {
		          const errorMessage = error instanceof Error ? error.message : 'Failed to retry invitation';
		          setError(errorMessage);
		          return false;
		        } finally {
		          setLoading(false);
		        }
		      },
		      
		      // Reset state
		      reset: () => set({
		        currentInvitation: null,
		        isLoading: false,
		        error: null,
		        invitationStep: 'contact',
		        selectedMethod: null,
		        recipientContact: {},
		        pendingInvitationToken: null,
		        deepLinkData: null,
		      }),
		      
		    }),
		    {
		      name: 'invitation-storage',
		      storage: createJSONStorage(() => AsyncStorage),
		      // Only persist essential data
		      partialize: (state) => ({
		        analytics: state.analytics,
		        recentInvitations: state.recentInvitations,
		        pendingInvitationToken: state.pendingInvitationToken,
		        deepLinkData: state.deepLinkData,
		      }),
		    }
		  )
		);
		
		// Selector hooks for better performance
		export const useInvitationLoading = () => useInvitationStore(state => state.isLoading);
		export const useInvitationError = () => useInvitationStore(state => state.error);
		export const useInvitationStep = () => useInvitationStore(state => state.invitationStep);
		export const useCurrentInvitation = () => useInvitationStore(state => state.currentInvitation);
		export const useInvitationAnalytics = () => useInvitationStore(state => state.analytics);
		export const usePendingInvitationToken = () => useInvitationStore(state => state.pendingInvitationToken);
		export const useDeepLinkData = () => useInvitationStore(state => state.deepLinkData);
		
		// Initialize invitation service on store creation
		invitationService.initialize();]]></file>
	<file path='state/researchStore.ts'><![CDATA[
		import { create } from 'zustand';
		import { persist, createJSONStorage } from 'zustand/middleware';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import { 
		  ResearchStudy, 
		  ConsentRecord, 
		  ResearchParticipation,
		  ResearchInsight,
		  ParticipantDashboard,
		  WithdrawalRequest
		} from '../types/research';
		import { researchService } from '../services/researchService';
		
		interface ResearchState {
		  // Data
		  availableStudies: ResearchStudy[];
		  participation: ResearchParticipation | null;
		  consentRecords: ConsentRecord[];
		  insights: ResearchInsight[];
		  dashboard: ParticipantDashboard | null;
		  
		  // UI State
		  isLoading: boolean;
		  error: string | null;
		  selectedStudy: ResearchStudy | null;
		  consentInProgress: boolean;
		  
		  // Actions
		  loadAvailableStudies: () => Promise<void>;
		  loadParticipation: (userId: string) => Promise<void>;
		  loadDashboard: (userId: string) => Promise<void>;
		  loadInsights: (userId: string) => Promise<void>;
		  
		  selectStudy: (study: ResearchStudy | null) => void;
		  
		  recordConsent: (
		    userId: string, 
		    studyId: string, 
		    consentItems: ConsentRecord['consentedTo'],
		    ipAddress?: string
		  ) => Promise<void>;
		  
		  joinStudy: (userId: string, studyId: string) => Promise<void>;
		  
		  withdrawFromStudy: (
		    userId: string, 
		    studyId: string, 
		    reason: string, 
		    dataDisposition: WithdrawalRequest['dataDisposition']
		  ) => Promise<void>;
		  
		  contributeData: (userId: string, dataType: string, dataPoints: number) => Promise<void>;
		  
		  updatePreferences: (userId: string, preferences: ResearchParticipation['preferences']) => Promise<void>;
		  
		  exportData: (userId: string) => Promise<object>;
		  deleteAllData: (userId: string) => Promise<void>;
		  
		  setError: (error: string | null) => void;
		  clearError: () => void;
		  reset: () => void;
		}
		
		export const useResearchStore = create<ResearchState>()(
		  persist(
		    (set, get) => ({
		      // Initial state
		      availableStudies: [],
		      participation: null,
		      consentRecords: [],
		      insights: [],
		      dashboard: null,
		      isLoading: false,
		      error: null,
		      selectedStudy: null,
		      consentInProgress: false,
		      
		      // Actions
		      loadAvailableStudies: async () => {
		        set({ isLoading: true, error: null });
		        try {
		          const studies = await researchService.getAvailableStudies();
		          set({ availableStudies: studies, isLoading: false });
		        } catch (error) {
		          set({ 
		            error: error instanceof Error ? error.message : 'Failed to load studies',
		            isLoading: false 
		          });
		        }
		      },
		      
		      loadParticipation: async (userId: string) => {
		        set({ isLoading: true, error: null });
		        try {
		          const [participation, consent] = await Promise.all([
		            researchService.getParticipation(userId),
		            researchService.getConsentRecords(userId)
		          ]);
		          set({ 
		            participation, 
		            consentRecords: consent,
		            isLoading: false 
		          });
		        } catch (error) {
		          set({ 
		            error: error instanceof Error ? error.message : 'Failed to load participation',
		            isLoading: false 
		          });
		        }
		      },
		      
		      loadDashboard: async (userId: string) => {
		        set({ isLoading: true, error: null });
		        try {
		          const dashboard = await researchService.getParticipantDashboard(userId);
		          set({ dashboard, isLoading: false });
		        } catch (error) {
		          set({ 
		            error: error instanceof Error ? error.message : 'Failed to load dashboard',
		            isLoading: false 
		          });
		        }
		      },
		      
		      loadInsights: async (userId: string) => {
		        set({ isLoading: true, error: null });
		        try {
		          const insights = await researchService.getResearchInsights(userId);
		          set({ insights, isLoading: false });
		        } catch (error) {
		          set({ 
		            error: error instanceof Error ? error.message : 'Failed to load insights',
		            isLoading: false 
		          });
		        }
		      },
		      
		      selectStudy: (study: ResearchStudy | null) => {
		        set({ selectedStudy: study });
		      },
		      
		      recordConsent: async (
		        userId: string, 
		        studyId: string, 
		        consentItems: ConsentRecord['consentedTo'],
		        ipAddress?: string
		      ) => {
		        set({ consentInProgress: true, error: null });
		        try {
		          const consentRecord = await researchService.recordConsent(
		            userId, 
		            studyId, 
		            consentItems, 
		            ipAddress
		          );
		          
		          const currentConsent = get().consentRecords;
		          set({ 
		            consentRecords: [...currentConsent, consentRecord],
		            consentInProgress: false 
		          });
		        } catch (error) {
		          set({ 
		            error: error instanceof Error ? error.message : 'Failed to record consent',
		            consentInProgress: false 
		          });
		        }
		      },
		      
		      joinStudy: async (userId: string, studyId: string) => {
		        set({ isLoading: true, error: null });
		        try {
		          await researchService.joinStudy(userId, studyId);
		          
		          // Reload participation to get updated state
		          const participation = await researchService.getParticipation(userId);
		          set({ participation, isLoading: false });
		          
		          // Reload dashboard as well
		          const dashboard = await researchService.getParticipantDashboard(userId);
		          set({ dashboard });
		        } catch (error) {
		          set({ 
		            error: error instanceof Error ? error.message : 'Failed to join study',
		            isLoading: false 
		          });
		        }
		      },
		      
		      withdrawFromStudy: async (
		        userId: string, 
		        studyId: string, 
		        reason: string, 
		        dataDisposition: WithdrawalRequest['dataDisposition']
		      ) => {
		        set({ isLoading: true, error: null });
		        try {
		          await researchService.withdrawFromStudy(userId, studyId, reason, dataDisposition);
		          
		          // Reload participation
		          const participation = await researchService.getParticipation(userId);
		          set({ participation, isLoading: false });
		          
		          // Reload dashboard
		          const dashboard = await researchService.getParticipantDashboard(userId);
		          set({ dashboard });
		        } catch (error) {
		          set({ 
		            error: error instanceof Error ? error.message : 'Failed to withdraw from study',
		            isLoading: false 
		          });
		        }
		      },
		      
		      contributeData: async (userId: string, dataType: string, dataPoints: number) => {
		        try {
		          if (dataType === 'behavioral') {
		            await researchService.contributeBehavioralData(userId, dataType, dataPoints);
		          }
		          
		          // Reload participation to update contributions
		          const participation = await researchService.getParticipation(userId);
		          set({ participation });
		          
		          // Update dashboard
		          const dashboard = await researchService.getParticipantDashboard(userId);
		          set({ dashboard });
		        } catch (error) {
		          console.error('Failed to contribute data:', error);
		        }
		      },
		      
		      updatePreferences: async (userId: string, preferences: ResearchParticipation['preferences']) => {
		        set({ isLoading: true, error: null });
		        try {
		          const participation = get().participation;
		          if (participation) {
		            const updated = { ...participation, preferences };
		            await researchService.updateParticipation(userId, updated);
		            set({ participation: updated, isLoading: false });
		          }
		        } catch (error) {
		          set({ 
		            error: error instanceof Error ? error.message : 'Failed to update preferences',
		            isLoading: false 
		          });
		        }
		      },
		      
		      exportData: async (userId: string) => {
		        set({ isLoading: true, error: null });
		        try {
		          const data = await researchService.exportUserData(userId);
		          set({ isLoading: false });
		          return data;
		        } catch (error) {
		          set({ 
		            error: error instanceof Error ? error.message : 'Failed to export data',
		            isLoading: false 
		          });
		          throw error;
		        }
		      },
		      
		      deleteAllData: async (userId: string) => {
		        set({ isLoading: true, error: null });
		        try {
		          await researchService.deleteAllUserData(userId);
		          set({ 
		            participation: null,
		            consentRecords: [],
		            insights: [],
		            dashboard: null,
		            isLoading: false 
		          });
		        } catch (error) {
		          set({ 
		            error: error instanceof Error ? error.message : 'Failed to delete data',
		            isLoading: false 
		          });
		        }
		      },
		      
		      setError: (error: string | null) => {
		        set({ error });
		      },
		      
		      clearError: () => {
		        set({ error: null });
		      },
		      
		      reset: () => {
		        set({
		          availableStudies: [],
		          participation: null,
		          consentRecords: [],
		          insights: [],
		          dashboard: null,
		          isLoading: false,
		          error: null,
		          selectedStudy: null,
		          consentInProgress: false
		        });
		      }
		    }),
		    {
		      name: 'research-storage',
		      storage: createJSONStorage(() => AsyncStorage),
		      partialize: (state) => ({
		        // Only persist non-sensitive data
		        availableStudies: state.availableStudies,
		        selectedStudy: state.selectedStudy
		      })
		    }
		  )
		);]]></file>
	<file path='state/rootStore.example.ts'><![CDATA[
		// This is an example of a Zustand store, use this for async storage.
		// DO NOTE USE THIS FILE, create new ones in the state folder.
		
		import { create } from "zustand";
		import { persist, createJSONStorage } from "zustand/middleware";
		import AsyncStorage from "@react-native-async-storage/async-storage";
		
		interface RootStore {}
		
		// Make sure to persist the store using the persist middleware.
		const useRootStore = create<RootStore>()(
		  persist(
		    (set, get) => ({
		      // add your Zustand store here
		      // someData: 0,
		      // addSomeData: () => set({ someData: get().someData + 1 }),
		    }),
		    {
		      name: "root-storage",
		      storage: createJSONStorage(() => AsyncStorage),
		    },
		  ),
		);
		
		export default useRootStore;]]></file>
	<file path='state/stores/assessmentStore.ts'><![CDATA[
		/**
		 * Assessment Store - Local-first assessment data management with Zustand
		 * Handles assessment progress, responses, and results with encryption support
		 */
		
		import { create } from 'zustand';
		import { persist, createJSONStorage } from 'zustand/middleware';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import { MMKV } from 'react-native-mmkv';
		import {
		  AssessmentTemplate,
		  AssessmentProgress,
		  AssessmentResponse,
		  AssessmentResults,
		  AssessmentScore,
		  PrivacyConsent,
		  SyncStatus,
		  AssessmentCategory
		} from '../types/assessment/types';
		import { EncryptionService } from '../services/encryptionService';
		import { StorageService } from '../services/storageService';
		
		// Secure MMKV storage for sensitive assessment data
		const secureStorage = new MMKV({
		  id: 'assessment-secure',
		  encryptionKey: 'assessment-encryption-key', // In production, derive from device keychain
		});
		
		interface AssessmentState {
		  // Templates and Configuration
		  templates: Record<string, AssessmentTemplate>;
		  activeTemplateId: string | null;
		  
		  // Progress Tracking
		  currentProgress: AssessmentProgress | null;
		  progressHistory: Record<string, AssessmentProgress>;
		  
		  // Results and Scores
		  results: Record<string, AssessmentResults>;
		  cachedScores: Record<string, AssessmentScore[]>;
		  
		  // Privacy and Consent
		  privacyConsent: PrivacyConsent | null;
		  dataCollectionEnabled: boolean;
		  
		  // Sync and Storage
		  syncStatus: SyncStatus;
		  offlineMode: boolean;
		  encryptionEnabled: boolean;
		  
		  // UI State
		  currentQuestionIndex: number;
		  showProgressSave: boolean;
		  assessmentStartTime: number;
		  
		  // Actions - Template Management
		  loadTemplate: (template: AssessmentTemplate) => void;
		  setActiveTemplate: (templateId: string) => void;
		  
		  // Actions - Progress Management
		  startAssessment: (templateId: string, userId: string) => void;
		  saveResponse: (questionId: string, response: AssessmentResponse) => Promise<void>;
		  saveProgress: () => Promise<void>;
		  resumeAssessment: (progressId: string) => void;
		  completeAssessment: () => Promise<AssessmentResults>;
		  
		  // Actions - Results Management
		  calculateScores: (responses: Record<string, AssessmentResponse>) => AssessmentScore[];
		  saveResults: (results: AssessmentResults) => Promise<void>;
		  getResults: (resultId: string) => AssessmentResults | null;
		  
		  // Actions - Privacy Management
		  updatePrivacyConsent: (consent: PrivacyConsent) => void;
		  setDataCollection: (enabled: boolean) => void;
		  exportData: () => Promise<string>;
		  deleteAllData: () => Promise<void>;
		  
		  // Actions - Sync Management
		  setSyncStatus: (status: Partial<SyncStatus>) => void;
		  setOfflineMode: (offline: boolean) => void;
		  getPendingSyncData: () => any[];
		  
		  // Actions - Navigation
		  setCurrentQuestion: (index: number) => void;
		  nextQuestion: () => void;
		  previousQuestion: () => void;
		  goToQuestion: (questionId: string) => void;
		}
		
		export const useAssessmentStore = create<AssessmentState>()(persist(
		    (set, get) => ({
		      // Initial State
		      templates: {},
		      activeTemplateId: null,
		      currentProgress: null,
		      progressHistory: {},
		      results: {},
		      cachedScores: {},
		      privacyConsent: null,
		      dataCollectionEnabled: false,
		      syncStatus: {
		        pendingChanges: 0,
		        needsResolution: false,
		      },
		      offlineMode: false,
		      encryptionEnabled: true,
		      currentQuestionIndex: 0,
		      showProgressSave: false,
		      assessmentStartTime: 0,
		
		      // Template Management
		      loadTemplate: (template) => {
		        set((state) => ({
		          templates: {
		            ...state.templates,
		            [template.id]: template,
		          },
		        }));
		      },
		
		      setActiveTemplate: (templateId) => {
		        set({ activeTemplateId: templateId });
		      },
		
		      // Progress Management
		      startAssessment: (templateId, userId) => {
		        const template = get().templates[templateId];
		        if (!template) throw new Error('Template not found');
		
		        const newProgress: AssessmentProgress = {
		          templateId,
		          userId,
		          startedAt: new Date().toISOString(),
		          lastUpdated: new Date().toISOString(),
		          currentSectionId: template.sections[0]?.id,
		          currentQuestionIndex: 0,
		          totalQuestions: template.totalQuestions,
		          completedQuestions: 0,
		          percentComplete: 0,
		          timeSpent: 0,
		          responses: {},
		          sectionProgress: {},
		        };
		
		        set({
		          currentProgress: newProgress,
		          activeTemplateId: templateId,
		          currentQuestionIndex: 0,
		          assessmentStartTime: Date.now(),
		        });
		      },
		
		      saveResponse: async (questionId, response) => {
		        const state = get();
		        if (!state.currentProgress) return;
		
		        const updatedResponse = {
		          ...response,
		          timestamp: new Date().toISOString(),
		        };
		
		        const updatedProgress = {
		          ...state.currentProgress,
		          responses: {
		            ...state.currentProgress.responses,
		            [questionId]: updatedResponse,
		          },
		          lastUpdated: new Date().toISOString(),
		          completedQuestions: Object.keys(state.currentProgress.responses).length + 1,
		          percentComplete: ((Object.keys(state.currentProgress.responses).length + 1) / state.currentProgress.totalQuestions) * 100,
		        };
		
		        set({ currentProgress: updatedProgress });
		
		        // Auto-save progress every few responses
		        if (updatedProgress.completedQuestions % 5 === 0) {
		          await get().saveProgress();
		        }
		      },
		
		      saveProgress: async () => {
		        const state = get();
		        if (!state.currentProgress) return;
		
		        const progressId = `progress_${state.currentProgress.templateId}_${state.currentProgress.userId}`;
		        
		        if (state.encryptionEnabled) {
		          const encrypted = await EncryptionService.encrypt(JSON.stringify(state.currentProgress));
		          await StorageService.setSecure(progressId, encrypted);
		        } else {
		          await StorageService.set(progressId, JSON.stringify(state.currentProgress));
		        }
		
		        set({
		          progressHistory: {
		            ...state.progressHistory,
		            [progressId]: state.currentProgress,
		          },
		          syncStatus: {
		            ...state.syncStatus,
		            pendingChanges: state.syncStatus.pendingChanges + 1,
		          },
		        });
		      },
		
		      resumeAssessment: (progressId) => {
		        const progress = get().progressHistory[progressId];
		        if (progress) {
		          set({
		            currentProgress: progress,
		            activeTemplateId: progress.templateId,
		            currentQuestionIndex: progress.currentQuestionIndex,
		          });
		        }
		      },
		
		      completeAssessment: async () => {
		        const state = get();
		        if (!state.currentProgress) throw new Error('No assessment in progress');
		
		        const scores = state.calculateScores(state.currentProgress.responses);
		        
		        const results: AssessmentResults = {
		          id: `results_${state.currentProgress.templateId}_${Date.now()}`,
		          templateId: state.currentProgress.templateId,
		          userId: state.currentProgress.userId,
		          completedAt: new Date().toISOString(),
		          totalTimeSpent: Date.now() - state.assessmentStartTime,
		          scores,
		          overallScore: scores.reduce((sum, score) => sum + score.normalizedScore, 0) / scores.length,
		          reliability: calculateReliability(state.currentProgress.responses),
		          validity: calculateValidity(state.currentProgress.responses),
		          insights: generateInsights(scores),
		          recommendations: generateRecommendations(scores),
		          privacyConsent: state.privacyConsent || getDefaultPrivacyConsent(),
		          encrypted: state.encryptionEnabled,
		          synced: false,
		        };
		
		        await get().saveResults(results);
		        
		        set({
		          currentProgress: null,
		          currentQuestionIndex: 0,
		          assessmentStartTime: 0,
		        });
		
		        return results;
		      },
		
		      // Score Calculation
		      calculateScores: (responses) => {
		        const template = get().templates[get().activeTemplateId!];
		        if (!template) return [];
		
		        const scoresByCategory: Record<AssessmentCategory, number[]> = {
		          personality: [],
		          cognitive: [],
		          behavioral: [],
		          emotional: [],
		          social: [],
		          preferences: [],
		          experiences: [],
		          relationships: [],
		        };
		
		        // Group responses by category and calculate raw scores
		        template.sections.forEach(section => {
		          section.questions.forEach(question => {
		            const response = responses[question.id];
		            if (response && typeof response.value === 'number') {
		              scoresByCategory[question.category].push(response.value);
		            }
		          });
		        });
		
		        // Convert to normalized scores
		        const scores: AssessmentScore[] = Object.entries(scoresByCategory)
		          .filter(([_, values]) => values.length > 0)
		          .map(([category, values]) => {
		            const rawScore = values.reduce((sum, val) => sum + val, 0) / values.length;
		            return {
		              category: category as AssessmentCategory,
		              rawScore,
		              normalizedScore: (rawScore / 5) * 100, // Assuming 1-5 scale
		              confidence: calculateScoreConfidence(values),
		            };
		          });
		
		        return scores;
		      },
		
		      saveResults: async (results) => {
		        const state = get();
		        
		        if (state.encryptionEnabled) {
		          const encrypted = await EncryptionService.encrypt(JSON.stringify(results));
		          await StorageService.setSecure(`results_${results.id}`, encrypted);
		        }
		
		        set({
		          results: {
		            ...state.results,
		            [results.id]: results,
		          },
		          cachedScores: {
		            ...state.cachedScores,
		            [results.id]: results.scores,
		          },
		          syncStatus: {
		            ...state.syncStatus,
		            pendingChanges: state.syncStatus.pendingChanges + 1,
		          },
		        });
		      },
		
		      getResults: (resultId) => {
		        return get().results[resultId] || null;
		      },
		
		      // Privacy Management
		      updatePrivacyConsent: (consent) => {
		        set({ privacyConsent: consent });
		      },
		
		      setDataCollection: (enabled) => {
		        set({ dataCollectionEnabled: enabled });
		      },
		
		      exportData: async () => {
		        const state = get();
		        const exportData = {
		          results: state.results,
		          progressHistory: state.progressHistory,
		          privacyConsent: state.privacyConsent,
		          exportedAt: new Date().toISOString(),
		        };
		        return JSON.stringify(exportData, null, 2);
		      },
		
		      deleteAllData: async () => {
		        // Clear secure storage
		        Object.keys(get().results).forEach(async (resultId) => {
		          await StorageService.removeSecure(`results_${resultId}`);
		        });
		
		        Object.keys(get().progressHistory).forEach(async (progressId) => {
		          await StorageService.removeSecure(progressId);
		        });
		
		        set({
		          currentProgress: null,
		          progressHistory: {},
		          results: {},
		          cachedScores: {},
		          privacyConsent: null,
		          dataCollectionEnabled: false,
		        });
		      },
		
		      // Sync Management
		      setSyncStatus: (status) => {
		        set({
		          syncStatus: {
		            ...get().syncStatus,
		            ...status,
		          },
		        });
		      },
		
		      setOfflineMode: (offline) => {
		        set({ offlineMode: offline });
		      },
		
		      getPendingSyncData: () => {
		        const state = get();
		        const pending = [];
		        
		        // Add unsynced results
		        Object.values(state.results)
		          .filter(result => !result.synced)
		          .forEach(result => pending.push({ type: 'result', data: result }));
		
		        return pending;
		      },
		
		      // Navigation
		      setCurrentQuestion: (index) => {
		        set({ currentQuestionIndex: index });
		      },
		
		      nextQuestion: () => {
		        const state = get();
		        const template = state.templates[state.activeTemplateId!];
		        if (template && state.currentQuestionIndex < template.totalQuestions - 1) {
		          set({ currentQuestionIndex: state.currentQuestionIndex + 1 });
		        }
		      },
		
		      previousQuestion: () => {
		        const state = get();
		        if (state.currentQuestionIndex > 0) {
		          set({ currentQuestionIndex: state.currentQuestionIndex - 1 });
		        }
		      },
		
		      goToQuestion: (questionId) => {
		        const state = get();
		        const template = state.templates[state.activeTemplateId!];
		        if (!template) return;
		
		        let questionIndex = 0;
		        let found = false;
		        
		        for (const section of template.sections) {
		          for (const question of section.questions) {
		            if (question.id === questionId) {
		              found = true;
		              break;
		            }
		            questionIndex++;
		          }
		          if (found) break;
		        }
		
		        if (found) {
		          set({ currentQuestionIndex: questionIndex });
		        }
		      },
		    }),
		    {
		      name: 'assessment-storage',
		      storage: createJSONStorage(() => AsyncStorage),
		      partialize: (state) => ({
		        templates: state.templates,
		        progressHistory: state.progressHistory,
		        results: {}, // Don't persist sensitive results in AsyncStorage
		        privacyConsent: state.privacyConsent,
		        dataCollectionEnabled: state.dataCollectionEnabled,
		        encryptionEnabled: state.encryptionEnabled,
		        offlineMode: state.offlineMode,
		      }),
		    }
		  )
		);
		
		// Utility Functions
		function calculateReliability(responses: Record<string, AssessmentResponse>): number {
		  // Calculate consistency based on response patterns and revisit counts
		  const revisitCounts = Object.values(responses).map(r => r.revisitCount || 0);
		  const avgRevisits = revisitCounts.reduce((sum, count) => sum + count, 0) / revisitCounts.length;
		  return Math.max(0, 1 - (avgRevisits / 10)); // Lower revisit count = higher reliability
		}
		
		function calculateValidity(responses: Record<string, AssessmentResponse>): number {
		  // Calculate validity based on response times and confidence levels
		  const validResponses = Object.values(responses).filter(r => 
		    r.timeSpent && r.timeSpent > 1000 && r.confidence && r.confidence > 2
		  );
		  return validResponses.length / Object.keys(responses).length;
		}
		
		function calculateScoreConfidence(values: number[]): number {
		  if (values.length < 2) return 0.5;
		  
		  const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
		  const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
		  const stdDev = Math.sqrt(variance);
		  
		  // Lower standard deviation = higher confidence
		  return Math.max(0.1, Math.min(1, 1 - (stdDev / mean)));
		}
		
		function generateInsights(scores: AssessmentScore[]): string[] {
		  const insights = [];
		  const highScores = scores.filter(s => s.normalizedScore > 75);
		  const lowScores = scores.filter(s => s.normalizedScore < 25);
		  
		  highScores.forEach(score => {
		    insights.push(`Strong ${score.category} traits detected`);
		  });
		  
		  lowScores.forEach(score => {
		    insights.push(`Opportunity for growth in ${score.category}`);
		  });
		  
		  return insights;
		}
		
		function generateRecommendations(scores: AssessmentScore[]): string[] {
		  const recommendations = [];
		  
		  scores.forEach(score => {
		    if (score.normalizedScore < 50) {
		      recommendations.push(`Consider activities to develop ${score.category} skills`);
		    } else if (score.normalizedScore > 80) {
		      recommendations.push(`Leverage your strong ${score.category} abilities`);
		    }
		  });
		  
		  return recommendations;
		}
		
		function getDefaultPrivacyConsent(): PrivacyConsent {
		  return {
		    dataCollection: false,
		    researchParticipation: false,
		    anonymizedSharing: false,
		    twinDataMerging: false,
		    dataRetention: 'until_deleted',
		    consentDate: new Date().toISOString(),
		    consentVersion: '1.0',
		  };
		}]]></file>
	<file path='state/stores/games/gameStore.ts'><![CDATA[
		import { create } from 'zustand';
		import { persist, createJSONStorage } from 'zustand/middleware';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import { GameState, GameSession, PsychicGameType, GameInvitation, Achievement, SyncScoreMetrics } from '../../../types/games';
		import * as Haptics from 'expo-haptics';
		
		interface GameActions {
		  // Session Management
		  createGameSession: (gameType: PsychicGameType, twinId: string) => GameSession;
		  updateGameSession: (sessionId: string, updates: Partial<GameSession>) => void;
		  completeGameSession: (sessionId: string, results: any) => void;
		  cancelGameSession: (sessionId: string) => void;
		  
		  // Invitations
		  sendGameInvitation: (toUserId: string, gameType: PsychicGameType) => void;
		  acceptInvitation: (invitationId: string) => void;
		  declineInvitation: (invitationId: string) => void;
		  
		  // Game Play
		  makeChoice: (sessionId: string, choice: any, responseTime: number) => void;
		  calculateSyncScore: (session: GameSession) => number;
		  
		  // Achievements
		  checkAchievements: () => void;
		  unlockAchievement: (achievementId: string) => void;
		  
		  // Analytics
		  updateSyncMetrics: (session: GameSession) => void;
		  getGameStats: (gameType?: PsychicGameType) => any;
		  
		  // Connection
		  setConnectionStatus: (status: 'online' | 'offline' | 'connecting') => void;
		  
		  // Reset
		  resetGameState: () => void;
		}
		
		type GameStore = GameState & GameActions;
		
		const initialSyncMetrics: SyncScoreMetrics = {
		  totalGames: 0,
		  perfectMatches: 0,
		  streakCount: 0,
		  maxStreak: 0,
		  averageResponseTimeDiff: 0,
		  syncPercentage: 0,
		  gameTypeStats: {
		    color_sync: { played: 0, matches: 0, averageScore: 0 },
		    number_intuition: { played: 0, matches: 0, averageScore: 0 },
		    emotion_mirror: { played: 0, matches: 0, averageScore: 0 },
		    symbol_connection: { played: 0, matches: 0, averageScore: 0 },
		    time_sync: { played: 0, matches: 0, averageScore: 0 }
		  }
		};
		
		const defaultAchievements: Achievement[] = [
		  {
		    id: 'first_match',
		    name: 'First Sync',
		    description: 'Achieve your first perfect match',
		    icon: 'flash',
		    unlocked: false,
		    category: 'sync',
		    requirement: { type: 'perfect_matches', value: 1 }
		  },
		  {
		    id: 'streak_5',
		    name: 'Sync Master',
		    description: 'Get 5 perfect matches in a row',
		    icon: 'flame',
		    unlocked: false,
		    category: 'streak',
		    requirement: { type: 'streak', value: 5 }
		  },
		  {
		    id: 'color_master',
		    name: 'Color Harmony',
		    description: 'Master the Color Sync game with 10 perfect matches',
		    icon: 'color-palette',
		    unlocked: false,
		    category: 'mastery',
		    requirement: { type: 'perfect_matches', value: 10, gameType: 'color_sync' }
		  },
		  {
		    id: 'mind_reader',
		    name: 'Mind Reader',
		    description: 'Achieve 80% sync rate across all games',
		    icon: 'eye',
		    unlocked: false,
		    category: 'special',
		    requirement: { type: 'sync_percentage', value: 80 }
		  }
		];
		
		export const useGameStore = create<GameStore>()(
		  persist(
		    (set, get) => ({
		      // Initial State
		      currentSession: null,
		      gameHistory: [],
		      syncMetrics: initialSyncMetrics,
		      achievements: defaultAchievements,
		      activeInvitations: [],
		      isConnected: false,
		      connectionStatus: 'offline',
		
		      // Session Management
		      createGameSession: (gameType, twinId) => {
		        const session: GameSession = {
		          id: Date.now().toString(),
		          gameType,
		          hostId: 'current_user', // In real app, get from auth
		          twinId,
		          status: 'waiting',
		          createdAt: new Date().toISOString(),
		          difficulty: 'medium',
		          maxRounds: 3,
		          currentRound: 0,
		          results: [],
		          syncScore: 0
		        };
		        
		        set({ currentSession: session });
		        return session;
		      },
		
		      updateGameSession: (sessionId, updates) => {
		        set(state => ({
		          currentSession: state.currentSession?.id === sessionId 
		            ? { ...state.currentSession, ...updates } 
		            : state.currentSession,
		          gameHistory: state.gameHistory.map(session => 
		            session.id === sessionId ? { ...session, ...updates } : session
		          )
		        }));
		      },
		
		      completeGameSession: (sessionId, results) => {
		        const state = get();
		        const session = state.currentSession;
		        
		        if (session && session.id === sessionId) {
		          const completedSession: GameSession = {
		            ...session,
		            status: 'completed',
		            completedAt: new Date().toISOString(),
		            results,
		            syncScore: get().calculateSyncScore(session)
		          };
		          
		          set(state => ({
		            currentSession: null,
		            gameHistory: [completedSession, ...state.gameHistory]
		          }));
		          
		          // Update metrics and check achievements
		          get().updateSyncMetrics(completedSession);
		          get().checkAchievements();
		        }
		      },
		
		      cancelGameSession: (sessionId) => {
		        set(state => ({
		          currentSession: state.currentSession?.id === sessionId ? null : state.currentSession
		        }));
		      },
		
		      // Game Play
		      makeChoice: (sessionId, choice, responseTime) => {
		        const state = get();
		        const session = state.currentSession;
		        
		        if (session && session.id === sessionId) {
		          const updatedSession = {
		            ...session,
		            hostChoice: choice,
		            status: 'in_progress' as const
		          };
		          
		          set({ currentSession: updatedSession });
		          
		          // Simulate twin response (in real app, wait for WebSocket)
		          setTimeout(() => {
		            get().simulateTwinResponse(sessionId, responseTime);
		          }, 1000 + Math.random() * 2000);
		        }
		      },
		
		      simulateTwinResponse: (sessionId: string, hostResponseTime: number) => {
		        console.log('Simulating twin response for session:', sessionId);
		        const state = get();
		        const session = state.currentSession;
		        
		        if (session && session.id === sessionId) {
		          const twinResponseTime = hostResponseTime + (Math.random() - 0.5) * 1000;
		          const isMatch = Math.random() > 0.6; // 40% match rate for demo
		          
		          let twinChoice;
		          if (session.gameType === 'color_sync') {
		            const colors = ['#ff1493', '#00bfff', '#00ff7f', '#ffff00', '#8a2be2', '#ff4500'];
		            twinChoice = isMatch ? session.hostChoice : colors[Math.floor(Math.random() * colors.length)];
		          } else if (session.gameType === 'number_intuition') {
		            twinChoice = isMatch ? session.hostChoice : Math.floor(Math.random() * 10) + 1;
		          } else {
		            twinChoice = session.hostChoice; // Default to match for other games
		          }
		          
		          const roundResult = {
		            round: session.currentRound + 1,
		            hostChoice: session.hostChoice,
		            twinChoice,
		            isMatch: session.hostChoice === twinChoice,
		            responseTimeDiff: Math.abs(hostResponseTime - twinResponseTime),
		            timestamp: new Date().toISOString()
		          };
		          
		          const updatedSession = {
		            ...session,
		            twinChoice,
		            currentRound: session.currentRound + 1,
		            results: [...session.results, roundResult]
		          };
		          
		          set({ currentSession: updatedSession });
		          
		          // Haptic feedback
		          if (roundResult.isMatch) {
		            Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		          } else {
		            Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
		          }
		          
		          // Complete game if max rounds reached
		          if (updatedSession.currentRound >= updatedSession.maxRounds) {
		            setTimeout(() => {
		              get().completeGameSession(sessionId, updatedSession.results);
		            }, 2000);
		          }
		        }
		      },
		
		      calculateSyncScore: (session) => {
		        if (session.results.length === 0) return 0;
		        
		        const matches = session.results.filter(r => r.isMatch).length;
		        const baseScore = (matches / session.results.length) * 100;
		        
		        // Bonus for response time synchronicity
		        const avgTimeDiff = session.results.reduce((sum, r) => sum + r.responseTimeDiff, 0) / session.results.length;
		        const timeBonus = Math.max(0, (2000 - avgTimeDiff) / 2000) * 20;
		        
		        return Math.round(Math.min(100, baseScore + timeBonus));
		      },
		
		      // Achievements
		      checkAchievements: () => {
		        const state = get();
		        const { syncMetrics, achievements } = state;
		        
		        achievements.forEach(achievement => {
		          if (!achievement.unlocked) {
		            let shouldUnlock = false;
		            
		            switch (achievement.requirement.type) {
		              case 'perfect_matches':
		                if (achievement.requirement.gameType) {
		                  const gameStats = syncMetrics.gameTypeStats[achievement.requirement.gameType];
		                  shouldUnlock = gameStats.matches >= achievement.requirement.value;
		                } else {
		                  shouldUnlock = syncMetrics.perfectMatches >= achievement.requirement.value;
		                }
		                break;
		              case 'streak':
		                shouldUnlock = syncMetrics.maxStreak >= achievement.requirement.value;
		                break;
		              case 'sync_percentage':
		                shouldUnlock = syncMetrics.syncPercentage >= achievement.requirement.value;
		                break;
		            }
		            
		            if (shouldUnlock) {
		              get().unlockAchievement(achievement.id);
		            }
		          }
		        });
		      },
		
		      unlockAchievement: (achievementId) => {
		        set(state => ({
		          achievements: state.achievements.map(achievement =>
		            achievement.id === achievementId
		              ? { ...achievement, unlocked: true, unlockedAt: new Date().toISOString() }
		              : achievement
		          )
		        }));
		        
		        Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
		      },
		
		      // Metrics
		      updateSyncMetrics: (session) => {
		        set(state => {
		          const currentStats = state.syncMetrics.gameTypeStats[session.gameType];
		          const matches = session.results.filter(r => r.isMatch).length;
		          const newMatches = matches > 0;
		          
		          const updatedGameTypeStats = {
		            ...state.syncMetrics.gameTypeStats,
		            [session.gameType]: {
		              played: currentStats.played + 1,
		              matches: currentStats.matches + matches,
		              averageScore: ((currentStats.averageScore * currentStats.played) + session.syncScore) / (currentStats.played + 1)
		            }
		          };
		          
		          const totalMatches = Object.values(updatedGameTypeStats).reduce((sum, stats) => sum + stats.matches, 0);
		          const totalGames = Object.values(updatedGameTypeStats).reduce((sum, stats) => sum + stats.played, 0);
		          
		          const newStreak = newMatches ? state.syncMetrics.streakCount + 1 : 0;
		          
		          return {
		            syncMetrics: {
		              ...state.syncMetrics,
		              totalGames,
		              perfectMatches: totalMatches,
		              streakCount: newStreak,
		              maxStreak: Math.max(state.syncMetrics.maxStreak, newStreak),
		              syncPercentage: totalGames > 0 ? Math.round((totalMatches / totalGames) * 100) : 0,
		              gameTypeStats: updatedGameTypeStats
		            }
		          };
		        });
		      },
		
		      getGameStats: (gameType) => {
		        const { syncMetrics } = get();
		        
		        if (gameType) {
		          return syncMetrics.gameTypeStats[gameType];
		        }
		        
		        return {
		          totalGames: syncMetrics.totalGames,
		          perfectMatches: syncMetrics.perfectMatches,
		          syncPercentage: syncMetrics.syncPercentage,
		          streak: syncMetrics.streakCount,
		          maxStreak: syncMetrics.maxStreak
		        };
		      },
		
		      // Invitations (placeholder for real-time features)
		      sendGameInvitation: (toUserId, gameType) => {
		        const invitation: GameInvitation = {
		          id: Date.now().toString(),
		          fromUserId: 'current_user',
		          toUserId,
		          gameType,
		          status: 'pending',
		          createdAt: new Date().toISOString(),
		          expiresAt: new Date(Date.now() + 5 * 60 * 1000).toISOString() // 5 minutes
		        };
		        
		        set(state => ({
		          activeInvitations: [...state.activeInvitations, invitation]
		        }));
		      },
		
		      acceptInvitation: (invitationId) => {
		        set(state => ({
		          activeInvitations: state.activeInvitations.map(inv =>
		            inv.id === invitationId ? { ...inv, status: 'accepted' } : inv
		          )
		        }));
		      },
		
		      declineInvitation: (invitationId) => {
		        set(state => ({
		          activeInvitations: state.activeInvitations.map(inv =>
		            inv.id === invitationId ? { ...inv, status: 'declined' } : inv
		          )
		        }));
		      },
		
		      // Connection
		      setConnectionStatus: (status) => {
		        set({ connectionStatus: status, isConnected: status === 'online' });
		      },
		
		      // Reset
		      resetGameState: () => {
		        set({
		          currentSession: null,
		          gameHistory: [],
		          syncMetrics: initialSyncMetrics,
		          achievements: defaultAchievements.map(a => ({ ...a, unlocked: false, unlockedAt: undefined })),
		          activeInvitations: []
		        });
		      }
		    }),
		    {
		      name: 'psychic-games-storage',
		      storage: createJSONStorage(() => AsyncStorage),
		      partialize: (state) => ({
		        gameHistory: state.gameHistory.slice(0, 50), // Keep last 50 games
		        syncMetrics: state.syncMetrics,
		        achievements: state.achievements
		      })
		    }
		  )
		);]]></file>
	<file path='state/stores/pairStore.ts'><![CDATA[
		/**
		 * Pair Store - Twin pair management and analytics
		 * Handles secure twin pairing, data sharing, and relationship insights
		 */
		
		import { create } from 'zustand';
		import { persist, createJSONStorage } from 'zustand/middleware';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import {
		  TwinPairData,
		  PairAnalytics,
		  AssessmentResults,
		  PrivacyConsent,
		  PairMatchingCriteria,
		} from '../types/assessment/types';
		import { SyncService } from '../services/syncService';
		import { storageService } from '../services/storageService';
		import { EncryptionService } from '../services/encryptionService';
		
		export interface PairInvitation {
		  id: string;
		  fromUserId: string;
		  toEmail?: string;
		  toPhone?: string;
		  shareCode: string;
		  createdAt: string;
		  expiresAt: string;
		  status: 'pending' | 'accepted' | 'declined' | 'expired';
		  message?: string;
		}
		
		export interface PairConnection {
		  pairId: string;
		  connectedAt: string;
		  lastInteraction: string;
		  connectionStrength: number; // 0-1 based on interaction frequency
		  sharedActivities: string[];
		  mutualConsent: boolean;
		}
		
		interface PairState {
		  // Pairing Management
		  currentPair: TwinPairData | null;
		  pairHistory: TwinPairData[];
		  pendingInvitations: PairInvitation[];
		  sentInvitations: PairInvitation[];
		  
		  // Analytics and Insights
		  pairAnalytics: PairAnalytics | null;
		  analyticsHistory: Record<string, PairAnalytics>;
		  insightNotifications: Array<{
		    id: string;
		    type: 'similarity' | 'growth' | 'strength' | 'recommendation';
		    title: string;
		    message: string;
		    timestamp: string;
		    read: boolean;
		  }>;
		  
		  // Connection Status
		  connection: PairConnection | null;
		  connectionHistory: PairConnection[];
		  isOnline: boolean;
		  lastSeen: string;
		  
		  // Privacy and Consent
		  sharingConsent: PrivacyConsent | null;
		  dataVisibility: {
		    assessmentResults: boolean;
		    personalInsights: boolean;
		    recommendations: boolean;
		    analytics: boolean;
		  };
		  
		  // Actions - Pairing
		  createInvitation: (email?: string, phone?: string, message?: string) => Promise<PairInvitation>;
		  sendInvitation: (invitation: PairInvitation) => Promise<void>;
		  acceptInvitation: (invitationId: string) => Promise<TwinPairData>;
		  declineInvitation: (invitationId: string) => Promise<void>;
		  unpairTwin: () => Promise<void>;
		  
		  // Actions - Analytics
		  generateAnalytics: (twin1Results: AssessmentResults, twin2Results: AssessmentResults) => Promise<PairAnalytics>;
		  updateAnalytics: () => Promise<void>;
		  getInsights: () => Promise<string[]>;
		  dismissInsightNotification: (notificationId: string) => void;
		  
		  // Actions - Connection
		  updateConnection: (activity: string) => void;
		  setOnlineStatus: (online: boolean) => void;
		  recordInteraction: (type: string, metadata?: any) => void;
		  
		  // Actions - Privacy
		  updateSharingConsent: (consent: Partial<PrivacyConsent>) => Promise<void>;
		  updateDataVisibility: (visibility: Partial<PairState['dataVisibility']>) => void;
		  exportPairData: () => Promise<string>;
		  deletePairData: () => Promise<void>;
		}
		
		export const usePairStore = create<PairState>()(persist(
		    (set, get) => ({
		      // Initial State
		      currentPair: null,
		      pairHistory: [],
		      pendingInvitations: [],
		      sentInvitations: [],
		      pairAnalytics: null,
		      analyticsHistory: {},
		      insightNotifications: [],
		      connection: null,
		      connectionHistory: [],
		      isOnline: false,
		      lastSeen: new Date().toISOString(),
		      sharingConsent: null,
		      dataVisibility: {
		        assessmentResults: false,
		        personalInsights: false,
		        recommendations: false,
		        analytics: false,
		      },
		
		      // Pairing Actions
		      createInvitation: async (email, phone, message) => {
		        const shareCode = await generateShareCode();
		        const invitation: PairInvitation = {
		          id: `inv_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
		          fromUserId: 'current_user_id', // Would get from auth context
		          toEmail: email,
		          toPhone: phone,
		          shareCode,
		          createdAt: new Date().toISOString(),
		          expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), // 7 days
		          status: 'pending',
		          message,
		        };
		        
		        set(state => ({
		          sentInvitations: [...state.sentInvitations, invitation],
		        }));
		        
		        // Store securely
		        await storageService.setSecure(`invitation_${invitation.id}`, invitation);
		        
		        return invitation;
		      },
		
		      sendInvitation: async (invitation) => {
		        // In a real implementation, this would send via email/SMS service
		        console.log('Sending invitation:', invitation);
		        
		        // Upload invitation to cloud for the recipient to find
		        try {
		          await SyncService.syncAssessmentResults(invitation as any, {
		            cloudProvider: 'supabase',
		            encryptCloud: true,
		          });
		        } catch (error) {
		          console.error('Failed to upload invitation:', error);
		          throw error;
		        }
		      },
		
		      acceptInvitation: async (invitationId) => {
		        const invitation = get().pendingInvitations.find(inv => inv.id === invitationId);
		        if (!invitation) throw new Error('Invitation not found');
		        
		        // Create twin pair
		        const pairData: TwinPairData = {
		          pairId: `pair_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
		          twin1Id: invitation.fromUserId,
		          twin2Id: 'current_user_id', // Would get from auth context
		          pairedAt: new Date().toISOString(),
		          bothConsented: false, // Will be updated when both consent
		          sharedAssessments: [],
		          privacyLevel: 'twin_only',
		        };
		        
		        // Update invitation status
		        set(state => ({
		          pendingInvitations: state.pendingInvitations.map(inv =>
		            inv.id === invitationId ? { ...inv, status: 'accepted' } : inv
		          ),
		          currentPair: pairData,
		          pairHistory: [...state.pairHistory, pairData],
		        }));
		        
		        // Store pair data securely
		        await storageService.setSecure(`pair_${pairData.pairId}`, pairData);
		        
		        // Initialize connection
		        const connection: PairConnection = {
		          pairId: pairData.pairId,
		          connectedAt: new Date().toISOString(),
		          lastInteraction: new Date().toISOString(),
		          connectionStrength: 0.1, // Starting value
		          sharedActivities: [],
		          mutualConsent: false,
		        };
		        
		        set({ connection });
		        
		        return pairData;
		      },
		
		      declineInvitation: async (invitationId) => {
		        set(state => ({
		          pendingInvitations: state.pendingInvitations.map(inv =>
		            inv.id === invitationId ? { ...inv, status: 'declined' } : inv
		          ),
		        }));
		        
		        // Remove from secure storage
		        await storageService.removeSecure(`invitation_${invitationId}`);
		      },
		
		      unpairTwin: async () => {
		        const state = get();
		        if (!state.currentPair) return;
		        
		        // Move to history
		        set({
		          currentPair: null,
		          connection: null,
		          pairAnalytics: null,
		        });
		        
		        // Clean up secure storage
		        await storageService.removeSecure(`pair_${state.currentPair.pairId}`);
		        if (state.pairAnalytics) {
		          await storageService.removeSecure(`pair_analytics_${state.currentPair.pairId}`);
		        }
		      },
		
		      // Analytics Actions
		      generateAnalytics: async (twin1Results, twin2Results) => {
		        const state = get();
		        if (!state.currentPair) throw new Error('No active pair');
		        
		        // Verify consent from both twins
		        if (!twin1Results.privacyConsent.twinDataMerging || 
		            !twin2Results.privacyConsent.twinDataMerging) {
		          throw new Error('Both twins must consent to data merging');
		        }
		        
		        const analytics = await SyncService.mergePairData(
		          state.currentPair.pairId,
		          twin1Results,
		          twin2Results
		        );
		        
		        set({
		          pairAnalytics: analytics,
		          analyticsHistory: {
		            ...state.analyticsHistory,
		            [Date.now().toString()]: analytics,
		          },
		        });
		        
		        // Generate insight notifications
		        const insights = generateInsightNotifications(analytics);
		        set(state => ({
		          insightNotifications: [...state.insightNotifications, ...insights],
		        }));
		        
		        return analytics;
		      },
		
		      updateAnalytics: async () => {
		        const state = get();
		        if (!state.currentPair || !state.pairAnalytics) return;
		        
		        // Retrieve latest assessment results and regenerate analytics
		        // This would typically fetch from the assessment store
		        console.log('Updating pair analytics...');
		      },
		
		      getInsights: async () => {
		        const state = get();
		        if (!state.pairAnalytics) return [];
		        
		        const insights = [];
		        
		        // Generate contextual insights based on analytics
		        Object.entries(state.pairAnalytics.similarityScores).forEach(([category, score]) => {
		          if (score > 0.8) {
		            insights.push(`You and your twin are highly similar in ${category}`);
		          } else if (score < 0.3) {
		            insights.push(`You and your twin have complementary ${category} traits`);
		          }
		        });
		        
		        return insights;
		      },
		
		      dismissInsightNotification: (notificationId) => {
		        set(state => ({
		          insightNotifications: state.insightNotifications.map(notif =>
		            notif.id === notificationId ? { ...notif, read: true } : notif
		          ),
		        }));
		      },
		
		      // Connection Actions
		      updateConnection: (activity) => {
		        const state = get();
		        if (!state.connection) return;
		        
		        const updatedConnection = {
		          ...state.connection,
		          lastInteraction: new Date().toISOString(),
		          connectionStrength: Math.min(1, state.connection.connectionStrength + 0.1),
		          sharedActivities: [...new Set([...state.connection.sharedActivities, activity])],
		        };
		        
		        set({
		          connection: updatedConnection,
		          connectionHistory: [...state.connectionHistory, updatedConnection],
		        });
		      },
		
		      setOnlineStatus: (online) => {
		        set({
		          isOnline: online,
		          lastSeen: new Date().toISOString(),
		        });
		      },
		
		      recordInteraction: (type, metadata) => {
		        const state = get();
		        if (!state.connection) return;
		        
		        // Record interaction for analytics
		        console.log('Recording interaction:', { type, metadata, timestamp: new Date().toISOString() });
		        
		        // Update connection strength based on interaction type
		        let strengthIncrease = 0.01; // Base increase
		        
		        switch (type) {
		          case 'assessment_shared':
		            strengthIncrease = 0.1;
		            break;
		          case 'message_sent':
		            strengthIncrease = 0.02;
		            break;
		          case 'game_played':
		            strengthIncrease = 0.05;
		            break;
		          case 'story_shared':
		            strengthIncrease = 0.08;
		            break;
		        }
		        
		        get().updateConnection(type);
		      },
		
		      // Privacy Actions
		      updateSharingConsent: async (consent) => {
		        const state = get();
		        const updatedConsent = {
		          ...state.sharingConsent,
		          ...consent,
		          consentDate: new Date().toISOString(),
		        };
		        
		        set({ sharingConsent: updatedConsent });
		        
		        // Store securely
		        await storageService.setSecure('pair_sharing_consent', updatedConsent);
		        
		        // Update pair consent status
		        if (state.currentPair && consent.twinDataMerging !== undefined) {
		          const updatedPair = {
		            ...state.currentPair,
		            bothConsented: consent.twinDataMerging, // Simplified - would check both twins
		          };
		          
		          set({ currentPair: updatedPair });
		          await storageService.setSecure(`pair_${updatedPair.pairId}`, updatedPair);
		        }
		      },
		
		      updateDataVisibility: (visibility) => {
		        set(state => ({
		          dataVisibility: {
		            ...state.dataVisibility,
		            ...visibility,
		          },
		        }));
		      },
		
		      exportPairData: async () => {
		        const state = get();
		        
		        const exportData = {
		          currentPair: state.currentPair,
		          pairHistory: state.pairHistory,
		          analytics: state.pairAnalytics,
		          analyticsHistory: state.analyticsHistory,
		          connection: state.connection,
		          connectionHistory: state.connectionHistory,
		          sharingConsent: state.sharingConsent,
		          exportedAt: new Date().toISOString(),
		        };
		        
		        return JSON.stringify(exportData, null, 2);
		      },
		
		      deletePairData: async () => {
		        const state = get();
		        
		        // Delete from secure storage
		        if (state.currentPair) {
		          await storageService.removeSecure(`pair_${state.currentPair.pairId}`);
		        }
		        
		        if (state.pairAnalytics) {
		          await storageService.removeSecure(`pair_analytics_${state.currentPair?.pairId}`);
		        }
		        
		        await storageService.removeSecure('pair_sharing_consent');
		        
		        // Clear state
		        set({
		          currentPair: null,
		          pairHistory: [],
		          pairAnalytics: null,
		          analyticsHistory: {},
		          connection: null,
		          connectionHistory: [],
		          sharingConsent: null,
		          insightNotifications: [],
		        });
		      },
		    }),
		    {
		      name: 'pair-storage',
		      storage: createJSONStorage(() => AsyncStorage),
		      partialize: (state) => ({
		        // Only persist non-sensitive data in AsyncStorage
		        dataVisibility: state.dataVisibility,
		        isOnline: state.isOnline,
		        lastSeen: state.lastSeen,
		        insightNotifications: state.insightNotifications.filter(n => !n.read),
		      }),
		    }
		  )
		);
		
		// Utility Functions
		async function generateShareCode(): Promise<string> {
		  const timestamp = Date.now().toString(36);
		  const random = Math.random().toString(36).substr(2, 6).toUpperCase();
		  return `${timestamp}-${random}`;
		}
		
		function generateInsightNotifications(analytics: PairAnalytics): Array<{
		  id: string;
		  type: 'similarity' | 'growth' | 'strength' | 'recommendation';
		  title: string;
		  message: string;
		  timestamp: string;
		  read: boolean;
		}> {
		  const notifications = [];
		  const timestamp = new Date().toISOString();
		  
		  // Similarity insights
		  Object.entries(analytics.similarityScores).forEach(([category, score]) => {
		    if (score > 0.9) {
		      notifications.push({
		        id: `similarity_${category}_${Date.now()}`,
		        type: 'similarity' as const,
		        title: 'Amazing Similarity!',
		        message: `You and your twin are incredibly similar in ${category} (${Math.round(score * 100)}% match)`,
		        timestamp,
		        read: false,
		      });
		    }
		  });
		  
		  // Growth opportunities
		  analytics.growthOpportunities.forEach((opportunity, index) => {
		    notifications.push({
		      id: `growth_${index}_${Date.now()}`,
		      type: 'growth' as const,
		      title: 'Growth Opportunity',
		      message: opportunity,
		      timestamp,
		      read: false,
		    });
		  });
		  
		  // Strengths
		  analytics.strengthAreas.forEach((strength, index) => {
		    notifications.push({
		      id: `strength_${index}_${Date.now()}`,
		      type: 'strength' as const,
		      title: 'Shared Strength',
		      message: strength,
		      timestamp,
		      read: false,
		    });
		  });
		  
		  return notifications;
		}]]></file>
	<file path='state/stores/stories/storyStore.ts'><![CDATA[
		import { create } from 'zustand';
		import { persist, createJSONStorage } from 'zustand/middleware';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import { Story, StoryDraft, StoryFilter, StoryStats, StoryCategory, StoryMedia, StoryMilestone } from '../../../types/stories';
		
		interface StoryState {
		  // Stories & Drafts
		  stories: Story[];
		  drafts: StoryDraft[];
		  currentDraft: StoryDraft | null;
		  
		  // UI State
		  selectedCategory: StoryCategory | 'all';
		  activeFilter: StoryFilter;
		  isCreatingStory: boolean;
		  isUploadingMedia: boolean;
		  uploadProgress: number;
		  
		  // Search & Filter
		  searchText: string;
		  filteredStories: Story[];
		  
		  // Actions - Story Management
		  addStory: (story: Omit<Story, 'id' | 'timestamp' | 'lastModified' | 'collaborations' | 'comments' | 'likes' | 'favorites' | 'views'>) => void;
		  updateStory: (storyId: string, updates: Partial<Story>) => void;
		  deleteStory: (storyId: string) => void;
		  shareStory: (storyId: string, twinId: string, permissions?: 'view' | 'comment' | 'edit') => void;
		  unshareStory: (storyId: string) => void;
		  
		  // Actions - Draft Management
		  saveDraft: (draft: Omit<StoryDraft, 'id' | 'lastSaved' | 'autoSaved'>) => void;
		  updateDraft: (draftId: string, updates: Partial<StoryDraft>) => void;
		  deleteDraft: (draftId: string) => void;
		  setCurrentDraft: (draft: StoryDraft | null) => void;
		  createStoryFromDraft: (draftId: string) => void;
		  
		  // Actions - Media Management
		  addMediaToStory: (storyId: string, media: StoryMedia) => void;
		  removeMediaFromStory: (storyId: string, mediaId: string) => void;
		  compressMedia: (mediaId: string) => Promise<void>;
		  
		  // Actions - Engagement
		  likeStory: (storyId: string, userId: string) => void;
		  unlikeStory: (storyId: string, userId: string) => void;
		  favoriteStory: (storyId: string, userId: string) => void;
		  unfavoriteStory: (storyId: string, userId: string) => void;
		  viewStory: (storyId: string, userId: string) => void;
		  
		  // Actions - Comments & Collaboration
		  addComment: (storyId: string, authorId: string, content: string) => void;
		  updateComment: (storyId: string, commentId: string, content: string) => void;
		  deleteComment: (storyId: string, commentId: string) => void;
		  addCollaboration: (storyId: string, twinId: string, contribution: 'text' | 'media' | 'edit' | 'comment', content?: string) => void;
		  
		  // Actions - Search & Filter
		  setSearchText: (text: string) => void;
		  setSelectedCategory: (category: StoryCategory | 'all') => void;
		  setActiveFilter: (filter: StoryFilter) => void;
		  applyFilters: () => void;
		  clearFilters: () => void;
		  
		  // Actions - UI State
		  setIsCreatingStory: (creating: boolean) => void;
		  setIsUploadingMedia: (uploading: boolean) => void;
		  setUploadProgress: (progress: number) => void;
		  
		  // Getters
		  getStoriesByCategory: (category: StoryCategory) => Story[];
		  getSharedStories: () => Story[];
		  getStoriesWithMedia: () => Story[];
		  getMilestoneStories: () => Story[];
		  getStoryStats: () => StoryStats;
		  getStoriesForTimeline: () => { [year: number]: Story[] };
		  getFavoriteStories: (userId: string) => Story[];
		  getRecentStories: (limit?: number) => Story[];
		}
		
		export const useStoryStore = create<StoryState>()(
		  persist(
		    (set, get) => ({
		      // Initial state
		      stories: [],
		      drafts: [],
		      currentDraft: null,
		      selectedCategory: 'all',
		      activeFilter: {},
		      isCreatingStory: false,
		      isUploadingMedia: false,
		      uploadProgress: 0,
		      searchText: '',
		      filteredStories: [],
		      
		      // Story Management
		      addStory: (storyData) => {
		        const story: Story = {
		          ...storyData,
		          id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
		          timestamp: new Date().toISOString(),
		          lastModified: new Date().toISOString(),
		          collaborations: [],
		          comments: [],
		          likes: [],
		          favorites: [],
		          views: [],
		        };
		        
		        set((state) => ({
		          stories: [story, ...state.stories],
		        }));
		        
		        // Auto-apply filters after adding
		        get().applyFilters();
		      },
		      
		      updateStory: (storyId, updates) => {
		        set((state) => ({
		          stories: state.stories.map((story) =>
		            story.id === storyId
		              ? { ...story, ...updates, lastModified: new Date().toISOString() }
		              : story
		          ),
		        }));
		        get().applyFilters();
		      },
		      
		      deleteStory: (storyId) => {
		        set((state) => ({
		          stories: state.stories.filter((story) => story.id !== storyId),
		        }));
		        get().applyFilters();
		      },
		      
		      shareStory: (storyId, twinId, permissions = 'view') => {
		        set((state) => ({
		          stories: state.stories.map((story) =>
		            story.id === storyId
		              ? {
		                  ...story,
		                  isShared: true,
		                  sharedWith: [...new Set([...story.sharedWith, twinId])],
		                  sharePermissions: permissions,
		                  lastModified: new Date().toISOString(),
		                }
		              : story
		          ),
		        }));
		      },
		      
		      unshareStory: (storyId) => {
		        set((state) => ({
		          stories: state.stories.map((story) =>
		            story.id === storyId
		              ? {
		                  ...story,
		                  isShared: false,
		                  sharedWith: [],
		                  lastModified: new Date().toISOString(),
		                }
		              : story
		          ),
		        }));
		      },
		      
		      // Draft Management
		      saveDraft: (draftData) => {
		        const draft: StoryDraft = {
		          ...draftData,
		          id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
		          lastSaved: new Date().toISOString(),
		          autoSaved: false,
		        };
		        
		        set((state) => ({
		          drafts: [draft, ...state.drafts.slice(0, 9)], // Keep max 10 drafts
		        }));
		      },
		      
		      updateDraft: (draftId, updates) => {
		        set((state) => ({
		          drafts: state.drafts.map((draft) =>
		            draft.id === draftId
		              ? { ...draft, ...updates, lastSaved: new Date().toISOString(), autoSaved: true }
		              : draft
		          ),
		        }));
		      },
		      
		      deleteDraft: (draftId) => {
		        set((state) => ({
		          drafts: state.drafts.filter((draft) => draft.id !== draftId),
		          currentDraft: state.currentDraft?.id === draftId ? null : state.currentDraft,
		        }));
		      },
		      
		      setCurrentDraft: (draft) => {
		        set({ currentDraft: draft });
		      },
		      
		      createStoryFromDraft: (draftId) => {
		        const draft = get().drafts.find(d => d.id === draftId);
		        if (!draft) return;
		        
		        const { id, lastSaved, autoSaved, ...storyData } = draft;
		        get().addStory({
		          ...storyData,
		          authorId: 'current-user', // This should come from user context
		          isShared: false,
		          isPrivate: false,
		          sharedWith: [],
		          sharePermissions: 'view',
		        });
		        
		        get().deleteDraft(draftId);
		      },
		      
		      // Media Management
		      addMediaToStory: (storyId, media) => {
		        set((state) => ({
		          stories: state.stories.map((story) =>
		            story.id === storyId
		              ? { 
		                  ...story, 
		                  media: [...story.media, media],
		                  lastModified: new Date().toISOString(),
		                }
		              : story
		          ),
		        }));
		      },
		      
		      removeMediaFromStory: (storyId, mediaId) => {
		        set((state) => ({
		          stories: state.stories.map((story) =>
		            story.id === storyId
		              ? { 
		                  ...story, 
		                  media: story.media.filter(m => m.id !== mediaId),
		                  lastModified: new Date().toISOString(),
		                }
		              : story
		          ),
		        }));
		      },
		      
		      compressMedia: async (mediaId) => {
		        // This would integrate with a media compression service
		        set({ isUploadingMedia: true, uploadProgress: 0 });
		        
		        // Simulated compression process
		        for (let i = 0; i <= 100; i += 10) {
		          set({ uploadProgress: i });
		          await new Promise(resolve => setTimeout(resolve, 100));
		        }
		        
		        set({ isUploadingMedia: false, uploadProgress: 0 });
		      },
		      
		      // Engagement
		      likeStory: (storyId, userId) => {
		        set((state) => ({
		          stories: state.stories.map((story) =>
		            story.id === storyId
		              ? { 
		                  ...story, 
		                  likes: [...new Set([...story.likes, userId])],
		                }
		              : story
		          ),
		        }));
		      },
		      
		      unlikeStory: (storyId, userId) => {
		        set((state) => ({
		          stories: state.stories.map((story) =>
		            story.id === storyId
		              ? { 
		                  ...story, 
		                  likes: story.likes.filter(id => id !== userId),
		                }
		              : story
		          ),
		        }));
		      },
		      
		      favoriteStory: (storyId, userId) => {
		        set((state) => ({
		          stories: state.stories.map((story) =>
		            story.id === storyId
		              ? { 
		                  ...story, 
		                  favorites: [...new Set([...story.favorites, userId])],
		                }
		              : story
		          ),
		        }));
		      },
		      
		      unfavoriteStory: (storyId, userId) => {
		        set((state) => ({
		          stories: state.stories.map((story) =>
		            story.id === storyId
		              ? { 
		                  ...story, 
		                  favorites: story.favorites.filter(id => id !== userId),
		                }
		              : story
		          ),
		        }));
		      },
		      
		      viewStory: (storyId, userId) => {
		        set((state) => ({
		          stories: state.stories.map((story) =>
		            story.id === storyId
		              ? { 
		                  ...story, 
		                  views: [...story.views, { userId, timestamp: new Date().toISOString() }],
		                }
		              : story
		          ),
		        }));
		      },
		      
		      // Comments & Collaboration
		      addComment: (storyId, authorId, content) => {
		        const comment = {
		          id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
		          authorId,
		          content,
		          timestamp: new Date().toISOString(),
		        };
		        
		        set((state) => ({
		          stories: state.stories.map((story) =>
		            story.id === storyId
		              ? { 
		                  ...story, 
		                  comments: [...story.comments, comment],
		                  lastModified: new Date().toISOString(),
		                }
		              : story
		          ),
		        }));
		      },
		      
		      updateComment: (storyId, commentId, content) => {
		        set((state) => ({
		          stories: state.stories.map((story) =>
		            story.id === storyId
		              ? { 
		                  ...story, 
		                  comments: story.comments.map(comment =>
		                    comment.id === commentId
		                      ? { ...comment, content, isEdited: true }
		                      : comment
		                  ),
		                  lastModified: new Date().toISOString(),
		                }
		              : story
		          ),
		        }));
		      },
		      
		      deleteComment: (storyId, commentId) => {
		        set((state) => ({
		          stories: state.stories.map((story) =>
		            story.id === storyId
		              ? { 
		                  ...story, 
		                  comments: story.comments.filter(comment => comment.id !== commentId),
		                  lastModified: new Date().toISOString(),
		                }
		              : story
		          ),
		        }));
		      },
		      
		      addCollaboration: (storyId, twinId, contribution, content) => {
		        const collaboration = {
		          twinId,
		          contributedAt: new Date().toISOString(),
		          contribution,
		          content,
		        };
		        
		        set((state) => ({
		          stories: state.stories.map((story) =>
		            story.id === storyId
		              ? { 
		                  ...story, 
		                  collaborations: [...story.collaborations, collaboration],
		                  lastModified: new Date().toISOString(),
		                }
		              : story
		          ),
		        }));
		      },
		      
		      // Search & Filter
		      setSearchText: (text) => {
		        set({ searchText: text });
		        get().applyFilters();
		      },
		      
		      setSelectedCategory: (category) => {
		        set({ selectedCategory: category });
		        get().applyFilters();
		      },
		      
		      setActiveFilter: (filter) => {
		        set({ activeFilter: filter });
		        get().applyFilters();
		      },
		      
		      applyFilters: () => {
		        const { stories, selectedCategory, activeFilter, searchText } = get();
		        
		        let filtered = [...stories];
		        
		        // Apply category filter
		        if (selectedCategory !== 'all') {
		          filtered = filtered.filter(story => story.category === selectedCategory);
		        }
		        
		        // Apply search text
		        if (searchText.trim()) {
		          const searchLower = searchText.toLowerCase();
		          filtered = filtered.filter(story =>
		            story.title.toLowerCase().includes(searchLower) ||
		            story.content.toLowerCase().includes(searchLower) ||
		            story.tags.some(tag => tag.toLowerCase().includes(searchLower))
		          );
		        }
		        
		        // Apply additional filters
		        if (activeFilter.categories?.length) {
		          filtered = filtered.filter(story => activeFilter.categories!.includes(story.category));
		        }
		        
		        if (activeFilter.tags?.length) {
		          filtered = filtered.filter(story =>
		            story.tags.some(tag => activeFilter.tags!.includes(tag))
		          );
		        }
		        
		        if (activeFilter.dateRange) {
		          const start = new Date(activeFilter.dateRange.start);
		          const end = new Date(activeFilter.dateRange.end);
		          filtered = filtered.filter(story => {
		            const storyDate = new Date(story.timestamp);
		            return storyDate >= start && storyDate <= end;
		          });
		        }
		        
		        if (activeFilter.milestoneOnly) {
		          filtered = filtered.filter(story => !!story.milestone);
		        }
		        
		        if (activeFilter.sharedOnly) {
		          filtered = filtered.filter(story => story.isShared);
		        }
		        
		        if (activeFilter.hasMedia) {
		          filtered = filtered.filter(story => story.media.length > 0);
		        }
		        
		        set({ filteredStories: filtered });
		      },
		      
		      clearFilters: () => {
		        set({
		          selectedCategory: 'all',
		          activeFilter: {},
		          searchText: '',
		          filteredStories: get().stories,
		        });
		      },
		      
		      // UI State
		      setIsCreatingStory: (creating) => {
		        set({ isCreatingStory: creating });
		      },
		      
		      setIsUploadingMedia: (uploading) => {
		        set({ isUploadingMedia: uploading });
		      },
		      
		      setUploadProgress: (progress) => {
		        set({ uploadProgress: progress });
		      },
		      
		      // Getters
		      getStoriesByCategory: (category) => {
		        return get().stories.filter(story => story.category === category);
		      },
		      
		      getSharedStories: () => {
		        return get().stories.filter(story => story.isShared);
		      },
		      
		      getStoriesWithMedia: () => {
		        return get().stories.filter(story => story.media.length > 0);
		      },
		      
		      getMilestoneStories: () => {
		        return get().stories.filter(story => !!story.milestone);
		      },
		      
		      getStoryStats: (): StoryStats => {
		        const stories = get().stories;
		        const now = new Date();
		        const thisMonth = new Date(now.getFullYear(), now.getMonth(), 1);
		        
		        return {
		          totalStories: stories.length,
		          storiesThisMonth: stories.filter(s => new Date(s.timestamp) >= thisMonth).length,
		          categoryCounts: stories.reduce((counts, story) => {
		            counts[story.category] = (counts[story.category] || 0) + 1;
		            return counts;
		          }, {} as Record<StoryCategory, number>),
		          totalMedia: stories.reduce((sum, story) => sum + story.media.length, 0),
		          totalViews: stories.reduce((sum, story) => sum + story.views.length, 0),
		          totalLikes: stories.reduce((sum, story) => sum + story.likes.length, 0),
		          collaborationCount: stories.reduce((sum, story) => sum + story.collaborations.length, 0),
		          milestoneCount: stories.filter(s => !!s.milestone).length,
		        };
		      },
		      
		      getStoriesForTimeline: () => {
		        const stories = get().stories;
		        return stories.reduce((timeline, story) => {
		          const year = new Date(story.timestamp).getFullYear();
		          if (!timeline[year]) timeline[year] = [];
		          timeline[year].push(story);
		          return timeline;
		        }, {} as { [year: number]: Story[] });
		      },
		      
		      getFavoriteStories: (userId) => {
		        return get().stories.filter(story => story.favorites.includes(userId));
		      },
		      
		      getRecentStories: (limit = 10) => {
		        return get().stories
		          .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
		          .slice(0, limit);
		      },
		    }),
		    {
		      name: 'story-storage',
		      storage: createJSONStorage(() => AsyncStorage),
		      partialize: (state) => ({
		        stories: state.stories,
		        drafts: state.drafts,
		        selectedCategory: state.selectedCategory,
		      }),
		    }
		  )
		);]]></file>
	<file path='state/subscriptionStore.ts'><![CDATA[
		import { create } from "zustand";
		import { persist, createJSONStorage } from "zustand/middleware";
		import AsyncStorage from "@react-native-async-storage/async-storage";
		import { SubscriptionInfo, SubscriptionPlan, SubscriptionStatus, PurchaseResult } from "../types/premium/subscription";
		
		interface SubscriptionState {
		  // Subscription status
		  subscriptionInfo: SubscriptionInfo;
		  isLoading: boolean;
		  error: string | null;
		  
		  // Premium feature access
		  hasAccessTo: (featureId: string) => boolean;
		  
		  // Purchase flow
		  isPurchasing: boolean;
		  isRestoring: boolean;
		  
		  // Analytics
		  conversionEvents: Array<{
		    event: string;
		    timestamp: string;
		    context?: Record<string, any>;
		  }>;
		  
		  // Actions
		  setSubscriptionInfo: (info: SubscriptionInfo) => void;
		  setLoading: (loading: boolean) => void;
		  setError: (error: string | null) => void;
		  setPurchasing: (purchasing: boolean) => void;
		  setRestoring: (restoring: boolean) => void;
		  
		  // Premium feature checks
		  canAccessFeature: (featureId: string) => boolean;
		  getPremiumUpsellData: (featureId: string) => { shouldShow: boolean; message: string; };
		  
		  // Analytics tracking
		  trackConversionEvent: (event: string, context?: Record<string, any>) => void;
		  
		  // Mock purchase functions (to be replaced with RevenueCat)
		  mockPurchase: (productId: string) => Promise<PurchaseResult>;
		  mockRestore: () => Promise<void>;
		  
		  // Reset
		  reset: () => void;
		}
		
		const initialSubscriptionInfo: SubscriptionInfo = {
		  isActive: false,
		  plan: "free",
		  status: "inactive",
		  willRenew: false,
		};
		
		export const useSubscriptionStore = create<SubscriptionState>()(
		  persist(
		    (set, get) => ({
		      // Initial state
		      subscriptionInfo: initialSubscriptionInfo,
		      isLoading: false,
		      error: null,
		      isPurchasing: false,
		      isRestoring: false,
		      conversionEvents: [],
		      
		      // Premium access checker
		      hasAccessTo: (featureId: string): boolean => {
		        const { subscriptionInfo } = get();
		        if (!subscriptionInfo.isActive) return false;
		        
		        // All premium features require active subscription
		        const premiumFeatures = [
		          "detailed_results",
		          "coaching_plans", 
		          "pdf_export",
		          "twin_analytics",
		          "recommendations",
		          "unlimited_assessments"
		        ];
		        
		        return premiumFeatures.includes(featureId);
		      },
		      
		      canAccessFeature: (featureId: string): boolean => {
		        return get().hasAccessTo(featureId);
		      },
		      
		      getPremiumUpsellData: (featureId: string) => {
		        const hasAccess = get().hasAccessTo(featureId);
		        
		        if (hasAccess) {
		          return { shouldShow: false, message: "" };
		        }
		        
		        const upsellMessages: Record<string, string> = {
		          detailed_results: "Unlock detailed personality insights and twin dynamics analysis",
		          coaching_plans: "Get personalized weekly exercises to strengthen your bond",
		          pdf_export: "Export professional reports to save and share",
		          twin_analytics: "Access comprehensive progress tracking dashboard",
		          recommendations: "Receive AI-powered insights based on your twin dynamics",
		          unlimited_assessments: "Retake assessments monthly to track your progress"
		        };
		        
		        return {
		          shouldShow: true,
		          message: upsellMessages[featureId] || "Upgrade to Premium for full access"
		        };
		      },
		      
		      // Actions
		      setSubscriptionInfo: (info) => set({ subscriptionInfo: info }),
		      setLoading: (loading) => set({ isLoading: loading }),
		      setError: (error) => set({ error }),
		      setPurchasing: (purchasing) => set({ isPurchasing: purchasing }),
		      setRestoring: (restoring) => set({ isRestoring: restoring }),
		      
		      trackConversionEvent: (event, context) => {
		        const newEvent = {
		          event,
		          timestamp: new Date().toISOString(),
		          context
		        };
		        
		        set((state) => ({
		          conversionEvents: [newEvent, ...state.conversionEvents.slice(0, 99)] // Keep last 100
		        }));
		      },
		      
		      // Mock functions for development (replace with RevenueCat implementation)
		      mockPurchase: async (productId: string): Promise<PurchaseResult> => {
		        set({ isPurchasing: true, error: null });
		        
		        try {
		          // Simulate purchase delay
		          await new Promise(resolve => setTimeout(resolve, 2000));
		          
		          // Mock successful purchase
		          const newSubscriptionInfo: SubscriptionInfo = {
		            isActive: true,
		            plan: productId.includes("monthly") ? "monthly" : "yearly",
		            status: "active",
		            purchaseDate: new Date().toISOString(),
		            expiryDate: new Date(Date.now() + (productId.includes("monthly") ? 30 : 365) * 24 * 60 * 60 * 1000).toISOString(),
		            productId,
		            willRenew: true,
		            originalTransactionId: `mock_${Date.now()}`
		          };
		          
		          set({ subscriptionInfo: newSubscriptionInfo, isPurchasing: false });
		          
		          // Track conversion
		          get().trackConversionEvent("purchase_completed", { productId });
		          
		          return {
		            success: true,
		            productId,
		            transactionId: newSubscriptionInfo.originalTransactionId
		          };
		        } catch (error) {
		          set({ isPurchasing: false, error: "Purchase failed" });
		          return {
		            success: false,
		            error: "Purchase failed"
		          };
		        }
		      },
		      
		      mockRestore: async () => {
		        set({ isRestoring: true, error: null });
		        
		        try {
		          await new Promise(resolve => setTimeout(resolve, 1500));
		          
		          // Mock restore - could restore previous purchase or do nothing
		          const hasValidPurchase = Math.random() > 0.5; // 50% chance of finding purchase
		          
		          if (hasValidPurchase) {
		            const restoredInfo: SubscriptionInfo = {
		              isActive: true,
		              plan: "yearly",
		              status: "active",
		              purchaseDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),
		              expiryDate: new Date(Date.now() + 335 * 24 * 60 * 60 * 1000).toISOString(),
		              productId: "twinship_yearly",
		              willRenew: true,
		              originalTransactionId: `restored_${Date.now()}`
		            };
		            
		            set({ subscriptionInfo: restoredInfo });
		            get().trackConversionEvent("purchase_restored", { plan: "yearly" });
		          }
		          
		          set({ isRestoring: false });
		        } catch (error) {
		          set({ isRestoring: false, error: "Restore failed" });
		        }
		      },
		      
		      reset: () => set({
		        subscriptionInfo: initialSubscriptionInfo,
		        isLoading: false,
		        error: null,
		        isPurchasing: false,
		        isRestoring: false,
		        conversionEvents: []
		      })
		    }),
		    {
		      name: "subscription-storage",
		      storage: createJSONStorage(() => AsyncStorage),
		      partialize: (state) => ({
		        subscriptionInfo: state.subscriptionInfo,
		        conversionEvents: state.conversionEvents
		      }),
		    }
		  )
		);]]></file>
	<file path='state/telemetryStore.ts'><![CDATA[
		/**
		 * Telemetry Store - Privacy-First State Management for Assessment Analytics
		 * Manages telemetry configuration, consent, and real-time monitoring
		 */
		
		import { create } from 'zustand';
		import { persist, createJSONStorage } from 'zustand/middleware';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import { 
		  TelemetryConfig, 
		  TelemetryAlert, 
		  TelemetryDashboardData,
		  NormingStatistics,
		  ItemAnalysis,
		  AnonymousSession,
		  TelemetryPrivacyLevel
		} from '../types/telemetry';
		
		interface TelemetryState {
		  // Configuration & Consent
		  config: TelemetryConfig;
		  userConsent: boolean;
		  consentTimestamp?: string;
		  consentVersion: string;
		
		  // Session Management
		  currentSession: AnonymousSession | null;
		  sessionHistory: Partial<AnonymousSession>[];
		  
		  // Real-time Monitoring
		  alerts: TelemetryAlert[];
		  isMonitoring: boolean;
		  lastAlertCheck: string;
		  
		  // Analytics Data
		  dashboardData: TelemetryDashboardData | null;
		  normingStatistics: Map<string, NormingStatistics>;
		  itemAnalyses: Map<string, ItemAnalysis>;
		  
		  // Performance Metrics
		  performanceMetrics: {
		    averageResponseTime: number;
		    dataQualityScore: number;
		    anomalyRate: number;
		    systemLoad: number;
		    lastUpdated: string;
		  };
		
		  // Queue Management
		  eventQueueSize: number;
		  batchesProcessed: number;
		  failedBatches: number;
		  lastBatchTimestamp?: string;
		}
		
		interface TelemetryActions {
		  // Configuration
		  updateConfig: (config: Partial<TelemetryConfig>) => void;
		  updateConsent: (consent: boolean) => Promise<void>;
		  resetConfiguration: () => void;
		
		  // Session Management
		  setCurrentSession: (session: AnonymousSession | null) => void;
		  addToSessionHistory: (session: Partial<AnonymousSession>) => void;
		  clearSessionHistory: () => void;
		
		  // Alert Management
		  addAlert: (alert: Omit<TelemetryAlert, 'id'>) => void;
		  resolveAlert: (alertId: string) => void;
		  clearAlerts: () => void;
		  markAlertAsRead: (alertId: string) => void;
		
		  // Analytics
		  updateDashboardData: (data: TelemetryDashboardData) => void;
		  addNormingStatistics: (questionId: string, stats: NormingStatistics) => void;
		  addItemAnalysis: (questionId: string, analysis: ItemAnalysis) => void;
		  clearAnalyticsData: () => void;
		
		  // Performance
		  updatePerformanceMetrics: (metrics: Partial<TelemetryState['performanceMetrics']>) => void;
		  incrementEventQueue: () => void;
		  decrementEventQueue: () => void;
		  incrementBatchesProcessed: () => void;
		  incrementFailedBatches: () => void;
		
		  // Utilities
		  getPrivacyCompliantData: () => Partial<TelemetryState>;
		  exportData: () => string;
		  importData: (data: string) => void;
		  getTelemetryStatus: () => 'disabled' | 'enabled' | 'consent_required' | 'error';
		}
		
		const initialConfig: TelemetryConfig = {
		  enabled: false,
		  privacyLevel: 'anonymous',
		  collectPerformanceMetrics: true,
		  collectAnomalyData: true,
		  collectNormingData: true,
		  batchSize: 50,
		  maxRetries: 3,
		  retentionDays: 90,
		  encryptionEnabled: true,
		  consentRequired: true,
		  anonymizationDelay: 300000, // 5 minutes
		};
		
		const initialPerformanceMetrics = {
		  averageResponseTime: 0,
		  dataQualityScore: 1.0,
		  anomalyRate: 0,
		  systemLoad: 0,
		  lastUpdated: new Date().toISOString(),
		};
		
		export const useTelemetryStore = create<TelemetryState & TelemetryActions>()(
		  persist(
		    (set, get) => ({
		      // Initial State
		      config: initialConfig,
		      userConsent: false,
		      consentVersion: '1.0.0',
		      currentSession: null,
		      sessionHistory: [],
		      alerts: [],
		      isMonitoring: false,
		      lastAlertCheck: new Date().toISOString(),
		      dashboardData: null,
		      normingStatistics: new Map(),
		      itemAnalyses: new Map(),
		      performanceMetrics: initialPerformanceMetrics,
		      eventQueueSize: 0,
		      batchesProcessed: 0,
		      failedBatches: 0,
		
		      // Configuration Actions
		      updateConfig: (newConfig) => 
		        set((state) => ({
		          config: { ...state.config, ...newConfig },
		        })),
		
		      resetConfiguration: () =>
		        set(() => ({
		          config: initialConfig,
		          userConsent: false,
		          consentTimestamp: undefined,
		        })),
		
		      updateConsent: async (consent: boolean) => {
		        const timestamp = new Date().toISOString();
		        set((state) => ({
		          userConsent: consent,
		          consentTimestamp: timestamp,
		          config: { ...state.config, enabled: consent },
		        }));
		
		        // Clear sensitive data if consent withdrawn
		        if (!consent) {
		          set((state) => ({
		            currentSession: null,
		            sessionHistory: [],
		            alerts: state.alerts.filter(alert => alert.type !== 'data_concern'),
		            dashboardData: null,
		            normingStatistics: new Map(),
		            itemAnalyses: new Map(),
		          }));
		        }
		      },
		
		      // Session Management
		      setCurrentSession: (session) =>
		        set(() => ({ currentSession: session })),
		
		      addToSessionHistory: (session) =>
		        set((state) => ({
		          sessionHistory: [
		            ...state.sessionHistory.slice(-19), // Keep last 20 sessions
		            session,
		          ],
		        })),
		
		      clearSessionHistory: () =>
		        set(() => ({ sessionHistory: [] })),
		
		      // Alert Management
		      addAlert: (alertData) => {
		        const alert: TelemetryAlert = {
		          ...alertData,
		          id: `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
		          timestamp: new Date().toISOString(),
		          resolved: false,
		        };
		
		        set((state) => ({
		          alerts: [alert, ...state.alerts.slice(0, 49)], // Keep last 50 alerts
		        }));
		
		        // Auto-resolve low-priority info alerts after 5 minutes
		        if (alert.severity === 'info') {
		          setTimeout(() => {
		            get().resolveAlert(alert.id);
		          }, 300000);
		        }
		      },
		
		      resolveAlert: (alertId) =>
		        set((state) => ({
		          alerts: state.alerts.map((alert) =>
		            alert.id === alertId
		              ? { ...alert, resolved: true, resolvedAt: new Date().toISOString() }
		              : alert
		          ),
		        })),
		
		      markAlertAsRead: (alertId) =>
		        set((state) => ({
		          alerts: state.alerts.map((alert) =>
		            alert.id === alertId
		              ? { ...alert, context: { ...alert.context, read: true } }
		              : alert
		          ),
		        })),
		
		      clearAlerts: () =>
		        set(() => ({ alerts: [] })),
		
		      // Analytics Actions
		      updateDashboardData: (data) =>
		        set(() => ({ 
		          dashboardData: data,
		          performanceMetrics: {
		            ...get().performanceMetrics,
		            lastUpdated: new Date().toISOString(),
		          },
		        })),
		
		      addNormingStatistics: (questionId, stats) =>
		        set((state) => {
		          const newMap = new Map(state.normingStatistics);
		          newMap.set(questionId, stats);
		          return { normingStatistics: newMap };
		        }),
		
		      addItemAnalysis: (questionId, analysis) =>
		        set((state) => {
		          const newMap = new Map(state.itemAnalyses);
		          newMap.set(questionId, analysis);
		          return { itemAnalyses: newMap };
		        }),
		
		      clearAnalyticsData: () =>
		        set(() => ({
		          dashboardData: null,
		          normingStatistics: new Map(),
		          itemAnalyses: new Map(),
		        })),
		
		      // Performance Actions
		      updatePerformanceMetrics: (metrics) =>
		        set((state) => ({
		          performanceMetrics: {
		            ...state.performanceMetrics,
		            ...metrics,
		            lastUpdated: new Date().toISOString(),
		          },
		        })),
		
		      incrementEventQueue: () =>
		        set((state) => ({ eventQueueSize: state.eventQueueSize + 1 })),
		
		      decrementEventQueue: () =>
		        set((state) => ({ 
		          eventQueueSize: Math.max(0, state.eventQueueSize - 1) 
		        })),
		
		      incrementBatchesProcessed: () =>
		        set((state) => ({
		          batchesProcessed: state.batchesProcessed + 1,
		          lastBatchTimestamp: new Date().toISOString(),
		        })),
		
		      incrementFailedBatches: () =>
		        set((state) => ({ failedBatches: state.failedBatches + 1 })),
		
		      // Utility Actions
		      getPrivacyCompliantData: () => {
		        const state = get();
		        
		        // Return only non-sensitive data based on privacy level
		        const baseData = {
		          config: {
		            ...state.config,
		            // Remove any potentially sensitive config
		          },
		          userConsent: state.userConsent,
		          consentVersion: state.consentVersion,
		          performanceMetrics: state.performanceMetrics,
		          eventQueueSize: state.eventQueueSize,
		          batchesProcessed: state.batchesProcessed,
		          isMonitoring: state.isMonitoring,
		        };
		
		        if (state.config.privacyLevel === 'anonymous') {
		          return baseData;
		        }
		
		        // Add more data for higher privacy levels if consented
		        if (state.userConsent && state.config.privacyLevel === 'pseudonymous') {
		          return {
		            ...baseData,
		            sessionHistory: state.sessionHistory.map(session => ({
		              sessionId: session.sessionId,
		              startTime: session.startTime,
		              endTime: session.endTime,
		              dataQualityScore: session.dataQualityScore,
		              flagged: session.flagged,
		            })),
		            alerts: state.alerts.filter(alert => 
		              alert.type !== 'data_concern' && !alert.resolved
		            ),
		          };
		        }
		
		        return baseData;
		      },
		
		      exportData: () => {
		        const privacyCompliantData = get().getPrivacyCompliantData();
		        return JSON.stringify(privacyCompliantData, null, 2);
		      },
		
		      importData: (data: string) => {
		        try {
		          const importedData = JSON.parse(data);
		          
		          // Validate and safely merge imported data
		          set((state) => ({
		            ...state,
		            config: { ...state.config, ...importedData.config },
		            performanceMetrics: { 
		              ...state.performanceMetrics, 
		              ...importedData.performanceMetrics 
		            },
		            // Only import non-sensitive data
		            userConsent: importedData.userConsent || false,
		            consentVersion: importedData.consentVersion || state.consentVersion,
		          }));
		        } catch (error) {
		          console.error('Failed to import telemetry data:', error);
		          get().addAlert({
		            type: 'system_error',
		            severity: 'error',
		            message: 'Failed to import telemetry configuration',
		            context: { error: error instanceof Error ? error.message : 'Unknown error' },
		          });
		        }
		      },
		
		      getTelemetryStatus: () => {
		        const state = get();
		        
		        if (!state.config.enabled) return 'disabled';
		        if (state.config.consentRequired && !state.userConsent) return 'consent_required';
		        if (state.failedBatches > state.batchesProcessed * 0.5) return 'error';
		        return 'enabled';
		      },
		    }),
		    {
		      name: 'telemetry-storage',
		      storage: createJSONStorage(() => AsyncStorage),
		      
		      // Serialize Map objects and exclude sensitive data from persistence
		      serialize: (state) => {
		        const serializedState = {
		          ...state.state,
		          normingStatistics: Array.from(state.state.normingStatistics.entries()),
		          itemAnalyses: Array.from(state.state.itemAnalyses.entries()),
		        };
		        
		        // Remove sensitive data from persistence
		        delete serializedState.currentSession;
		        delete serializedState.dashboardData;
		        
		        // Only keep recent alerts
		        serializedState.alerts = serializedState.alerts
		          .slice(0, 10)
		          .filter((alert: TelemetryAlert) => !alert.resolved);
		        
		        // Only keep recent session history
		        serializedState.sessionHistory = serializedState.sessionHistory.slice(-5);
		        
		        return JSON.stringify(serializedState);
		      },
		      
		      // Deserialize Map objects
		      deserialize: (str) => {
		        const parsed = JSON.parse(str);
		        return {
		          ...parsed,
		          normingStatistics: new Map(parsed.normingStatistics || []),
		          itemAnalyses: new Map(parsed.itemAnalyses || []),
		        };
		      },
		
		      // Partial persistence - only persist essential data
		      partialize: (state) => ({
		        config: state.config,
		        userConsent: state.userConsent,
		        consentTimestamp: state.consentTimestamp,
		        consentVersion: state.consentVersion,
		        performanceMetrics: state.performanceMetrics,
		        batchesProcessed: state.batchesProcessed,
		        failedBatches: state.failedBatches,
		        lastBatchTimestamp: state.lastBatchTimestamp,
		        // Exclude sensitive runtime data
		      }),
		    }
		  )
		);
		
		// Selectors for commonly used data
		export const selectTelemetryConfig = () => useTelemetryStore((state) => state.config);
		export const selectUserConsent = () => useTelemetryStore((state) => state.userConsent);
		export const selectCurrentSession = () => useTelemetryStore((state) => state.currentSession);
		export const selectActiveAlerts = () => useTelemetryStore((state) => 
		  state.alerts.filter(alert => !alert.resolved)
		);
		export const selectCriticalAlerts = () => useTelemetryStore((state) => 
		  state.alerts.filter(alert => !alert.resolved && alert.severity === 'critical')
		);
		export const selectPerformanceMetrics = () => useTelemetryStore((state) => state.performanceMetrics);
		export const selectTelemetryStatus = () => useTelemetryStore((state) => state.getTelemetryStatus());
		export const selectDashboardData = () => useTelemetryStore((state) => state.dashboardData);
		
		// Privacy-safe data access
		export const selectAnonymizedMetrics = () => useTelemetryStore((state) => {
		  const status = state.getTelemetryStatus();
		  const metrics = state.performanceMetrics;
		  
		  return {
		    status,
		    isEnabled: status === 'enabled',
		    dataQuality: metrics.dataQualityScore,
		    systemHealth: metrics.systemLoad,
		    lastUpdated: metrics.lastUpdated,
		    queueSize: state.eventQueueSize,
		    batchesProcessed: state.batchesProcessed,
		  };
		});
		
		// Computed values
		export const selectQualityIndicators = () => useTelemetryStore((state) => {
		  const alerts = state.alerts.filter(alert => !alert.resolved);
		  const criticalCount = alerts.filter(alert => alert.severity === 'critical').length;
		  const errorCount = alerts.filter(alert => alert.severity === 'error').length;
		  const warningCount = alerts.filter(alert => alert.severity === 'warning').length;
		  
		  return {
		    overall: state.performanceMetrics.dataQualityScore,
		    alerts: {
		      critical: criticalCount,
		      error: errorCount,
		      warning: warningCount,
		      total: alerts.length,
		    },
		    system: {
		      queueHealth: state.eventQueueSize < state.config.batchSize,
		      batchHealth: state.failedBatches === 0 || state.batchesProcessed / Math.max(1, state.failedBatches) > 10,
		      consentStatus: state.userConsent,
		    },
		  };
		});
		
		export default useTelemetryStore;]]></file>
	<file path='state/twinStore.ts'><![CDATA[
		import { getZodiacSign } from "../utils/zodiac";
		import { create } from "zustand";
		import { persist, createJSONStorage } from "zustand/middleware";
		import AsyncStorage from "@react-native-async-storage/async-storage";
		
		export type TwinType = "identical" | "fraternal" | "other";
		export type ThemeColor = "neon-pink" | "neon-blue" | "neon-green" | "neon-yellow" | "neon-purple" | "neon-orange" | "neon-cyan" | "neon-red";
		
		export interface TwinProfile {
		  id: string;
		  name: string;
		  age: number;
		  gender: string;
		  sexualOrientation?: string;
		  showSexualOrientation?: boolean;
		  twinType: TwinType;
		  otherTwinTypeDescription?: string;
		  twinDeceased?: boolean;
		  birthDate: string;
		  zodiacSign?: string;
		  placeOfBirth?: string;
		  timeOfBirth?: string;
		  profilePicture?: string;
		  accentColor: ThemeColor;
		  isConnected: boolean;
		  lastSeen?: string;
		}
		
		export interface TwintuitionAlert {
		  id: string;
		  message: string;
		  timestamp: string;
		  isRead: boolean;
		  type: "feeling" | "thought" | "action";
		}
		
		// Updated game types for new system
		export type GameType = "cognitive_sync_maze" | "emotional_resonance" | "temporal_decision" | "iconic_duo";
		
		export interface GameInsight {
		  type: string;
		  message: string;
		  data: any;
		}
		
		export interface GameResult {
		  id: string;
		  gameType: GameType;
		  score: number;
		  timestamp: string;
		  twinScore: number;
		  insights?: GameInsight[];
		  cognitiveData?: any;
		  emotionalData?: any;
		  decisionData?: any;
		  duoData?: any;
		}
		
		export interface Story {
		  id: string;
		  title: string;
		  content: string;
		  photos: string[];
		  timestamp: string;
		  isShared: boolean;
		  milestone?: boolean;
		}
		
		interface TwinState {
		  // Profile & Setup
		  isOnboarded: boolean;
		  userProfile: TwinProfile | null;
		  twinProfile: TwinProfile | null;
		  themeColor: ThemeColor;
		  
		  // Features
		  twintuitionAlerts: TwintuitionAlert[];
		  gameResults: GameResult[];
		  stories: Story[];
		  syncScore: number;
		  
		  // Pairing
		  shareCode: string | null;
		  paired: boolean;
		  pendingInvitation: {
		    email?: string;
		    phone?: string;
		    status: 'pending' | 'accepted' | 'declined';
		  } | null;
		  
		  // New invitation system integration
		  invitationToken: string | null;
		  invitationStatus: 'none' | 'sent' | 'received' | 'processing' | 'accepted' | 'declined';
		  lastInvitationSent: string | null;
		  invitationHistory: Array<{
		    id: string;
		    type: 'sent' | 'received';
		    timestamp: string;
		    status: 'pending' | 'accepted' | 'declined' | 'expired';
		    recipientName?: string;
		    senderName?: string;
		  }>;
		
		  // Settings
		  researchParticipation: boolean;
		  notificationsEnabled: boolean;
		  
		  // Research integration
		  hasActiveResearchStudies: boolean;
		  researchContributions: number;
		  
		  // Actions
		  setOnboarded: (onboarded: boolean) => void;
		  setUserProfile: (profile: TwinProfile) => void;
		  setTwinProfile: (profile: TwinProfile) => void;
		  setShareCode: (code: string | null) => void;
		  setPaired: (value: boolean) => void;
		  setPendingInvitation: (invitation: { email?: string; phone?: string; status: 'pending' | 'accepted' | 'declined'; } | null) => void;
		  
		  // New invitation actions
		  setInvitationToken: (token: string | null) => void;
		  setInvitationStatus: (status: TwinState['invitationStatus']) => void;
		  setLastInvitationSent: (timestamp: string | null) => void;
		  addInvitationToHistory: (invitation: TwinState['invitationHistory'][0]) => void;
		  
		  signOut: () => void;
		  addTwintuitionAlert: (alert: Omit<TwintuitionAlert, "id" | "timestamp">) => void;
		  markAlertAsRead: (alertId: string) => void;
		  
		  // Updated game methods
		  addGameResult: (result: Omit<GameResult, "id" | "timestamp">) => void;
		  calculateSyncScore: () => void;
		  getGameTypeStats: (gameType: GameType) => { played: number; averageScore: number; bestScore: number; };
		  getInsightsByType: (insightType: string) => GameInsight[];
		  
		  addStory: (story: Omit<Story, "id" | "timestamp">) => void;
		  updateStory: (storyId: string, updates: Partial<Story>) => void;
		  setResearchParticipation: (participate: boolean) => void;
		  setNotificationsEnabled: (enabled: boolean) => void;
		  setHasActiveResearchStudies: (hasStudies: boolean) => void;
		  incrementResearchContributions: () => void;
		}
		
		export const useTwinStore = create<TwinState>()(
		  persist(
		    (set, get) => ({
		      // Initial state
		      isOnboarded: false,
		      userProfile: null,
		      twinProfile: null,
		      themeColor: "neon-purple",
		      twintuitionAlerts: [],
		      gameResults: [],
		      stories: [],
		      syncScore: 0,
		      researchParticipation: false,
		      notificationsEnabled: true,
		      hasActiveResearchStudies: false,
		      researchContributions: 0,
		      shareCode: null,
		      paired: false,
		      pendingInvitation: null,
		      
		      // New invitation system
		      invitationToken: null,
		      invitationStatus: 'none',
		      lastInvitationSent: null,
		      invitationHistory: [],
		
		      // Actions
		      setOnboarded: (onboarded) => set({ isOnboarded: onboarded }),
		      
		      setUserProfile: (profile) => {
		        if (profile.birthDate) {
		          const date = new Date(profile.birthDate);
		          const month = date.getMonth() + 1;
		          const day = date.getDate();
		          profile.zodiacSign = getZodiacSign(month, day);
		        } else {
		          profile.zodiacSign = "Unknown";
		        }
		        set({ 
		          userProfile: profile,
		          themeColor: profile.accentColor || "neon-purple"
		        });
		      },
		      
		      setTwinProfile: (profile) => {
		        if (profile.birthDate) {
		          const date = new Date(profile.birthDate);
		          const month = date.getMonth() + 1;
		          const day = date.getDate();
		          profile.zodiacSign = getZodiacSign(month, day);
		        } else {
		          profile.zodiacSign = "Unknown";
		        }
		        set({ twinProfile: profile });
		      },
		      
		      setPendingInvitation: (invitation) => set({ pendingInvitation: invitation }),
		      
		      // New invitation actions
		      setInvitationToken: (token) => set({ invitationToken: token }),
		      
		      setInvitationStatus: (status) => set({ invitationStatus: status }),
		      
		      setLastInvitationSent: (timestamp) => set({ lastInvitationSent: timestamp }),
		      
		      addInvitationToHistory: (invitation) => {
		        const history = get().invitationHistory;
		        set({ invitationHistory: [invitation, ...history.slice(0, 9)] }); // Keep last 10
		      },
		
		      setShareCode: (code) => set({ shareCode: code }),
		
		      setPaired: (value) => set({ 
		        paired: value,
		        userProfile: get().userProfile ? { ...get().userProfile!, isConnected: value } : null,
		        twinProfile: get().twinProfile ? { ...get().twinProfile!, isConnected: value } : null,
		      }),
		      
		      signOut: () => set({ 
		        isOnboarded: false,
		        userProfile: null,
		        twinProfile: null,
		        themeColor: "neon-purple",
		        shareCode: null,
		        paired: false,
		        pendingInvitation: null,
		        invitationToken: null,
		        invitationStatus: 'none',
		        lastInvitationSent: null,
		        invitationHistory: [],
		        twintuitionAlerts: [],
		        gameResults: [],
		        stories: [],
		        syncScore: 0,
		        researchParticipation: false,
		        notificationsEnabled: true,
		        hasActiveResearchStudies: false,
		        researchContributions: 0,
		      }),
		      
		      addTwintuitionAlert: (alert) => {
		        const newAlert: TwintuitionAlert = {
		          ...alert,
		          id: Date.now().toString(),
		          timestamp: new Date().toISOString(),
		          isRead: false,
		        };
		        set((state) => ({
		          twintuitionAlerts: [newAlert, ...state.twintuitionAlerts],
		        }));
		      },
		      
		      markAlertAsRead: (alertId) =>
		        set((state) => ({
		          twintuitionAlerts: state.twintuitionAlerts.map((alert) =>
		            alert.id === alertId ? { ...alert, isRead: true } : alert
		          ),
		        })),
		      
		      // Updated game result method
		      addGameResult: (result) => {
		        const newResult: GameResult = {
		          ...result,
		          id: Date.now().toString(),
		          timestamp: new Date().toISOString(),
		        };
		        set((state) => ({
		          gameResults: [newResult, ...state.gameResults],
		        }));
		        
		        // Recalculate sync score after adding result
		        get().calculateSyncScore();
		      },
		      
		      calculateSyncScore: () => {
		        const results = get().gameResults;
		        if (results.length === 0) {
		          set({ syncScore: 0 });
		          return;
		        }
		        
		        const totalScore = results.reduce((acc, result) => acc + result.score, 0);
		        const avgScore = totalScore / results.length;
		        
		        set({ syncScore: avgScore });
		      },
		      
		      getGameTypeStats: (gameType) => {
		        const state = get();
		        const gameTypeResults = state.gameResults.filter(result => result.gameType === gameType);
		        const totalScore = gameTypeResults.reduce((sum, result) => sum + result.score, 0);
		        const bestScore = gameTypeResults.length > 0 ? Math.max(...gameTypeResults.map(r => r.score)) : 0;
		        
		        return {
		          played: gameTypeResults.length,
		          averageScore: gameTypeResults.length > 0 ? Math.round(totalScore / gameTypeResults.length) : 0,
		          bestScore
		        };
		      },
		      
		      getInsightsByType: (insightType) => {
		        const state = get();
		        const allInsights: GameInsight[] = [];
		        
		        state.gameResults.forEach(result => {
		          if (result.insights) {
		            const typeInsights = result.insights.filter(i => i.type === insightType);
		            allInsights.push(...typeInsights);
		          }
		        });
		        
		        return allInsights;
		      },
		      
		      addStory: (story) => {
		        const newStory: Story = {
		          ...story,
		          id: Date.now().toString(),
		          timestamp: new Date().toISOString(),
		        };
		        set((state) => ({
		          stories: [newStory, ...state.stories],
		        }));
		      },
		      
		      updateStory: (storyId, updates) =>
		        set((state) => ({
		          stories: state.stories.map((story) =>
		            story.id === storyId ? { ...story, ...updates } : story
		          ),
		        })),
		      
		      setResearchParticipation: (participate) =>
		        set({ researchParticipation: participate }),
		        
		      setHasActiveResearchStudies: (hasStudies: boolean) =>
		        set({ hasActiveResearchStudies: hasStudies }),
		        
		      incrementResearchContributions: () =>
		        set((state) => ({ researchContributions: state.researchContributions + 1 })),
		      
		      setNotificationsEnabled: (enabled) =>
		        set({ notificationsEnabled: enabled }),
		    }),
		    {
		      name: "twin-storage",
		      storage: createJSONStorage(() => AsyncStorage),
		      partialize: (state) => ({
		        isOnboarded: state.isOnboarded,
		        userProfile: state.userProfile,
		        twinProfile: state.twinProfile,
		        themeColor: state.themeColor,
		        researchParticipation: state.researchParticipation,
		        notificationsEnabled: state.notificationsEnabled,
		        hasActiveResearchStudies: state.hasActiveResearchStudies,
		        researchContributions: state.researchContributions,
		        shareCode: state.shareCode,
		        paired: state.paired,
		        invitationToken: state.invitationToken,
		        invitationStatus: state.invitationStatus,
		        lastInvitationSent: state.lastInvitationSent,
		        invitationHistory: state.invitationHistory,
		        pendingInvitation: state.pendingInvitation,
		        gameResults: state.gameResults,
		        syncScore: state.syncScore,
		      }),
		    }
		  )
		);
		
		// Non-persisted store for temporary data
		interface TempTwinState {
		  currentChatMessages: any[];
		  isTyping: boolean;
		  connectionStatus: "connected" | "disconnected" | "connecting";
		  
		  setChatMessages: (messages: any[]) => void;
		  addChatMessage: (message: any) => void;
		  setIsTyping: (typing: boolean) => void;
		  setConnectionStatus: (status: "connected" | "disconnected" | "connecting") => void;
		}
		
		export const useTempTwinStore = create<TempTwinState>((set) => ({
		  currentChatMessages: [],
		  isTyping: false,
		  connectionStatus: "disconnected",
		  
		  setChatMessages: (messages) => set({ currentChatMessages: messages }),
		  
		  addChatMessage: (message) =>
		    set((state) => ({
		      currentChatMessages: [...state.currentChatMessages, message],
		    })),
		  
		  setIsTyping: (typing) => set({ isTyping: typing }),
		  
		  setConnectionStatus: (status) => set({ connectionStatus: status }),
		}));]]></file>
	<file path='state/twintuitionStore.ts'><![CDATA[
		import { create } from 'zustand';
		import { persist, createJSONStorage } from 'zustand/middleware';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import {
		  BehaviorEvent,
		  SyncEvent,
		  TwintuitionConfig,
		  TwintuitionAnalytics,
		  TwinConnectionMetrics,
		  NotificationPreferences,
		} from '../types/twintuition';
		import { TwintuitionAlert } from '../state/twinStore';
		
		interface TwintuitionState {
		  // Configuration
		  config: TwintuitionConfig;
		  notificationPrefs: NotificationPreferences;
		  
		  // Data
		  syncEvents: SyncEvent[];
		  behaviorHistory: BehaviorEvent[];
		  currentAlert: TwintuitionAlert | null;
		  
		  // Analytics
		  analytics: TwintuitionAnalytics | null;
		  connectionMetrics: TwinConnectionMetrics | null;
		  
		  // UI State
		  showingAlert: boolean;
		  syncScore: number;
		  lastAnalysisTime: string | null;
		  
		  // Actions
		  updateConfig: (config: Partial<TwintuitionConfig>) => void;
		  updateNotificationPrefs: (prefs: Partial<NotificationPreferences>) => void;
		  addSyncEvent: (event: SyncEvent) => void;
		  addBehaviorEvent: (event: BehaviorEvent) => void;
		  setCurrentAlert: (alert: TwintuitionAlert | null) => void;
		  setShowingAlert: (showing: boolean) => void;
		  updateAnalytics: (analytics: TwintuitionAnalytics) => void;
		  updateConnectionMetrics: (metrics: TwinConnectionMetrics) => void;
		  updateSyncScore: (score: number) => void;
		  clearOldData: (daysToKeep?: number) => void;
		  exportData: () => Promise<string>;
		  importData: (data: string) => Promise<void>;
		}
		
		const defaultConfig: TwintuitionConfig = {
		  sensitivity: 0.7,
		  timeWindowMinutes: 15,
		  enableLocationSync: false,
		  enableMoodSync: true,
		  enableActionSync: true,
		  minConfidenceThreshold: 0.6,
		};
		
		const defaultNotificationPrefs: NotificationPreferences = {
		  enabled: true,
		  quietHours: {
		    start: '22:00',
		    end: '08:00',
		  },
		  minimumConfidence: 0.6,
		  allowedTypes: ['simultaneous_action', 'mood_synchronization', 'app_synchronization'],
		  soundEnabled: true,
		  vibrationEnabled: true,
		};
		
		export const useTwintuitionStore = create<TwintuitionState>()(persist(
		    (set, get) => ({
		      // Initial state
		      config: defaultConfig,
		      notificationPrefs: defaultNotificationPrefs,
		      syncEvents: [],
		      behaviorHistory: [],
		      currentAlert: null,
		      analytics: null,
		      connectionMetrics: null,
		      showingAlert: false,
		      syncScore: 0,
		      lastAnalysisTime: null,
		
		      // Actions
		      updateConfig: (newConfig) =>
		        set((state) => ({
		          config: { ...state.config, ...newConfig },
		        })),
		
		      updateNotificationPrefs: (newPrefs) =>
		        set((state) => ({
		          notificationPrefs: { ...state.notificationPrefs, ...newPrefs },
		        })),
		
		      addSyncEvent: (event) =>
		        set((state) => ({
		          syncEvents: [event, ...state.syncEvents].slice(0, 100), // Keep last 100
		        })),
		
		      addBehaviorEvent: (event) =>
		        set((state) => ({
		          behaviorHistory: [event, ...state.behaviorHistory].slice(0, 200), // Keep last 200
		        })),
		
		      setCurrentAlert: (alert) => set({ currentAlert: alert }),
		
		      setShowingAlert: (showing) => set({ showingAlert: showing }),
		
		      updateAnalytics: (analytics) => set({ analytics }),
		
		      updateConnectionMetrics: (metrics) => set({ connectionMetrics }),
		
		      updateSyncScore: (score) => set({ syncScore }),
		
		      clearOldData: (daysToKeep = 30) => {
		        const cutoffDate = new Date();
		        cutoffDate.setDate(cutoffDate.getDate() - daysToKeep);
		        const cutoffTime = cutoffDate.toISOString();
		
		        set((state) => ({
		          syncEvents: state.syncEvents.filter(
		            (event) => event.detectedAt >= cutoffTime
		          ),
		          behaviorHistory: state.behaviorHistory.filter(
		            (event) => event.timestamp >= cutoffTime
		          ),
		        }));
		      },
		
		      exportData: async () => {
		        const state = get();
		        const exportData = {
		          syncEvents: state.syncEvents,
		          analytics: state.analytics,
		          connectionMetrics: state.connectionMetrics,
		          config: state.config,
		          exportedAt: new Date().toISOString(),
		        };
		        return JSON.stringify(exportData, null, 2);
		      },
		
		      importData: async (data) => {
		        try {
		          const parsed = JSON.parse(data);
		          if (parsed.syncEvents && Array.isArray(parsed.syncEvents)) {
		            set((state) => ({
		              syncEvents: [...parsed.syncEvents, ...state.syncEvents].slice(0, 100),
		              analytics: parsed.analytics || state.analytics,
		              connectionMetrics: parsed.connectionMetrics || state.connectionMetrics,
		              config: { ...state.config, ...(parsed.config || {}) },
		            }));
		          }
		        } catch (error) {
		          console.error('Failed to import data:', error);
		          throw new Error('Invalid data format');
		        }
		      },
		    }),
		    {
		      name: 'twintuition-storage',
		      storage: createJSONStorage(() => AsyncStorage),
		      partialize: (state) => ({
		        config: state.config,
		        notificationPrefs: state.notificationPrefs,
		        syncEvents: state.syncEvents.slice(0, 50), // Only persist recent events
		        analytics: state.analytics,
		        connectionMetrics: state.connectionMetrics,
		        syncScore: state.syncScore,
		        lastAnalysisTime: state.lastAnalysisTime,
		      }),
		    }
		  )
		);
		
		// Computed selectors
		export const useTwintuitionSelectors = () => {
		  const store = useTwintuitionStore();
		  
		  return {
		    // Get sync events by type
		    getSyncEventsByType: (type: SyncEvent['type']) =>
		      store.syncEvents.filter((event) => event.type === type),
		    
		    // Get recent high-confidence events
		    getHighConfidenceEvents: (minConfidence = 0.8) =>
		      store.syncEvents.filter((event) => event.confidence >= minConfidence),
		    
		    // Get sync events for date range
		    getSyncEventsInRange: (startDate: Date, endDate: Date) =>
		      store.syncEvents.filter((event) => {
		        const eventDate = new Date(event.detectedAt);
		        return eventDate >= startDate && eventDate <= endDate;
		      }),
		    
		    // Get behavior events by type
		    getBehaviorEventsByType: (type: BehaviorEvent['type']) =>
		      store.behaviorHistory.filter((event) => event.type === type),
		    
		    // Calculate streak days
		    getCurrentSyncStreak: () => {
		      const events = store.syncEvents.sort(
		        (a, b) => new Date(b.detectedAt).getTime() - new Date(a.detectedAt).getTime()
		      );
		      
		      let streak = 0;
		      let currentDate = new Date();
		      currentDate.setHours(0, 0, 0, 0);
		      
		      for (const event of events) {
		        const eventDate = new Date(event.detectedAt);
		        eventDate.setHours(0, 0, 0, 0);
		        
		        const daysDiff = Math.floor(
		          (currentDate.getTime() - eventDate.getTime()) / (1000 * 60 * 60 * 24)
		        );
		        
		        if (daysDiff === streak) {
		          streak++;
		          currentDate.setDate(currentDate.getDate() - 1);
		        } else {
		          break;
		        }
		      }
		      
		      return streak;
		    },
		    
		    // Get most active sync times
		    getMostActiveSyncTimes: () => {
		      const hourCounts = new Map<number, number>();
		      
		      store.syncEvents.forEach((event) => {
		        const hour = new Date(event.detectedAt).getHours();
		        hourCounts.set(hour, (hourCounts.get(hour) || 0) + 1);
		      });
		      
		      return Array.from(hourCounts.entries())
		        .sort(([,a], [,b]) => b - a)
		        .slice(0, 3)
		        .map(([hour, count]) => ({ hour, count }));
		    },
		  };
		};
		
		// Helper function to check if notifications should be shown
		export const shouldShowNotification = (state: TwintuitionState): boolean => {
		  if (!state.notificationPrefs.enabled) return false;
		  
		  const now = new Date();
		  const currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
		  
		  const quietStart = state.notificationPrefs.quietHours.start;
		  const quietEnd = state.notificationPrefs.quietHours.end;
		  
		  // Check if current time is in quiet hours
		  if (quietStart <= quietEnd) {
		    // Same day range (e.g., 14:00 to 18:00)
		    if (currentTime >= quietStart && currentTime <= quietEnd) {
		      return false;
		    }
		  } else {
		    // Overnight range (e.g., 22:00 to 08:00)
		    if (currentTime >= quietStart || currentTime <= quietEnd) {
		      return false;
		    }
		  }
		  
		  return true;
		};]]></file>
	<file path='tests/__tests__/assessmentScoring.test.ts'><![CDATA[
		/**
		 * Assessment Scoring Algorithm Tests
		 * Comprehensive test suite for scoring reliability and mathematical accuracy
		 */
		
		import * as fc from 'fast-check';
		import {
		  likertToNormalizedScore,
		  reverseScore,
		  calculateMeanScore,
		  calculateSubscaleScore,
		  calculateCompositeIndices,
		  validateAssessmentResponses,
		  calculateReliabilityMetrics,
		  calculatePercentileRank
		} from '../../utils/assessment/scoringAlgorithms';
		
		import {
		  mockResponses,
		  mockSubscales,
		  mockCompositeIndices,
		  mockDataGenerators,
		  mockNormativeData,
		  algorithmTestCases,
		  performanceTestData
		} from '../mocks/assessmentMockData';
		
		import { AssessmentResponse, LikertResponse, AssessmentCategory } from '../../utils/assessment/types';
		
		describe('Assessment Scoring Algorithms', () => {
		  
		  describe('likertToNormalizedScore', () => {
		    it('should convert valid Likert responses to 0-100 scale correctly', () => {
		      algorithmTestCases.likertConversion.forEach(({ input, expected, reversed }) => {
		        const result = likertToNormalizedScore(input as LikertResponse, reversed);
		        expect(result).toBeCloseTo(expected, 2);
		      });
		    });
		
		    it('should handle boundary values correctly', () => {
		      expect(likertToNormalizedScore(1, false)).toBe(0);
		      expect(likertToNormalizedScore(8, false)).toBe(100);
		      expect(likertToNormalizedScore(1, true)).toBe(100);
		      expect(likertToNormalizedScore(8, true)).toBe(0);
		    });
		
		    it('should throw error for invalid responses', () => {
		      expect(() => likertToNormalizedScore(0 as LikertResponse)).toThrow('Invalid Likert response');
		      expect(() => likertToNormalizedScore(9 as LikertResponse)).toThrow('Invalid Likert response');
		      expect(() => likertToNormalizedScore(-1 as LikertResponse)).toThrow('Invalid Likert response');
		    });
		
		    // Property-based testing
		    it('should always return values between 0-100 for valid inputs', () => {
		      fc.assert(fc.property(
		        fc.integer({ min: 1, max: 8 }),
		        fc.boolean(),
		        (response, reversed) => {
		          const result = likertToNormalizedScore(response as LikertResponse, reversed);
		          return result >= 0 && result <= 100;
		        }
		      ));
		    });
		
		    it('should be monotonically increasing for non-reversed responses', () => {
		      fc.assert(fc.property(
		        fc.integer({ min: 1, max: 7 }),
		        (response) => {
		          const current = likertToNormalizedScore(response as LikertResponse, false);
		          const next = likertToNormalizedScore((response + 1) as LikertResponse, false);
		          return current < next;
		        }
		      ));
		    });
		
		    it('should be monotonically decreasing for reversed responses', () => {
		      fc.assert(fc.property(
		        fc.integer({ min: 1, max: 7 }),
		        (response) => {
		          const current = likertToNormalizedScore(response as LikertResponse, true);
		          const next = likertToNormalizedScore((response + 1) as LikertResponse, true);
		          return current > next;
		        }
		      ));
		    });
		  });
		
		  describe('reverseScore', () => {
		    it('should correctly reverse score using 8-point formula', () => {
		      algorithmTestCases.reverseScoring.forEach(({ input, expected }) => {
		        expect(reverseScore(input as LikertResponse)).toBe(expected);
		      });
		    });
		
		    it('should be its own inverse', () => {
		      fc.assert(fc.property(
		        fc.integer({ min: 1, max: 8 }),
		        (response) => {
		          const reversed = reverseScore(response as LikertResponse);
		          const doubleReversed = reverseScore(reversed);
		          return doubleReversed === response;
		        }
		      ));
		    });
		
		    it('should maintain symmetry around 4.5', () => {
		      expect(reverseScore(1) + reverseScore(8)).toBe(9);
		      expect(reverseScore(2) + reverseScore(7)).toBe(9);
		      expect(reverseScore(3) + reverseScore(6)).toBe(9);
		      expect(reverseScore(4) + reverseScore(5)).toBe(9);
		    });
		
		    it('should throw error for invalid inputs', () => {
		      expect(() => reverseScore(0 as LikertResponse)).toThrow();
		      expect(() => reverseScore(9 as LikertResponse)).toThrow();
		    });
		  });
		
		  describe('calculateMeanScore', () => {
		    it('should calculate simple mean correctly', () => {
		      const responses = mockResponses.realistic;
		      const expectedMean = responses.reduce((sum, r) => sum + r.response, 0) / responses.length;
		      expect(calculateMeanScore(responses)).toBeCloseTo(expectedMean, 2);
		    });
		
		    it('should handle weighted mean calculation', () => {
		      const responses = mockResponses.realistic.slice(0, 3);
		      const weights = new Map([
		        ['q1', 2.0],
		        ['q2', 1.0],
		        ['q3', 0.5]
		      ]);
		      
		      const expectedWeighted = (
		        (responses[0].response * 2.0) + 
		        (responses[1].response * 1.0) + 
		        (responses[2].response * 0.5)
		      ) / 3.5;
		      
		      expect(calculateMeanScore(responses, weights)).toBeCloseTo(expectedWeighted, 2);
		    });
		
		    it('should throw error for empty responses', () => {
		      expect(() => calculateMeanScore([])).toThrow('Cannot calculate mean of empty responses array');
		    });
		
		    it('should handle single response', () => {
		      const singleResponse = [mockResponses.realistic[0]];
		      expect(calculateMeanScore(singleResponse)).toBe(singleResponse[0].response);
		    });
		
		    // Property-based testing
		    it('should always return value within valid Likert range for unweighted mean', () => {
		      fc.assert(fc.property(
		        fc.array(fc.record({
		          questionId: fc.string(),
		          response: fc.integer({ min: 1, max: 8 }),
		          timestamp: fc.constant('2023-01-01T10:00:00Z')
		        }), { minLength: 1, maxLength: 20 }),
		        (responses) => {
		          const mean = calculateMeanScore(responses as AssessmentResponse[]);
		          return mean >= 1 && mean <= 8;
		        }
		      ));
		    });
		  });
		
		  describe('calculateSubscaleScore', () => {
		    it('should calculate subscale score with proper components', () => {
		      const responses = mockResponses.realistic;
		      const reversedQuestions = new Set(['q2', 'q4']); // Reverse score q2 and q4
		      const category: AssessmentCategory = 'communication';
		      
		      const result = calculateSubscaleScore(responses, category, reversedQuestions);
		      
		      expect(result.category).toBe(category);
		      expect(result.rawScore).toBeGreaterThanOrEqual(1);
		      expect(result.rawScore).toBeLessThanOrEqual(8);
		      expect(result.normalizedScore).toBeGreaterThanOrEqual(0);
		      expect(result.normalizedScore).toBeLessThanOrEqual(100);
		      expect(result.percentile).toBeGreaterThanOrEqual(0);
		      expect(result.percentile).toBeLessThanOrEqual(100);
		      expect(result.reliability).toBeGreaterThanOrEqual(0);
		      expect(result.reliability).toBeLessThanOrEqual(1);
		      expect(['very_low', 'low', 'below_average', 'average', 'above_average', 'high', 'very_high'])
		        .toContain(result.interpretation);
		    });
		
		    it('should apply reverse scoring correctly', () => {
		      const responses = [
		        { questionId: 'q1', response: 2, timestamp: '2023-01-01T10:00:00Z' },
		        { questionId: 'q2', response: 2, timestamp: '2023-01-01T10:00:05Z' }
		      ] as AssessmentResponse[];
		      
		      const withoutReverse = calculateSubscaleScore(responses, 'communication');
		      const withReverse = calculateSubscaleScore(responses, 'communication', new Set(['q2']));
		      
		      expect(withReverse.rawScore).toBeGreaterThan(withoutReverse.rawScore);
		    });
		
		    it('should throw error for empty responses', () => {
		      expect(() => calculateSubscaleScore([], 'communication')).toThrow();
		    });
		
		    it('should use custom norms when provided', () => {
		      const responses = mockResponses.realistic;
		      const customNorms = { mean: 75, std: 10 };
		      
		      const result = calculateSubscaleScore(responses, 'communication', new Set(), customNorms);
		      
		      expect(result.percentile).toBeDefined();
		      expect(result.percentile).toBeGreaterThanOrEqual(0);
		      expect(result.percentile).toBeLessThanOrEqual(100);
		    });
		  });
		
		  describe('calculateCompositeIndices', () => {
		    it('should calculate all three composite indices correctly', () => {
		      const subscales = mockSubscales.highFunctioningTwin;
		      const result = calculateCompositeIndices(subscales);
		      
		      expect(result.CI).toBeGreaterThanOrEqual(0);
		      expect(result.CI).toBeLessThanOrEqual(100);
		      expect(result.ARI).toBeGreaterThanOrEqual(0);
		      expect(result.ARI).toBeLessThanOrEqual(100);
		      expect(result.TRS).toBeGreaterThanOrEqual(0);
		      expect(result.TRS).toBeLessThanOrEqual(100);
		    });
		
		    it('should calculate Connection Index from communication, emotional, and psychic scores', () => {
		      const subscales = [
		        { category: 'communication' as AssessmentCategory, normalizedScore: 90, rawScore: 0, percentile: 0, interpretation: 'high' as const, reliability: 0.9 },
		        { category: 'emotional_connection' as AssessmentCategory, normalizedScore: 80, rawScore: 0, percentile: 0, interpretation: 'high' as const, reliability: 0.9 },
		        { category: 'psychic_connection' as AssessmentCategory, normalizedScore: 60, rawScore: 0, percentile: 0, interpretation: 'average' as const, reliability: 0.9 }
		      ];
		      
		      const result = calculateCompositeIndices(subscales);
		      const expectedCI = Math.round((90 + 80 + 60) / 3);
		      
		      expect(result.CI).toBe(expectedCI);
		    });
		
		    it('should calculate ARI as absolute difference between independence and support', () => {
		      const subscales = [
		        { category: 'independence' as AssessmentCategory, normalizedScore: 80, rawScore: 0, percentile: 0, interpretation: 'high' as const, reliability: 0.9 },
		        { category: 'support_system' as AssessmentCategory, normalizedScore: 40, rawScore: 0, percentile: 0, interpretation: 'low' as const, reliability: 0.9 }
		      ];
		      
		      const result = calculateCompositeIndices(subscales);
		      expect(result.ARI).toBe(40); // |80 - 40|
		    });
		
		    it('should handle missing subscales gracefully', () => {
		      const incompleteSubscales = [
		        { category: 'communication' as AssessmentCategory, normalizedScore: 70, rawScore: 0, percentile: 0, interpretation: 'average' as const, reliability: 0.9 }
		      ];
		      
		      const result = calculateCompositeIndices(incompleteSubscales);
		      
		      expect(result.CI).toBeGreaterThanOrEqual(0);
		      expect(result.ARI).toBeGreaterThanOrEqual(0);
		      expect(result.TRS).toBeGreaterThanOrEqual(0);
		    });
		
		    it('should weight TRS components according to specification', () => {
		      const fullSubscales = [
		        { category: 'communication' as AssessmentCategory, normalizedScore: 100, rawScore: 0, percentile: 0, interpretation: 'very_high' as const, reliability: 0.9 },
		        { category: 'emotional_connection' as AssessmentCategory, normalizedScore: 100, rawScore: 0, percentile: 0, interpretation: 'very_high' as const, reliability: 0.9 },
		        { category: 'shared_experiences' as AssessmentCategory, normalizedScore: 0, rawScore: 0, percentile: 0, interpretation: 'very_low' as const, reliability: 0.9 },
		        { category: 'conflict_resolution' as AssessmentCategory, normalizedScore: 0, rawScore: 0, percentile: 0, interpretation: 'very_low' as const, reliability: 0.9 },
		        { category: 'independence' as AssessmentCategory, normalizedScore: 0, rawScore: 0, percentile: 0, interpretation: 'very_low' as const, reliability: 0.9 },
		        { category: 'support_system' as AssessmentCategory, normalizedScore: 0, rawScore: 0, percentile: 0, interpretation: 'very_low' as const, reliability: 0.9 },
		        { category: 'psychic_connection' as AssessmentCategory, normalizedScore: 0, rawScore: 0, percentile: 0, interpretation: 'very_low' as const, reliability: 0.9 },
		        { category: 'identity_formation' as AssessmentCategory, normalizedScore: 0, rawScore: 0, percentile: 0, interpretation: 'very_low' as const, reliability: 0.9 }
		      ];
		      
		      const result = calculateCompositeIndices(fullSubscales);
		      
		      // Should be weighted heavily toward communication and emotional_connection (0.2 + 0.2 = 0.4)
		      expect(result.TRS).toBeGreaterThan(30); // 100 * 0.4 = 40, minus other components
		    });
		  });
		
		  describe('validateAssessmentResponses', () => {
		    it('should validate complete valid responses', () => {
		      const requiredQuestions = new Set(['q1', 'q2', 'q3', 'q4', 'q5']);
		      const result = validateAssessmentResponses(mockResponses.realistic, requiredQuestions);
		      
		      expect(result.isValid).toBe(true);
		      expect(result.errors).toHaveLength(0);
		      expect(result.missingResponses).toHaveLength(0);
		    });
		
		    it('should detect missing required responses', () => {
		      const requiredQuestions = new Set(['q1', 'q2', 'q3', 'q4', 'q5', 'q6']);
		      const result = validateAssessmentResponses(mockResponses.realistic, requiredQuestions);
		      
		      expect(result.isValid).toBe(false);
		      expect(result.missingResponses).toContain('q6');
		    });
		
		    it('should detect invalid response values', () => {
		      const invalidResponses = [
		        { questionId: 'q1', response: 0 as any, timestamp: '2023-01-01T10:00:00Z' },
		        { questionId: 'q2', response: 9 as any, timestamp: '2023-01-01T10:00:05Z' }
		      ];
		      
		      const result = validateAssessmentResponses(invalidResponses, new Set(['q1', 'q2']));
		      
		      expect(result.isValid).toBe(false);
		      expect(result.errors.length).toBeGreaterThan(0);
		      expect(result.errors.some(e => e.includes('Invalid response value'))).toBe(true);
		    });
		
		    it('should warn about suspiciously fast responses', () => {
		      const result = validateAssessmentResponses(mockResponses.suspiciousFast, new Set(['q1', 'q2', 'q3', 'q4', 'q5']));
		      
		      expect(result.warnings.length).toBeGreaterThan(0);
		      expect(result.warnings.some(w => w.includes('Very fast response time'))).toBe(true);
		    });
		
		    it('should detect invalid timestamps', () => {
		      const invalidTimestamps = [
		        { questionId: 'q1', response: 5, timestamp: 'invalid-date' }
		      ] as AssessmentResponse[];
		      
		      const result = validateAssessmentResponses(invalidTimestamps, new Set(['q1']));
		      
		      expect(result.isValid).toBe(false);
		      expect(result.errors.some(e => e.includes('Invalid timestamp'))).toBe(true);
		    });
		
		    it('should warn about straight-line responding', () => {
		      const result = validateAssessmentResponses(mockResponses.suspiciousFast, new Set(['q1', 'q2', 'q3', 'q4', 'q5']));
		      
		      expect(result.warnings.some(w => w.includes('straight-line responding'))).toBe(true);
		    });
		  });
		
		  describe('calculateReliabilityMetrics', () => {
		    it('should calculate reliability metrics for valid responses', () => {
		      const result = calculateReliabilityMetrics(mockResponses.realistic);
		      
		      expect(result.cronbachAlpha).toBeGreaterThanOrEqual(0);
		      expect(result.cronbachAlpha).toBeLessThanOrEqual(1);
		      expect(result.standardError).toBeGreaterThan(0);
		      expect(result.confidenceInterval).toHaveLength(2);
		      expect(result.confidenceInterval[0]).toBeLessThan(result.confidenceInterval[1]);
		    });
		
		    it('should handle minimum data requirements', () => {
		      const singleResponse = [mockResponses.realistic[0]];
		      const result = calculateReliabilityMetrics(singleResponse);
		      
		      expect(result.cronbachAlpha).toBe(0);
		    });
		
		    it('should produce higher alpha for more consistent responses', () => {
		      const consistentResult = calculateReliabilityMetrics(mockResponses.perfect);
		      const inconsistentResult = calculateReliabilityMetrics(mockResponses.realistic);
		      
		      expect(consistentResult.cronbachAlpha).toBeGreaterThanOrEqual(inconsistentResult.cronbachAlpha);
		    });
		  });
		
		  describe('calculatePercentileRank', () => {
		    it('should calculate percentile rank correctly', () => {
		      algorithmTestCases.percentileCalculation.forEach(({ score, scores, expected }) => {
		        const result = calculatePercentileRank(score, scores);
		        expect(result).toBeCloseTo(expected, 2);
		      });
		    });
		
		    it('should handle edge cases', () => {
		      expect(calculatePercentileRank(50, [])).toBe(50); // Default to median
		      expect(calculatePercentileRank(100, [100])).toBe(50); // Single score
		      expect(calculatePercentileRank(50, [10, 20, 30, 40])).toBe(100); // Above all
		      expect(calculatePercentileRank(5, [10, 20, 30, 40])).toBe(0); // Below all
		    });
		
		    it('should handle ties correctly', () => {
		      const scores = [50, 50, 50, 50];
		      expect(calculatePercentileRank(50, scores)).toBe(100);
		    });
		
		    // Property-based testing
		    it('should always return values between 0-100', () => {
		      fc.assert(fc.property(
		        fc.integer({ min: 1, max: 100 }),
		        fc.array(fc.integer({ min: 1, max: 100 }), { minLength: 1, maxLength: 50 }),
		        (score, scores) => {
		          const percentile = calculatePercentileRank(score, scores);
		          return percentile >= 0 && percentile <= 100;
		        }
		      ));
		    });
		  });
		
		  // Performance tests
		  describe('Performance benchmarks', () => {
		    it('should handle small datasets efficiently', () => {
		      const start = performance.now();
		      
		      for (let i = 0; i < 100; i++) {
		        calculateMeanScore(performanceTestData.small);
		        likertToNormalizedScore(mockDataGenerators.randomLikertResponse(), false);
		      }
		      
		      const duration = performance.now() - start;
		      expect(duration).toBeLessThan(100); // Should complete in under 100ms
		    });
		
		    it('should handle medium datasets efficiently', () => {
		      const start = performance.now();
		      
		      for (let i = 0; i < 10; i++) {
		        calculateMeanScore(performanceTestData.medium);
		        calculateReliabilityMetrics(performanceTestData.medium);
		      }
		      
		      const duration = performance.now() - start;
		      expect(duration).toBeLessThan(1000); // Should complete in under 1 second
		    });
		
		    it('should handle large datasets within reasonable time', () => {
		      const start = performance.now();
		      
		      calculateMeanScore(performanceTestData.large);
		      calculateReliabilityMetrics(performanceTestData.large);
		      validateAssessmentResponses(performanceTestData.large, new Set());
		      
		      const duration = performance.now() - start;
		      expect(duration).toBeLessThan(5000); // Should complete in under 5 seconds
		    });
		  });
		
		  // Integration tests
		  describe('End-to-end scoring workflow', () => {
		    it('should process complete assessment from responses to final scores', () => {
		      const responses = mockResponses.realistic;
		      
		      // Validate responses
		      const validation = validateAssessmentResponses(responses, new Set(['q1', 'q2', 'q3', 'q4', 'q5']));
		      expect(validation.isValid).toBe(true);
		      
		      // Calculate subscale score
		      const subscaleScore = calculateSubscaleScore(responses, 'communication');
		      expect(subscaleScore).toBeDefined();
		      expect(subscaleScore.reliability).toBeGreaterThan(0);
		      
		      // Calculate composite indices
		      const subscales = [subscaleScore];
		      const compositeIndices = calculateCompositeIndices(subscales);
		      expect(compositeIndices).toBeDefined();
		      
		      // Calculate reliability metrics
		      const reliability = calculateReliabilityMetrics(responses);
		      expect(reliability.cronbachAlpha).toBeGreaterThanOrEqual(0);
		    });
		  });
		});]]></file>
	<file path='tests/__tests__/twintuitionService.test.ts'><![CDATA[
		import { twintuitionService } from '../../services/twintuitionService';
		import { BehaviorEvent } from '../../types/twintuition';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		
		// Mock dependencies
		jest.mock('expo-notifications');
		jest.mock('expo-location', () => ({
		  requestForegroundPermissionsAsync: jest.fn(() => 
		    Promise.resolve({ status: 'denied' })
		  ),
		  getCurrentPositionAsync: jest.fn(),
		}));
		jest.mock('@react-native-async-storage/async-storage');
		
		// Mock the twinStore with proper state
		const mockUserProfile = {
		  id: 'test-user-123',
		  name: 'Test User',
		  age: 25,
		  gender: 'female',
		  twinType: 'identical' as const,
		  birthDate: '1998-01-01',
		  accentColor: 'neon-pink' as const,
		  isConnected: true
		};
		
		const mockTwinProfile = {
		  id: 'test-twin-456',
		  name: 'Test Twin',
		  age: 25,
		  gender: 'female',
		  twinType: 'identical' as const,
		  birthDate: '1998-01-01',
		  accentColor: 'neon-blue' as const,
		  isConnected: true
		};
		
		jest.mock('../../state/twinStore', () => ({
		  useTwinStore: {
		    getState: () => ({
		      userProfile: mockUserProfile,
		      twinProfile: mockTwinProfile,
		      twintuitionAlerts: []
		    })
		  }
		}));
		
		describe('TwintuitionService', () => {
		  beforeEach(() => {
		    jest.clearAllMocks();
		  });
		
		  describe('initialization', () => {
		    it('should initialize successfully', async () => {
		      await expect(twintuitionService.initialize()).resolves.not.toThrow();
		    });
		  });
		
		  describe('behavior tracking', () => {
		    const mockBehaviorEvent: Omit<BehaviorEvent, 'id' | 'timestamp'> = {
		      userId: 'user1',
		      twinId: 'twin1',
		      type: 'app_interaction',
		      action: 'open_app',
		      context: {},
		    };
		
		    it('should track behavior events', async () => {
		      await twintuitionService.trackBehavior(mockBehaviorEvent);
		      // Verify the event was added to the buffer and stored
		    });
		
		    it('should limit buffer size to 100 events', async () => {
		      // Add 150 events
		      for (let i = 0; i < 150; i++) {
		        await twintuitionService.trackBehavior({
		          ...mockBehaviorEvent,
		          userId: `user${i}`,
		        });
		      }
		      
		      // Buffer should only contain last 100 events
		      // This would need access to private buffer property for full testing
		    });
		  });
		
		  describe('app tracking methods', () => {
		    it('should track app open event', async () => {
		      await twintuitionService.trackAppOpen();
		      // Verify trackBehavior was called with correct parameters
		    });
		
		    it('should track message with emotion analysis', async () => {
		      await twintuitionService.trackMessage('I am so happy today! 😊');
		      // Verify message was tracked with emotion detected
		    });
		
		    it('should track mood updates', async () => {
		      await twintuitionService.trackMoodUpdate('happy', 8);
		      // Verify mood update was tracked correctly
		    });
		  });
		
		  describe('emotion analysis', () => {
		    it('should detect happy emotions', async () => {
		      const message = 'I am so happy and excited! 😄🎉';
		      await twintuitionService.trackMessage(message);
		      // Should detect 'happy' or 'excited' emotion
		    });
		
		    it('should detect sad emotions', async () => {
		      const message = 'Feeling really down today 😢';
		      await twintuitionService.trackMessage(message);
		      // Should detect 'sad' emotion
		    });
		
		    it('should default to neutral for unrecognized emotions', async () => {
		      const message = 'Just a normal message with no emotional indicators';
		      await twintuitionService.trackMessage(message);
		      // Should detect 'neutral' emotion
		    });
		  });
		
		  describe('sync score calculation', () => {
		    it('should return initial score of 0 for new users', async () => {
		      const score = await twintuitionService.getTwinSyncScore();
		      expect(score.score).toBe(0);
		      expect(score.breakdown).toHaveProperty('totalSyncEvents');
		      expect(score.breakdown).toHaveProperty('strongestConnection');
		    });
		
		    it('should calculate score based on sync events', async () => {
		      // This would require mocking the store with some alerts
		      // and testing that the score is calculated correctly
		    });
		  });
		
		  describe('configuration management', () => {
		    it('should update configuration', async () => {
		      const newConfig = {
		        sensitivity: 0.8,
		        timeWindowMinutes: 30,
		      };
		      
		      await twintuitionService.updateConfig(newConfig);
		      
		      // Verify AsyncStorage.setItem was called
		      expect(AsyncStorage.setItem).toHaveBeenCalledWith(
		        'twintuition-config',
		        expect.stringContaining('0.8')
		      );
		    });
		
		    it('should load configuration on initialization', async () => {
		      const mockConfig = JSON.stringify({ sensitivity: 0.9 });
		      (AsyncStorage.getItem as jest.Mock).mockResolvedValue(mockConfig);
		      
		      await twintuitionService.initialize();
		      
		      expect(AsyncStorage.getItem).toHaveBeenCalledWith('twintuition-config');
		    });
		  });
		
		  describe('privacy and data management', () => {
		    it('should anonymize location data when storing', async () => {
		      const eventWithLocation: Omit<BehaviorEvent, 'id' | 'timestamp'> = {
		        userId: 'user1',
		        type: 'location_update',
		        action: 'location_change',
		        context: {},
		        location: {
		          latitude: 37.7749,
		          longitude: -122.4194,
		        },
		      };
		      
		      await twintuitionService.trackBehavior(eventWithLocation);
		      
		      // Verify that stored data has location marked as 'REDACTED'
		      // This would need to check the stored data in AsyncStorage
		    });
		
		    it('should limit stored events per day to 50', async () => {
		      // Add more than 50 events for the same day
		      for (let i = 0; i < 60; i++) {
		        await twintuitionService.trackBehavior({
		          userId: `user${i}`,
		          type: 'app_interaction',
		          action: 'test_action',
		          context: {},
		        });
		      }
		      
		      // Verify that only 50 events are stored
		      // This would need to check AsyncStorage contents
		    });
		  });
		
		  describe('notification generation', () => {
		    it('should generate appropriate alert messages', async () => {
		      // This would test the private generateAlertMessage method
		      // by triggering synchronicity detection
		    });
		
		    it('should respect quiet hours', async () => {
		      // Test that notifications are not sent during quiet hours
		      // This would involve mocking the date/time and notification preferences
		    });
		  });
		
		  describe('analytics tracking', () => {
		    it('should track analytics locally', async () => {
		      // Test that analytics are stored locally without sensitive data
		    });
		
		    it('should limit analytics storage to 100 events', async () => {
		      // Test that analytics storage doesn't grow unbounded
		    });
		  });
		
		  describe('error handling', () => {
		    it('should handle AsyncStorage errors gracefully', async () => {
		      (AsyncStorage.setItem as jest.Mock).mockRejectedValue(new Error('Storage error'));
		      
		      await expect(twintuitionService.trackAppOpen()).resolves.not.toThrow();
		    });
		
		    it('should handle notification permission denial gracefully', async () => {
		      // Mock permission denial and ensure service continues to work
		    });
		
		    it('should handle location permission denial gracefully', async () => {
		      // Mock location permission denial
		      await expect(twintuitionService.requestLocationPermission()).resolves.toBe(false);
		    });
		  });
		});
		
		// Integration tests
		describe('TwintuitionService Integration', () => {
		  describe('end-to-end synchronicity detection', () => {
		    it('should detect app synchronization', async () => {
		      // Simulate two twins opening the app within the time window
		      await twintuitionService.trackBehavior({
		        userId: 'twin1',
		        twinId: 'twin2',
		        type: 'app_interaction',
		        action: 'open_app',
		        context: {},
		      });
		      
		      // Wait a moment then track twin2
		      setTimeout(async () => {
		        await twintuitionService.trackBehavior({
		          userId: 'twin2',
		          twinId: 'twin1',
		          type: 'app_interaction',
		          action: 'open_app',
		          context: {},
		        });
		        
		        // Should trigger synchronicity detection
		        // Verify alert is generated
		      }, 1000);
		    });
		
		    it('should detect mood synchronization', async () => {
		      // Simulate both twins reporting similar moods
		      await twintuitionService.trackMoodUpdate('happy', 8);
		      
		      setTimeout(async () => {
		        await twintuitionService.trackMoodUpdate('excited', 9);
		        // Should detect emotional synchronicity
		      }, 5000);
		    });
		  });
		});]]></file>
	<file path='tests/mocks/assessmentMockData.ts'>
		/**
		 * Mock Data for Assessment Testing
		 * Diverse twin scenarios for comprehensive test coverage
		 */
		
		import { 
		  AssessmentResponse, 
		  AssessmentSession, 
		  AssessmentResults,
		  SubscaleScore,
		  CompositeIndex,
		  LikertResponse,
		  AssessmentCategory
		} from '../../utils/assessment/types';
		
		/**
		 * Generate mock assessment responses with various patterns
		 */
		export const mockResponses = {
		  // Perfect responses (all 8s)
		  perfect: [
		    { questionId: 'q1', response: 8, timestamp: '2023-01-01T10:00:00Z', responseTime: 2000 },
		    { questionId: 'q2', response: 8, timestamp: '2023-01-01T10:00:05Z', responseTime: 2500 },
		    { questionId: 'q3', response: 8, timestamp: '2023-01-01T10:00:10Z', responseTime: 1800 },
		    { questionId: 'q4', response: 8, timestamp: '2023-01-01T10:00:15Z', responseTime: 2200 },
		    { questionId: 'q5', response: 8, timestamp: '2023-01-01T10:00:20Z', responseTime: 1900 }
		  ] as AssessmentResponse[],
		
		  // Poor responses (all 1s)
		  poor: [
		    { questionId: 'q1', response: 1, timestamp: '2023-01-01T10:00:00Z', responseTime: 1000 },
		    { questionId: 'q2', response: 1, timestamp: '2023-01-01T10:00:05Z', responseTime: 1200 },
		    { questionId: 'q3', response: 1, timestamp: '2023-01-01T10:00:10Z', responseTime: 900 },
		    { questionId: 'q4', response: 1, timestamp: '2023-01-01T10:00:15Z', responseTime: 1100 },
		    { questionId: 'q5', response: 1, timestamp: '2023-01-01T10:00:20Z', responseTime: 950 }
		  ] as AssessmentResponse[],
		
		  // Mixed realistic responses
		  realistic: [
		    { questionId: 'q1', response: 6, timestamp: '2023-01-01T10:00:00Z', responseTime: 3000 },
		    { questionId: 'q2', response: 4, timestamp: '2023-01-01T10:00:05Z', responseTime: 4500 },
		    { questionId: 'q3', response: 7, timestamp: '2023-01-01T10:00:10Z', responseTime: 2800 },
		    { questionId: 'q4', response: 3, timestamp: '2023-01-01T10:00:15Z', responseTime: 5200 },
		    { questionId: 'q5', response: 8, timestamp: '2023-01-01T10:00:20Z', responseTime: 2100 }
		  ] as AssessmentResponse[],
		
		  // Suspicious fast responses (potential quality issues)
		  suspiciousFast: [
		    { questionId: 'q1', response: 5, timestamp: '2023-01-01T10:00:00Z', responseTime: 200 },
		    { questionId: 'q2', response: 5, timestamp: '2023-01-01T10:00:05Z', responseTime: 150 },
		    { questionId: 'q3', response: 5, timestamp: '2023-01-01T10:00:10Z', responseTime: 300 },
		    { questionId: 'q4', response: 5, timestamp: '2023-01-01T10:00:15Z', responseTime: 180 },
		    { questionId: 'q5', response: 5, timestamp: '2023-01-01T10:00:20Z', responseTime: 220 }
		  ] as AssessmentResponse[],
		
		  // Edge case: missing responses
		  incomplete: [
		    { questionId: 'q1', response: 6, timestamp: '2023-01-01T10:00:00Z', responseTime: 3000 },
		    { questionId: 'q3', response: 7, timestamp: '2023-01-01T10:00:10Z', responseTime: 2800 },
		    { questionId: 'q5', response: 8, timestamp: '2023-01-01T10:00:20Z', responseTime: 2100 }
		  ] as AssessmentResponse[],
		
		  // Large dataset for performance testing
		  largePerfect: Array.from({ length: 100 }, (_, i) => ({
		    questionId: `q${i + 1}`,
		    response: 8 as LikertResponse,
		    timestamp: new Date(2023, 0, 1, 10, 0, i * 5).toISOString(),
		    responseTime: 2000 + Math.random() * 1000
		  })),
		
		  largeRealistic: Array.from({ length: 100 }, (_, i) => ({
		    questionId: `q${i + 1}`,
		    response: Math.floor(Math.random() * 8 + 1) as LikertResponse,
		    timestamp: new Date(2023, 0, 1, 10, 0, i * 5).toISOString(),
		    responseTime: 1000 + Math.random() * 4000
		  }))
		};
		
		/**
		 * Mock assessment sessions for different scenarios
		 */
		export const mockSessions = {
		  completed: {
		    id: 'session_1',
		    userId: 'user_1',
		    startTime: '2023-01-01T10:00:00Z',
		    endTime: '2023-01-01T10:30:00Z',
		    responses: mockResponses.realistic,
		    progress: 100,
		    isComplete: true,
		    version: '1.0.0'
		  } as AssessmentSession,
		
		  inProgress: {
		    id: 'session_2',
		    userId: 'user_2',
		    startTime: '2023-01-01T11:00:00Z',
		    responses: mockResponses.incomplete,
		    progress: 60,
		    isComplete: false,
		    version: '1.0.0'
		  } as AssessmentSession,
		
		  abandoned: {
		    id: 'session_3',
		    userId: 'user_3',
		    startTime: '2023-01-01T12:00:00Z',
		    endTime: '2023-01-01T12:05:00Z',
		    responses: [mockResponses.realistic[0]],
		    progress: 5,
		    isComplete: false,
		    version: '1.0.0'
		  } as AssessmentSession
		};
		
		/**
		 * Mock subscale scores for different twin profiles
		 */
		export const mockSubscales = {
		  highFunctioningTwin: [
		    {
		      category: 'communication' as AssessmentCategory,
		      rawScore: 7.2,
		      normalizedScore: 88.6,
		      percentile: 85,
		      interpretation: 'high' as const,
		      reliability: 0.89
		    },
		    {
		      category: 'emotional_connection' as AssessmentCategory,
		      rawScore: 6.8,
		      normalizedScore: 82.9,
		      percentile: 78,
		      interpretation: 'high' as const,
		      reliability: 0.91
		    },
		    {
		      category: 'conflict_resolution' as AssessmentCategory,
		      rawScore: 6.5,
		      normalizedScore: 78.6,
		      percentile: 72,
		      interpretation: 'above_average' as const,
		      reliability: 0.87
		    },
		    {
		      category: 'independence' as AssessmentCategory,
		      rawScore: 5.8,
		      normalizedScore: 68.6,
		      percentile: 58,
		      interpretation: 'average' as const,
		      reliability: 0.83
		    },
		    {
		      category: 'support_system' as AssessmentCategory,
		      rawScore: 7.0,
		      normalizedScore: 85.7,
		      percentile: 80,
		      interpretation: 'high' as const,
		      reliability: 0.88
		    }
		  ] as SubscaleScore[],
		
		  challengedTwin: [
		    {
		      category: 'communication' as AssessmentCategory,
		      rawScore: 3.2,
		      normalizedScore: 31.4,
		      percentile: 25,
		      interpretation: 'below_average' as const,
		      reliability: 0.89
		    },
		    {
		      category: 'emotional_connection' as AssessmentCategory,
		      rawScore: 2.8,
		      normalizedScore: 25.7,
		      percentile: 18,
		      interpretation: 'low' as const,
		      reliability: 0.91
		    },
		    {
		      category: 'conflict_resolution' as AssessmentCategory,
		      rawScore: 2.5,
		      normalizedScore: 21.4,
		      percentile: 12,
		      interpretation: 'low' as const,
		      reliability: 0.87
		    },
		    {
		      category: 'independence' as AssessmentCategory,
		      rawScore: 4.8,
		      normalizedScore: 54.3,
		      percentile: 52,
		      interpretation: 'average' as const,
		      reliability: 0.83
		    },
		    {
		      category: 'support_system' as AssessmentCategory,
		      rawScore: 3.0,
		      normalizedScore: 28.6,
		      percentile: 22,
		      interpretation: 'below_average' as const,
		      reliability: 0.88
		    }
		  ] as SubscaleScore[],
		
		  balancedTwin: [
		    {
		      category: 'communication' as AssessmentCategory,
		      rawScore: 5.0,
		      normalizedScore: 57.1,
		      percentile: 52,
		      interpretation: 'average' as const,
		      reliability: 0.89
		    },
		    {
		      category: 'emotional_connection' as AssessmentCategory,
		      rawScore: 4.8,
		      normalizedScore: 54.3,
		      percentile: 48,
		      interpretation: 'average' as const,
		      reliability: 0.91
		    },
		    {
		      category: 'conflict_resolution' as AssessmentCategory,
		      rawScore: 5.2,
		      normalizedScore: 60.0,
		      percentile: 55,
		      interpretation: 'average' as const,
		      reliability: 0.87
		    },
		    {
		      category: 'independence' as AssessmentCategory,
		      rawScore: 5.5,
		      normalizedScore: 64.3,
		      percentile: 62,
		      interpretation: 'average' as const,
		      reliability: 0.83
		    },
		    {
		      category: 'support_system' as AssessmentCategory,
		      rawScore: 4.7,
		      normalizedScore: 52.9,
		      percentile: 45,
		      interpretation: 'average' as const,
		      reliability: 0.88
		    }
		  ] as SubscaleScore[]
		};
		
		/**
		 * Mock composite indices for different scenarios
		 */
		export const mockCompositeIndices = {
		  highConnection: {
		    CI: 85, // High connection index
		    ARI: 15, // Low autonomy-relatedness imbalance (good balance)
		    TRS: 82 // High twin relationship strength
		  } as CompositeIndex,
		
		  lowConnection: {
		    CI: 28, // Low connection index
		    ARI: 45, // High autonomy-relatedness imbalance
		    TRS: 35 // Low twin relationship strength
		  } as CompositeIndex,
		
		  balanced: {
		    CI: 55, // Average connection
		    ARI: 22, // Moderate balance
		    TRS: 58 // Average relationship strength
		  } as CompositeIndex
		};
		
		/**
		 * Mock complete assessment results for different twin types
		 */
		export const mockAssessmentResults = {
		  identicalTwinsHighFunctioning: {
		    sessionId: 'session_identical_high_1',
		    userId: 'twin_1_identical',
		    completedAt: '2023-01-01T10:30:00Z',
		    subscales: mockSubscales.highFunctioningTwin,
		    compositeIndices: mockCompositeIndices.highConnection,
		    overallScore: 84,
		    growthAreas: [],
		    strengths: ['communication', 'emotional_connection', 'support_system'],
		    reliabilityMetrics: {
		      cronbachAlpha: 0.91,
		      standardError: 0.68,
		      confidenceInterval: [6.2, 7.8] as [number, number]
		    }
		  } as AssessmentResults,
		
		  identicalTwinsChallenged: {
		    sessionId: 'session_identical_challenged_1',
		    userId: 'twin_2_identical',
		    completedAt: '2023-01-01T11:30:00Z',
		    subscales: mockSubscales.challengedTwin,
		    compositeIndices: mockCompositeIndices.lowConnection,
		    overallScore: 32,
		    growthAreas: [
		      {
		        category: 'communication' as AssessmentCategory,
		        priority: 'high' as const,
		        recommendedActions: ['Practice active listening', 'Use structured communication'],
		        resources: ['Communication workbook', 'Twin therapy sessions']
		      },
		      {
		        category: 'emotional_connection' as AssessmentCategory,
		        priority: 'high' as const,
		        recommendedActions: ['Emotion validation exercises', 'Shared activities'],
		        resources: ['Emotion coaching guide', 'Twin bonding activities']
		      }
		    ],
		    strengths: ['independence'],
		    reliabilityMetrics: {
		      cronbachAlpha: 0.88,
		      standardError: 0.82,
		      confidenceInterval: [2.1, 4.3] as [number, number]
		    }
		  } as AssessmentResults,
		
		  fraternalTwinsBalanced: {
		    sessionId: 'session_fraternal_balanced_1',
		    userId: 'twin_1_fraternal',
		    completedAt: '2023-01-01T12:30:00Z',
		    subscales: mockSubscales.balancedTwin,
		    compositeIndices: mockCompositeIndices.balanced,
		    overallScore: 57,
		    growthAreas: [
		      {
		        category: 'communication' as AssessmentCategory,
		        priority: 'medium' as const,
		        recommendedActions: ['Improve clarity in expression'],
		        resources: ['Communication skills guide']
		      }
		    ],
		    strengths: ['independence', 'conflict_resolution'],
		    reliabilityMetrics: {
		      cronbachAlpha: 0.86,
		      standardError: 0.74,
		      confidenceInterval: [4.2, 5.8] as [number, number]
		    }
		  } as AssessmentResults
		};
		
		/**
		 * Mock data generators for property-based testing
		 */
		export const mockDataGenerators = {
		  /**
		   * Generate random valid Likert response
		   */
		  randomLikertResponse: (): LikertResponse => {
		    return (Math.floor(Math.random() * 8) + 1) as LikertResponse;
		  },
		
		  /**
		   * Generate array of random responses for testing
		   */
		  randomResponseArray: (length: number): AssessmentResponse[] => {
		    return Array.from({ length }, (_, i) => ({
		      questionId: `q${i + 1}`,
		      response: mockDataGenerators.randomLikertResponse(),
		      timestamp: new Date(Date.now() - (length - i) * 5000).toISOString(),
		      responseTime: 1000 + Math.random() * 4000
		    }));
		  },
		
		  /**
		   * Generate edge case responses (boundary values)
		   */
		  edgeCaseResponses: (): AssessmentResponse[] => [
		    { questionId: 'edge1', response: 1, timestamp: '2023-01-01T10:00:00Z', responseTime: 500 },
		    { questionId: 'edge2', response: 8, timestamp: '2023-01-01T10:00:05Z', responseTime: 5000 },
		    { questionId: 'edge3', response: 1, timestamp: '2023-01-01T10:00:10Z', responseTime: 100 }, // Very fast
		    { questionId: 'edge4', response: 8, timestamp: '2023-01-01T10:00:15Z', responseTime: 10000 } // Very slow
		  ],
		
		  /**
		   * Generate invalid data for error testing
		   */
		  invalidResponses: () => [
		    // These would cause errors in real usage
		    { questionId: 'invalid1', response: 0 as any, timestamp: '2023-01-01T10:00:00Z' },
		    { questionId: 'invalid2', response: 9 as any, timestamp: '2023-01-01T10:00:05Z' },
		    { questionId: 'invalid3', response: 5 as LikertResponse, timestamp: 'invalid-date' },
		    { questionId: '', response: 5 as LikertResponse, timestamp: '2023-01-01T10:00:15Z' }
		  ]
		};
		
		/**
		 * Mock normative data for testing percentile calculations
		 */
		export const mockNormativeData = {
		  communication: { mean: 52.3, std: 14.7 },
		  emotional_connection: { mean: 48.9, std: 16.2 },
		  shared_experiences: { mean: 51.1, std: 13.8 },
		  conflict_resolution: { mean: 49.7, std: 15.4 },
		  independence: { mean: 53.2, std: 12.9 },
		  support_system: { mean: 50.8, std: 14.1 },
		  psychic_connection: { mean: 45.3, std: 18.6 },
		  identity_formation: { mean: 52.7, std: 13.5 }
		};
		
		/**
		 * Performance testing datasets
		 */
		export const performanceTestData = {
		  small: mockDataGenerators.randomResponseArray(10),
		  medium: mockDataGenerators.randomResponseArray(100),
		  large: mockDataGenerators.randomResponseArray(1000),
		  xlarge: mockDataGenerators.randomResponseArray(10000)
		};
		
		/**
		 * Test data for specific algorithm validation
		 */
		export const algorithmTestCases = {
		  likertConversion: [
		    { input: 1, expected: 0, reversed: false },
		    { input: 8, expected: 100, reversed: false },
		    { input: 1, expected: 100, reversed: true },
		    { input: 8, expected: 0, reversed: true },
		    { input: 5, expected: 57.14, reversed: false } // (5-1)/7*100 = 57.14
		  ],
		  
		  reverseScoring: [
		    { input: 1, expected: 8 },
		    { input: 8, expected: 1 },
		    { input: 4, expected: 5 },
		    { input: 5, expected: 4 }
		  ],
		  
		  percentileCalculation: [
		    { score: 75, scores: [50, 60, 70, 75, 80, 90], expected: 66.67 },
		    { score: 50, scores: [50, 50, 50, 50], expected: 100 },
		    { score: 100, scores: [10, 20, 30, 40], expected: 100 }
		  ]
		};</file>
	<file path='tests/mocks/expo-location.js'>
		// Mock for expo-location
		export const getCurrentPositionAsync = jest.fn(() => Promise.resolve({
		  coords: {
		    latitude: 37.7749,
		    longitude: -122.4194,
		    accuracy: 10,
		  }
		}));
		
		export const requestForegroundPermissionsAsync = jest.fn(() => Promise.resolve({ status: 'granted' }));
		export const getPermissionsAsync = jest.fn(() => Promise.resolve({ status: 'granted' }));
		
		export default {
		  getCurrentPositionAsync,
		  requestForegroundPermissionsAsync,
		  getPermissionsAsync,
		};</file>
	<file path='tests/mocks/expo-notifications.js'>
		// Mock for expo-notifications
		export const setNotificationHandler = jest.fn();
		export const scheduleNotificationAsync = jest.fn();
		export const getAllScheduledNotificationsAsync = jest.fn(() => Promise.resolve([]));
		export const cancelAllScheduledNotificationsAsync = jest.fn(() => Promise.resolve());
		export const getPermissionsAsync = jest.fn(() => Promise.resolve({ status: 'granted' }));
		export const requestPermissionsAsync = jest.fn(() => Promise.resolve({ status: 'granted' }));
		
		export default {
		  setNotificationHandler,
		  scheduleNotificationAsync,
		  getAllScheduledNotificationsAsync,
		  cancelAllScheduledNotificationsAsync,
		  getPermissionsAsync,
		  requestPermissionsAsync,
		};</file>
	<file path='tests/setup.ts'>
		import '@testing-library/jest-native/extend-expect';
		
		// Mock AsyncStorage
		jest.mock('@react-native-async-storage/async-storage', () => ({
		  setItem: jest.fn(() => Promise.resolve()),
		  getItem: jest.fn(() => Promise.resolve(null)),
		  removeItem: jest.fn(() => Promise.resolve()),
		  clear: jest.fn(() => Promise.resolve()),
		  getAllKeys: jest.fn(() => Promise.resolve([])),
		}));
		
		// Mock react-native modules
		jest.mock('react-native', () => ({
		  Platform: {
		    OS: 'ios',
		    select: (config: any) => config.ios || config.default,
		  },
		  Dimensions: {
		    get: () => ({ width: 375, height: 812 }),
		    addEventListener: jest.fn(),
		    removeEventListener: jest.fn(),
		  },
		  Alert: {
		    alert: jest.fn(),
		  },
		}));
		
		// Mock zustand persist
		jest.mock('zustand/middleware', () => ({
		  persist: (config: any) => config,
		  createJSONStorage: () => ({
		    getItem: jest.fn(),
		    setItem: jest.fn(),
		    removeItem: jest.fn(),
		  }),
		}));
		
		// Global test utilities
		global.console = {
		  ...console,
		  warn: jest.fn(),
		  error: jest.fn(),
		};</file>
	<file path='tests/telemetry/telemetryIntegration.test.ts'><![CDATA[
		/**
		 * Telemetry Integration Tests
		 * Tests privacy-compliant data collection and analysis
		 */
		
		import { telemetryService } from '../../services/telemetryService';
		import { anomalyDetector } from '../../utils/anomalyDetection';
		import { statisticalNorming } from '../../utils/statisticalNorming';
		import { useTelemetryStore } from '../../state/telemetryStore';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		
		// Mock AsyncStorage for testing
		jest.mock('@react-native-async-storage/async-storage', () => ({
		  getItem: jest.fn(),
		  setItem: jest.fn(),
		  removeItem: jest.fn(),
		  clear: jest.fn(),
		}));
		
		// Mock Crypto for testing
		jest.mock('expo-crypto', () => ({
		  getRandomBytesAsync: jest.fn(() => Promise.resolve(new Uint8Array(16))),
		  digestStringAsync: jest.fn((algorithm, data) => 
		    Promise.resolve(`hashed_${data.substring(0, 8)}`)
		  ),
		  CryptoDigestAlgorithm: {
		    SHA256: 'SHA256',
		  },
		}));
		
		describe('TelemetryService', () => {
		  beforeEach(async () => {
		    jest.clearAllMocks();
		    await telemetryService.initialize(false);
		  });
		
		  describe('Initialization and Consent', () => {
		    it('should initialize with consent disabled by default', async () => {
		      const config = telemetryService.getConfig();
		      expect(config.enabled).toBe(false);
		      expect(config.consentRequired).toBe(true);
		    });
		
		    it('should enable telemetry when consent is granted', async () => {
		      await telemetryService.updateConsent(true);
		      const config = telemetryService.getConfig();
		      expect(config.enabled).toBe(true);
		    });
		
		    it('should create anonymous session when enabled', async () => {
		      await telemetryService.updateConsent(true);
		      const sessionInfo = telemetryService.getSessionInfo();
		      
		      expect(sessionInfo).toBeTruthy();
		      expect(sessionInfo?.sessionId).toBeTruthy();
		      expect(sessionInfo?.dataQualityScore).toBe(1.0);
		      expect(sessionInfo?.flagged).toBe(false);
		    });
		  });
		
		  describe('Data Collection', () => {
		    beforeEach(async () => {
		      await telemetryService.updateConsent(true);
		    });
		
		    it('should track question events with privacy compliance', async () => {
		      const questionData = {
		        questionId: 'test_q1',
		        questionCategory: 'identity_fusion' as const,
		        questionIndex: 0,
		        sectionId: 'section_1',
		        timeOnQuestion: 5000,
		        responseValue: 5 as const,
		        revisionCount: 0,
		        confidenceLevel: 4,
		      };
		
		      await telemetryService.trackQuestionEvent('question_answered', questionData);
		      
		      // Should store event in queue (tested via AsyncStorage mock calls)
		      expect(AsyncStorage.setItem).toHaveBeenCalledWith(
		        'telemetry_queue',
		        expect.stringContaining('question_answered')
		      );
		    });
		
		    it('should track assessment completion with metrics', async () => {
		      const assessmentData = {
		        assessmentVersion: '1.0.0',
		        totalQuestions: 50,
		        completedQuestions: 50,
		        totalTimeSpent: 900000, // 15 minutes
		        totalRevisions: 5,
		      };
		
		      await telemetryService.trackAssessmentEvent('assessment_completed', assessmentData);
		      
		      expect(AsyncStorage.setItem).toHaveBeenCalledWith(
		        'telemetry_queue',
		        expect.stringContaining('assessment_completed')
		      );
		    });
		
		    it('should not collect data when consent is withdrawn', async () => {
		      await telemetryService.updateConsent(false);
		      
		      const questionData = {
		        questionId: 'test_q1',
		        questionCategory: 'identity_fusion' as const,
		        questionIndex: 0,
		        sectionId: 'section_1',
		        timeOnQuestion: 5000,
		        responseValue: 5 as const,
		        revisionCount: 0,
		      };
		
		      await telemetryService.trackQuestionEvent('question_answered', questionData);
		      
		      // Should not create queue entries when disabled
		      const queueCalls = (AsyncStorage.setItem as jest.Mock).mock.calls.filter(
		        call => call[0] === 'telemetry_queue'
		      );
		      
		      // There should be no queue calls after disabling consent
		      const callsAfterDisabling = queueCalls.slice(-1);  
		      expect(callsAfterDisabling.length === 0 || callsAfterDisabling[0][1] === '[]').toBe(true);
		    });
		  });
		
		  describe('Privacy Compliance', () => {
		    beforeEach(async () => {
		      await telemetryService.updateConsent(true);
		    });
		
		    it('should hash sensitive values for privacy', async () => {
		      const questionData = {
		        questionId: 'test_q1',
		        questionCategory: 'identity_fusion' as const,
		        questionIndex: 0,
		        sectionId: 'section_1',
		        timeOnQuestion: 5000,
		        responseValue: 'sensitive_response',
		        revisionCount: 0,
		      };
		
		      await telemetryService.trackQuestionEvent('question_answered', questionData);
		      
		      // Verify that response patterns are hashed, not stored directly
		      const queueCall = (AsyncStorage.setItem as jest.Mock).mock.calls.find(
		        call => call[0] === 'telemetry_queue'
		      );
		      
		      expect(queueCall[1]).not.toContain('sensitive_response');
		      expect(queueCall[1]).toContain('hashed_');
		    });
		
		    it('should create anonymized session identifiers', async () => {
		      const sessionInfo = telemetryService.getSessionInfo();
		      
		      expect(sessionInfo?.sessionId).toBeTruthy();
		      expect(sessionInfo?.sessionId).toMatch(/^[0-9a-f]+$/); // Hex format
		      expect(sessionInfo?.sessionId.length).toBeGreaterThan(16); // Sufficient entropy
		    });
		  });
		
		  describe('Batch Processing', () => {
		    beforeEach(async () => {
		      await telemetryService.updateConsent(true);
		    });
		
		    it('should process batches when queue reaches limit', async () => {
		      const batchSize = telemetryService.getConfig().batchSize;
		      
		      // Add events up to batch size
		      for (let i = 0; i < batchSize; i++) {
		        await telemetryService.trackQuestionEvent('question_viewed', {
		          questionId: `test_q${i}`,
		          questionCategory: 'identity_fusion',
		          questionIndex: i,
		          sectionId: 'section_1',
		          timeOnQuestion: 1000,
		          revisionCount: 0,
		        });
		      }
		
		      // Should trigger batch processing
		      expect(AsyncStorage.setItem).toHaveBeenCalledWith(
		        'telemetry_batches',
		        expect.stringContaining('batchId')
		      );
		    });
		  });
		});
		
		describe('AnomalyDetection', () => {
		  describe('Straight-line Responding', () => {
		    it('should detect straight-line responding patterns', () => {
		      const pattern = {
		        responses: [5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
		        timestamps: Array.from({ length: 10 }, (_, i) => Date.now() + i * 1000),
		        revisions: Array(10).fill(0),
		        categories: Array(10).fill('identity_fusion'),
		      };
		
		      const result = anomalyDetector.analyzeStraightLineResponding(pattern);
		      
		      expect(result.detected).toBe(true);
		      expect(result.type).toBe('straight_line_responding');
		      expect(result.severity).toBe('critical');
		      expect(result.confidence).toBeGreaterThan(0.8);
		    });
		
		    it('should not flag normal response variance', () => {
		      const pattern = {
		        responses: [1, 3, 5, 2, 4, 6, 3, 5, 2, 4],
		        timestamps: Array.from({ length: 10 }, (_, i) => Date.now() + i * 3000),
		        revisions: Array(10).fill(0),
		        categories: Array(10).fill('identity_fusion'),
		      };
		
		      const result = anomalyDetector.analyzeStraightLineResponding(pattern);
		      
		      expect(result.detected).toBe(false);
		    });
		  });
		
		  describe('Timing Anomalies', () => {
		    it('should detect bot-like fast responses', () => {
		      const pattern = {
		        responseTimes: Array(10).fill(300), // Consistent 300ms responses
		        averageTime: 300,
		        variance: 0,
		        outliers: [],
		      };
		
		      const result = anomalyDetector.analyzeResponseTiming(pattern);
		      
		      expect(result.detected).toBe(true);
		      expect(result.type).toBe('bot_like_behavior');
		      expect(result.severity).toBe('critical');
		    });
		
		    it('should handle normal timing variations', () => {
		      const pattern = {
		        responseTimes: [2000, 3500, 4200, 2800, 3100, 5000, 2500, 3800],
		        averageTime: 3375,
		        variance: 875000, // Reasonable variance
		        outliers: [5000],
		      };
		
		      const result = anomalyDetector.analyzeResponseTiming(pattern);
		      
		      expect(result.detected).toBe(false);
		    });
		  });
		
		  describe('Response Patterns', () => {
		    it('should detect alternating response patterns', () => {
		      const pattern = {
		        responses: [1, 7, 1, 7, 1, 7, 1, 7, 1, 7],
		        timestamps: Array.from({ length: 10 }, (_, i) => Date.now() + i * 2000),
		        revisions: Array(10).fill(0),
		        categories: Array(10).fill('identity_fusion'),
		      };
		
		      const result = anomalyDetector.analyzeResponseConsistency(pattern);
		      
		      expect(result.detected).toBe(true);
		      expect(result.type).toBe('inconsistent_patterns');
		      expect(result.statisticalEvidence.alternatingScore).toBeGreaterThan(0.5);
		    });
		  });
		});
		
		describe('StatisticalNorming', () => {
		  describe('Norming Statistics Calculation', () => {
		    it('should calculate comprehensive norming statistics', () => {
		      const sampleData = {
		        questionId: 'test_q1',
		        category: 'identity_fusion' as const,
		        responses: [1, 2, 3, 4, 5, 4, 3, 2, 1, 5, 4, 3, 2, 1, 5], // Varied responses
		        responseTimes: Array(15).fill(3000),
		        revisions: Array(15).fill(0),
		        sessionIds: Array.from({ length: 15 }, (_, i) => `session_${i}`),
		      };
		
		      const stats = statisticalNorming.calculateNormingStatistics(sampleData);
		      
		      expect(stats.questionId).toBe('test_q1');
		      expect(stats.category).toBe('identity_fusion');
		      expect(stats.sampleSize).toBe(15);
		      expect(stats.statistics.mean).toBeDefined();
		      expect(stats.statistics.standard_deviation).toBeDefined();
		      expect(stats.responseDistribution).toBeDefined();
		      expect(stats.qualityMetrics.averageResponseTime).toBe(3000);
		    });
		
		    it('should throw error for insufficient sample size', () => {
		      const insufficientData = {
		        questionId: 'test_q1',
		        category: 'identity_fusion' as const,
		        responses: [1, 2, 3], // Only 3 responses
		        responseTimes: [1000, 2000, 3000],
		        revisions: [0, 0, 0],
		        sessionIds: ['s1', 's2', 's3'],
		      };
		
		      expect(() => {
		        statisticalNorming.calculateNormingStatistics(insufficientData);
		      }).toThrow('Insufficient sample size');
		    });
		  });
		
		  describe('Item Analysis', () => {
		    it('should analyze item difficulty and discrimination', () => {
		      const itemData = {
		        questionId: 'test_q1',
		        category: 'identity_fusion' as const,
		        responses: [1, 2, 3, 4, 5, 6, 7, 4, 3, 2, 5, 6, 4, 3, 7],
		        responseTimes: Array(15).fill(2500),
		        revisions: Array(15).fill(0),
		        sessionIds: Array.from({ length: 15 }, (_, i) => `session_${i}`),
		      };
		
		      const analysis = statisticalNorming.analyzeItem(itemData);
		      
		      expect(analysis.questionId).toBe('test_q1');
		      expect(analysis.difficulty).toBeGreaterThan(0);
		      expect(analysis.difficulty).toBeLessThan(1);
		      expect(analysis.discrimination).toBeDefined();
		      expect(analysis.recommendations).toBeInstanceOf(Array);
		      expect(typeof analysis.flagged).toBe('boolean');
		    });
		  });
		
		  describe('Reliability Calculation', () => {
		    it('should calculate Cronbach\'s alpha for scale reliability', () => {
		      // Sample item responses for 5 items, 20 respondents
		      const itemResponses = [
		        [4, 3, 5, 2, 4, 3, 5, 4, 3, 2, 5, 4, 3, 2, 4, 5, 3, 4, 2, 5],
		        [3, 4, 4, 3, 5, 4, 4, 3, 4, 3, 4, 5, 4, 3, 5, 4, 4, 3, 3, 4],
		        [5, 5, 6, 4, 5, 5, 6, 5, 4, 4, 6, 5, 4, 4, 5, 6, 5, 5, 4, 6],
		        [2, 3, 4, 2, 3, 3, 4, 3, 2, 2, 4, 3, 2, 2, 3, 4, 3, 3, 2, 4],
		        [4, 4, 5, 3, 4, 4, 5, 4, 3, 3, 5, 4, 3, 3, 4, 5, 4, 4, 3, 5],
		      ];
		
		      const itemIds = ['item1', 'item2', 'item3', 'item4', 'item5'];
		      
		      const reliability = statisticalNorming.calculateReliability(itemResponses, itemIds);
		      
		      expect(reliability.cronbachAlpha).toBeGreaterThan(0);
		      expect(reliability.cronbachAlpha).toBeLessThanOrEqual(1);
		      expect(reliability.splitHalfReliability).toBeDefined();
		      expect(reliability.standardError).toBeGreaterThan(0);
		      expect(reliability.confidenceInterval).toHaveLength(2);
		    });
		
		    it('should require at least 2 items for reliability calculation', () => {
		      const singleItem = [[1, 2, 3, 4, 5]];
		      const itemIds = ['item1'];
		      
		      expect(() => {
		        statisticalNorming.calculateReliability(singleItem, itemIds);
		      }).toThrow('At least 2 items required');
		    });
		  });
		
		  describe('Normative Score Conversion', () => {
		    beforeEach(() => {
		      // Add some sample norming data
		      const sampleData = {
		        questionId: 'test_q1',
		        category: 'identity_fusion' as const,
		        responses: Array.from({ length: 100 }, () => Math.floor(Math.random() * 7) + 1),
		        responseTimes: Array(100).fill(3000),
		        revisions: Array(100).fill(0),
		        sessionIds: Array.from({ length: 100 }, (_, i) => `session_${i}`),
		      };
		
		      statisticalNorming.calculateNormingStatistics(sampleData);
		    });
		
		    it('should convert raw scores to normative scores', () => {
		      const normativeScores = statisticalNorming.convertToNormativeScores(5, 'test_q1');
		      
		      expect(normativeScores).toBeTruthy();
		      expect(normativeScores?.rawScore).toBe(5);
		      expect(normativeScores?.zScore).toBeDefined();
		      expect(normativeScores?.percentileRank).toBeGreaterThanOrEqual(0);
		      expect(normativeScores?.percentileRank).toBeLessThanOrEqual(100);
		      expect(normativeScores?.stanine).toBeGreaterThanOrEqual(1);
		      expect(normativeScores?.stanine).toBeLessThanOrEqual(9);
		      expect(normativeScores?.qualitativeDescription).toBeTruthy();
		    });
		
		    it('should return null for questions without norming data', () => {
		      const normativeScores = statisticalNorming.convertToNormativeScores(5, 'nonexistent_q');
		      expect(normativeScores).toBeNull();
		    });
		  });
		});
		
		describe('TelemetryStore', () => {
		  beforeEach(() => {
		    // Reset store state
		    useTelemetryStore.setState({
		      config: {
		        enabled: false,
		        privacyLevel: 'anonymous',
		        collectPerformanceMetrics: true,
		        collectAnomalyData: true,
		        collectNormingData: true,
		        batchSize: 50,
		        maxRetries: 3,
		        retentionDays: 90,
		        encryptionEnabled: true,
		        consentRequired: true,
		        anonymizationDelay: 300000,
		      },
		      userConsent: false,
		      alerts: [],
		      performanceMetrics: {
		        averageResponseTime: 0,
		        dataQualityScore: 1.0,
		        anomalyRate: 0,
		        systemLoad: 0,
		        lastUpdated: new Date().toISOString(),
		      },
		    });
		  });
		
		  it('should update consent and configuration', async () => {
		    const store = useTelemetryStore.getState();
		    
		    await store.updateConsent(true);
		    
		    const updatedState = useTelemetryStore.getState();
		    expect(updatedState.userConsent).toBe(true);
		    expect(updatedState.config.enabled).toBe(true);
		  });
		
		  it('should clear sensitive data when consent is withdrawn', async () => {
		    const store = useTelemetryStore.getState();
		    
		    // Set up some data
		    store.setCurrentSession({
		      sessionId: 'test_session',
		      startTime: new Date().toISOString(),
		      deviceFingerprint: 'test_fingerprint',
		      consentedForNorming: true,
		      consentedForResearch: true,
		      dataQualityScore: 0.9,
		      flagged: false,
		      exclusionReasons: [],
		    });
		    
		    // Add some alerts
		    store.addAlert({
		      type: 'data_concern',
		      severity: 'warning',
		      message: 'Test alert',
		      context: {},
		    });
		
		    // Withdraw consent
		    await store.updateConsent(false);
		    
		    const updatedState = useTelemetryStore.getState();
		    expect(updatedState.currentSession).toBeNull();
		    expect(updatedState.alerts.filter(a => a.type === 'data_concern')).toHaveLength(0);
		  });
		
		  it('should provide privacy-compliant data export', () => {
		    const store = useTelemetryStore.getState();
		    store.updateConsent(true);
		    
		    const exportData = store.getPrivacyCompliantData();
		    
		    expect(exportData).toHaveProperty('config');
		    expect(exportData).toHaveProperty('userConsent');
		    expect(exportData).toHaveProperty('performanceMetrics');
		    
		    // Should not contain sensitive data
		    expect(exportData).not.toHaveProperty('currentSession');
		    expect(exportData).not.toHaveProperty('dashboardData');
		  });
		
		  it('should calculate telemetry status correctly', () => {
		    const store = useTelemetryStore.getState();
		    
		    expect(store.getTelemetryStatus()).toBe('disabled');
		    
		    store.updateConfig({ enabled: true });
		    expect(store.getTelemetryStatus()).toBe('consent_required');
		    
		    store.updateConsent(true);
		    expect(store.getTelemetryStatus()).toBe('enabled');
		  });
		});
		
		describe('Integration Tests', () => {
		  it('should handle complete assessment flow with telemetry', async () => {
		    // Initialize telemetry with consent
		    await telemetryService.initialize(true);
		    await telemetryService.updateConsent(true);
		
		    // Start assessment
		    await telemetryService.trackAssessmentEvent('assessment_started', {
		      assessmentVersion: '1.0.0',
		      totalQuestions: 5,
		      completedQuestions: 0,
		      totalTimeSpent: 0,
		      totalRevisions: 0,
		    });
		
		    // Answer questions
		    for (let i = 0; i < 5; i++) {
		      await telemetryService.trackQuestionEvent('question_viewed', {
		        questionId: `q${i + 1}`,
		        questionCategory: 'identity_fusion',
		        questionIndex: i,
		        sectionId: 'section_1',
		        timeOnQuestion: 0,
		        revisionCount: 0,
		      });
		
		      await telemetryService.trackQuestionEvent('question_answered', {
		        questionId: `q${i + 1}`,
		        questionCategory: 'identity_fusion',
		        questionIndex: i,
		        sectionId: 'section_1',
		        timeOnQuestion: 2000 + Math.random() * 1000,
		        responseValue: Math.floor(Math.random() * 7) + 1 as any,
		        revisionCount: 0,
		        confidenceLevel: 4,
		      });
		    }
		
		    // Complete assessment
		    await telemetryService.trackAssessmentEvent('assessment_completed', {
		      assessmentVersion: '1.0.0',
		      totalQuestions: 5,
		      completedQuestions: 5,
		      totalTimeSpent: 12000,
		      totalRevisions: 0,
		    });
		
		    // Verify data was collected
		    const sessionInfo = telemetryService.getSessionInfo();
		    expect(sessionInfo).toBeTruthy();
		    expect(sessionInfo?.dataQualityScore).toBeGreaterThan(0);
		  });
		});]]></file>
	<file path='types/ai.ts'><![CDATA[
		export interface AIMessage {
		  role: "user" | "assistant" | "system";
		  content: string;
		}
		
		export interface AIRequestOptions {
		  temperature?: number;
		  maxTokens?: number;
		  model?: string;
		}
		
		export interface AIResponse {
		  content: string;
		  usage?: {
		    promptTokens: number;
		    completionTokens: number;
		    totalTokens: number;
		  };
		}
		
		export interface AIService {
		  chat(messages: AIMessage[], options?: AIRequestOptions): Promise<AIResponse>;
		  complete(prompt: string, options?: AIRequestOptions): Promise<AIResponse>;
		}]]></file>
	<file path='types/assessment.ts'>
		export type LikertScale = 1 | 2 | 3 | 4 | 5 | 6 | 7;
		
		export type AssessmentCategory = 
		  | 'identity_fusion'
		  | 'autonomy'
		  | 'boundaries'
		  | 'communication'
		  | 'codependency'
		  | 'differentiation'
		  | 'attachment'
		  | 'conflict_resolution'
		  | 'partner_inclusion'
		  | 'power_dynamics'
		  | 'openness'
		  | 'conscientiousness'
		  | 'extraversion'
		  | 'agreeableness'
		  | 'neuroticism';
		
		export type CompositeIndex = 'CI' | 'ARI' | 'TRS';
		
		export interface AssessmentItem {
		  id: string;
		  question: string;
		  category: AssessmentCategory;
		  subcategory?: string;
		  reverseScored: boolean;
		  weight?: number;
		  compositeIndices?: CompositeIndex[];
		}
		
		export interface AssessmentResponse {
		  itemId: string;
		  value: LikertScale;
		  timestamp: string;
		}
		
		export interface AssessmentSession {
		  id: string;
		  userId: string;
		  twinId?: string;
		  startDate: string;
		  completionDate?: string;
		  responses: AssessmentResponse[];
		  currentProgress: number;
		  isComplete: boolean;
		}
		
		export interface SubscaleScore {
		  category: AssessmentCategory;
		  rawScore: number;
		  scaledScore: number; // 0-100
		  percentile?: number;
		  interpretation: string;
		}
		
		export interface CompositeScore {
		  index: CompositeIndex;
		  value: number; // 0-100
		  interpretation: string;
		  components: AssessmentCategory[];
		}
		
		export interface AssessmentResults {
		  sessionId: string;
		  userId: string;
		  twinId?: string;
		  completionDate: string;
		  subscaleScores: SubscaleScore[];
		  compositeScores: CompositeScore[];
		  overallProfile: string;
		  recommendations: Recommendation[];
		}
		
		export interface Recommendation {
		  id: string;
		  title: string;
		  description: string;
		  category: AssessmentCategory;
		  priority: 'high' | 'medium' | 'low';
		  microExperiment?: MicroExperiment;
		}
		
		export interface MicroExperiment {
		  id: string;
		  title: string;
		  duration: string;
		  instructions: string[];
		  expectedOutcome: string;
		  trackingMetrics: string[];
		}
		
		export interface PairAnalytics {
		  user1Id: string;
		  user2Id: string;
		  compatibilityScore: number;
		  strengthAreas: AssessmentCategory[];
		  growthAreas: AssessmentCategory[];
		  riskFactors: string[];
		  recommendations: Recommendation[];
		}
		
		export interface ScoreInterpretation {
		  range: [number, number];
		  level: 'very_low' | 'low' | 'moderate' | 'high' | 'very_high';
		  description: string;
		  implications: string;
		}</file>
	<file path='types/assessment/types.ts'><![CDATA[
		/**
		 * Core Assessment Types for Twinship
		 * Defines the structure for twin assessment data with privacy-first design
		 */
		
		export type AssessmentCategory = 
		  | 'personality' 
		  | 'cognitive' 
		  | 'behavioral' 
		  | 'emotional' 
		  | 'social' 
		  | 'preferences' 
		  | 'experiences' 
		  | 'relationships';
		
		export type ResponseType = 'scale' | 'multiple_choice' | 'ranking' | 'boolean' | 'text';
		
		export type PrivacyLevel = 'private' | 'twin_only' | 'research_anonymous' | 'research_identified';
		
		export interface AssessmentQuestion {
		  id: string;
		  category: AssessmentCategory;
		  text: string;
		  description?: string;
		  responseType: ResponseType;
		  options?: string[];
		  scaleMin?: number;
		  scaleMax?: number;
		  scaleLabels?: { min: string; max: string };
		  required: boolean;
		  privacyLevel: PrivacyLevel;
		  researchWeight: number; // 0-1, importance for research analytics
		}
		
		export interface AssessmentResponse {
		  questionId: string;
		  value: any; // string, number, boolean, or array depending on responseType
		  timestamp: string;
		  confidence?: number; // 1-5 scale for response certainty
		  timeSpent?: number; // milliseconds spent on question
		  revisitCount?: number; // how many times user changed answer
		}
		
		export interface AssessmentSection {
		  id: string;
		  title: string;
		  description: string;
		  category: AssessmentCategory;
		  questions: AssessmentQuestion[];
		  estimatedMinutes: number;
		  icon?: string;
		}
		
		export interface AssessmentTemplate {
		  id: string;
		  title: string;
		  version: string;
		  description: string;
		  sections: AssessmentSection[];
		  totalQuestions: number;
		  estimatedMinutes: number;
		  createdAt: string;
		  updatedAt: string;
		}
		
		export interface AssessmentProgress {
		  templateId: string;
		  userId: string;
		  startedAt: string;
		  lastUpdated: string;
		  completedAt?: string;
		  currentSectionId?: string;
		  currentQuestionIndex: number;
		  totalQuestions: number;
		  completedQuestions: number;
		  percentComplete: number;
		  timeSpent: number; // total milliseconds
		  responses: Record<string, AssessmentResponse>;
		  sectionProgress: Record<string, {
		    completed: boolean;
		    startedAt?: string;
		    completedAt?: string;
		    timeSpent: number;
		  }>;
		}
		
		export interface AssessmentScore {
		  category: AssessmentCategory;
		  rawScore: number;
		  normalizedScore: number; // 0-100
		  percentile?: number;
		  confidence: number; // statistical confidence in score
		  subscores?: Record<string, number>;
		}
		
		export interface AssessmentResults {
		  id: string;
		  templateId: string;
		  userId: string;
		  completedAt: string;
		  totalTimeSpent: number;
		  scores: AssessmentScore[];
		  overallScore?: number;
		  reliability: number; // 0-1, consistency of responses
		  validity: number; // 0-1, quality of responses
		  insights: string[];
		  recommendations: string[];
		  privacyConsent: PrivacyConsent;
		  encrypted: boolean;
		  synced: boolean;
		}
		
		export interface PrivacyConsent {
		  dataCollection: boolean;
		  researchParticipation: boolean;
		  anonymizedSharing: boolean;
		  twinDataMerging: boolean;
		  dataRetention: 'indefinite' | '1year' | '5years' | 'until_deleted';
		  consentDate: string;
		  consentVersion: string;
		}
		
		export interface TwinPairData {
		  pairId: string;
		  twin1Id: string;
		  twin2Id: string;
		  pairedAt: string;
		  bothConsented: boolean;
		  sharedAssessments: string[]; // assessment IDs both twins completed
		  pairAnalytics?: PairAnalytics;
		  privacyLevel: PrivacyLevel;
		}
		
		export interface PairAnalytics {
		  similarityScores: Record<AssessmentCategory, number>;
		  complementarityScores: Record<AssessmentCategory, number>;
		  overallCompatibility: number;
		  uniqueTraits: {
		    twin1: string[];
		    twin2: string[];
		  };
		  sharedTraits: string[];
		  growthOpportunities: string[];
		  strengthAreas: string[];
		  lastUpdated: string;
		}
		
		export interface SyncStatus {
		  lastSyncAttempt?: string;
		  lastSuccessfulSync?: string;
		  pendingChanges: number;
		  syncErrors?: string[];
		  needsResolution: boolean;
		}
		
		export interface EncryptionMetadata {
		  algorithm: string;
		  keyVersion: string;
		  encryptedAt: string;
		  checksum: string;
		}]]></file>
	<file path='types/chat.ts'>
		import { ThemeColor } from '../state/twinStore';
		
		export interface ChatMessage {
		  id: string;
		  text: string;
		  senderId: string;
		  senderName: string;
		  timestamp: string;
		  type: 'text' | 'image' | 'emoji' | 'reaction' | 'twintuition';
		  imageUrl?: string;
		  replyTo?: string;
		  reactions?: MessageReaction[];
		  isDelivered: boolean;
		  isRead: boolean;
		  accentColor: ThemeColor;
		}
		
		export interface MessageReaction {
		  emoji: string;
		  userId: string;
		  userName: string;
		  timestamp: string;
		}
		
		export interface TypingIndicator {
		  userId: string;
		  userName: string;
		  timestamp: string;
		}
		
		export interface ChatConnection {
		  status: 'connected' | 'connecting' | 'disconnected' | 'reconnecting';
		  lastSeen?: string;
		  unreadCount: number;
		}
		
		export interface TwintuitionMoment {
		  id: string;
		  message: string;
		  timestamp: string;
		  type: 'sync' | 'intuition' | 'connection';
		  confidence: number;
		}
		
		export interface VoiceMessage {
		  id: string;
		  uri: string;
		  duration: number;
		  waveform?: number[];
		}
		
		export interface QuickResponse {
		  id: string;
		  text: string;
		  emoji: string;
		}
		
		export const QUICK_RESPONSES: QuickResponse[] = [
		  { id: '1', text: 'I was just thinking that!', emoji: '🤔' },
		  { id: '2', text: 'Twintuition moment!', emoji: '✨' },
		  { id: '3', text: 'Same here!', emoji: '🤝' },
		  { id: '4', text: 'Love you twin!', emoji: '❤️' },
		  { id: '5', text: 'Miss you!', emoji: '🥺' },
		  { id: '6', text: 'On my way!', emoji: '🏃' },
		];
		
		export const TWIN_EMOJIS = ['👯', '👭', '👬', '💫', '✨', '🔮', '💎', '🌟', '💝', '🎭', '🪞', '💫'];</file>
	<file path='types/games/index.ts'><![CDATA[
		// New game types for the sophisticated twin connection system
		export type TwinGameType = 'cognitive_sync_maze' | 'emotional_resonance' | 'temporal_decision' | 'iconic_duo';
		
		export type GameDifficulty = 'easy' | 'medium' | 'hard';
		
		// Cognitive & Psychological Insights
		export interface GameInsight {
		  type: string;
		  message: string;
		  significance?: 'high' | 'medium' | 'low';
		  data: any;
		}
		
		export interface TwinGameSession {
		  id: string;
		  gameType: TwinGameType;
		  twins: {
		    user1: TwinGamePlayer;
		    user2: TwinGamePlayer;
		  };
		  status: 'waiting' | 'in_progress' | 'analyzing' | 'completed' | 'cancelled';
		  createdAt: string;
		  startedAt?: string;
		  completedAt?: string;
		  insights: GameInsight[];
		  synchronicityScore: number;
		  metrics: {
		    synchronicity: SynchronicityMetrics;
		    cognitivePatterns?: CognitivePatterns;
		    emotionalResonance?: EmotionalMetrics;
		    decisionAlignment?: DecisionMetrics;
		  };
		}
		
		export interface TwinGamePlayer {
		  id: string;
		  name: string;
		  choices: any[];
		  responseData: any;
		  completionTime?: number;
		}
		
		// Cognitive Pattern Analysis (for Maze game)
		export interface CognitivePatterns {
		  pathwaySimilarity: number;
		  decisionTiming: TimingPattern[];
		  errorCorrectionStyle: 'immediate' | 'delayed' | 'backtrack';
		  approachStrategy: 'systematic' | 'intuitive' | 'hybrid';
		  directionalBias: {
		    leftTurns: number;
		    rightTurns: number;
		    preference: 'left' | 'right' | 'balanced';
		  };
		}
		
		export interface TimingPattern {
		  phase: string;
		  avgResponseTime: number;
		  consistency: number;
		}
		
		// Emotional Resonance Metrics
		export interface EmotionalMetrics {
		  vocabularyOverlap: number;
		  somaticSimilarity: number;
		  colorEmotionAlignment: number;
		  intensityCorrelation: number;
		  dominantEmotions: string[];
		}
		
		// Decision Pattern Analysis
		export interface DecisionMetrics {
		  valueAlignment: number;
		  riskToleranceGap: number;
		  stressResponseSimilarity: number;
		  temporalSync: number;
		  dominantValues: string[];
		}
		
		// Synchronicity Calculations
		export interface SynchronicityMetrics {
		  overallScore: number;
		  cognitiveSync: number;
		  emotionalSync: number;
		  temporalSync: number;
		  intuitionAccuracy: number;
		}
		
		// Game Configurations
		export interface TwinGameConfig {
		  id: TwinGameType;
		  name: string;
		  description: string;
		  psychologicalFocus: string;
		  icon: string;
		  difficulty: GameDifficulty;
		  insightExample: string;
		  timeLimit?: number;
		  rounds?: number;
		}
		
		// Maze Game Specific
		export interface TouchPoint {
		  x: number;
		  y: number;
		  timestamp: number;
		  pressure?: number;
		}
		
		export interface MazeError {
		  position: TouchPoint;
		  correctionTime: number;
		  correctionType: 'immediate' | 'backtrack';
		}
		
		export interface MazePath {
		  points: TouchPoint[];
		  errors: MazeError[];
		  totalTime: number;
		  completionStatus: 'completed' | 'abandoned';
		}
		
		// Emotional Resonance Specific
		export interface EmotionalResponse {
		  imageId: string;
		  emotionalRatings: {
		    [emotion: string]: number;
		  };
		  somaticLocation: {
		    x: number;
		    y: number;
		    area: 'head' | 'chest' | 'stomach' | 'full';
		  };
		  colorAssociation: string;
		  wordAssociations: string[];
		  responseTime: number;
		}
		
		// Temporal Decision Specific
		export interface Decision {
		  scenarioId: string;
		  choices: string[];
		  timeToDecide: number;
		  timestamp: number;
		  stressLevel: 'low' | 'medium' | 'high';
		}
		
		export interface DecisionScenario {
		  id: string;
		  title: string;
		  prompt: string;
		  options: string[];
		  timeLimit: number;
		  category: 'crisis' | 'resource' | 'social' | 'ethical';
		}
		
		// Iconic Duo Specific
		export interface DuoProfile {
		  id: string;
		  names: string;
		  category: string;
		  description: string;
		  dynamics: string[];
		  color: string;
		  icon: string;
		}
		
		export interface DuoMatchResult {
		  matchedDuo: DuoProfile;
		  perceptionGap: number;
		  alignmentAreas: string[];
		  divergenceAreas: string[];
		}
		
		// Achievement System (Updated)
		export interface TwinAchievement {
		  id: string;
		  name: string;
		  description: string;
		  icon: string;
		  unlocked: boolean;
		  unlockedAt?: string;
		  category: 'insight' | 'synchronicity' | 'discovery' | 'milestone';
		  requirement: {
		    type: 'sync_score' | 'game_count' | 'insight_count' | 'special';
		    value: number;
		    gameType?: TwinGameType;
		  };
		}
		
		// Game State (Updated)
		export interface TwinGameState {
		  currentSession: TwinGameSession | null;
		  gameHistory: TwinGameSession[];
		  insights: GameInsight[];
		  achievements: TwinAchievement[];
		  synchronicityProfile: {
		    cognitive: CognitivePatterns | null;
		    emotional: EmotionalMetrics | null;
		    decision: DecisionMetrics | null;
		    relationship: DuoMatchResult | null;
		  };
		}
		
		// Analytics (Updated)
		export interface TwinGameAnalytics {
		  sessionId: string;
		  gameType: TwinGameType;
		  duration: number;
		  synchronicityScore: number;
		  insightsGenerated: number;
		  keyDiscoveries: string[];
		  twinConnectionStrength: number;
		}
		
		// Visual Effects (kept for continuity)
		export interface ParticleEffect {
		  id: string;
		  type: 'success' | 'sync' | 'mystical' | 'insight';
		  x: number;
		  y: number;
		  color: string;
		  duration: number;
		}
		
		export interface SoundEffect {
		  type: 'match' | 'miss' | 'sync' | 'countdown' | 'mystical' | 'discovery';
		  volume: number;
		}
		
		// Re-export any hooks or stores if they exist
		// export * from '../../../state/stores/games/gameStore';
		// export * from '../../../hooks/games/useGameConfig';]]></file>
	<file path='types/premium/subscription.ts'>
		export type SubscriptionPlan = "free" | "monthly" | "yearly";
		
		export type SubscriptionStatus = "active" | "expired" | "canceled" | "trial" | "inactive";
		
		export interface SubscriptionProduct {
		  id: string;
		  title: string;
		  description: string;
		  price: string;
		  priceAmountMicros: number;
		  priceCurrencyCode: string;
		  subscriptionPeriod: "monthly" | "yearly";
		  introductoryPrice?: {
		    price: string;
		    priceAmountMicros: number;
		    cycles: number;
		    period: string;
		  };
		}
		
		export interface PremiumFeature {
		  id: string;
		  name: string;
		  description: string;
		  icon: string;
		  category: "assessment" | "coaching" | "analytics" | "export" | "insights";
		  isPremium: boolean;
		  teaser?: {
		    title: string;
		    content: string;
		    preview?: any;
		  };
		}
		
		export interface SubscriptionInfo {
		  isActive: boolean;
		  plan: SubscriptionPlan;
		  status: SubscriptionStatus;
		  expiryDate?: string;
		  purchaseDate?: string;
		  originalTransactionId?: string;
		  productId?: string;
		  willRenew: boolean;
		  trialEndDate?: string;
		  isInIntroductoryPeriod?: boolean;
		  gracePeriodEndDate?: string;
		}
		
		export interface PurchaseResult {
		  success: boolean;
		  productId?: string;
		  transactionId?: string;
		  error?: string;
		  userCancelled?: boolean;
		}
		
		export interface RestorePurchasesResult {
		  success: boolean;
		  restoredPurchases: number;
		  error?: string;
		}
		
		export const PREMIUM_FEATURES: PremiumFeature[] = [
		  {
		    id: "detailed_results",
		    name: "Detailed Assessment Results",
		    description: "Comprehensive personality insights and twin dynamics analysis",
		    icon: "analytics",
		    category: "assessment",
		    isPremium: true,
		    teaser: {
		      title: "Unlock Your Twin Bond Analysis",
		      content: "See detailed scores across 12+ personality dimensions and twin-specific metrics"
		    }
		  },
		  {
		    id: "coaching_plans",
		    name: "Personalized Coaching Plans", 
		    description: "Weekly micro-experiments and relationship strategies",
		    icon: "fitness",
		    category: "coaching",
		    isPremium: true,
		    teaser: {
		      title: "Get Your Custom Action Plan",
		      content: "Receive personalized weekly exercises to strengthen your twin bond"
		    }
		  },
		  {
		    id: "pdf_export",
		    name: "PDF Report Export",
		    description: "Professional reports you can save and share",
		    icon: "document-text",
		    category: "export",
		    isPremium: true
		  },
		  {
		    id: "twin_analytics",
		    name: "Advanced Twin Analytics",
		    description: "Comprehensive dashboard with progress tracking",
		    icon: "stats-chart",
		    category: "analytics", 
		    isPremium: true,
		    teaser: {
		      title: "Track Your Twin Journey",
		      content: "See how your relationship evolves over time with detailed metrics"
		    }
		  },
		  {
		    id: "recommendations",
		    name: "AI-Powered Recommendations",
		    description: "Smart insights based on your twin dynamics",
		    icon: "bulb",
		    category: "insights",
		    isPremium: true,
		    teaser: {
		      title: "Discover Personalized Insights",
		      content: "AI analyzes your results to provide tailored relationship advice"
		    }
		  },
		  {
		    id: "unlimited_assessments",
		    name: "Unlimited Retakes",
		    description: "Track progress by retaking assessments monthly",
		    icon: "refresh",
		    category: "assessment",
		    isPremium: true
		  }
		];
		
		export const SUBSCRIPTION_PRODUCTS: SubscriptionProduct[] = [
		  {
		    id: "twinship_monthly",
		    title: "Monthly Premium",
		    description: "Full access to all premium features",
		    price: "$9.99",
		    priceAmountMicros: 9990000,
		    priceCurrencyCode: "USD",
		    subscriptionPeriod: "monthly"
		  },
		  {
		    id: "twinship_yearly", 
		    title: "Yearly Premium",
		    description: "Save 40% with annual billing",
		    price: "$59.99",
		    priceAmountMicros: 59990000,
		    priceCurrencyCode: "USD",
		    subscriptionPeriod: "yearly",
		    introductoryPrice: {
		      price: "$19.99",
		      priceAmountMicros: 19990000,
		      cycles: 1,
		      period: "3 months"
		    }
		  }
		];</file>
	<file path='types/research.ts'><![CDATA[
		export interface ResearchStudy {
		  id: string;
		  title: string;
		  description: string;
		  fullDescription: string;
		  duration: string;
		  compensation: string[];
		  participants: number;
		  status: 'recruiting' | 'active' | 'completed';
		  category: 'synchronicity' | 'psychology' | 'genetics' | 'behavior' | 'communication';
		  requirements: string[];
		  ethicsApproval: string;
		  leadResearcher: string;
		  institution: string;
		  consentVersion: number;
		  dataTypes: ResearchDataType[];
		  benefits: string[];
		}
		
		export interface ResearchDataType {
		  type: 'assessment' | 'behavioral' | 'communication' | 'games' | 'biometric';
		  description: string;
		  anonymizationLevel: 'full' | 'pseudonymized' | 'aggregated';
		  retentionPeriod: string;
		  sharingScope: 'internal' | 'academic' | 'public';
		}
		
		export interface ConsentRecord {
		  id: string;
		  userId: string;
		  studyId: string;
		  consentVersion: number;
		  consentedAt: string;
		  consentedTo: ConsentItem[];
		  ipAddress?: string;
		  location?: string;
		  withdrawnAt?: string;
		  withdrawalReason?: string;
		}
		
		export interface ConsentItem {
		  id: string;
		  title: string;
		  description: string;
		  required: boolean;
		  consented: boolean;
		  dataTypes: string[];
		}
		
		export interface ResearchParticipation {
		  userId: string;
		  activeStudies: string[];
		  totalStudies: number;
		  joinedAt: string;
		  dataContributions: DataContribution[];
		  insights: ResearchInsight[];
		  preferences: ResearchPreferences;
		  withdrawalRequests: WithdrawalRequest[];
		}
		
		export interface DataContribution {
		  id: string;
		  studyId: string;
		  dataType: ResearchDataType['type'];
		  contributedAt: string;
		  dataPoints: number;
		  anonymizedId: string;
		  status: 'pending' | 'processed' | 'included' | 'excluded';
		}
		
		export interface ResearchInsight {
		  id: string;
		  studyId: string;
		  title: string;
		  summary: string;
		  findings: string[];
		  relevantToUser: boolean;
		  publishedAt: string;
		  publicationLink?: string;
		  significance: 'preliminary' | 'significant' | 'breakthrough';
		}
		
		export interface ResearchPreferences {
		  dataSharing: {
		    fullAnonymization: boolean;
		    academicSharing: boolean;
		    publicResults: boolean;
		    commercialUse: boolean;
		  };
		  communication: {
		    updates: boolean;
		    insights: boolean;
		    publications: boolean;
		    surveys: boolean;
		  };
		  participation: {
		    maxStudies: number;
		    preferredCategories: ResearchStudy['category'][];
		    timeCommitment: 'minimal' | 'moderate' | 'extensive';
		  };
		}
		
		export interface WithdrawalRequest {
		  id: string;
		  studyId: string;
		  requestedAt: string;
		  reason: string;
		  dataDisposition: 'delete' | 'anonymize' | 'retain_aggregated';
		  status: 'pending' | 'processing' | 'completed';
		  completedAt?: string;
		}
		
		export interface ResearchEthics {
		  irbApproval: string;
		  consentVersion: number;
		  dataProtectionCompliance: string[];
		  participantRights: string[];
		  contactInformation: {
		    principalInvestigator: string;
		    ethicsBoard: string;
		    support: string;
		  };
		}
		
		export interface AggregatedFindings {
		  studyId: string;
		  totalParticipants: number;
		  keyFindings: string[];
		  statisticalSignificance: number;
		  confidenceIntervals: Record<string, [number, number]>;
		  limitations: string[];
		  nextSteps: string[];
		  publicationStatus: 'draft' | 'submitted' | 'published';
		}
		
		export interface ParticipantDashboard {
		  totalContributions: number;
		  activeStudies: ResearchStudy[];
		  recentInsights: ResearchInsight[];
		  impactMetrics: {
		    dataPointsContributed: number;
		    studiesSupported: number;
		    publicationsEnabled: number;
		    scientificImpact: number;
		  };
		  upcomingMilestones: string[];
		  recognitions: string[];
		}]]></file>
	<file path='types/stories/index.ts'><![CDATA[
		export type StoryCategory = 
		  | 'childhood' 
		  | 'milestones' 
		  | 'adventures' 
		  | 'synchronicity' 
		  | 'achievements' 
		  | 'memories'
		  | 'other';
		
		export type MediaType = 'photo' | 'video' | 'audio';
		
		export interface StoryMedia {
		  id: string;
		  type: MediaType;
		  uri: string;
		  thumbnail?: string;
		  duration?: number; // for video/audio in seconds
		  size: number;
		  mimeType: string;
		  compressed?: boolean;
		  originalUri?: string;
		  caption?: string;
		}
		
		export interface StoryLocation {
		  latitude: number;
		  longitude: number;
		  address?: string;
		  placeName?: string;
		}
		
		export interface StoryMilestone {
		  type: 'birthday' | 'anniversary' | 'achievement' | 'first' | 'last' | 'custom';
		  date: string;
		  ageAtTime?: number;
		  significance: string;
		}
		
		export interface StoryCollaboration {
		  twinId: string;
		  contributedAt: string;
		  contribution: 'text' | 'media' | 'edit' | 'comment';
		  content?: string;
		}
		
		export interface StoryComment {
		  id: string;
		  authorId: string;
		  content: string;
		  timestamp: string;
		  isEdited?: boolean;
		}
		
		export interface Story {
		  id: string;
		  title: string;
		  content: string;
		  category: StoryCategory;
		  tags: string[];
		  
		  // Media attachments
		  media: StoryMedia[];
		  
		  // Metadata
		  timestamp: string;
		  lastModified: string;
		  authorId: string;
		  
		  // Sharing & privacy
		  isShared: boolean;
		  isPrivate: boolean;
		  sharedWith: string[]; // twin IDs
		  sharePermissions: 'view' | 'comment' | 'edit';
		  
		  // Story features
		  milestone?: StoryMilestone;
		  location?: StoryLocation;
		  collaborations: StoryCollaboration[];
		  comments: StoryComment[];
		  
		  // Engagement
		  likes: string[]; // user IDs who liked
		  favorites: string[]; // user IDs who favorited
		  views: { userId: string; timestamp: string }[];
		  
		  // Rich content
		  richText?: boolean;
		  textFormatting?: any; // Rich text editor state
		  
		  // Anniversary reminders
		  anniversaryReminder?: boolean;
		  reminderFrequency?: 'yearly' | 'monthly' | 'custom';
		  nextReminder?: string;
		}
		
		export interface StoryDraft {
		  id: string;
		  title: string;
		  content: string;
		  category: StoryCategory;
		  tags: string[];
		  media: StoryMedia[];
		  milestone?: StoryMilestone;
		  location?: StoryLocation;
		  lastSaved: string;
		  autoSaved: boolean;
		}
		
		export interface StoryFilter {
		  categories?: StoryCategory[];
		  tags?: string[];
		  dateRange?: {
		    start: string;
		    end: string;
		  };
		  milestoneOnly?: boolean;
		  sharedOnly?: boolean;
		  authorId?: string;
		  hasMedia?: boolean;
		  searchText?: string;
		}
		
		export interface StoryStats {
		  totalStories: number;
		  storiesThisMonth: number;
		  categoryCounts: Record<StoryCategory, number>;
		  totalMedia: number;
		  totalViews: number;
		  totalLikes: number;
		  collaborationCount: number;
		  milestoneCount: number;
		}
		
		export interface MemoryTimeline {
		  year: number;
		  stories: Story[];
		  milestones: Story[];
		  highlights: Story[];
		}]]></file>
	<file path='types/telemetry.ts'><![CDATA[
		/**
		 * Telemetry Types for Assessment Norming
		 * Privacy-first anonymous data collection for scientific validity
		 */
		
		import { AssessmentCategory, LikertScale } from './assessment';
		
		// Core telemetry event types
		export type TelemetryEventType = 
		  | 'assessment_started'
		  | 'question_viewed'
		  | 'question_answered'
		  | 'question_revised'
		  | 'section_completed'
		  | 'assessment_completed'
		  | 'assessment_abandoned'
		  | 'anomaly_detected'
		  | 'validation_failed'
		  | 'performance_metric';
		
		// Anomaly detection types
		export type AnomalyType =
		  | 'straight_line_responding'
		  | 'too_fast_completion'
		  | 'too_slow_completion'
		  | 'excessive_revisions'
		  | 'inconsistent_patterns'
		  | 'suspicious_timing'
		  | 'bot_like_behavior'
		  | 'data_quality_issue';
		
		// Statistical analysis types
		export type StatisticalMeasure =
		  | 'mean'
		  | 'median'
		  | 'standard_deviation'
		  | 'variance'
		  | 'skewness'
		  | 'kurtosis'
		  | 'cronbach_alpha'
		  | 'item_difficulty'
		  | 'item_discrimination'
		  | 'response_variance';
		
		// Privacy levels for data collection
		export type TelemetryPrivacyLevel = 'anonymous' | 'pseudonymous' | 'aggregated_only';
		
		// Base telemetry event interface
		export interface BaseTelemetryEvent {
		  id: string;
		  type: TelemetryEventType;
		  timestamp: string;
		  sessionId: string; // Anonymous session identifier
		  privacyLevel: TelemetryPrivacyLevel;
		  // No user-identifiable information beyond this point
		}
		
		// Question-level telemetry
		export interface QuestionTelemetryEvent extends BaseTelemetryEvent {
		  type: 'question_viewed' | 'question_answered' | 'question_revised';
		  questionId: string;
		  questionCategory: AssessmentCategory;
		  questionIndex: number;
		  sectionId: string;
		  timeOnQuestion: number; // milliseconds
		  responseValue?: LikertScale | string | number;
		  revisionCount: number;
		  confidenceLevel?: number; // 1-5 if collected
		  responsePatternHash?: string; // Hash for pattern analysis without storing actual data
		}
		
		// Section-level telemetry
		export interface SectionTelemetryEvent extends BaseTelemetryEvent {
		  type: 'section_completed';
		  sectionId: string;
		  sectionCategory: AssessmentCategory;
		  questionsInSection: number;
		  timeInSection: number; // milliseconds
		  completionRate: number; // 0-1
		  averageConfidence?: number;
		  revisionsInSection: number;
		}
		
		// Assessment-level telemetry
		export interface AssessmentTelemetryEvent extends BaseTelemetryEvent {
		  type: 'assessment_started' | 'assessment_completed' | 'assessment_abandoned';
		  assessmentVersion: string;
		  totalQuestions: number;
		  completedQuestions: number;
		  totalTimeSpent: number; // milliseconds
		  completionRate: number; // 0-1
		  averageResponseTime: number; // milliseconds per question
		  totalRevisions: number;
		  abandonmentPoint?: {
		    sectionId: string;
		    questionIndex: number;
		    timeSpent: number;
		  };
		}
		
		// Anomaly detection event
		export interface AnomalyTelemetryEvent extends BaseTelemetryEvent {
		  type: 'anomaly_detected';
		  anomalyType: AnomalyType;
		  severity: 'low' | 'medium' | 'high' | 'critical';
		  detectionAlgorithm: string;
		  contextData: {
		    questionId?: string;
		    sectionId?: string;
		    suspiciousPattern: string;
		    statisticalScore?: number;
		    threshold?: number;
		  };
		  actionTaken: 'flagged' | 'excluded' | 'requires_review' | 'auto_corrected';
		}
		
		// Performance metrics
		export interface PerformanceTelemetryEvent extends BaseTelemetryEvent {
		  type: 'performance_metric';
		  metricName: string;
		  metricValue: number;
		  context: {
		    deviceType?: string;
		    osVersion?: string;
		    appVersion: string;
		    networkCondition?: 'excellent' | 'good' | 'poor' | 'offline';
		    batteryLevel?: number;
		    memoryUsage?: number;
		  };
		}
		
		// Aggregated statistics for norming
		export interface NormingStatistics {
		  questionId: string;
		  category: AssessmentCategory;
		  sampleSize: number;
		  statistics: {
		    [K in StatisticalMeasure]?: number;
		  };
		  responseDistribution: Record<string, number>; // response value -> count
		  demographicBreakdowns?: {
		    ageGroups?: Record<string, number>;
		    genderGroups?: Record<string, number>;
		    twinTypes?: Record<string, number>;
		  };
		  qualityMetrics: {
		    averageResponseTime: number;
		    responseVariance: number;
		    consistencyScore: number;
		    anomalyRate: number;
		    reliabilityCoefficient?: number;
		  };
		  normativeData: {
		    percentileRanks: Record<string, number>; // response value -> percentile
		    zScores: Record<string, number>;
		    standardizedScores: Record<string, number>; // 0-100 scale
		  };
		  lastUpdated: string;
		  confidenceInterval: number; // 95% CI width
		}
		
		// Item analysis results
		export interface ItemAnalysis {
		  questionId: string;
		  category: AssessmentCategory;
		  difficulty: number; // 0-1, proportion answering correctly/highly
		  discrimination: number; // point-biserial correlation with total score
		  optionAnalysis?: {
		    [option: string]: {
		      frequency: number;
		      discrimination: number;
		      attractiveness: number; // for distractors
		    };
		  };
		  reliability: {
		    itemTotalCorrelation: number;
		    alphaIfDeleted: number;
		  };
		  recommendations: ItemRecommendation[];
		  flagged: boolean;
		  flagReasons: string[];
		}
		
		// Recommendations for item improvement
		export interface ItemRecommendation {
		  type: 'reword' | 'remove' | 'adjust_options' | 'change_category' | 'manual_review';
		  priority: 'low' | 'medium' | 'high' | 'critical';
		  reason: string;
		  suggestedAction: string;
		  statisticalEvidence: Record<string, number>;
		}
		
		// Privacy-compliant user session metadata
		export interface AnonymousSession {
		  sessionId: string; // Cryptographically secure random ID
		  startTime: string;
		  endTime?: string;
		  deviceFingerprint: string; // Hashed device characteristics
		  demographicHash?: string; // Hashed demographic data if consented
		  twinPairHash?: string; // Hashed pair identifier if both twins consent
		  consentedForNorming: boolean;
		  consentedForResearch: boolean;
		  dataQualityScore: number; // 0-1, overall session quality
		  flagged: boolean;
		  exclusionReasons: string[];
		}
		
		// Telemetry collection configuration
		export interface TelemetryConfig {
		  enabled: boolean;
		  privacyLevel: TelemetryPrivacyLevel;
		  collectPerformanceMetrics: boolean;
		  collectAnomalyData: boolean;
		  collectNormingData: boolean;
		  batchSize: number;
		  maxRetries: number;
		  retentionDays: number;
		  encryptionEnabled: boolean;
		  consentRequired: boolean;
		  anonymizationDelay: number; // milliseconds before removing session links
		}
		
		// Batch telemetry submission
		export interface TelemetryBatch {
		  batchId: string;
		  timestamp: string;
		  events: BaseTelemetryEvent[];
		  checksum: string;
		  compressed: boolean;
		  encrypted: boolean;
		  privacyLevel: TelemetryPrivacyLevel;
		}
		
		// Real-time monitoring alerts
		export interface TelemetryAlert {
		  id: string;
		  type: 'anomaly_spike' | 'quality_decline' | 'system_error' | 'data_concern';
		  severity: 'info' | 'warning' | 'error' | 'critical';
		  message: string;
		  timestamp: string;
		  context: Record<string, any>;
		  resolved: boolean;
		  resolvedAt?: string;
		}
		
		// Dashboard analytics data
		export interface TelemetryDashboardData {
		  timeRange: {
		    start: string;
		    end: string;
		  };
		  overview: {
		    totalSessions: number;
		    completedAssessments: number;
		    averageCompletionTime: number;
		    completionRate: number;
		    anomalyRate: number;
		    dataQualityScore: number;
		  };
		  questionMetrics: {
		    questionId: string;
		    averageResponseTime: number;
		    difficultyLevel: number;
		    discriminationIndex: number;
		    responseVariance: number;
		    anomalyCount: number;
		  }[];
		  categoryPerformance: {
		    category: AssessmentCategory;
		    averageScores: number[];
		    reliability: number;
		    sampleSize: number;
		    standardError: number;
		  }[];
		  qualityIndicators: {
		    straightLineResponding: number;
		    excessiveSpeed: number;
		    inconsistentPatterns: number;
		    technicalIssues: number;
		  };
		  trendsData: {
		    date: string;
		    completionRate: number;
		    averageQuality: number;
		    anomalyRate: number;
		  }[];
		}]]></file>
	<file path='types/twintuition.ts'><![CDATA[
		export interface BehaviorEvent {
		  id: string;
		  userId: string;
		  twinId?: string;
		  timestamp: string;
		  type: 'app_interaction' | 'communication' | 'mood_update' | 'location_update' | 'game_action';
		  action: string;
		  context: {
		    [key: string]: any;
		  };
		  location?: {
		    latitude: number;
		    longitude: number;
		  };
		}
		
		export interface SyncEvent {
		  type: 'simultaneous_action' | 'mood_synchronization' | 'app_synchronization' | 'location_synchronization' | 'temporal_pattern';
		  confidence: number; // 0-1
		  description: string;
		  involvedEvents: BehaviorEvent[];
		  detectedAt: string;
		}
		
		export interface TwintuitionConfig {
		  sensitivity: number; // 0-1, higher means more sensitive to patterns
		  timeWindowMinutes: number; // How many minutes to look back for synchronicity
		  enableLocationSync: boolean;
		  enableMoodSync: boolean;
		  enableActionSync: boolean;
		  minConfidenceThreshold: number; // Minimum confidence to trigger alert
		}
		
		export interface SyncPattern {
		  type: SyncEvent['type'];
		  confidence: number;
		  description: string;
		  events: BehaviorEvent[];
		  detectedFeatures: string[];
		}
		
		export interface TwintuitionAnalytics {
		  totalSyncEvents: number;
		  syncEventsByType: Record<string, number>;
		  averageConfidence: number;
		  strongestSyncTime: string; // Hour of day when sync is strongest
		  syncStreak: number; // Days with at least one sync event
		  lastSyncEvent: string;
		}
		
		export interface TwinConnectionMetrics {
		  syncScore: number; // 0-100
		  connectionStrength: 'Building' | 'Moderate' | 'Strong' | 'Extraordinary';
		  dailyAverageSync: number;
		  topSyncTypes: Array<{
		    type: string;
		    count: number;
		    averageConfidence: number;
		  }>;
		  recentTrends: {
		    increasing: boolean;
		    changePercent: number;
		    timeframe: string;
		  };
		}
		
		export interface NotificationPreferences {
		  enabled: boolean;
		  quietHours: {
		    start: string; // HH:mm format
		    end: string;
		  };
		  minimumConfidence: number;
		  allowedTypes: SyncEvent['type'][];
		  soundEnabled: boolean;
		  vibrationEnabled: boolean;
		}
		
		export interface LocationSyncData {
		  distance: number; // meters
		  similarity: number; // 0-1
		  type: 'same_location' | 'nearby' | 'similar_type' | 'synchronized_movement';
		  confidence: number;
		}
		
		export interface EmotionalSyncData {
		  emotion1: string;
		  emotion2: string;
		  similarity: number; // 0-1
		  intensity1: number;
		  intensity2: number;
		  confidence: number;
		}
		
		export interface TemporalSyncData {
		  pattern: 'daily_routine' | 'sleep_pattern' | 'activity_timing' | 'communication_rhythm';
		  correlation: number; // -1 to 1
		  phase: 'in_sync' | 'opposite' | 'delayed';
		  confidence: number;
		}]]></file>
	<file path='utils/__tests__/assessmentScoring.test.ts'><![CDATA[
		/**
		 * Test Suite for Twinship Assessment Scoring Engine
		 * Comprehensive tests for all scoring functions and edge cases
		 */
		
		import {
		  transformLikertTo100Scale,
		  reverseScoreItem,
		  calculateSubscaleScore,
		  calculateCompositeIndex,
		  calculatePercentileRank,
		  interpretScoreLevel,
		  generateScoreInterpretation,
		  assessRiskLevel,
		  validateAssessmentData,
		  DEFAULT_SCORING_CONFIG,
		} from '../assessmentScoring';
		
		import {
		  compareTwinScores,
		  calculateTwinSimilarity,
		  analyzeComplementarity,
		  identifyGrowthAreas,
		  calculateCompatibilityMetrics,
		} from '../pairAnalytics';
		
		import { TWINSHIP_ITEM_BANK, validateItemBank } from '../assessmentItemBank';
		
		import {
		  LikertResponse,
		  AssessmentData,
		  IndividualAssessmentResult,
		  TwinSubscales,
		  CompositeIndices,
		  BigFiveTraits,
		} from '../../types/assessment';
		
		// Test data fixtures
		const mockTwinSubscales: TwinSubscales = {
		  emotionalFusion: 65,
		  identityBlurring: 70,
		  separationAnxiety: 60,
		  boundaryDiffusion: 55,
		  individualIdentity: 40,
		  personalBoundaries: 45,
		  independentDecisionMaking: 35,
		  selfAdvocacy: 50,
		  adaptabilityToChange: 55,
		  conflictResolution: 60,
		  emotionalRegulation: 50,
		  socialSupport: 45,
		  changeAnxiety: 70,
		  attachmentInsecurity: 65,
		  roleConfusion: 60,
		  futureOrientation: 40,
		};
		
		const mockBigFive: BigFiveTraits = {
		  openness: 60,
		  conscientiousness: 55,
		  extraversion: 45,
		  agreeableness: 70,
		  neuroticism: 65,
		};
		
		const mockCompositeIndices: CompositeIndices = {
		  codependencyIndex: 62,
		  autonomyResilienceIndex: 43,
		  transitionRiskScore: 68,
		};
		
		const createMockAssessmentResult = (
		  userId: string,
		  overrides: Partial<{
		    bigFive: Partial<BigFiveTraits>;
		    subscales: Partial<TwinSubscales>;
		    compositeIndices: Partial<CompositeIndices>;
		  }> = {}
		): IndividualAssessmentResult => ({
		  userId,
		  assessmentDate: new Date('2024-01-15'),
		  bigFive: { ...mockBigFive, ...overrides.bigFive },
		  subscales: { ...mockTwinSubscales, ...overrides.subscales },
		  compositeIndices: { ...mockCompositeIndices, ...overrides.compositeIndices },
		  interpretations: {
		    bigFive: {
		      openness: {
		        level: 'moderate',
		        description: 'Moderate openness',
		        percentile: 60,
		        recommendations: [],
		      },
		      conscientiousness: {
		        level: 'moderate',
		        description: 'Moderate conscientiousness',
		        percentile: 55,
		        recommendations: [],
		      },
		      extraversion: {
		        level: 'moderate',
		        description: 'Moderate extraversion',
		        percentile: 45,
		        recommendations: [],
		      },
		      agreeableness: {
		        level: 'high',
		        description: 'High agreeableness',
		        percentile: 70,
		        recommendations: [],
		      },
		      neuroticism: {
		        level: 'high',
		        description: 'High neuroticism',
		        percentile: 65,
		        recommendations: [],
		      },
		    },
		    compositeIndices: {
		      codependencyIndex: {
		        level: 'moderate',
		        description: 'Moderate codependency',
		        percentile: 62,
		        recommendations: [],
		      },
		      autonomyResilienceIndex: {
		        level: 'low',
		        description: 'Low autonomy',
		        percentile: 43,
		        recommendations: [],
		      },
		      transitionRiskScore: {
		        level: 'high',
		        description: 'High transition risk',
		        percentile: 68,
		        recommendations: [],
		      },
		    },
		  },
		  riskAssessment: {
		    level: 'moderate',
		    factors: ['Moderate codependency'],
		    interventions: ['Individual therapy'],
		    urgency: 'medium',
		  },
		  overallSummary: {
		    primaryStrengths: ['High agreeableness'],
		    primaryConcerns: ['High codependency'],
		    developmentAreas: ['Autonomy'],
		    recommendedInterventions: ['Therapy'],
		  },
		  dataQuality: {
		    completionRate: 0.95,
		    consistencyScore: 0.85,
		    recommendProceed: true,
		  },
		});
		
		describe('Core Scoring Functions', () => {
		  describe('transformLikertTo100Scale', () => {
		    it('should transform 1-7 scale to 0-100 scale correctly', () => {
		      expect(transformLikertTo100Scale(1)).toBe(0);
		      expect(transformLikertTo100Scale(4)).toBe(50);
		      expect(transformLikertTo100Scale(7)).toBe(100);
		    });
		
		    it('should handle edge cases within range', () => {
		      expect(transformLikertTo100Scale(2)).toBe(17); // (2-1)/(7-1) * 100 = 16.67, rounded to 17
		      expect(transformLikertTo100Scale(6)).toBe(83); // (6-1)/(7-1) * 100 = 83.33, rounded to 83
		    });
		
		    it('should work with custom configuration', () => {
		      const customConfig = {
		        ...DEFAULT_SCORING_CONFIG,
		        scales: {
		          likertRange: [1, 5] as [number, number],
		          targetRange: [0, 100] as [number, number],
		        },
		      };
		      
		      expect(transformLikertTo100Scale(1, customConfig)).toBe(0);
		      expect(transformLikertTo100Scale(3, customConfig)).toBe(50);
		      expect(transformLikertTo100Scale(5, customConfig)).toBe(100);
		    });
		  });
		
		  describe('reverseScoreItem', () => {
		    it('should reverse score items correctly', () => {
		      expect(reverseScoreItem(1)).toBe(7); // 8 - 1 = 7
		      expect(reverseScoreItem(4)).toBe(4); // 8 - 4 = 4 
		      expect(reverseScoreItem(7)).toBe(1); // 8 - 7 = 1
		    });
		
		    it('should work with custom configuration', () => {
		      const customConfig = {
		        ...DEFAULT_SCORING_CONFIG,
		        scales: {
		          likertRange: [1, 5] as [number, number],
		          targetRange: [0, 100] as [number, number],
		        },
		      };
		      
		      expect(reverseScoreItem(1, customConfig)).toBe(5); // (5+1) - 1 = 5
		      expect(reverseScoreItem(3, customConfig)).toBe(3); // (5+1) - 3 = 3
		      expect(reverseScoreItem(5, customConfig)).toBe(1); // (5+1) - 5 = 1
		    });
		  });
		
		  describe('calculateSubscaleScore', () => {
		    it('should calculate simple average correctly', () => {
		      const responses: (LikertResponse | null)[] = [4, 5, 6, 4, 5];
		      const result = calculateSubscaleScore(responses);
		      
		      // Each response transformed: 4->50, 5->67, 6->83, 4->50, 5->67
		      // Average: (50+67+83+50+67)/5 = 63.4, rounded to 63
		      expect(result.score).toBe(63);
		      expect(result.validItemCount).toBe(5);
		    });
		
		    it('should handle reverse-scored items', () => {
		      const responses: (LikertResponse | null)[] = [4, 5, 6];
		      const reverseItems = [false, true, false];
		      const result = calculateSubscaleScore(responses, reverseItems);
		      
		      // Transformed: 4->50, 5(reversed to 3)->33, 6->83
		      // Average: (50+33+83)/3 = 55.33, rounded to 55
		      expect(result.score).toBe(55);
		      expect(result.validItemCount).toBe(3);
		    });
		
		    it('should handle weighted items', () => {
		      const responses: (LikertResponse | null)[] = [4, 6];
		      const reverseItems: boolean[] = [];
		      const weights = [1.0, 2.0];
		      const result = calculateSubscaleScore(responses, reverseItems, weights);
		      
		      // Transformed & weighted: 4->50*1=50, 6->83*2=166
		      // Weighted average: (50+166)/(1+2) = 216/3 = 72
		      expect(result.score).toBe(72);
		      expect(result.validItemCount).toBe(2);
		    });
		
		    it('should handle null responses', () => {
		      const responses: (LikertResponse | null)[] = [4, null, 6, null, 5];
		      const result = calculateSubscaleScore(responses);
		      
		      // Only valid responses: 4->50, 6->83, 5->67
		      // Average: (50+83+67)/3 = 66.67, rounded to 67
		      expect(result.score).toBe(67);
		      expect(result.validItemCount).toBe(3);
		    });
		
		    it('should return 0 score for all null responses', () => {
		      const responses: (LikertResponse | null)[] = [null, null, null];
		      const result = calculateSubscaleScore(responses);
		      
		      expect(result.score).toBe(0);
		      expect(result.validItemCount).toBe(0);
		    });
		
		    it('should enforce score bounds (0-100)', () => {
		      // Test with responses that might create out-of-bounds scores
		      const responses: (LikertResponse | null)[] = [1, 1, 1];
		      const result = calculateSubscaleScore(responses);
		      
		      expect(result.score).toBeGreaterThanOrEqual(0);
		      expect(result.score).toBeLessThanOrEqual(100);
		    });
		  });
		
		  describe('calculateCompositeIndex', () => {
		    it('should calculate codependency index correctly', () => {
		      const weights = DEFAULT_SCORING_CONFIG.weights.compositeIndices.codependencyIndex;
		      const result = calculateCompositeIndex(mockTwinSubscales, weights);
		      
		      // Should weight emotional fusion (65 * 0.3), identity blurring (70 * 0.25), etc.
		      expect(result).toBeGreaterThan(0);
		      expect(result).toBeLessThanOrEqual(100);
		    });
		
		    it('should return 0 when all weights are 0', () => {
		      const zeroWeights: Record<keyof TwinSubscales, number> = {
		        emotionalFusion: 0,
		        identityBlurring: 0,
		        separationAnxiety: 0,
		        boundaryDiffusion: 0,
		        individualIdentity: 0,
		        personalBoundaries: 0,
		        independentDecisionMaking: 0,
		        selfAdvocacy: 0,
		        adaptabilityToChange: 0,
		        conflictResolution: 0,
		        emotionalRegulation: 0,
		        socialSupport: 0,
		        changeAnxiety: 0,
		        attachmentInsecurity: 0,
		        roleConfusion: 0,
		        futureOrientation: 0,
		      };
		      
		      const result = calculateCompositeIndex(mockTwinSubscales, zeroWeights);
		      expect(result).toBe(0);
		    });
		
		    it('should handle negative weights correctly', () => {
		      const weights: Record<keyof TwinSubscales, number> = {
		        emotionalFusion: 0.5,
		        identityBlurring: 0,
		        separationAnxiety: 0,
		        boundaryDiffusion: 0,
		        individualIdentity: 0,
		        personalBoundaries: 0,
		        independentDecisionMaking: 0,
		        selfAdvocacy: 0,
		        adaptabilityToChange: 0,
		        conflictResolution: 0,
		        emotionalRegulation: 0,
		        socialSupport: 0,
		        changeAnxiety: 0,
		        attachmentInsecurity: 0,
		        roleConfusion: 0,
		        futureOrientation: -0.3, // Negative weight
		      };
		      
		      const result = calculateCompositeIndex(mockTwinSubscales, weights);
		      expect(result).toBeGreaterThanOrEqual(0);
		      expect(result).toBeLessThanOrEqual(100);
		    });
		  });
		
		  describe('calculatePercentileRank', () => {
		    it('should calculate percentile rank correctly', () => {
		      const percentiles = [20, 40, 60, 80];
		      
		      expect(calculatePercentileRank(10, percentiles)).toBe(25); // Below first percentile
		      expect(calculatePercentileRank(30, percentiles)).toBe(50); // Between first and second
		      expect(calculatePercentileRank(70, percentiles)).toBe(75); // Between third and fourth
		      expect(calculatePercentileRank(90, percentiles)).toBe(100); // Above all percentiles
		    });
		
		    it('should handle empty percentiles array', () => {
		      expect(calculatePercentileRank(50, [])).toBe(50); // Default to 50th percentile
		    });
		
		    it('should handle exact matches', () => {
		      const percentiles = [25, 50, 75];
		      expect(calculatePercentileRank(50, percentiles)).toBe(67); // Matches second percentile
		    });
		  });
		
		  describe('interpretScoreLevel', () => {
		    it('should interpret score levels correctly', () => {
		      expect(interpretScoreLevel(10)).toBe('very-low');
		      expect(interpretScoreLevel(25)).toBe('low');
		      expect(interpretScoreLevel(50)).toBe('moderate');
		      expect(interpretScoreLevel(75)).toBe('high');
		      expect(interpretScoreLevel(90)).toBe('very-high');
		    });
		
		    it('should handle boundary cases', () => {
		      expect(interpretScoreLevel(16)).toBe('low'); // Exactly at boundary
		      expect(interpretScoreLevel(37)).toBe('moderate'); // Exactly at boundary
		      expect(interpretScoreLevel(63)).toBe('high'); // Exactly at boundary
		      expect(interpretScoreLevel(84)).toBe('very-high'); // Exactly at boundary
		    });
		
		    it('should handle edge case of 100', () => {
		      expect(interpretScoreLevel(100)).toBe('very-high');
		    });
		  });
		
		  describe('generateScoreInterpretation', () => {
		    it('should generate interpretation with all components', () => {
		      const percentiles = [20, 40, 60, 80];
		      const interpretation = generateScoreInterpretation(70, percentiles, 'codependencyIndex');
		      
		      expect(interpretation).toHaveProperty('level');
		      expect(interpretation).toHaveProperty('description');
		      expect(interpretation).toHaveProperty('percentile');
		      expect(interpretation).toHaveProperty('recommendations');
		      expect(interpretation.recommendations).toBeInstanceOf(Array);
		    });
		
		    it('should provide different interpretations for different dimensions', () => {
		      const percentiles = [20, 40, 60, 80];
		      const codependencyInterp = generateScoreInterpretation(70, percentiles, 'codependencyIndex');
		      const autonomyInterp = generateScoreInterpretation(70, percentiles, 'autonomyResilienceIndex');
		      
		      expect(codependencyInterp.description).not.toBe(autonomyInterp.description);
		    });
		  });
		
		  describe('assessRiskLevel', () => {
		    it('should assess risk based on composite indices', () => {
		      const highRiskIndices: CompositeIndices = {
		        codependencyIndex: 80,
		        autonomyResilienceIndex: 20,
		        transitionRiskScore: 85,
		      };
		      
		      const riskAssessment = assessRiskLevel(highRiskIndices);
		      
		      expect(['moderate', 'high', 'severe']).toContain(riskAssessment.level);
		      expect(riskAssessment.factors).toBeInstanceOf(Array);
		      expect(riskAssessment.interventions).toBeInstanceOf(Array);
		      expect(['low', 'medium', 'high']).toContain(riskAssessment.urgency);
		    });
		
		    it('should assess low risk for healthy scores', () => {
		      const lowRiskIndices: CompositeIndices = {
		        codependencyIndex: 30,
		        autonomyResilienceIndex: 80,
		        transitionRiskScore: 25,
		      };
		      
		      const riskAssessment = assessRiskLevel(lowRiskIndices);
		      
		      expect(['minimal', 'low']).toContain(riskAssessment.level);
		      expect(riskAssessment.urgency).toBe('low');
		    });
		  });
		});
		
		describe('Pair Analytics Functions', () => {
		  const twin1 = createMockAssessmentResult('twin1');
		  const twin2 = createMockAssessmentResult('twin2', {
		    bigFive: { openness: 40, extraversion: 70 },
		    compositeIndices: { codependencyIndex: 45, autonomyResilienceIndex: 65 },
		  });
		
		  describe('calculateTwinSimilarity', () => {
		    it('should calculate similarity scores between twins', () => {
		      const similarity = calculateTwinSimilarity(twin1, twin2);
		      
		      expect(similarity).toHaveProperty('bigFive');
		      expect(similarity).toHaveProperty('overall');
		      expect(similarity.overall).toBeGreaterThanOrEqual(0);
		      expect(similarity.overall).toBeLessThanOrEqual(1);
		      
		      // Check that all Big Five traits have similarity scores
		      expect(similarity.bigFive).toHaveProperty('openness');
		      expect(similarity.bigFive).toHaveProperty('conscientiousness');
		      expect(similarity.bigFive).toHaveProperty('extraversion');
		      expect(similarity.bigFive).toHaveProperty('agreeableness');
		      expect(similarity.bigFive).toHaveProperty('neuroticism');
		    });
		
		    it('should show high similarity for identical twins', () => {
		      const identicalTwin2 = createMockAssessmentResult('twin2');
		      const similarity = calculateTwinSimilarity(twin1, identicalTwin2);
		      
		      expect(similarity.overall).toBe(1); // Perfect similarity
		      Object.values(similarity.bigFive).forEach(sim => {
		        expect(sim).toBe(1);
		      });
		    });
		
		    it('should show lower similarity for very different twins', () => {
		      const veryDifferentTwin = createMockAssessmentResult('twin2', {
		        bigFive: {
		          openness: 10,
		          conscientiousness: 15,
		          extraversion: 90,
		          agreeableness: 20,
		          neuroticism: 10,
		        },
		      });
		      
		      const similarity = calculateTwinSimilarity(twin1, veryDifferentTwin);
		      expect(similarity.overall).toBeLessThan(0.7); // Low overall similarity
		    });
		  });
		
		  describe('analyzeComplementarity', () => {
		    it('should identify complementarity patterns', () => {
		      const complementarity = analyzeComplementarity(twin1, twin2);
		      
		      expect(complementarity).toHaveProperty('strengths');
		      expect(complementarity).toHaveProperty('gaps');
		      expect(complementarity).toHaveProperty('conflicts');
		      expect(complementarity.strengths).toBeInstanceOf(Array);
		      expect(complementarity.gaps).toBeInstanceOf(Array);
		      expect(complementarity.conflicts).toBeInstanceOf(Array);
		    });
		  });
		
		  describe('identifyGrowthAreas', () => {
		    it('should identify individual and shared growth areas', () => {
		      const growthAreas = identifyGrowthAreas(twin1, twin2);
		      
		      expect(growthAreas).toHaveProperty('individual');
		      expect(growthAreas).toHaveProperty('shared');
		      expect(growthAreas.individual).toHaveProperty('twin1');
		      expect(growthAreas.individual).toHaveProperty('twin2');
		      expect(growthAreas.individual.twin1).toBeInstanceOf(Array);
		      expect(growthAreas.individual.twin2).toBeInstanceOf(Array);
		      expect(growthAreas.shared).toBeInstanceOf(Array);
		    });
		  });
		
		  describe('compareTwinScores', () => {
		    it('should generate comprehensive pair comparison', () => {
		      const comparison = compareTwinScores(twin1, twin2);
		      
		      expect(comparison).toHaveProperty('pairId');
		      expect(comparison).toHaveProperty('twin1');
		      expect(comparison).toHaveProperty('twin2');
		      expect(comparison).toHaveProperty('similarity');
		      expect(comparison).toHaveProperty('complementarity');
		      expect(comparison).toHaveProperty('growthAreas');
		      expect(comparison).toHaveProperty('dynamics');
		      expect(comparison).toHaveProperty('pairRecommendations');
		      
		      expect(comparison.pairId).toBe('twin1_twin2');
		    });
		  });
		
		  describe('calculateCompatibilityMetrics', () => {
		    it('should calculate compatibility metrics', () => {
		      const compatibility = calculateCompatibilityMetrics(twin1, twin2);
		      
		      expect(compatibility).toHaveProperty('overallCompatibility');
		      expect(compatibility).toHaveProperty('dimensionCompatibility');
		      expect(compatibility).toHaveProperty('compatibilityLevel');
		      expect(compatibility).toHaveProperty('relationshipStrengths');
		      expect(compatibility).toHaveProperty('potentialChallenges');
		      
		      expect(compatibility.overallCompatibility).toBeGreaterThanOrEqual(0);
		      expect(compatibility.overallCompatibility).toBeLessThanOrEqual(100);
		      expect(compatibility.relationshipStrengths).toBeInstanceOf(Array);
		      expect(compatibility.potentialChallenges).toBeInstanceOf(Array);
		    });
		  });
		});
		
		describe('Assessment Data Validation', () => {
		  const createMockAssessmentData = (overrides: Partial<AssessmentData> = {}): AssessmentData => ({
		    userId: 'test-user',
		    responses: TWINSHIP_ITEM_BANK.items.slice(0, 50).map((item, index) => ({
		      itemId: item.id,
		      response: (Math.floor(Math.random() * 7) + 1) as LikertResponse,
		      timestamp: new Date(),
		      responseTime: 2000 + Math.random() * 3000,
		    })),
		    startedAt: new Date(Date.now() - 30 * 60 * 1000), // 30 minutes ago
		    version: '1.0.0',
		    ...overrides,
		  });
		
		  describe('validateAssessmentData', () => {
		    it('should validate complete assessment data', () => {
		      const data = createMockAssessmentData();
		      // Add all required responses
		      data.responses = TWINSHIP_ITEM_BANK.items.map((item, index) => ({
		        itemId: item.id,
		        response: (Math.floor(Math.random() * 7) + 1) as LikertResponse,
		        timestamp: new Date(),
		        responseTime: 2000 + Math.random() * 3000,
		      }));
		      
		      const validation = validateAssessmentData(data, TWINSHIP_ITEM_BANK);
		      
		      expect(validation).toHaveProperty('isValid');
		      expect(validation).toHaveProperty('errors');
		      expect(validation).toHaveProperty('warnings');
		      expect(validation).toHaveProperty('dataQuality');
		      expect(validation.dataQuality).toHaveProperty('completionRate');
		      expect(validation.dataQuality).toHaveProperty('consistencyScore');
		      expect(validation.dataQuality).toHaveProperty('recommendProceed');
		    });
		
		    it('should flag incomplete assessment data', () => {
		      const data = createMockAssessmentData();
		      // Keep only partial responses (less than minimum threshold)
		      data.responses = data.responses.slice(0, Math.floor(TWINSHIP_ITEM_BANK.items.length * 0.7));
		      
		      const validation = validateAssessmentData(data, TWINSHIP_ITEM_BANK);
		      
		      expect(validation.isValid).toBe(false);
		      expect(validation.errors.some(error => error.code === 'INSUFFICIENT_COMPLETION')).toBe(true);
		    });
		
		    it('should warn about suspicious response patterns', () => {
		      const data = createMockAssessmentData();
		      // Create suspiciously fast responses
		      data.responses = data.responses.map(response => ({
		        ...response,
		        responseTime: 500, // Very fast
		      }));
		      
		      const validation = validateAssessmentData(data, TWINSHIP_ITEM_BANK);
		      
		      expect(validation.warnings.some(warning => warning.code === 'RAPID_RESPONSES')).toBe(true);
		    });
		  });
		});
		
		describe('Assessment Item Bank', () => {
		  describe('validateItemBank', () => {
		    it('should validate item bank integrity', () => {
		      const validation = validateItemBank();
		      
		      expect(validation).toHaveProperty('isValid');
		      expect(validation).toHaveProperty('errors');
		      expect(validation).toHaveProperty('warnings');
		      expect(validation).toHaveProperty('summary');
		      
		      if (!validation.isValid) {
		        console.warn('Item bank validation errors:', validation.errors);
		      }
		      
		      expect(validation.summary.totalItems).toBeGreaterThan(200);
		      expect(validation.summary.scalesCovered).toBeGreaterThan(15);
		    });
		  });
		
		  describe('Item Bank Content', () => {
		    it('should have comprehensive coverage of twin-specific constructs', () => {
		      const twinSpecificScales = [
		        'emotionalFusion',
		        'identityBlurring',
		        'separationAnxiety',
		        'boundaryDiffusion',
		        'individualIdentity',
		        'personalBoundaries',
		        'independentDecisionMaking',
		        'selfAdvocacy',
		      ];
		      
		      twinSpecificScales.forEach(scale => {
		        expect(TWINSHIP_ITEM_BANK.scales).toHaveProperty(scale);
		        expect(TWINSHIP_ITEM_BANK.scales[scale as keyof typeof TWINSHIP_ITEM_BANK.scales].items.length).toBeGreaterThan(5);
		      });
		    });
		
		    it('should include Big Five personality measures', () => {
		      const bigFiveTraits = ['openness', 'conscientiousness', 'extraversion', 'agreeableness', 'neuroticism'];
		      
		      bigFiveTraits.forEach(trait => {
		        expect(TWINSHIP_ITEM_BANK.scales).toHaveProperty(trait);
		        expect(TWINSHIP_ITEM_BANK.scales[trait as keyof typeof TWINSHIP_ITEM_BANK.scales].items.length).toBe(10);
		      });
		    });
		
		    it('should have appropriate reliability estimates', () => {
		      Object.values(TWINSHIP_ITEM_BANK.scales).forEach(scale => {
		        if (scale.reliabilityAlpha !== undefined) {
		          expect(scale.reliabilityAlpha).toBeGreaterThanOrEqual(0.7); // Acceptable reliability
		        }
		      });
		    });
		  });
		});
		
		describe('Edge Cases and Error Handling', () => {
		  it('should handle extreme scores gracefully', () => {
		    const extremeSubscales: TwinSubscales = {
		      emotionalFusion: 100,
		      identityBlurring: 0,
		      separationAnxiety: 100,
		      boundaryDiffusion: 0,
		      individualIdentity: 100,
		      personalBoundaries: 0,
		      independentDecisionMaking: 100,
		      selfAdvocacy: 0,
		      adaptabilityToChange: 100,
		      conflictResolution: 0,
		      emotionalRegulation: 100,
		      socialSupport: 0,
		      changeAnxiety: 100,
		      attachmentInsecurity: 0,
		      roleConfusion: 100,
		      futureOrientation: 0,
		    };
		    
		    const weights = DEFAULT_SCORING_CONFIG.weights.compositeIndices.codependencyIndex;
		    const result = calculateCompositeIndex(extremeSubscales, weights);
		    
		    expect(result).toBeGreaterThanOrEqual(0);
		    expect(result).toBeLessThanOrEqual(100);
		  });
		
		  it('should handle missing or invalid data types gracefully', () => {
		    expect(() => {
		      calculateSubscaleScore([]);
		    }).not.toThrow();
		    
		    expect(() => {
		      calculatePercentileRank(50, []);
		    }).not.toThrow();
		  });
		
		  it('should provide meaningful defaults when configuration is incomplete', () => {
		    const interpretation = generateScoreInterpretation(50, [], 'unknownDimension');
		    
		    expect(interpretation).toHaveProperty('level');
		    expect(interpretation).toHaveProperty('description');
		    expect(interpretation).toHaveProperty('recommendations');
		    expect(interpretation.recommendations).toBeInstanceOf(Array);
		  });
		});
		
		describe('Performance and Scale', () => {
		  it('should handle large datasets efficiently', () => {
		    const startTime = performance.now();
		    
		    // Simulate processing 1000 twin pairs
		    for (let i = 0; i < 1000; i++) {
		      const twin1 = createMockAssessmentResult(`twin1_${i}`);
		      const twin2 = createMockAssessmentResult(`twin2_${i}`);
		      calculateTwinSimilarity(twin1, twin2);
		    }
		    
		    const endTime = performance.now();
		    const processingTime = endTime - startTime;
		    
		    // Should process 1000 pairs in reasonable time (less than 1 second)
		    expect(processingTime).toBeLessThan(1000);
		  });
		
		  it('should maintain precision with repeated calculations', () => {
		    const responses: LikertResponse[] = [4, 4, 4, 4, 4];
		    
		    // Run the same calculation multiple times
		    const results = Array.from({ length: 100 }, () =>
		      calculateSubscaleScore(responses).score
		    );
		    
		    // All results should be identical (deterministic)
		    expect(new Set(results).size).toBe(1);
		    expect(results[0]).toBe(50); // 4 on 1-7 scale should map to 50 on 0-100 scale
		  });
		});
		
		// Integration tests
		describe('Integration Tests', () => {
		  it('should produce consistent results across the entire pipeline', () => {
		    // Create comprehensive assessment data
		    const assessmentData: AssessmentData = {
		      userId: 'integration-test-user',
		      responses: TWINSHIP_ITEM_BANK.items.map(item => ({
		        itemId: item.id,
		        response: 4 as LikertResponse, // Neutral response
		        timestamp: new Date(),
		        responseTime: 3000,
		      })),
		      startedAt: new Date(Date.now() - 45 * 60 * 1000),
		      completedAt: new Date(),
		      version: '1.0.0',
		    };
		    
		    // Validate the data
		    const validation = validateAssessmentData(assessmentData, TWINSHIP_ITEM_BANK);
		    expect(validation.dataQuality.recommendProceed).toBe(true);
		    
		    // For full integration, would need to implement the complete generateAssessmentReport function
		    // This test ensures the validation pipeline works end-to-end
		  });
		});]]></file>
	<file path='utils/__tests__/behaviorAnalytics.test.ts'><![CDATA[
		import {
		  analyzePatterns,
		  detectSynchronicity,
		  calculateSyncScore,
		} from '../behaviorAnalytics';
		import { BehaviorEvent, TwintuitionConfig } from '../../types/twintuition';
		
		describe('behaviorAnalytics', () => {
		  const defaultConfig: TwintuitionConfig = {
		    sensitivity: 0.7,
		    timeWindowMinutes: 15,
		    enableLocationSync: true,
		    enableMoodSync: true,
		    enableActionSync: true,
		    minConfidenceThreshold: 0.6,
		  };
		
		  const createMockEvent = (overrides: Partial<BehaviorEvent> = {}): BehaviorEvent => ({
		    id: 'test-id',
		    userId: 'user1',
		    twinId: 'twin1',
		    timestamp: new Date().toISOString(),
		    type: 'app_interaction',
		    action: 'open_app',
		    context: {},
		    ...overrides,
		  });
		
		  describe('analyzePatterns', () => {
		    it('should return empty array for insufficient events', async () => {
		      const events = [createMockEvent()];
		      const patterns = await analyzePatterns(events, defaultConfig);
		      expect(patterns).toHaveLength(0);
		    });
		
		    it('should detect simultaneous actions', async () => {
		      const now = new Date();
		      const events = [
		        createMockEvent({
		          userId: 'twin1',
		          twinId: 'twin2',
		          timestamp: now.toISOString(),
		          action: 'open_app',
		        }),
		        createMockEvent({
		          userId: 'twin2',
		          twinId: 'twin1',
		          timestamp: new Date(now.getTime() + 5 * 60 * 1000).toISOString(), // 5 minutes later
		          action: 'open_app',
		        }),
		      ];
		
		      const patterns = await analyzePatterns(events, defaultConfig);
		      expect(patterns.length).toBeGreaterThan(0);
		      expect(patterns[0].type).toBe('simultaneous_action');
		    });
		
		    it('should detect mood synchronization', async () => {
		      const now = new Date();
		      const events = [
		        createMockEvent({
		          userId: 'twin1',
		          twinId: 'twin2',
		          type: 'mood_update',
		          action: 'set_mood',
		          context: { mood: 'happy' },
		          timestamp: now.toISOString(),
		        }),
		        createMockEvent({
		          userId: 'twin2',
		          twinId: 'twin1',
		          type: 'mood_update',
		          action: 'set_mood',
		          context: { mood: 'excited' }, // Similar emotion
		          timestamp: new Date(now.getTime() + 10 * 60 * 1000).toISOString(),
		        }),
		      ];
		
		      const patterns = await analyzePatterns(events, defaultConfig);
		      const moodPattern = patterns.find(p => p.type === 'mood_synchronization');
		      expect(moodPattern).toBeDefined();
		      expect(moodPattern?.confidence).toBeGreaterThan(0.5);
		    });
		
		    it('should detect location synchronization', async () => {
		      const now = new Date();
		      const location1 = { latitude: 37.7749, longitude: -122.4194 }; // San Francisco
		      const location2 = { latitude: 37.7849, longitude: -122.4094 }; // Very close to SF
		
		      const events = [
		        createMockEvent({
		          userId: 'twin1',
		          twinId: 'twin2',
		          location: location1,
		          timestamp: now.toISOString(),
		        }),
		        createMockEvent({
		          userId: 'twin2',
		          twinId: 'twin1',
		          location: location2,
		          timestamp: new Date(now.getTime() + 5 * 60 * 1000).toISOString(),
		        }),
		      ];
		
		      const patterns = await analyzePatterns(events, defaultConfig);
		      const locationPattern = patterns.find(p => p.type === 'location_synchronization');
		      expect(locationPattern).toBeDefined();
		    });
		
		    it('should filter patterns by confidence threshold', async () => {
		      const highThresholdConfig = { ...defaultConfig, minConfidenceThreshold: 0.9 };
		      const events = [
		        createMockEvent({ userId: 'twin1', timestamp: new Date().toISOString() }),
		        createMockEvent({
		          userId: 'twin2',
		          timestamp: new Date(Date.now() + 30 * 60 * 1000).toISOString(), // 30 minutes later
		        }),
		      ];
		
		      const patterns = await analyzePatterns(events, highThresholdConfig);
		      // Should filter out low-confidence patterns
		      expect(patterns.every(p => p.confidence >= 0.9)).toBe(true);
		    });
		  });
		
		  describe('detectSynchronicity', () => {
		    it('should return null for events without twin events', async () => {
		      const newEvent = createMockEvent({ twinId: undefined });
		      const recentEvents: BehaviorEvent[] = [];
		      
		      const syncEvent = await detectSynchronicity(newEvent, recentEvents, defaultConfig);
		      expect(syncEvent).toBeNull();
		    });
		
		    it('should detect immediate synchronicity for similar actions', async () => {
		      const newEvent = createMockEvent({
		        userId: 'twin1',
		        twinId: 'twin2',
		        action: 'send_message',
		        timestamp: new Date().toISOString(),
		      });
		
		      const recentEvents = [
		        createMockEvent({
		          userId: 'twin2',
		          twinId: 'twin1',
		          action: 'send_message',
		          timestamp: new Date(Date.now() - 2 * 60 * 1000).toISOString(), // 2 minutes ago
		        }),
		      ];
		
		      const syncEvent = await detectSynchronicity(newEvent, recentEvents, defaultConfig);
		      expect(syncEvent).toBeDefined();
		      expect(syncEvent?.type).toBe('app_synchronization');
		      expect(syncEvent?.confidence).toBeGreaterThan(0.6);
		    });
		
		    it('should boost confidence for location similarity', async () => {
		      const location = { latitude: 37.7749, longitude: -122.4194 };
		      const newEvent = createMockEvent({
		        userId: 'twin1',
		        location,
		        timestamp: new Date().toISOString(),
		      });
		
		      const recentEvents = [
		        createMockEvent({
		          userId: 'twin2',
		          location,
		          timestamp: new Date(Date.now() - 5 * 60 * 1000).toISOString(),
		        }),
		      ];
		
		      const syncEvent = await detectSynchronicity(newEvent, recentEvents, defaultConfig);
		      expect(syncEvent?.confidence).toBeGreaterThan(0.7); // Should be boosted
		    });
		
		    it('should boost confidence for emotional similarity', async () => {
		      const newEvent = createMockEvent({
		        userId: 'twin1',
		        context: { emotion: 'happy' },
		        timestamp: new Date().toISOString(),
		      });
		
		      const recentEvents = [
		        createMockEvent({
		          userId: 'twin2',
		          context: { emotion: 'happy' },
		          timestamp: new Date(Date.now() - 5 * 60 * 1000).toISOString(),
		        }),
		      ];
		
		      const syncEvent = await detectSynchronicity(newEvent, recentEvents, defaultConfig);
		      expect(syncEvent?.confidence).toBeGreaterThan(0.6);
		    });
		
		    it('should respect time window limitations', async () => {
		      const shortWindowConfig = { ...defaultConfig, timeWindowMinutes: 5 };
		      const newEvent = createMockEvent({
		        timestamp: new Date().toISOString(),
		      });
		
		      const recentEvents = [
		        createMockEvent({
		          userId: 'twin2',
		          timestamp: new Date(Date.now() - 10 * 60 * 1000).toISOString(), // 10 minutes ago
		        }),
		      ];
		
		      const syncEvent = await detectSynchronicity(newEvent, recentEvents, shortWindowConfig);
		      expect(syncEvent).toBeNull(); // Outside time window
		    });
		  });
		
		  describe('calculateSyncScore', () => {
		    it('should return 0 for insufficient events', () => {
		      const events = [createMockEvent()];
		      const score = calculateSyncScore(events);
		      expect(score).toBe(0);
		    });
		
		    it('should calculate score based on various factors', () => {
		      const now = new Date();
		      const events = [
		        createMockEvent({
		          userId: 'twin1',
		          timestamp: now.toISOString(),
		          action: 'open_app',
		        }),
		        createMockEvent({
		          userId: 'twin2',
		          timestamp: new Date(now.getTime() + 5 * 60 * 1000).toISOString(),
		          action: 'open_app', // Same action
		        }),
		        createMockEvent({
		          userId: 'twin1',
		          timestamp: new Date(now.getTime() + 10 * 60 * 1000).toISOString(),
		          context: { emotion: 'happy' },
		        }),
		        createMockEvent({
		          userId: 'twin2',
		          timestamp: new Date(now.getTime() + 15 * 60 * 1000).toISOString(),
		          context: { emotion: 'happy' }, // Same emotion
		        }),
		      ];
		
		      const score = calculateSyncScore(events);
		      expect(score).toBeGreaterThan(0);
		      expect(score).toBeLessThanOrEqual(100);
		    });
		
		    it('should give higher scores for more synchronized events', () => {
		      const now = new Date();
		      
		      // Low sync events
		      const lowSyncEvents = [
		        createMockEvent({ userId: 'twin1', timestamp: now.toISOString() }),
		        createMockEvent({
		          userId: 'twin2',
		          timestamp: new Date(now.getTime() + 45 * 60 * 1000).toISOString(), // 45 min later
		        }),
		      ];
		
		      // High sync events
		      const highSyncEvents = [
		        createMockEvent({
		          userId: 'twin1',
		          timestamp: now.toISOString(),
		          action: 'send_message',
		          context: { emotion: 'excited' },
		        }),
		        createMockEvent({
		          userId: 'twin2',
		          timestamp: new Date(now.getTime() + 2 * 60 * 1000).toISOString(), // 2 min later
		          action: 'send_message', // Same action
		          context: { emotion: 'excited' }, // Same emotion
		        }),
		      ];
		
		      const lowScore = calculateSyncScore(lowSyncEvents);
		      const highScore = calculateSyncScore(highSyncEvents);
		
		      expect(highScore).toBeGreaterThan(lowScore);
		    });
		  });
		
		  describe('edge cases', () => {
		    it('should handle events with missing data gracefully', async () => {
		      const events = [
		        createMockEvent({ context: undefined }),
		        createMockEvent({ location: undefined }),
		        createMockEvent({ twinId: undefined }),
		      ];
		
		      expect(() => analyzePatterns(events, defaultConfig)).not.toThrow();
		    });
		
		    it('should handle invalid timestamps', async () => {
		      const events = [
		        createMockEvent({ timestamp: 'invalid-timestamp' }),
		        createMockEvent({ timestamp: '' }),
		      ];
		
		      expect(() => analyzePatterns(events, defaultConfig)).not.toThrow();
		    });
		
		    it('should handle extreme coordinate values', async () => {
		      const events = [
		        createMockEvent({
		          location: { latitude: 91, longitude: 181 }, // Invalid coordinates
		        }),
		        createMockEvent({
		          location: { latitude: -91, longitude: -181 },
		        }),
		      ];
		
		      expect(() => analyzePatterns(events, defaultConfig)).not.toThrow();
		    });
		  });
		
		  describe('performance', () => {
		    it('should handle large datasets efficiently', async () => {
		      const events = Array.from({ length: 1000 }, (_, i) =>
		        createMockEvent({
		          id: `event-${i}`,
		          userId: i % 2 === 0 ? 'twin1' : 'twin2',
		          timestamp: new Date(Date.now() - i * 60000).toISOString(),
		        })
		      );
		
		      const startTime = Date.now();
		      await analyzePatterns(events, defaultConfig);
		      const endTime = Date.now();
		
		      // Should complete in reasonable time (less than 5 seconds)
		      expect(endTime - startTime).toBeLessThan(5000);
		    });
		  });
		});]]></file>
	<file path='utils/analytics/pairAnalytics.ts'><![CDATA[
		/**
		 * Pair Analytics
		 * Functions for comparing twin assessment results and calculating compatibility
		 */
		
		import {
		  AssessmentResults,
		  SubscaleScore,
		  PairResults,
		  CompositeIndex,
		  AssessmentCategory,
		  ScoreInterpretation
		} from '../assessment/types';
		
		/**
		 * Compare two twin assessment results and calculate compatibility
		 * @param userResults - First twin's assessment results
		 * @param twinResults - Second twin's assessment results
		 * @returns Comprehensive pair analysis with privacy preservation
		 */
		export function analyzeTwinCompatibility(
		  userResults: AssessmentResults,
		  twinResults: AssessmentResults
		): PairResults {
		  // Verify privacy and data integrity
		  if (!isPrivacyPreserved(userResults, twinResults)) {
		    throw new Error('Privacy requirements not met for pair analysis');
		  }
		
		  const compatibilityScore = calculateCompatibilityScore(userResults, twinResults);
		  const sharedStrengths = identifySharedStrengths(userResults, twinResults);
		  const complementaryAreas = identifyComplementaryAreas(userResults, twinResults);
		  const concernAreas = identifyConcernAreas(userResults, twinResults);
		
		  return {
		    userResults: anonymizeResults(userResults),
		    twinResults: anonymizeResults(twinResults),
		    compatibilityScore,
		    sharedStrengths,
		    complementaryAreas,
		    concernAreas,
		    privacyPreserved: true
		  };
		}
		
		/**
		 * Calculate overall compatibility score between twins
		 * @param results1 - First twin's results
		 * @param results2 - Second twin's results
		 * @returns Compatibility score (0-100)
		 */
		export function calculateCompatibilityScore(
		  results1: AssessmentResults,
		  results2: AssessmentResults
		): number {
		  const subscaleCompatibility = calculateSubscaleCompatibility(results1.subscales, results2.subscales);
		  const compositeCompatibility = calculateCompositeCompatibility(results1.compositeIndices, results2.compositeIndices);
		  
		  // Weighted combination: 70% subscales, 30% composites
		  const compatibilityScore = (subscaleCompatibility * 0.7) + (compositeCompatibility * 0.3);
		  
		  return Math.round(compatibilityScore * 100) / 100;
		}
		
		/**
		 * Calculate compatibility across subscales
		 * @param subscales1 - First twin's subscale scores
		 * @param subscales2 - Second twin's subscale scores
		 * @returns Average compatibility score (0-1)
		 */
		function calculateSubscaleCompatibility(
		  subscales1: SubscaleScore[],
		  subscales2: SubscaleScore[]
		): number {
		  const scoreMap1 = new Map(subscales1.map(s => [s.category, s.normalizedScore]));
		  const scoreMap2 = new Map(subscales2.map(s => [s.category, s.normalizedScore]));
		  
		  let totalCompatibility = 0;
		  let categoryCount = 0;
		  
		  for (const category of scoreMap1.keys()) {
		    const score1 = scoreMap1.get(category)!;
		    const score2 = scoreMap2.get(category);
		    
		    if (score2 !== undefined) {
		      // Calculate compatibility based on score similarity
		      // Use inverse of normalized difference for compatibility
		      const difference = Math.abs(score1 - score2) / 100; // Normalize to 0-1
		      const compatibility = 1 - difference;
		      
		      // Weight different categories differently
		      const weight = getCategoryWeight(category);
		      totalCompatibility += compatibility * weight;
		      categoryCount += weight;
		    }
		  }
		  
		  return categoryCount > 0 ? totalCompatibility / categoryCount : 0;
		}
		
		/**
		 * Calculate compatibility of composite indices
		 * @param indices1 - First twin's composite indices
		 * @param indices2 - Second twin's composite indices
		 * @returns Composite compatibility score (0-1)
		 */
		function calculateCompositeCompatibility(
		  indices1: CompositeIndex,
		  indices2: CompositeIndex
		): number {
		  const ciCompatibility = 1 - Math.abs(indices1.CI - indices2.CI) / 100;
		  const ariCompatibility = 1 - Math.abs(indices1.ARI - indices2.ARI) / 100;
		  const trsCompatibility = 1 - Math.abs(indices1.TRS - indices2.TRS) / 100;
		  
		  // Weight TRS more heavily as it's the overall relationship strength
		  return (ciCompatibility * 0.3) + (ariCompatibility * 0.3) + (trsCompatibility * 0.4);
		}
		
		/**
		 * Identify shared strengths between twins
		 * @param results1 - First twin's results
		 * @param results2 - Second twin's results
		 * @returns Array of shared strength categories
		 */
		export function identifySharedStrengths(
		  results1: AssessmentResults,
		  results2: AssessmentResults
		): string[] {
		  const sharedStrengths: string[] = [];
		  
		  const strengths1 = new Set(results1.strengths);
		  const strengths2 = new Set(results2.strengths);
		  
		  // Find intersection of strengths
		  for (const strength of strengths1) {
		    if (strengths2.has(strength)) {
		      sharedStrengths.push(strength);
		    }
		  }
		  
		  // Also check for subscales where both twins score above average
		  const scoreMap1 = new Map(results1.subscales.map(s => [s.category, s]));
		  const scoreMap2 = new Map(results2.subscales.map(s => [s.category, s]));
		  
		  for (const [category, score1] of scoreMap1) {
		    const score2 = scoreMap2.get(category);
		    if (score2 && 
		        (score1.interpretation === 'high' || score1.interpretation === 'very_high') &&
		        (score2.interpretation === 'high' || score2.interpretation === 'very_high')) {
		      const strengthName = formatCategoryName(category);
		      if (!sharedStrengths.includes(strengthName)) {
		        sharedStrengths.push(strengthName);
		      }
		    }
		  }
		  
		  return sharedStrengths;
		}
		
		/**
		 * Identify complementary areas where twins balance each other
		 * @param results1 - First twin's results
		 * @param results2 - Second twin's results
		 * @returns Array of complementary area descriptions
		 */
		export function identifyComplementaryAreas(
		  results1: AssessmentResults,
		  results2: AssessmentResults
		): string[] {
		  const complementaryAreas: string[] = [];
		  
		  const scoreMap1 = new Map(results1.subscales.map(s => [s.category, s]));
		  const scoreMap2 = new Map(results2.subscales.map(s => [s.category, s]));
		  
		  // Look for areas where one twin is strong and the other is moderate/weak
		  for (const [category, score1] of scoreMap1) {
		    const score2 = scoreMap2.get(category);
		    if (score2) {
		      const isComplementary = isScoreComplementary(score1, score2);
		      if (isComplementary) {
		        complementaryAreas.push(
		          `${formatCategoryName(category)}: One twin provides strength while the other offers balance`
		        );
		      }
		    }
		  }
		  
		  // Check for independence-support balance
		  const independence1 = scoreMap1.get('independence')?.normalizedScore ?? 50;
		  const independence2 = scoreMap2.get('independence')?.normalizedScore ?? 50;
		  const support1 = scoreMap1.get('support_system')?.normalizedScore ?? 50;
		  const support2 = scoreMap2.get('support_system')?.normalizedScore ?? 50;
		  
		  if (Math.abs(independence1 - support2) < 20 && Math.abs(independence2 - support1) < 20) {
		    complementaryAreas.push('Balanced independence and mutual support');
		  }
		  
		  return complementaryAreas;
		}
		
		/**
		 * Identify concern areas that may need attention
		 * @param results1 - First twin's results
		 * @param results2 - Second twin's results
		 * @returns Array of concern area descriptions
		 */
		export function identifyConcernAreas(
		  results1: AssessmentResults,
		  results2: AssessmentResults
		): string[] {
		  const concernAreas: string[] = [];
		  
		  const scoreMap1 = new Map(results1.subscales.map(s => [s.category, s]));
		  const scoreMap2 = new Map(results2.subscales.map(s => [s.category, s]));
		  
		  // Look for areas where both twins score low
		  for (const [category, score1] of scoreMap1) {
		    const score2 = scoreMap2.get(category);
		    if (score2 && 
		        (score1.interpretation === 'low' || score1.interpretation === 'very_low') &&
		        (score2.interpretation === 'low' || score2.interpretation === 'very_low')) {
		      concernAreas.push(`Both twins may benefit from developing ${formatCategoryName(category)}`);
		    }
		  }
		  
		  // Check for extreme differences that might indicate conflict
		  for (const [category, score1] of scoreMap1) {
		    const score2 = scoreMap2.get(category);
		    if (score2) {
		      const difference = Math.abs(score1.normalizedScore - score2.normalizedScore);
		      if (difference > 50) { // Very large difference
		        concernAreas.push(
		          `Significant difference in ${formatCategoryName(category)} may require attention`
		        );
		      }
		    }
		  }
		  
		  // Check overall compatibility
		  const overallCompatibility = calculateCompatibilityScore(results1, results2);
		  if (overallCompatibility < 40) {
		    concernAreas.push('Overall compatibility is low - professional guidance recommended');
		  }
		  
		  return concernAreas;
		}
		
		/**
		 * Calculate growth recommendations for the pair
		 * @param pairResults - Complete pair analysis results
		 * @returns Prioritized growth recommendations
		 */
		export function generatePairGrowthRecommendations(pairResults: PairResults): {
		  priority: 'high' | 'medium' | 'low';
		  category: string;
		  recommendation: string;
		  activities: string[];
		}[] {
		  const recommendations: {
		    priority: 'high' | 'medium' | 'low';
		    category: string;
		    recommendation: string;
		    activities: string[];
		  }[] = [];
		  
		  // High priority recommendations based on concern areas
		  for (const concern of pairResults.concernAreas) {
		    if (concern.includes('compatibility is low')) {
		      recommendations.push({
		        priority: 'high',
		        category: 'Overall Relationship',
		        recommendation: 'Seek professional guidance to improve twin relationship dynamics',
		        activities: [
		          'Schedule sessions with a twin relationship counselor',
		          'Practice structured communication exercises',
		          'Establish clear boundaries and expectations'
		        ]
		      });
		    }
		  }
		  
		  // Medium priority recommendations for complementary areas
		  for (const complementary of pairResults.complementaryAreas) {
		    recommendations.push({
		      priority: 'medium',
		      category: extractCategoryFromDescription(complementary),
		      recommendation: 'Leverage your complementary strengths to support each other',
		      activities: [
		        'Identify specific ways to support each other',
		        'Create structured check-ins to share strengths',
		        'Practice appreciation and recognition exercises'
		      ]
		    });
		  }
		  
		  // Low priority recommendations for shared strengths
		  for (const strength of pairResults.sharedStrengths) {
		    recommendations.push({
		      priority: 'low',
		      category: strength,
		      recommendation: 'Continue to build on this shared strength',
		      activities: [
		        'Celebrate and acknowledge this strength regularly',
		        'Find new ways to express this strength together',
		        'Share this strength with others in your support network'
		      ]
		    });
		  }
		  
		  return recommendations.sort((a, b) => {
		    const priorityOrder = { high: 3, medium: 2, low: 1 };
		    return priorityOrder[b.priority] - priorityOrder[a.priority];
		  });
		}
		
		// Privacy and anonymization functions
		
		/**
		 * Check if privacy requirements are met for pair analysis
		 * @param results1 - First twin's results
		 * @param results2 - Second twin's results
		 * @returns Whether privacy is preserved
		 */
		function isPrivacyPreserved(
		  results1: AssessmentResults,
		  results2: AssessmentResults
		): boolean {
		  // Check that both results have valid session IDs and user IDs
		  if (!results1.sessionId || !results2.sessionId ||
		      !results1.userId || !results2.userId) {
		    return false;
		  }
		  
		  // Ensure results are from different users
		  if (results1.userId === results2.userId) {
		    return false;
		  }
		  
		  // Check for minimum data completeness
		  if (results1.subscales.length < 5 || results2.subscales.length < 5) {
		    return false;
		  }
		  
		  return true;
		}
		
		/**
		 * Anonymize assessment results for pair analysis
		 * @param results - Original assessment results
		 * @returns Anonymized results
		 */
		function anonymizeResults(results: AssessmentResults): AssessmentResults {
		  return {
		    ...results,
		    userId: 'anonymized',
		    sessionId: `anon_${Date.now()}`,
		  };
		}
		
		// Helper functions
		
		/**
		 * Get weight for different assessment categories
		 * @param category - Assessment category
		 * @returns Weight factor (0-1)
		 */
		function getCategoryWeight(category: AssessmentCategory): number {
		  const weights: Record<AssessmentCategory, number> = {
		    communication: 1.2,
		    emotional_connection: 1.2,
		    conflict_resolution: 1.1,
		    shared_experiences: 1.0,
		    support_system: 1.0,
		    independence: 0.9,
		    psychic_connection: 0.7,
		    identity_formation: 0.8
		  };
		  
		  return weights[category] ?? 1.0;
		}
		
		/**
		 * Check if two scores are complementary
		 * @param score1 - First subscale score
		 * @param score2 - Second subscale score
		 * @returns Whether scores are complementary
		 */
		function isScoreComplementary(score1: SubscaleScore, score2: SubscaleScore): boolean {
		  const high1 = score1.interpretation === 'high' || score1.interpretation === 'very_high';
		  const low1 = score1.interpretation === 'low' || score1.interpretation === 'very_low';
		  const high2 = score2.interpretation === 'high' || score2.interpretation === 'very_high';
		  const low2 = score2.interpretation === 'low' || score2.interpretation === 'very_low';
		  
		  return (high1 && (low2 || score2.interpretation === 'below_average')) ||
		         (high2 && (low1 || score1.interpretation === 'below_average'));
		}
		
		/**
		 * Format category name for display
		 * @param category - Assessment category
		 * @returns Formatted display name
		 */
		function formatCategoryName(category: AssessmentCategory): string {
		  const names: Record<AssessmentCategory, string> = {
		    communication: 'Communication Skills',
		    emotional_connection: 'Emotional Connection',
		    shared_experiences: 'Shared Experiences',
		    conflict_resolution: 'Conflict Resolution',
		    independence: 'Independence',
		    support_system: 'Support System',
		    psychic_connection: 'Psychic Connection',
		    identity_formation: 'Identity Formation'
		  };
		  
		  return names[category] ?? category;
		}
		
		/**
		 * Extract category from description text
		 * @param description - Description text
		 * @returns Extracted category name
		 */
		function extractCategoryFromDescription(description: string): string {
		  // Simple extraction - in real implementation, use more sophisticated matching
		  if (description.includes('independence')) return 'Independence';
		  if (description.includes('support')) return 'Support System';
		  if (description.includes('communication')) return 'Communication';
		  return 'General';
		}]]></file>
	<file path='utils/anomalyDetection.ts'><![CDATA[
		/**
		 * Anomaly Detection for Assessment Response Patterns
		 * Identifies suspicious response patterns and data quality issues
		 */
		
		import { 
		  QuestionTelemetryEvent, 
		  AssessmentTelemetryEvent, 
		  AnomalyType 
		} from '../types/telemetry';
		import { LikertScale } from '../types/assessment';
		
		interface AnomalyResult {
		  detected: boolean;
		  type: AnomalyType;
		  severity: 'low' | 'medium' | 'high' | 'critical';
		  confidence: number; // 0-1
		  explanation: string;
		  statisticalEvidence: Record<string, number>;
		  recommendedAction: 'ignore' | 'flag' | 'exclude' | 'manual_review';
		}
		
		interface ResponsePattern {
		  responses: (number | string)[];
		  timestamps: number[];
		  revisions: number[];
		  categories: string[];
		}
		
		interface TimingPattern {
		  responseTimes: number[];
		  averageTime: number;
		  variance: number;
		  outliers: number[];
		}
		
		class AnomalyDetectionEngine {
		  // Configurable thresholds
		  private readonly thresholds = {
		    // Timing-based thresholds
		    minResponseTime: 500, // 500ms minimum reasonable response time
		    maxResponseTime: 300000, // 5 minutes maximum reasonable response time
		    fastResponseThreshold: 1000, // 1 second for "too fast" detection
		    slowResponseThreshold: 120000, // 2 minutes for "too slow" detection
		    
		    // Pattern-based thresholds
		    straightLineThreshold: 0.8, // 80% same responses indicates straight-line
		    varianceThreshold: 0.5, // Low variance threshold for response diversity
		    
		    // Statistical thresholds
		    outlierZScore: 3.0, // Z-score for outlier detection
		    consistencyThreshold: 0.7, // Consistency score threshold
		    
		    // Behavioral thresholds
		    maxRevisions: 10, // Maximum reasonable revisions per question
		    botLikeSpeedThreshold: 800, // Consistent sub-800ms responses indicate bot
		    suspiciousPatternLength: 5, // Number of consecutive similar responses
		  };
		
		  /**
		   * Analyze response patterns for straight-line responding
		   */
		  analyzeStraightLineResponding(pattern: ResponsePattern): AnomalyResult {
		    if (pattern.responses.length < 5) {
		      return this.createNormalResult();
		    }
		
		    // Count most frequent response
		    const responseCounts = this.countResponses(pattern.responses);
		    const totalResponses = pattern.responses.length;
		    const maxCount = Math.max(...Object.values(responseCounts));
		    const straightLineRatio = maxCount / totalResponses;
		
		    // Check for consecutive identical responses
		    const consecutiveCount = this.findLongestConsecutiveSequence(pattern.responses);
		    const consecutiveRatio = consecutiveCount / totalResponses;
		
		    // Calculate response variance
		    const numericResponses = pattern.responses
		      .filter(r => typeof r === 'number') as number[];
		    const variance = this.calculateVariance(numericResponses);
		
		    const detected = straightLineRatio >= this.thresholds.straightLineThreshold ||
		                    consecutiveRatio >= 0.6 ||
		                    variance < this.thresholds.varianceThreshold;
		
		    if (!detected) {
		      return this.createNormalResult();
		    }
		
		    const severity = this.determineSeverity([
		      { value: straightLineRatio, threshold: 0.9, weight: 0.4 },
		      { value: consecutiveRatio, threshold: 0.7, weight: 0.3 },
		      { value: 1 - variance, threshold: 0.8, weight: 0.3 }
		    ]);
		
		    return {
		      detected: true,
		      type: 'straight_line_responding',
		      severity,
		      confidence: Math.min(0.95, straightLineRatio * 0.8 + consecutiveRatio * 0.2),
		      explanation: `${(straightLineRatio * 100).toFixed(1)}% of responses are identical, with ${consecutiveCount} consecutive identical responses`,
		      statisticalEvidence: {
		        straightLineRatio,
		        consecutiveCount,
		        consecutiveRatio,
		        responseVariance: variance,
		        totalResponses,
		      },
		      recommendedAction: severity === 'critical' ? 'exclude' : 'flag',
		    };
		  }
		
		  /**
		   * Analyze response timing patterns
		   */
		  analyzeResponseTiming(pattern: TimingPattern): AnomalyResult {
		    const { responseTimes, averageTime, variance } = pattern;
		    
		    if (responseTimes.length < 3) {
		      return this.createNormalResult();
		    }
		
		    // Check for consistently fast responses (bot-like behavior)
		    const fastResponses = responseTimes.filter(t => t < this.thresholds.botLikeSpeedThreshold);
		    const fastResponseRatio = fastResponses.length / responseTimes.length;
		
		    // Check for extremely fast responses
		    const extremelyFastResponses = responseTimes.filter(t => t < this.thresholds.minResponseTime);
		    const extremelyFastRatio = extremelyFastResponses.length / responseTimes.length;
		
		    // Check for timing consistency (too consistent = bot-like)
		    const coefficientOfVariation = Math.sqrt(variance) / averageTime;
		    const tooConsistent = coefficientOfVariation < 0.2 && averageTime < 2000;
		
		    // Detect different types of timing anomalies
		    const anomalies: Array<{type: AnomalyType, score: number, evidence: any}> = [];
		
		    if (fastResponseRatio >= 0.8) {
		      anomalies.push({
		        type: 'too_fast_completion',
		        score: fastResponseRatio,
		        evidence: { fastResponseRatio, averageTime, fastCount: fastResponses.length }
		      });
		    }
		
		    if (extremelyFastRatio >= 0.3) {
		      anomalies.push({
		        type: 'bot_like_behavior',
		        score: extremelyFastRatio * 1.5,
		        evidence: { extremelyFastRatio, averageTime, coefficientOfVariation }
		      });
		    }
		
		    if (tooConsistent && averageTime < 1500) {
		      anomalies.push({
		        type: 'bot_like_behavior',
		        score: 1 - coefficientOfVariation,
		        evidence: { coefficientOfVariation, averageTime, tooConsistent }
		      });
		    }
		
		    if (anomalies.length === 0) {
		      return this.createNormalResult();
		    }
		
		    // Return the most severe anomaly
		    const primaryAnomaly = anomalies.reduce((max, current) => 
		      current.score > max.score ? current : max
		    );
		
		    const severity = this.determineSeverity([
		      { value: primaryAnomaly.score, threshold: 0.7, weight: 1.0 }
		    ]);
		
		    return {
		      detected: true,
		      type: primaryAnomaly.type,
		      severity,
		      confidence: Math.min(0.9, primaryAnomaly.score),
		      explanation: this.getTimingAnomalyExplanation(primaryAnomaly.type, primaryAnomaly.evidence),
		      statisticalEvidence: {
		        averageResponseTime: averageTime,
		        responseVariance: variance,
		        coefficientOfVariation,
		        fastResponseRatio,
		        extremelyFastRatio,
		        totalResponses: responseTimes.length,
		        ...primaryAnomaly.evidence,
		      },
		      recommendedAction: severity === 'critical' ? 'exclude' : 'flag',
		    };
		  }
		
		  /**
		   * Analyze response consistency and patterns
		   */
		  analyzeResponseConsistency(pattern: ResponsePattern): AnomalyResult {
		    if (pattern.responses.length < 8) {
		      return this.createNormalResult();
		    }
		
		    // Check for alternating patterns (1,7,1,7,1,7...)
		    const alternatingScore = this.detectAlternatingPattern(pattern.responses);
		    
		    // Check for sequential patterns (1,2,3,4,5,6,7,1,2,3...)
		    const sequentialScore = this.detectSequentialPattern(pattern.responses);
		    
		    // Check for reverse patterns within sections
		    const reverseScore = this.detectReversePattern(pattern.responses);
		
		    // Check for extreme response style (only using endpoints)
		    const extremeScore = this.detectExtremeResponseStyle(pattern.responses);
		
		    const anomalies = [
		      { type: 'inconsistent_patterns' as AnomalyType, score: alternatingScore, name: 'alternating' },
		      { type: 'inconsistent_patterns' as AnomalyType, score: sequentialScore, name: 'sequential' },
		      { type: 'inconsistent_patterns' as AnomalyType, score: reverseScore, name: 'reverse' },
		      { type: 'suspicious_timing' as AnomalyType, score: extremeScore, name: 'extreme' },
		    ].filter(a => a.score > 0.3);
		
		    if (anomalies.length === 0) {
		      return this.createNormalResult();
		    }
		
		    const primaryAnomaly = anomalies.reduce((max, current) => 
		      current.score > max.score ? current : max
		    );
		
		    const severity = this.determineSeverity([
		      { value: primaryAnomaly.score, threshold: 0.6, weight: 1.0 }
		    ]);
		
		    return {
		      detected: true,
		      type: primaryAnomaly.type,
		      severity,
		      confidence: Math.min(0.85, primaryAnomaly.score),
		      explanation: `Detected ${primaryAnomaly.name} response pattern (score: ${primaryAnomaly.score.toFixed(3)})`,
		      statisticalEvidence: {
		        alternatingScore,
		        sequentialScore,
		        reverseScore,
		        extremeScore,
		        primaryPattern: primaryAnomaly.name,
		        totalResponses: pattern.responses.length,
		      },
		      recommendedAction: severity >= 'high' ? 'flag' : 'ignore',
		    };
		  }
		
		  /**
		   * Analyze excessive revisions
		   */
		  analyzeRevisionPatterns(pattern: ResponsePattern): AnomalyResult {
		    const totalRevisions = pattern.revisions.reduce((sum, r) => sum + r, 0);
		    const averageRevisions = totalRevisions / pattern.revisions.length;
		    const maxRevisions = Math.max(...pattern.revisions);
		    
		    // Count questions with excessive revisions
		    const excessiveRevisions = pattern.revisions.filter(r => r > this.thresholds.maxRevisions);
		    const excessiveRatio = excessiveRevisions.length / pattern.revisions.length;
		
		    const detected = excessiveRatio > 0.2 || 
		                    averageRevisions > 3 || 
		                    maxRevisions > this.thresholds.maxRevisions;
		
		    if (!detected) {
		      return this.createNormalResult();
		    }
		
		    const severity = this.determineSeverity([
		      { value: excessiveRatio, threshold: 0.4, weight: 0.4 },
		      { value: averageRevisions / 5, threshold: 0.6, weight: 0.3 },
		      { value: maxRevisions / 15, threshold: 0.8, weight: 0.3 }
		    ]);
		
		    return {
		      detected: true,
		      type: 'excessive_revisions',
		      severity,
		      confidence: Math.min(0.8, excessiveRatio + (averageRevisions / 10)),
		      explanation: `Average ${averageRevisions.toFixed(1)} revisions per question, with ${excessiveRevisions.length} questions having >10 revisions`,
		      statisticalEvidence: {
		        totalRevisions,
		        averageRevisions,
		        maxRevisions,
		        excessiveCount: excessiveRevisions.length,
		        excessiveRatio,
		        totalQuestions: pattern.revisions.length,
		      },
		      recommendedAction: severity === 'high' ? 'manual_review' : 'flag',
		    };
		  }
		
		  /**
		   * Comprehensive anomaly analysis
		   */
		  analyzeAllPatterns(
		    responsePattern: ResponsePattern,
		    timingPattern: TimingPattern
		  ): AnomalyResult[] {
		    const results: AnomalyResult[] = [];
		
		    // Run all detection algorithms
		    results.push(this.analyzeStraightLineResponding(responsePattern));
		    results.push(this.analyzeResponseTiming(timingPattern));
		    results.push(this.analyzeResponseConsistency(responsePattern));
		    results.push(this.analyzeRevisionPatterns(responsePattern));
		
		    // Filter out normal results
		    return results.filter(r => r.detected);
		  }
		
		  /**
		   * Create pattern objects from telemetry events
		   */
		  createResponsePattern(events: QuestionTelemetryEvent[]): ResponsePattern {
		    return {
		      responses: events.map(e => e.responseValue || 0),
		      timestamps: events.map(e => new Date(e.timestamp).getTime()),
		      revisions: events.map(e => e.revisionCount),
		      categories: events.map(e => e.questionCategory),
		    };
		  }
		
		  createTimingPattern(events: QuestionTelemetryEvent[]): TimingPattern {
		    const responseTimes = events.map(e => e.timeOnQuestion);
		    const averageTime = responseTimes.reduce((sum, t) => sum + t, 0) / responseTimes.length;
		    const variance = this.calculateVariance(responseTimes);
		    const outliers = this.findTimingOutliers(responseTimes);
		
		    return {
		      responseTimes,
		      averageTime,
		      variance,
		      outliers,
		    };
		  }
		
		  // Private helper methods
		  private createNormalResult(): AnomalyResult {
		    return {
		      detected: false,
		      type: 'data_quality_issue',
		      severity: 'low',
		      confidence: 0,
		      explanation: 'No anomalies detected',
		      statisticalEvidence: {},
		      recommendedAction: 'ignore',
		    };
		  }
		
		  private countResponses(responses: (number | string)[]): Record<string, number> {
		    const counts: Record<string, number> = {};
		    responses.forEach(response => {
		      const key = response.toString();
		      counts[key] = (counts[key] || 0) + 1;
		    });
		    return counts;
		  }
		
		  private findLongestConsecutiveSequence(responses: (number | string)[]): number {
		    if (responses.length === 0) return 0;
		    
		    let maxLength = 1;
		    let currentLength = 1;
		    
		    for (let i = 1; i < responses.length; i++) {
		      if (responses[i] === responses[i - 1]) {
		        currentLength++;
		        maxLength = Math.max(maxLength, currentLength);
		      } else {
		        currentLength = 1;
		      }
		    }
		    
		    return maxLength;
		  }
		
		  private calculateVariance(numbers: number[]): number {
		    if (numbers.length < 2) return 0;
		    
		    const mean = numbers.reduce((sum, n) => sum + n, 0) / numbers.length;
		    const variance = numbers.reduce((sum, n) => sum + Math.pow(n - mean, 2), 0) / (numbers.length - 1);
		    
		    return variance;
		  }
		
		  private determineSeverity(
		    factors: Array<{ value: number; threshold: number; weight: number }>
		  ): 'low' | 'medium' | 'high' | 'critical' {
		    const weightedScore = factors.reduce((sum, factor) => {
		      const normalized = Math.min(1, factor.value / factor.threshold);
		      return sum + (normalized * factor.weight);
		    }, 0) / factors.reduce((sum, factor) => sum + factor.weight, 0);
		
		    if (weightedScore >= 0.95) return 'critical';
		    if (weightedScore >= 0.7) return 'high';
		    if (weightedScore >= 0.4) return 'medium';
		    return 'low';
		  }
		
		  private detectAlternatingPattern(responses: (number | string)[]): number {
		    if (responses.length < 4) return 0;
		    
		    let alternatingCount = 0;
		    for (let i = 2; i < responses.length; i++) {
		      if (responses[i] === responses[i - 2] && responses[i] !== responses[i - 1]) {
		        alternatingCount++;
		      }
		    }
		    
		    return alternatingCount / (responses.length - 2);
		  }
		
		  private detectSequentialPattern(responses: (number | string)[]): number {
		    if (responses.length < 5) return 0;
		    
		    const numericResponses = responses.filter(r => typeof r === 'number') as number[];
		    if (numericResponses.length < 5) return 0;
		    
		    let sequentialCount = 0;
		    for (let i = 1; i < numericResponses.length; i++) {
		      const diff = numericResponses[i] - numericResponses[i - 1];
		      if (Math.abs(diff) === 1) {
		        sequentialCount++;
		      }
		    }
		    
		    return sequentialCount / (numericResponses.length - 1);
		  }
		
		  private detectReversePattern(responses: (number | string)[]): number {
		    // Check for patterns like 7,6,5,4,3,2,1 or 1,2,3,4,5,6,7
		    if (responses.length < 6) return 0;
		    
		    const numericResponses = responses.filter(r => typeof r === 'number') as number[];
		    if (numericResponses.length < 6) return 0;
		    
		    let reverseScore = 0;
		    for (let i = 0; i <= numericResponses.length - 6; i++) {
		      const segment = numericResponses.slice(i, i + 6);
		      const isAscending = segment.every((val, idx) => idx === 0 || val > segment[idx - 1]);
		      const isDescending = segment.every((val, idx) => idx === 0 || val < segment[idx - 1]);
		      
		      if (isAscending || isDescending) {
		        reverseScore++;
		      }
		    }
		    
		    return reverseScore / Math.max(1, numericResponses.length - 5);
		  }
		
		  private detectExtremeResponseStyle(responses: (number | string)[]): number {
		    const numericResponses = responses.filter(r => typeof r === 'number') as number[];
		    if (numericResponses.length < 5) return 0;
		    
		    // Assuming 7-point Likert scale, check for only 1s and 7s
		    const extremeResponses = numericResponses.filter(r => r === 1 || r === 7);
		    return extremeResponses.length / numericResponses.length;
		  }
		
		  private findTimingOutliers(times: number[]): number[] {
		    if (times.length < 3) return [];
		    
		    const mean = times.reduce((sum, t) => sum + t, 0) / times.length;
		    const stdDev = Math.sqrt(this.calculateVariance(times));
		    
		    return times.filter(time => {
		      const zScore = Math.abs(time - mean) / stdDev;
		      return zScore > this.thresholds.outlierZScore;
		    });
		  }
		
		  private getTimingAnomalyExplanation(type: AnomalyType, evidence: any): string {
		    switch (type) {
		      case 'too_fast_completion':
		        return `${(evidence.fastResponseRatio * 100).toFixed(1)}% of responses completed in under ${this.thresholds.botLikeSpeedThreshold}ms (average: ${evidence.averageTime.toFixed(0)}ms)`;
		      case 'bot_like_behavior':
		        return `Consistent rapid responses with low variation (CV: ${evidence.coefficientOfVariation?.toFixed(3)}, average: ${evidence.averageTime.toFixed(0)}ms)`;
		      default:
		        return 'Timing anomaly detected';
		    }
		  }
		}
		
		export const anomalyDetector = new AnomalyDetectionEngine();
		export default anomalyDetector;]]></file>
	<file path='utils/assessment/assessmentStore.ts'><![CDATA[
		/**
		 * Assessment Store
		 * Manages assessment state, data integrity, and persistence
		 */
		
		import { create } from 'zustand';
		import { persist, createJSONStorage } from 'zustand/middleware';
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import { 
		  AssessmentSession, 
		  AssessmentResponse, 
		  AssessmentResults,
		  ValidationResult,
		  LikertResponse
		} from './types';
		import { validateAssessmentResponses, calculateReliabilityMetrics } from './scoringAlgorithms';
		
		interface AssessmentState {
		  // Current session
		  currentSession: AssessmentSession | null;
		  
		  // Historical data
		  completedSessions: AssessmentSession[];
		  assessmentResults: AssessmentResults[];
		  
		  // UI state
		  isAssessmentActive: boolean;
		  currentQuestionIndex: number;
		  lastSaveTime: string | null;
		  autoSaveEnabled: boolean;
		  
		  // Data integrity
		  lastValidation: ValidationResult | null;
		  backupData: string | null;
		  
		  // Actions
		  startAssessment: (userId: string, version: string) => void;
		  saveResponse: (questionId: string, response: LikertResponse, responseTime?: number) => void;
		  updateProgress: (progress: number) => void;
		  completeAssessment: () => Promise<void>;
		  pauseAssessment: () => void;
		  resumeAssessment: () => void;
		  abandonAssessment: () => void;
		  
		  // Data management
		  validateCurrentSession: () => ValidationResult;
		  createBackup: () => void;
		  restoreFromBackup: () => boolean;
		  exportData: () => string;
		  importData: (data: string) => boolean;
		  clearAllData: () => void;
		  
		  // Auto-save
		  enableAutoSave: () => void;
		  disableAutoSave: () => void;
		  performAutoSave: () => void;
		}
		
		export const useAssessmentStore = create<AssessmentState>()(
		  persist(
		    (set, get) => ({
		      // Initial state
		      currentSession: null,
		      completedSessions: [],
		      assessmentResults: [],
		      isAssessmentActive: false,
		      currentQuestionIndex: 0,
		      lastSaveTime: null,
		      autoSaveEnabled: true,
		      lastValidation: null,
		      backupData: null,
		
		      // Assessment lifecycle
		      startAssessment: (userId: string, version: string) => {
		        const newSession: AssessmentSession = {
		          id: `assessment_${Date.now()}_${userId}`,
		          userId,
		          startTime: new Date().toISOString(),
		          responses: [],
		          progress: 0,
		          isComplete: false,
		          version
		        };
		
		        set({
		          currentSession: newSession,
		          isAssessmentActive: true,
		          currentQuestionIndex: 0,
		          lastSaveTime: new Date().toISOString()
		        });
		        
		        // Create initial backup
		        get().createBackup();
		      },
		
		      saveResponse: (questionId: string, response: LikertResponse, responseTime?: number) => {
		        const state = get();
		        if (!state.currentSession || !state.isAssessmentActive) {
		          throw new Error('No active assessment session');
		        }
		
		        const newResponse: AssessmentResponse = {
		          questionId,
		          response,
		          timestamp: new Date().toISOString(),
		          responseTime
		        };
		
		        // Remove any existing response for this question (allow updates)
		        const updatedResponses = [
		          ...state.currentSession.responses.filter(r => r.questionId !== questionId),
		          newResponse
		        ];
		
		        const updatedSession = {
		          ...state.currentSession,
		          responses: updatedResponses
		        };
		
		        set({
		          currentSession: updatedSession,
		          lastSaveTime: new Date().toISOString()
		        });
		
		        // Auto-save if enabled
		        if (state.autoSaveEnabled) {
		          setTimeout(() => get().performAutoSave(), 100);
		        }
		      },
		
		      updateProgress: (progress: number) => {
		        const state = get();
		        if (!state.currentSession) return;
		
		        const updatedSession = {
		          ...state.currentSession,
		          progress: Math.max(0, Math.min(100, progress))
		        };
		
		        set({ 
		          currentSession: updatedSession,
		          currentQuestionIndex: Math.floor((progress / 100) * 50) // Assuming 50 questions
		        });
		      },
		
		      completeAssessment: async () => {
		        const state = get();
		        if (!state.currentSession || !state.isAssessmentActive) {
		          throw new Error('No active assessment session to complete');
		        }
		
		        // Validate session before completion
		        const validation = get().validateCurrentSession();
		        if (!validation.isValid) {
		          throw new Error(`Cannot complete assessment: ${validation.errors.join(', ')}`);
		        }
		
		        const completedSession = {
		          ...state.currentSession,
		          endTime: new Date().toISOString(),
		          progress: 100,
		          isComplete: true
		        };
		
		        set({
		          currentSession: null,
		          isAssessmentActive: false,
		          completedSessions: [...state.completedSessions, completedSession],
		          currentQuestionIndex: 0,
		          lastSaveTime: new Date().toISOString()
		        });
		
		        // Create backup after completion
		        get().createBackup();
		      },
		
		      pauseAssessment: () => {
		        set({ isAssessmentActive: false });
		        get().performAutoSave();
		      },
		
		      resumeAssessment: () => {
		        const state = get();
		        if (state.currentSession && !state.currentSession.isComplete) {
		          set({ isAssessmentActive: true });
		        }
		      },
		
		      abandonAssessment: () => {
		        const state = get();
		        if (state.currentSession) {
		          // Move to completed sessions as abandoned
		          const abandonedSession = {
		            ...state.currentSession,
		            endTime: new Date().toISOString(),
		            isComplete: false
		          };
		          
		          set({
		            currentSession: null,
		            isAssessmentActive: false,
		            completedSessions: [...state.completedSessions, abandonedSession],
		            currentQuestionIndex: 0
		          });
		        }
		      },
		
		      // Data integrity and validation
		      validateCurrentSession: () => {
		        const state = get();
		        if (!state.currentSession) {
		          return {
		            isValid: false,
		            errors: ['No current session to validate'],
		            warnings: [],
		            missingResponses: []
		          };
		        }
		
		        // Create a set of all required questions (this would come from your question bank)
		        const requiredQuestions = new Set<string>();
		        // TODO: Populate with actual required question IDs
		        
		        const validation = validateAssessmentResponses(
		          state.currentSession.responses,
		          requiredQuestions
		        );
		
		        set({ lastValidation: validation });
		        return validation;
		      },
		
		      createBackup: () => {
		        const state = get();
		        const backupData = JSON.stringify({
		          currentSession: state.currentSession,
		          completedSessions: state.completedSessions,
		          assessmentResults: state.assessmentResults,
		          timestamp: new Date().toISOString()
		        });
		
		        set({ backupData });
		      },
		
		      restoreFromBackup: () => {
		        const state = get();
		        if (!state.backupData) return false;
		
		        try {
		          const backup = JSON.parse(state.backupData);
		          set({
		            currentSession: backup.currentSession,
		            completedSessions: backup.completedSessions || [],
		            assessmentResults: backup.assessmentResults || []
		          });
		          return true;
		        } catch (error) {
		          console.error('Failed to restore from backup:', error);
		          return false;
		        }
		      },
		
		      exportData: () => {
		        const state = get();
		        return JSON.stringify({
		          completedSessions: state.completedSessions,
		          assessmentResults: state.assessmentResults,
		          exportedAt: new Date().toISOString(),
		          version: '1.0.0'
		        }, null, 2);
		      },
		
		      importData: (data: string) => {
		        try {
		          const imported = JSON.parse(data);
		          
		          // Validate imported data structure
		          if (!imported.completedSessions || !Array.isArray(imported.completedSessions)) {
		            throw new Error('Invalid data structure: missing completedSessions array');
		          }
		
		          set({
		            completedSessions: [
		              ...get().completedSessions,
		              ...imported.completedSessions.filter((session: AssessmentSession) => 
		                !get().completedSessions.some(existing => existing.id === session.id)
		              )
		            ],
		            assessmentResults: [
		              ...get().assessmentResults,
		              ...(imported.assessmentResults || []).filter((result: AssessmentResults) => 
		                !get().assessmentResults.some(existing => existing.sessionId === result.sessionId)
		              )
		            ]
		          });
		
		          return true;
		        } catch (error) {
		          console.error('Failed to import data:', error);
		          return false;
		        }
		      },
		
		      clearAllData: () => {
		        set({
		          currentSession: null,
		          completedSessions: [],
		          assessmentResults: [],
		          isAssessmentActive: false,
		          currentQuestionIndex: 0,
		          lastSaveTime: null,
		          lastValidation: null,
		          backupData: null
		        });
		      },
		
		      // Auto-save functionality
		      enableAutoSave: () => set({ autoSaveEnabled: true }),
		      
		      disableAutoSave: () => set({ autoSaveEnabled: false }),
		
		      performAutoSave: () => {
		        const state = get();
		        if (!state.autoSaveEnabled || !state.currentSession) return;
		
		        // Create backup
		        get().createBackup();
		        
		        // Update last save time
		        set({ lastSaveTime: new Date().toISOString() });
		      }
		    }),
		    {
		      name: 'assessment-storage',
		      storage: createJSONStorage(() => AsyncStorage),
		      partialize: (state) => ({
		        completedSessions: state.completedSessions,
		        assessmentResults: state.assessmentResults,
		        autoSaveEnabled: state.autoSaveEnabled,
		        backupData: state.backupData
		      }),
		      onRehydrateStorage: () => (state) => {
		        // Recovery logic after app restart
		        if (state?.currentSession && state.isAssessmentActive) {
		          // Check if session was interrupted
		          const now = new Date();
		          const lastSave = state.lastSaveTime ? new Date(state.lastSaveTime) : now;
		          const timeDiff = now.getTime() - lastSave.getTime();
		          
		          // If more than 30 minutes since last save, consider session abandoned
		          if (timeDiff > 30 * 60 * 1000) {
		            state.abandonAssessment();
		          }
		        }
		      }
		    }
		  )
		);
		
		// Recovery utilities
		export const assessmentRecovery = {
		  /**
		   * Check for interrupted sessions and offer recovery
		   */
		  checkForInterruptedSession: (): AssessmentSession | null => {
		    const state = useAssessmentStore.getState();
		    if (state.currentSession && !state.currentSession.isComplete && !state.isAssessmentActive) {
		      return state.currentSession;
		    }
		    return null;
		  },
		
		  /**
		   * Calculate estimated completion time based on current progress
		   */
		  estimateTimeRemaining: (session: AssessmentSession, avgTimePerQuestion: number = 15): number => {
		    const remaining = 100 - session.progress;
		    const questionsRemaining = (remaining / 100) * 50; // Assuming 50 total questions
		    return questionsRemaining * avgTimePerQuestion; // seconds
		  }
		};]]></file>
	<file path='utils/assessment/scoringAlgorithms.ts'><![CDATA[
		/**
		 * Assessment Scoring Algorithms
		 * Mathematical functions for converting Likert responses to meaningful scores
		 */
		
		import { 
		  LikertResponse, 
		  AssessmentResponse, 
		  SubscaleScore, 
		  CompositeIndex, 
		  ScoreInterpretation,
		  AssessmentCategory,
		  ReliabilityMetrics,
		  ValidationResult
		} from './types';
		
		/**
		 * Convert Likert scale (1-8) to 0-100 scale
		 * @param response - Likert response (1-8)
		 * @param isReversed - Whether to reverse score (8 becomes 1, etc.)
		 * @returns Normalized score (0-100)
		 */
		export function likertToNormalizedScore(
		  response: LikertResponse, 
		  isReversed: boolean = false
		): number {
		  if (response < 1 || response > 8) {
		    throw new Error(`Invalid Likert response: ${response}. Must be between 1-8.`);
		  }
		  
		  const adjustedResponse = isReversed ? (9 - response) : response;
		  
		  // Convert 1-8 scale to 0-100: (response - 1) / 7 * 100
		  return Math.round(((adjustedResponse - 1) / 7) * 100 * 100) / 100;
		}
		
		/**
		 * Calculate reverse scoring for negatively worded items
		 * @param response - Original Likert response
		 * @returns Reversed response using 8-point scale formula
		 */
		export function reverseScore(response: LikertResponse): LikertResponse {
		  if (response < 1 || response > 8) {
		    throw new Error(`Invalid Likert response: ${response}. Must be between 1-8.`);
		  }
		  return (9 - response) as LikertResponse;
		}
		
		/**
		 * Calculate mean score for a set of responses
		 * @param responses - Array of assessment responses
		 * @param questionWeights - Optional weights for each question
		 * @returns Weighted or simple mean score
		 */
		export function calculateMeanScore(
		  responses: AssessmentResponse[],
		  questionWeights?: Map<string, number>
		): number {
		  if (responses.length === 0) {
		    throw new Error('Cannot calculate mean of empty responses array');
		  }
		
		  let totalScore = 0;
		  let totalWeight = 0;
		
		  for (const response of responses) {
		    const weight = questionWeights?.get(response.questionId) ?? 1;
		    totalScore += response.response * weight;
		    totalWeight += weight;
		  }
		
		  return totalScore / totalWeight;
		}
		
		/**
		 * Calculate subscale score with normalization and interpretation
		 * @param responses - Responses for this subscale
		 * @param category - Assessment category
		 * @param reversedQuestions - Set of question IDs that should be reverse scored
		 * @param norms - Normative data for percentile calculation
		 * @returns Complete subscale score object
		 */
		export function calculateSubscaleScore(
		  responses: AssessmentResponse[],
		  category: AssessmentCategory,
		  reversedQuestions: Set<string> = new Set(),
		  norms: { mean: number; std: number } = { mean: 50, std: 15 }
		): SubscaleScore {
		  if (responses.length === 0) {
		    throw new Error(`No responses provided for category: ${category}`);
		  }
		
		  // Calculate raw score with reverse scoring applied
		  let rawSum = 0;
		  for (const response of responses) {
		    const isReversed = reversedQuestions.has(response.questionId);
		    rawSum += isReversed ? reverseScore(response.response) : response.response;
		  }
		  
		  const rawScore = rawSum / responses.length;
		  const normalizedScore = likertToNormalizedScore(Math.round(rawScore) as LikertResponse, false);
		  
		  // Calculate percentile using normal distribution
		  const zScore = (normalizedScore - norms.mean) / norms.std;
		  const percentile = Math.round(normalCDF(zScore) * 100);
		  
		  // Determine interpretation
		  const interpretation = getScoreInterpretation(percentile);
		  
		  // Calculate reliability (simplified Cronbach's alpha approximation)
		  const reliability = calculateCronbachAlpha(responses);
		
		  return {
		    category,
		    rawScore,
		    normalizedScore,
		    percentile: Math.max(0, Math.min(100, percentile)),
		    interpretation,
		    reliability
		  };
		}
		
		/**
		 * Calculate composite indices (CI, ARI, TRS)
		 * @param subscales - Array of subscale scores
		 * @returns Composite index scores
		 */
		export function calculateCompositeIndices(subscales: SubscaleScore[]): CompositeIndex {
		  const scoreMap = new Map(subscales.map(s => [s.category, s.normalizedScore]));
		  
		  // Connection Index: Communication + Emotional Connection + Psychic Connection
		  const CI = Math.round(
		    ((scoreMap.get('communication') ?? 0) +
		     (scoreMap.get('emotional_connection') ?? 0) +
		     (scoreMap.get('psychic_connection') ?? 0)) / 3
		  );
		  
		  // Autonomy-Relatedness Index: Independence vs Support System balance
		  const independence = scoreMap.get('independence') ?? 50;
		  const support = scoreMap.get('support_system') ?? 50;
		  const ARI = Math.round(Math.abs(independence - support));
		  
		  // Twin Relationship Strength: Weighted composite of all scales
		  const weights = {
		    communication: 0.20,
		    emotional_connection: 0.20,
		    shared_experiences: 0.15,
		    conflict_resolution: 0.15,
		    independence: 0.10,
		    support_system: 0.10,
		    psychic_connection: 0.05,
		    identity_formation: 0.05
		  };
		  
		  let TRS = 0;
		  let totalWeight = 0;
		  
		  for (const [category, weight] of Object.entries(weights)) {
		    const score = scoreMap.get(category as AssessmentCategory);
		    if (score !== undefined) {
		      TRS += score * weight;
		      totalWeight += weight;
		    }
		  }
		  
		  return {
		    CI: Math.max(0, Math.min(100, CI)),
		    ARI: Math.max(0, Math.min(100, ARI)),
		    TRS: Math.max(0, Math.min(100, Math.round(TRS / totalWeight)))
		  };
		}
		
		/**
		 * Validate assessment responses for completeness and consistency
		 * @param responses - Array of assessment responses
		 * @param requiredQuestions - Set of required question IDs
		 * @returns Validation result with errors and warnings
		 */
		export function validateAssessmentResponses(
		  responses: AssessmentResponse[],
		  requiredQuestions: Set<string>
		): ValidationResult {
		  const errors: string[] = [];
		  const warnings: string[] = [];
		  const missingResponses: string[] = [];
		  
		  // Check for missing required responses
		  const responseQuestions = new Set(responses.map(r => r.questionId));
		  for (const required of requiredQuestions) {
		    if (!responseQuestions.has(required)) {
		      missingResponses.push(required);
		    }
		  }
		  
		  // Validate individual responses
		  for (const response of responses) {
		    // Check response value range
		    if (response.response < 1 || response.response > 8) {
		      errors.push(`Invalid response value ${response.response} for question ${response.questionId}`);
		    }
		    
		    // Check for suspiciously fast responses (< 500ms)
		    if (response.responseTime && response.responseTime < 500) {
		      warnings.push(`Very fast response time (${response.responseTime}ms) for question ${response.questionId}`);
		    }
		    
		    // Check for invalid timestamps
		    if (isNaN(new Date(response.timestamp).getTime())) {
		      errors.push(`Invalid timestamp for question ${response.questionId}`);
		    }
		  }
		  
		  // Check for straight-line responses (all same value)
		  const uniqueResponses = new Set(responses.map(r => r.response));
		  if (uniqueResponses.size === 1 && responses.length >= 5) {
		    warnings.push('All responses have the same value - possible straight-line responding');
		  }
		  
		  return {
		    isValid: errors.length === 0 && missingResponses.length === 0,
		    errors,
		    warnings,
		    missingResponses
		  };
		}
		
		/**
		 * Calculate reliability metrics including Cronbach's alpha
		 * @param responses - Assessment responses
		 * @returns Reliability metrics
		 */
		export function calculateReliabilityMetrics(responses: AssessmentResponse[]): ReliabilityMetrics {
		  const cronbachAlpha = calculateCronbachAlpha(responses);
		  const standardError = Math.sqrt(1 - cronbachAlpha) * calculateStandardDeviation(responses.map(r => r.response));
		  
		  // 95% confidence interval approximation
		  const margin = 1.96 * standardError;
		  const meanScore = responses.reduce((sum, r) => sum + r.response, 0) / responses.length;
		  
		  return {
		    cronbachAlpha,
		    standardError,
		    confidenceInterval: [
		      Math.max(1, meanScore - margin),
		      Math.min(8, meanScore + margin)
		    ]
		  };
		}
		
		// Helper Functions
		
		/**
		 * Calculate Cronbach's alpha for internal consistency
		 * @param responses - Assessment responses
		 * @returns Cronbach's alpha coefficient (0-1)
		 */
		function calculateCronbachAlpha(responses: AssessmentResponse[]): number {
		  if (responses.length < 2) return 0;
		  
		  const values = responses.map(r => r.response);
		  const n = values.length;
		  const variance = calculateVariance(values);
		  
		  if (variance === 0) return 1; // Perfect consistency if no variance
		  
		  const meanValue = values.reduce((sum, v) => sum + v, 0) / values.length;
		  const itemVariances = values.map(v => Math.pow(v - meanValue, 2));
		  const sumItemVariances = itemVariances.reduce((sum, v) => sum + v, 0) / (n - 1);
		  
		  // Simplified alpha calculation
		  const alpha = (n / (n - 1)) * (1 - (sumItemVariances / variance));
		  return Math.max(0, Math.min(1, isNaN(alpha) ? 0 : alpha));
		}
		
		/**
		 * Calculate standard deviation
		 * @param values - Array of numbers
		 * @returns Standard deviation
		 */
		function calculateStandardDeviation(values: number[]): number {
		  const variance = calculateVariance(values);
		  return Math.sqrt(variance);
		}
		
		/**
		 * Calculate variance
		 * @param values - Array of numbers
		 * @returns Variance
		 */
		function calculateVariance(values: number[]): number {
		  if (values.length === 0) return 0;
		  
		  const meanValue = mean(values);
		  const squaredDiffs = values.map(value => Math.pow(value - meanValue, 2));
		  return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / values.length;
		}
		
		/**
		 * Calculate mean of array
		 * @param values - Array of numbers
		 * @returns Mean value
		 */
		function mean(values: number[]): number {
		  return values.reduce((sum, value) => sum + value, 0) / values.length;
		}
		
		/**
		 * Normal cumulative distribution function approximation
		 * @param z - Z-score
		 * @returns Cumulative probability
		 */
		function normalCDF(z: number): number {
		  // Approximation using Taylor series
		  const t = 1 / (1 + 0.2316419 * Math.abs(z));
		  const d = 0.3989423 * Math.exp(-z * z / 2);
		  let prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
		  
		  return z > 0 ? 1 - prob : prob;
		}
		
		/**
		 * Get score interpretation based on percentile
		 * @param percentile - Percentile score (0-100)
		 * @returns Score interpretation category
		 */
		function getScoreInterpretation(percentile: number): ScoreInterpretation {
		  if (percentile >= 98) return 'very_high';
		  if (percentile >= 84) return 'high';
		  if (percentile >= 70) return 'above_average';
		  if (percentile >= 30) return 'average';
		  if (percentile >= 16) return 'below_average';
		  if (percentile >= 2) return 'low';
		  return 'very_low';
		}
		
		/**
		 * Calculate percentile rank for a score
		 * @param score - Individual score
		 * @param allScores - Array of all scores for comparison
		 * @returns Percentile rank (0-100)
		 */
		export function calculatePercentileRank(score: number, allScores: number[]): number {
		  if (allScores.length === 0) return 50; // Default to median if no comparison data
		  if (allScores.length === 1) return 50; // Single score defaults to median
		  
		  const belowOrEqualCount = allScores.filter(s => s <= score).length;
		  
		  // Standard percentile calculation: (rank / total) * 100
		  // For score 75 in [50, 60, 70, 75, 80, 90]: (4/6)*100 = 66.67%
		  const percentile = (belowOrEqualCount / allScores.length) * 100;
		  
		  return Math.round(percentile * 100) / 100; // Round to 2 decimal places
		}]]></file>
	<file path='utils/assessment/types.ts'>
		/**
		 * Assessment System Types
		 * Comprehensive type definitions for Twinship assessment scoring
		 */
		
		export type LikertResponse = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;
		
		export interface AssessmentQuestion {
		  id: string;
		  text: string;
		  category: AssessmentCategory;
		  subcategory: string;
		  isReversed: boolean;
		  weight: number;
		}
		
		export type AssessmentCategory = 
		  | 'communication'
		  | 'emotional_connection' 
		  | 'shared_experiences'
		  | 'conflict_resolution'
		  | 'independence'
		  | 'support_system'
		  | 'psychic_connection'
		  | 'identity_formation';
		
		export interface AssessmentResponse {
		  questionId: string;
		  response: LikertResponse;
		  timestamp: string;
		  responseTime?: number; // milliseconds
		}
		
		export interface AssessmentSession {
		  id: string;
		  userId: string;
		  startTime: string;
		  endTime?: string;
		  responses: AssessmentResponse[];
		  progress: number; // 0-100
		  isComplete: boolean;
		  version: string; // assessment version for longitudinal studies
		}
		
		export interface SubscaleScore {
		  category: AssessmentCategory;
		  rawScore: number;
		  normalizedScore: number; // 0-100
		  percentile: number;
		  interpretation: ScoreInterpretation;
		  reliability: number; // Cronbach's alpha for this subscale
		}
		
		export interface CompositeIndex {
		  CI: number; // Connection Index
		  ARI: number; // Autonomy-Relatedness Index  
		  TRS: number; // Twin Relationship Strength
		}
		
		export interface AssessmentResults {
		  sessionId: string;
		  userId: string;
		  completedAt: string;
		  subscales: SubscaleScore[];
		  compositeIndices: CompositeIndex;
		  overallScore: number;
		  growthAreas: GrowthArea[];
		  strengths: string[];
		  reliabilityMetrics: ReliabilityMetrics;
		}
		
		export interface PairResults {
		  userResults: AssessmentResults;
		  twinResults: AssessmentResults;
		  compatibilityScore: number;
		  sharedStrengths: string[];
		  complementaryAreas: string[];
		  concernAreas: string[];
		  privacyPreserved: boolean;
		}
		
		export type ScoreInterpretation = 
		  | 'very_low' 
		  | 'low' 
		  | 'below_average' 
		  | 'average' 
		  | 'above_average' 
		  | 'high' 
		  | 'very_high';
		
		export interface GrowthArea {
		  category: AssessmentCategory;
		  priority: 'low' | 'medium' | 'high';
		  recommendedActions: string[];
		  resources: string[];
		}
		
		export interface ReliabilityMetrics {
		  cronbachAlpha: number;
		  testRetestReliability?: number;
		  standardError: number;
		  confidenceInterval: [number, number];
		}
		
		export interface ValidationResult {
		  isValid: boolean;
		  errors: string[];
		  warnings: string[];
		  missingResponses: string[];
		}</file>
	<file path='utils/assessmentItemBank.ts'><![CDATA[
		/**
		 * Twinship Assessment Item Bank
		 * Comprehensive collection of twin-specific psychological assessment items
		 */
		
		import {
		  AssessmentItemBank,
		  AssessmentItem,
		  TwinSubscales,
		  BigFiveTraits,
		} from '../types/assessment';
		
		/**
		 * Complete assessment item bank with 200+ twin-specific questions
		 */
		export const TWINSHIP_ITEM_BANK: AssessmentItemBank = {
		  version: '1.0.0',
		  items: [
		    // Emotional Fusion Items (12 items)
		    {
		      id: 'EF001',
		      category: 'emotionalFusion',
		      text: 'When my twin is upset, I automatically feel upset too.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'EF002',
		      category: 'emotionalFusion',
		      text: 'I can be happy even when my twin is feeling sad.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'EF003',
		      category: 'emotionalFusion',
		      text: 'My twin and I seem to feel the same emotions at the same time.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'EF004',
		      category: 'emotionalFusion',
		      text: 'I find it difficult to have different feelings than my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'EF005',
		      category: 'emotionalFusion',
		      text: 'I can enjoy myself even when my twin is having a bad day.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'EF006',
		      category: 'emotionalFusion',
		      text: 'When my twin is excited about something, I get excited too, even if I don\'t really care about it.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'EF007',
		      category: 'emotionalFusion',
		      text: 'I can maintain my own emotional state regardless of my twin\'s mood.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'EF008',
		      category: 'emotionalFusion',
		      text: 'My twin\'s emotions feel like my own emotions.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'EF009',
		      category: 'emotionalFusion',
		      text: 'I worry that if I\'m happy when my twin is sad, I\'m being insensitive.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'EF010',
		      category: 'emotionalFusion',
		      text: 'I can empathize with my twin without taking on their emotions.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'EF011',
		      category: 'emotionalFusion',
		      text: 'When my twin is anxious, I become anxious too.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'EF012',
		      category: 'emotionalFusion',
		      text: 'I can support my twin emotionally while maintaining my own emotional balance.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		
		    // Identity Blurring Items (12 items)
		    {
		      id: 'IB001',
		      category: 'identityBlurring',
		      text: 'People often think of my twin and me as one person rather than two individuals.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IB002',
		      category: 'identityBlurring',
		      text: 'I have a clear sense of who I am separate from my twin.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'IB003',
		      category: 'identityBlurring',
		      text: 'I often use "we" when talking about myself.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IB004',
		      category: 'identityBlurring',
		      text: 'It\'s hard for me to imagine my life without my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IB005',
		      category: 'identityBlurring',
		      text: 'I can easily describe what makes me different from my twin.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'IB006',
		      category: 'identityBlurring',
		      text: 'My twin and I finish each other\'s sentences regularly.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IB007',
		      category: 'identityBlurring',
		      text: 'I have interests and hobbies that are completely separate from my twin\'s.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'IB008',
		      category: 'identityBlurring',
		      text: 'When people ask about me, I often end up talking about both my twin and myself.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IB009',
		      category: 'identityBlurring',
		      text: 'My goals and dreams are very similar to my twin\'s goals and dreams.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IB010',
		      category: 'identityBlurring',
		      text: 'I have a strong individual identity that exists independently of being a twin.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'IB011',
		      category: 'identityBlurring',
		      text: 'My twin and I often have the same thoughts at the same time.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IB012',
		      category: 'identityBlurring',
		      text: 'I can introduce myself without mentioning that I\'m a twin.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		
		    // Separation Anxiety Items (12 items)
		    {
		      id: 'SA001',
		      category: 'separationAnxiety',
		      text: 'I feel anxious when my twin and I are apart for more than a day.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SA002',
		      category: 'separationAnxiety',
		      text: 'I enjoy having time to myself without my twin.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'SA003',
		      category: 'separationAnxiety',
		      text: 'I worry about what might happen to my twin when we\'re not together.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SA004',
		      category: 'separationAnxiety',
		      text: 'Being apart from my twin for a week would not bother me.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'SA005',
		      category: 'separationAnxiety',
		      text: 'I feel incomplete when my twin is not around.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SA006',
		      category: 'separationAnxiety',
		      text: 'I can function normally even when separated from my twin for extended periods.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'SA007',
		      category: 'separationAnxiety',
		      text: 'I often call or text my twin when we\'re apart to make sure they\'re okay.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SA008',
		      category: 'separationAnxiety',
		      text: 'I get physically uncomfortable (stomach aches, headaches) when separated from my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SA009',
		      category: 'separationAnxiety',
		      text: 'I can sleep well even when my twin is not nearby.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'SA010',
		      category: 'separationAnxiety',
		      text: 'I panic if I can\'t reach my twin when I try to contact them.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SA011',
		      category: 'separationAnxiety',
		      text: 'Being in different cities from my twin would be very stressful for me.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SA012',
		      category: 'separationAnxiety',
		      text: 'I look forward to opportunities to experience life independently from my twin.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		
		    // Boundary Diffusion Items (10 items)
		    {
		      id: 'BD001',
		      category: 'boundaryDiffusion',
		      text: 'My twin and I share everything - clothes, friends, activities, even secrets.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'BD002',
		      category: 'boundaryDiffusion',
		      text: 'I have some things that are just mine and not shared with my twin.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'BD003',
		      category: 'boundaryDiffusion',
		      text: 'My twin often speaks for me in social situations.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'BD004',
		      category: 'boundaryDiffusion',
		      text: 'I can say "no" to my twin when I don\'t want to do something.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'BD005',
		      category: 'boundaryDiffusion',
		      text: 'My twin and I make most decisions together, even personal ones.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'BD006',
		      category: 'boundaryDiffusion',
		      text: 'I have friends who are close to me but not to my twin.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'BD007',
		      category: 'boundaryDiffusion',
		      text: 'My twin knows all my passwords and has access to my personal accounts.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'BD008',
		      category: 'boundaryDiffusion',
		      text: 'I can keep certain thoughts and feelings private from my twin.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'BD009',
		      category: 'boundaryDiffusion',
		      text: 'My twin and I rarely disagree about important matters.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'BD010',
		      category: 'boundaryDiffusion',
		      text: 'I maintain clear boundaries about what I will and won\'t share with my twin.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		
		    // Individual Identity Items (15 items)
		    {
		      id: 'II001',
		      category: 'individualIdentity',
		      text: 'I have a strong sense of who I am as an individual.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'II002',
		      category: 'individualIdentity',
		      text: 'My personality is very different from my twin\'s personality.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'II003',
		      category: 'individualIdentity',
		      text: 'I have personal values that may differ from my twin\'s values.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'II004',
		      category: 'individualIdentity',
		      text: 'People can easily tell my twin and me apart based on our personalities.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'II005',
		      category: 'individualIdentity',
		      text: 'I have career aspirations that are independent of my twin\'s career plans.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'II006',
		      category: 'individualIdentity',
		      text: 'My life goals are clearly defined and separate from my twin\'s goals.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'II007',
		      category: 'individualIdentity',
		      text: 'I feel confident in who I am when I\'m not with my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'II008',
		      category: 'individualIdentity',
		      text: 'I have developed skills and talents that my twin doesn\'t have.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'II009',
		      category: 'individualIdentity',
		      text: 'My personal style (clothing, decoration, etc.) reflects my individual taste.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'II010',
		      category: 'individualIdentity',
		      text: 'I can express opinions that are different from my twin\'s without feeling guilty.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'II011',
		      category: 'individualIdentity',
		      text: 'I have personal interests that I pursue independently of my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'II012',
		      category: 'individualIdentity',
		      text: 'I feel comfortable being the center of attention without my twin present.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'II013',
		      category: 'individualIdentity',
		      text: 'I know what I like and dislike, separate from my twin\'s preferences.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'II014',
		      category: 'individualIdentity',
		      text: 'I have a personal philosophy or worldview that I\'ve developed independently.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'II015',
		      category: 'individualIdentity',
		      text: 'I can make major life decisions without heavily relying on my twin\'s input.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		
		    // Personal Boundaries Items (12 items)
		    {
		      id: 'PB001',
		      category: 'personalBoundaries',
		      text: 'I can tell my twin when I need space without feeling guilty.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'PB002',
		      category: 'personalBoundaries',
		      text: 'My twin respects my privacy and personal space.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'PB003',
		      category: 'personalBoundaries',
		      text: 'I feel comfortable setting limits with my twin about what I will and won\'t do.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'PB004',
		      category: 'personalBoundaries',
		      text: 'My twin and I respect each other\'s individual boundaries.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'PB005',
		      category: 'personalBoundaries',
		      text: 'I can refuse to share personal information with my twin if I choose to.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'PB006',
		      category: 'personalBoundaries',
		      text: 'I have clear guidelines about what belongings I share with my twin and what I keep private.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'PB007',
		      category: 'personalBoundaries',
		      text: 'I can spend time alone without my twin asking detailed questions about what I did.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'PB008',
		      category: 'personalBoundaries',
		      text: 'My twin asks permission before making decisions that affect both of us.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'PB009',
		      category: 'personalBoundaries',
		      text: 'I feel comfortable having some relationships that don\'t include my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'PB010',
		      category: 'personalBoundaries',
		      text: 'My twin and I can disagree without it becoming a major conflict.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'PB011',
		      category: 'personalBoundaries',
		      text: 'I can express when my twin has crossed a boundary without fear of damaging our relationship.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'PB012',
		      category: 'personalBoundaries',
		      text: 'My twin and I maintain healthy emotional boundaries while still being close.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		
		    // Independent Decision Making Items (12 items)
		    {
		      id: 'IDM001',
		      category: 'independentDecisionMaking',
		      text: 'I can make important decisions without consulting my twin first.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IDM002',
		      category: 'independentDecisionMaking',
		      text: 'I trust my own judgment even when my twin disagrees.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IDM003',
		      category: 'independentDecisionMaking',
		      text: 'I can choose what to wear without considering what my twin will think.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IDM004',
		      category: 'independentDecisionMaking',
		      text: 'I make career choices based on my own interests and abilities.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IDM005',
		      category: 'independentDecisionMaking',
		      text: 'I can decide how to spend my free time without automatically including my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IDM006',
		      category: 'independentDecisionMaking',
		      text: 'I feel confident making financial decisions independently.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IDM007',
		      category: 'independentDecisionMaking',
		      text: 'I can choose my own friends without worrying about whether my twin likes them.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IDM008',
		      category: 'independentDecisionMaking',
		      text: 'I make decisions about my romantic relationships independently.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IDM009',
		      category: 'independentDecisionMaking',
		      text: 'I can choose where to live without my twin\'s approval.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IDM010',
		      category: 'independentDecisionMaking',
		      text: 'I trust myself to make good decisions without my twin\'s input.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IDM011',
		      category: 'independentDecisionMaking',
		      text: 'I can make spontaneous decisions without feeling I need to check with my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'IDM012',
		      category: 'independentDecisionMaking',
		      text: 'I take responsibility for my own decisions, even when they don\'t turn out well.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		
		    // Self Advocacy Items (10 items)
		    {
		      id: 'SAV001',
		      category: 'selfAdvocacy',
		      text: 'I can speak up for myself in group settings.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SAV002',
		      category: 'selfAdvocacy',
		      text: 'I express my needs clearly to others, including my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SAV003',
		      category: 'selfAdvocacy',
		      text: 'I can ask for help when I need it.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SAV004',
		      category: 'selfAdvocacy',
		      text: 'I stand up for my rights and beliefs.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SAV005',
		      category: 'selfAdvocacy',
		      text: 'I can negotiate for what I want in relationships.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SAV006',
		      category: 'selfAdvocacy',
		      text: 'I speak up when someone treats me unfairly.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SAV007',
		      category: 'selfAdvocacy',
		      text: 'I can express disagreement with others without fear.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SAV008',
		      category: 'selfAdvocacy',
		      text: 'I assert my individual needs even when they differ from my twin\'s needs.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SAV009',
		      category: 'selfAdvocacy',
		      text: 'I can represent myself effectively in professional situations.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SAV010',
		      category: 'selfAdvocacy',
		      text: 'I communicate my boundaries clearly to others.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		
		    // Adaptability to Change Items (10 items)
		    {
		      id: 'AC001',
		      category: 'adaptabilityToChange',
		      text: 'I adjust well to new situations and environments.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AC002',
		      category: 'adaptabilityToChange',
		      text: 'I feel comfortable when my routine changes unexpectedly.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AC003',
		      category: 'adaptabilityToChange',
		      text: 'I see change as an opportunity for growth.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AC004',
		      category: 'adaptabilityToChange',
		      text: 'I can handle uncertainty without becoming overly anxious.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AC005',
		      category: 'adaptabilityToChange',
		      text: 'I adapt my behavior to fit different social situations.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AC006',
		      category: 'adaptabilityToChange',
		      text: 'I remain flexible when plans change.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AC007',
		      category: 'adaptabilityToChange',
		      text: 'I can cope effectively with unexpected challenges.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AC008',
		      category: 'adaptabilityToChange',
		      text: 'I find it easy to learn new ways of doing things.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AC009',
		      category: 'adaptabilityToChange',
		      text: 'I can adjust my expectations when circumstances change.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AC010',
		      category: 'adaptabilityToChange',
		      text: 'I maintain a positive attitude during times of change.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		
		    // Conflict Resolution Items (10 items)
		    {
		      id: 'CR001',
		      category: 'conflictResolution',
		      text: 'I handle disagreements with my twin constructively.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CR002',
		      category: 'conflictResolution',
		      text: 'I can find compromises when my twin and I disagree.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CR003',
		      category: 'conflictResolution',
		      text: 'I stay calm during conflicts with my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CR004',
		      category: 'conflictResolution',
		      text: 'I can see my twin\'s perspective even when we disagree.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CR005',
		      category: 'conflictResolution',
		      text: 'I address problems with my twin directly rather than avoiding them.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CR006',
		      category: 'conflictResolution',
		      text: 'I can apologize when I\'m wrong in a conflict with my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CR007',
		      category: 'conflictResolution',
		      text: 'I work toward win-win solutions when my twin and I have conflicts.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CR008',
		      category: 'conflictResolution',
		      text: 'I can manage my emotions during heated discussions with my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CR009',
		      category: 'conflictResolution',
		      text: 'I listen actively to my twin\'s concerns during disagreements.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CR010',
		      category: 'conflictResolution',
		      text: 'I can repair our relationship after conflicts with my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		
		    // Emotional Regulation Items (12 items)
		    {
		      id: 'ER001',
		      category: 'emotionalRegulation',
		      text: 'I can manage my emotions effectively.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'ER002',
		      category: 'emotionalRegulation',
		      text: 'I stay calm under pressure.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'ER003',
		      category: 'emotionalRegulation',
		      text: 'I can soothe myself when I\'m upset.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'ER004',
		      category: 'emotionalRegulation',
		      text: 'I control my temper well.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'ER005',
		      category: 'emotionalRegulation',
		      text: 'I can think clearly even when I\'m emotional.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'ER006',
		      category: 'emotionalRegulation',
		      text: 'I bounce back quickly from emotional setbacks.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'ER007',
		      category: 'emotionalRegulation',
		      text: 'I can express my emotions appropriately.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'ER008',
		      category: 'emotionalRegulation',
		      text: 'I rarely lose control of my emotions.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'ER009',
		      category: 'emotionalRegulation',
		      text: 'I can delay gratification when necessary.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'ER010',
		      category: 'emotionalRegulation',
		      text: 'I handle stress well.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'ER011',
		      category: 'emotionalRegulation',
		      text: 'I can remain optimistic during difficult times.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'ER012',
		      category: 'emotionalRegulation',
		      text: 'I process my emotions in healthy ways.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		
		    // Social Support Items (8 items)
		    {
		      id: 'SS001',
		      category: 'socialSupport',
		      text: 'I have friends I can turn to for support besides my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SS002',
		      category: 'socialSupport',
		      text: 'I feel comfortable asking for help from people other than my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SS003',
		      category: 'socialSupport',
		      text: 'I maintain friendships that are separate from my twin relationship.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SS004',
		      category: 'socialSupport',
		      text: 'I have mentors or role models who guide me independently.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SS005',
		      category: 'socialSupport',
		      text: 'I can build new relationships easily.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SS006',
		      category: 'socialSupport',
		      text: 'I have a diverse network of people I can rely on.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SS007',
		      category: 'socialSupport',
		      text: 'I feel part of communities beyond my twin relationship.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'SS008',
		      category: 'socialSupport',
		      text: 'I can give and receive support in various relationships.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		
		    // Change Anxiety Items (10 items)
		    {
		      id: 'CA001',
		      category: 'changeAnxiety',
		      text: 'I worry excessively about upcoming changes in my life.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CA002',
		      category: 'changeAnxiety',
		      text: 'The thought of major life transitions makes me anxious.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CA003',
		      category: 'changeAnxiety',
		      text: 'I prefer my life to stay the same rather than change.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CA004',
		      category: 'changeAnxiety',
		      text: 'I get nervous about changes that might affect my relationship with my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CA005',
		      category: 'changeAnxiety',
		      text: 'I avoid making changes even when they might be beneficial.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CA006',
		      category: 'changeAnxiety',
		      text: 'I feel overwhelmed when multiple changes happen at once.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CA007',
		      category: 'changeAnxiety',
		      text: 'I spend a lot of time worrying about "what if" scenarios.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CA008',
		      category: 'changeAnxiety',
		      text: 'I get physically symptoms (headaches, stomach aches) when facing change.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CA009',
		      category: 'changeAnxiety',
		      text: 'I have trouble sleeping when big changes are coming up.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'CA010',
		      category: 'changeAnxiety',
		      text: 'I need a lot of time to prepare mentally for any change.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		
		    // Attachment Insecurity Items (10 items)
		    {
		      id: 'AI001',
		      category: 'attachmentInsecurity',
		      text: 'I worry that my twin will find someone more important than me.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AI002',
		      category: 'attachmentInsecurity',
		      text: 'I need frequent reassurance that my twin still cares about me.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AI003',
		      category: 'attachmentInsecurity',
		      text: 'I get jealous when my twin spends time with other people.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AI004',
		      category: 'attachmentInsecurity',
		      text: 'I fear that my twin will eventually grow tired of our relationship.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AI005',
		      category: 'attachmentInsecurity',
		      text: 'I worry about being abandoned or replaced by my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AI006',
		      category: 'attachmentInsecurity',
		      text: 'I get upset when my twin doesn\'t respond to my messages quickly.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AI007',
		      category: 'attachmentInsecurity',
		      text: 'I feel secure in my relationship with my twin.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'AI008',
		      category: 'attachmentInsecurity',
		      text: 'I trust that my twin will be there for me long-term.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'AI009',
		      category: 'attachmentInsecurity',
		      text: 'I worry about what will happen to our relationship as we get older.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'AI010',
		      category: 'attachmentInsecurity',
		      text: 'I feel confident that my twin values our relationship as much as I do.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		
		    // Role Confusion Items (8 items)
		    {
		      id: 'RC001',
		      category: 'roleConfusion',
		      text: 'I\'m not sure what my role should be as my twin and I become adults.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'RC002',
		      category: 'roleConfusion',
		      text: 'I know exactly what kind of twin I want to be.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'RC003',
		      category: 'roleConfusion',
		      text: 'I struggle to define my responsibilities toward my twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'RC004',
		      category: 'roleConfusion',
		      text: 'I\'m unclear about how much I should sacrifice for my twin\'s happiness.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'RC005',
		      category: 'roleConfusion',
		      text: 'I have clear boundaries about my obligations to my twin.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'RC006',
		      category: 'roleConfusion',
		      text: 'I sometimes feel like I don\'t know how to be a good twin.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'RC007',
		      category: 'roleConfusion',
		      text: 'I understand my role in the twin relationship clearly.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'RC008',
		      category: 'roleConfusion',
		      text: 'I\'m confident about balancing my individual needs with my twin responsibilities.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		
		    // Future Orientation Items (8 items)
		    {
		      id: 'FO001',
		      category: 'futureOrientation',
		      text: 'I have clear goals for my future.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'FO002',
		      category: 'futureOrientation',
		      text: 'I plan for my future independently of my twin\'s plans.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'FO003',
		      category: 'futureOrientation',
		      text: 'I feel optimistic about what lies ahead for me.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'FO004',
		      category: 'futureOrientation',
		      text: 'I can imagine a fulfilling life for myself, even if it\'s different from my twin\'s life.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'FO005',
		      category: 'futureOrientation',
		      text: 'I worry about my future because I can\'t imagine it without my twin.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'FO006',
		      category: 'futureOrientation',
		      text: 'I have specific steps planned to achieve my individual goals.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'FO007',
		      category: 'futureOrientation',
		      text: 'I feel excited about the possibilities in my future.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'FO008',
		      category: 'futureOrientation',
		      text: 'I believe I can create a meaningful life path for myself.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		
		    // Big Five - Openness Items (10 items)
		    {
		      id: 'O001',
		      category: 'openness',
		      text: 'I enjoy trying new experiences and activities.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'O002',
		      category: 'openness',
		      text: 'I am interested in art, music, or literature.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'O003',
		      category: 'openness',
		      text: 'I like to explore new ideas and concepts.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'O004',
		      category: 'openness',
		      text: 'I prefer familiar routines over new experiences.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'O005',
		      category: 'openness',
		      text: 'I am curious about many different things.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'O006',
		      category: 'openness',
		      text: 'I enjoy abstract or philosophical discussions.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'O007',
		      category: 'openness',
		      text: 'I am creative and imaginative.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'O008',
		      category: 'openness',
		      text: 'I prefer practical matters over imaginative ones.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'O009',
		      category: 'openness',
		      text: 'I enjoy learning about different cultures and ways of life.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'O010',
		      category: 'openness',
		      text: 'I like to think about complex problems.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		
		    // Big Five - Conscientiousness Items (10 items)  
		    {
		      id: 'C001',
		      category: 'conscientiousness',
		      text: 'I am organized and systematic.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'C002',
		      category: 'conscientiousness',
		      text: 'I follow through on my commitments.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'C003',
		      category: 'conscientiousness',
		      text: 'I am often late for appointments.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'C004',
		      category: 'conscientiousness',
		      text: 'I work hard to achieve my goals.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'C005',
		      category: 'conscientiousness',
		      text: 'I am disciplined and self-controlled.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'C006',
		      category: 'conscientiousness',
		      text: 'I often leave tasks unfinished.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'C007',
		      category: 'conscientiousness',
		      text: 'I pay attention to details.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'C008',
		      category: 'conscientiousness',
		      text: 'I am reliable and dependable.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'C009',
		      category: 'conscientiousness',
		      text: 'I tend to be messy and disorganized.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'C010',
		      category: 'conscientiousness',
		      text: 'I plan ahead and prepare for upcoming events.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		
		    // Big Five - Extraversion Items (10 items)
		    {
		      id: 'E001',
		      category: 'extraversion',
		      text: 'I enjoy being the center of attention.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'E002',
		      category: 'extraversion',
		      text: 'I feel energized when I\'m around other people.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'E003',
		      category: 'extraversion',
		      text: 'I prefer quiet activities over social gatherings.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'E004',
		      category: 'extraversion',
		      text: 'I am talkative and outgoing.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'E005',
		      category: 'extraversion',
		      text: 'I enjoy meeting new people.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'E006',
		      category: 'extraversion',
		      text: 'I prefer working alone rather than in groups.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'E007',
		      category: 'extraversion',
		      text: 'I am enthusiastic and energetic.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'E008',
		      category: 'extraversion',
		      text: 'I feel comfortable in large social gatherings.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'E009',
		      category: 'extraversion',
		      text: 'I tend to be reserved and quiet.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'E010',
		      category: 'extraversion',
		      text: 'I seek out social activities and events.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		
		    // Big Five - Agreeableness Items (10 items)
		    {
		      id: 'A001',
		      category: 'agreeableness',
		      text: 'I am sympathetic and understanding toward others.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'A002',
		      category: 'agreeableness',
		      text: 'I trust people easily.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'A003',
		      category: 'agreeableness',
		      text: 'I can be critical and harsh with others.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'A004',
		      category: 'agreeableness',
		      text: 'I cooperate well with others.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'A005',
		      category: 'agreeableness',
		      text: 'I am generous and helpful.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'A006',
		      category: 'agreeableness',
		      text: 'I tend to be suspicious of others\' motives.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'A007',
		      category: 'agreeableness',
		      text: 'I forgive others easily.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'A008',
		      category: 'agreeableness',
		      text: 'I am considerate and kind.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'A009',
		      category: 'agreeableness',
		      text: 'I can be cold and indifferent to others.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'A010',
		      category: 'agreeableness',
		      text: 'I enjoy helping others solve their problems.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		
		    // Big Five - Neuroticism Items (10 items)
		    {
		      id: 'N001',
		      category: 'neuroticism',
		      text: 'I worry about many things.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'N002',
		      category: 'neuroticism',
		      text: 'I remain calm under pressure.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'N003',
		      category: 'neuroticism',
		      text: 'I get stressed easily.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'N004',
		      category: 'neuroticism',
		      text: 'I am emotionally stable.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'N005',
		      category: 'neuroticism',
		      text: 'I often feel anxious or nervous.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'N006',
		      category: 'neuroticism',
		      text: 'I handle criticism well.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'N007',
		      category: 'neuroticism',
		      text: 'I am prone to mood swings.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'N008',
		      category: 'neuroticism',
		      text: 'I rarely feel sad or depressed.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		    {
		      id: 'N009',
		      category: 'neuroticism',
		      text: 'I get upset easily.',
		      reverseScored: false,
		      weight: 1.0,
		    },
		    {
		      id: 'N010',
		      category: 'neuroticism',
		      text: 'I am generally optimistic.',
		      reverseScored: true,
		      weight: 1.0,
		    },
		  ],
		
		  scales: {
		    // Twin-specific subscales
		    emotionalFusion: {
		      items: ['EF001', 'EF002', 'EF003', 'EF004', 'EF005', 'EF006', 'EF007', 'EF008', 'EF009', 'EF010', 'EF011', 'EF012'],
		      reliabilityAlpha: 0.89,
		      validityEvidence: ['Correlates with codependency measures', 'Predicts relationship difficulties'],
		    },
		    identityBlurring: {
		      items: ['IB001', 'IB002', 'IB003', 'IB004', 'IB005', 'IB006', 'IB007', 'IB008', 'IB009', 'IB010', 'IB011', 'IB012'],
		      reliabilityAlpha: 0.91,
		      validityEvidence: ['Correlates with identity development measures', 'Predicts autonomy difficulties'],
		    },
		    separationAnxiety: {
		      items: ['SA001', 'SA002', 'SA003', 'SA004', 'SA005', 'SA006', 'SA007', 'SA008', 'SA009', 'SA010', 'SA011', 'SA012'],
		      reliabilityAlpha: 0.93,
		      validityEvidence: ['Correlates with attachment anxiety', 'Predicts transition difficulties'],
		    },
		    boundaryDiffusion: {
		      items: ['BD001', 'BD002', 'BD003', 'BD004', 'BD005', 'BD006', 'BD007', 'BD008', 'BD009', 'BD010'],
		      reliabilityAlpha: 0.87,
		      validityEvidence: ['Correlates with boundary measures', 'Predicts relationship problems'],
		    },
		    individualIdentity: {
		      items: ['II001', 'II002', 'II003', 'II004', 'II005', 'II006', 'II007', 'II008', 'II009', 'II010', 'II011', 'II012', 'II013', 'II014', 'II015'],
		      reliabilityAlpha: 0.92,
		      validityEvidence: ['Correlates with identity achievement', 'Predicts positive outcomes'],
		    },
		    personalBoundaries: {
		      items: ['PB001', 'PB002', 'PB003', 'PB004', 'PB005', 'PB006', 'PB007', 'PB008', 'PB009', 'PB010', 'PB011', 'PB012'],
		      reliabilityAlpha: 0.90,
		      validityEvidence: ['Correlates with assertiveness', 'Predicts relationship quality'],
		    },
		    independentDecisionMaking: {
		      items: ['IDM001', 'IDM002', 'IDM003', 'IDM004', 'IDM005', 'IDM006', 'IDM007', 'IDM008', 'IDM009', 'IDM010', 'IDM011', 'IDM012'],
		      reliabilityAlpha: 0.88,
		      validityEvidence: ['Correlates with autonomy measures', 'Predicts life satisfaction'],
		    },
		    selfAdvocacy: {
		      items: ['SAV001', 'SAV002', 'SAV003', 'SAV004', 'SAV005', 'SAV006', 'SAV007', 'SAV008', 'SAV009', 'SAV010'],
		      reliabilityAlpha: 0.86,
		      validityEvidence: ['Correlates with assertiveness', 'Predicts career success'],
		    },
		    adaptabilityToChange: {
		      items: ['AC001', 'AC002', 'AC003', 'AC004', 'AC005', 'AC006', 'AC007', 'AC008', 'AC009', 'AC010'],
		      reliabilityAlpha: 0.85,
		      validityEvidence: ['Correlates with resilience', 'Predicts adjustment outcomes'],
		    },
		    conflictResolution: {
		      items: ['CR001', 'CR002', 'CR003', 'CR004', 'CR005', 'CR006', 'CR007', 'CR008', 'CR009', 'CR010'],
		      reliabilityAlpha: 0.89,
		      validityEvidence: ['Correlates with relationship satisfaction', 'Predicts conflict outcomes'],
		    },
		    emotionalRegulation: {
		      items: ['ER001', 'ER002', 'ER003', 'ER004', 'ER005', 'ER006', 'ER007', 'ER008', 'ER009', 'ER010', 'ER011', 'ER012'],
		      reliabilityAlpha: 0.91,
		      validityEvidence: ['Correlates with mental health', 'Predicts coping effectiveness'],
		    },
		    socialSupport: {
		      items: ['SS001', 'SS002', 'SS003', 'SS004', 'SS005', 'SS006', 'SS007', 'SS008'],
		      reliabilityAlpha: 0.84,
		      validityEvidence: ['Correlates with social network quality', 'Predicts well-being'],
		    },
		    changeAnxiety: {
		      items: ['CA001', 'CA002', 'CA003', 'CA004', 'CA005', 'CA006', 'CA007', 'CA008', 'CA009', 'CA010'],
		      reliabilityAlpha: 0.92,
		      validityEvidence: ['Correlates with anxiety measures', 'Predicts transition difficulties'],
		    },
		    attachmentInsecurity: {
		      items: ['AI001', 'AI002', 'AI003', 'AI004', 'AI005', 'AI006', 'AI007', 'AI008', 'AI009', 'AI010'],
		      reliabilityAlpha: 0.90,
		      validityEvidence: ['Correlates with attachment style', 'Predicts relationship problems'],
		    },
		    roleConfusion: {
		      items: ['RC001', 'RC002', 'RC003', 'RC004', 'RC005', 'RC006', 'RC007', 'RC008'],
		      reliabilityAlpha: 0.83,
		      validityEvidence: ['Correlates with identity confusion', 'Predicts role strain'],
		    },
		    futureOrientation: {
		      items: ['FO001', 'FO002', 'FO003', 'FO004', 'FO005', 'FO006', 'FO007', 'FO008'],
		      reliabilityAlpha: 0.87,
		      validityEvidence: ['Correlates with goal-setting', 'Predicts achievement outcomes'],
		    },
		
		    // Big Five personality traits
		    openness: {
		      items: ['O001', 'O002', 'O003', 'O004', 'O005', 'O006', 'O007', 'O008', 'O009', 'O010'],
		      reliabilityAlpha: 0.82,
		      validityEvidence: ['Established Big Five measure', 'Cross-cultural validity'],
		    },
		    conscientiousness: {
		      items: ['C001', 'C002', 'C003', 'C004', 'C005', 'C006', 'C007', 'C008', 'C009', 'C010'],
		      reliabilityAlpha: 0.85,
		      validityEvidence: ['Established Big Five measure', 'Predicts academic/career success'],
		    },
		    extraversion: {
		      items: ['E001', 'E002', 'E003', 'E004', 'E005', 'E006', 'E007', 'E008', 'E009', 'E010'],
		      reliabilityAlpha: 0.88,
		      validityEvidence: ['Established Big Five measure', 'Predicts social behavior'],
		    },
		    agreeableness: {
		      items: ['A001', 'A002', 'A003', 'A004', 'A005', 'A006', 'A007', 'A008', 'A009', 'A010'],
		      reliabilityAlpha: 0.81,
		      validityEvidence: ['Established Big Five measure', 'Predicts prosocial behavior'],
		    },
		    neuroticism: {
		      items: ['N001', 'N002', 'N003', 'N004', 'N005', 'N006', 'N007', 'N008', 'N009', 'N010'],
		      reliabilityAlpha: 0.89,
		      validityEvidence: ['Established Big Five measure', 'Predicts mental health outcomes'],
		    },
		  },
		};
		
		/**
		 * Get items for a specific scale/subscale
		 */
		export const getScaleItems = (scaleName: keyof (TwinSubscales & BigFiveTraits)): AssessmentItem[] => {
		  const itemIds = TWINSHIP_ITEM_BANK.scales[scaleName]?.items || [];
		  return TWINSHIP_ITEM_BANK.items.filter(item => itemIds.includes(item.id));
		};
		
		/**
		 * Get all items in randomized order for assessment administration
		 */
		export const getRandomizedAssessmentItems = (seed?: number): AssessmentItem[] => {
		  const items = [...TWINSHIP_ITEM_BANK.items];
		  
		  // Simple seeded shuffle for reproducible randomization
		  if (seed !== undefined) {
		    let randomState = seed;
		    for (let i = items.length - 1; i > 0; i--) {
		      randomState = (randomState * 9301 + 49297) % 233280;
		      const j = Math.floor((randomState / 233280) * (i + 1));
		      [items[i], items[j]] = [items[j], items[i]];
		    }
		  } else {
		    // Standard shuffle
		    for (let i = items.length - 1; i > 0; i--) {
		      const j = Math.floor(Math.random() * (i + 1));
		      [items[i], items[j]] = [items[j], items[i]];
		    }
		  }
		  
		  return items;
		};
		
		/**
		 * Validate item bank integrity
		 */
		export const validateItemBank = (): {
		  isValid: boolean;
		  errors: string[];
		  warnings: string[];
		  summary: {
		    totalItems: number;
		    scalesCovered: number;
		    averageItemsPerScale: number;
		  };
		} => {
		  const errors: string[] = [];
		  const warnings: string[] = [];
		  
		  // Check that all scale items exist in the item bank
		  Object.entries(TWINSHIP_ITEM_BANK.scales).forEach(([scaleName, scaleData]) => {
		    scaleData.items.forEach(itemId => {
		      const item = TWINSHIP_ITEM_BANK.items.find(i => i.id === itemId);
		      if (!item) {
		        errors.push(`Scale ${scaleName} references non-existent item ${itemId}`);
		      } else if (item.category !== scaleName) {
		        errors.push(`Item ${itemId} category mismatch: scale ${scaleName} vs item category ${item.category}`);
		      }
		    });
		  });
		  
		  // Check for orphaned items (items not referenced by any scale)
		  TWINSHIP_ITEM_BANK.items.forEach(item => {
		    const isReferenced = Object.values(TWINSHIP_ITEM_BANK.scales).some(scale =>
		      scale.items.includes(item.id)
		    );
		    if (!isReferenced) {
		      warnings.push(`Item ${item.id} is not referenced by any scale`);
		    }
		  });
		  
		  // Check scale reliability
		  Object.entries(TWINSHIP_ITEM_BANK.scales).forEach(([scaleName, scaleData]) => {
		    if (scaleData.reliabilityAlpha && scaleData.reliabilityAlpha < 0.7) {
		      warnings.push(`Scale ${scaleName} has low reliability (α = ${scaleData.reliabilityAlpha})`);
		    }
		  });
		  
		  const totalItems = TWINSHIP_ITEM_BANK.items.length;
		  const scalesCovered = Object.keys(TWINSHIP_ITEM_BANK.scales).length;
		  const averageItemsPerScale = totalItems / scalesCovered;
		  
		  return {
		    isValid: errors.length === 0,
		    errors,
		    warnings,
		    summary: {
		      totalItems,
		      scalesCovered,
		      averageItemsPerScale: Math.round(averageItemsPerScale * 100) / 100,
		    },
		  };
		};]]></file>
	<file path='utils/assessmentScoring.ts'><![CDATA[
		import { 
		  AssessmentItem, 
		  AssessmentResponse, 
		  AssessmentCategory,
		  SubscaleScore,
		  CompositeScore,
		  CompositeIndex,
		  ScoreInterpretation,
		  AssessmentResults,
		  LikertScale
		} from '../types/assessment';
		import assessmentItemBank from '../data/assessmentItemBank.json';
		
		/**
		 * Transform a Likert scale response (1-7) to 0-100 scale
		 */
		export const transformLikertTo100Scale = (value: LikertScale): number => {
		  // Convert 1-7 to 0-100 scale
		  // 1 -> 0, 2 -> 16.67, 3 -> 33.33, 4 -> 50, 5 -> 66.67, 6 -> 83.33, 7 -> 100
		  return ((value - 1) / 6) * 100;
		};
		
		/**
		 * Apply reverse scoring using 8-response formula
		 */
		export const reverseScoreItem = (value: LikertScale): LikertScale => {
		  return (8 - value) as LikertScale;
		};
		
		/**
		 * Calculate subscale score for a specific category
		 */
		export const calculateSubscaleScore = (
		  responses: AssessmentResponse[],
		  category: AssessmentCategory
		): SubscaleScore => {
		  // Get all items for this category
		  const categoryItems = Object.values(assessmentItemBank.categories)
		    .find(cat => cat.items.some(item => item.category === category))
		    ?.items.filter(item => item.category === category) || [];
		
		  // Get responses for this category
		  const categoryResponses = responses.filter(response =>
		    categoryItems.some(item => item.id === response.itemId)
		  );
		
		  if (categoryResponses.length === 0) {
		    return {
		      category,
		      rawScore: 0,
		      scaledScore: 0,
		      interpretation: 'No responses available'
		    };
		  }
		
		  // Calculate raw score with reverse scoring
		  let totalScore = 0;
		  let validResponses = 0;
		
		  categoryResponses.forEach(response => {
		    const item = categoryItems.find(i => i.id === response.itemId);
		    if (item) {
		      let value = response.value;
		      if (item.reverseScored) {
		        value = reverseScoreItem(value);
		      }
		      totalScore += transformLikertTo100Scale(value);
		      validResponses++;
		    }
		  });
		
		  const scaledScore = validResponses > 0 ? totalScore / validResponses : 0;
		  
		  return {
		    category,
		    rawScore: totalScore,
		    scaledScore,
		    percentile: calculatePercentile(scaledScore, category),
		    interpretation: interpretScoreLevel(scaledScore, category)
		  };
		};
		
		/**
		 * Calculate composite index scores
		 */
		export const calculateCompositeIndex = (
		  responses: AssessmentResponse[],
		  index: CompositeIndex
		): CompositeScore => {
		  // Get all items that contribute to this index
		  const relevantItems: AssessmentItem[] = [];
		  const components: Set<AssessmentCategory> = new Set();
		
		  Object.values(assessmentItemBank.categories).forEach(category => {
		    category.items.forEach(item => {
		      if (item.compositeIndices?.includes(index)) {
		        relevantItems.push(item);
		        components.add(item.category);
		      }
		    });
		  });
		
		  // Calculate weighted average
		  let totalScore = 0;
		  let totalWeight = 0;
		
		  relevantItems.forEach(item => {
		    const response = responses.find(r => r.itemId === item.id);
		    if (response) {
		      let value = response.value;
		      if (item.reverseScored) {
		        value = reverseScoreItem(value);
		      }
		      const weight = item.weight || 1;
		      totalScore += transformLikertTo100Scale(value) * weight;
		      totalWeight += weight;
		    }
		  });
		
		  const finalScore = totalWeight > 0 ? totalScore / totalWeight : 0;
		
		  return {
		    index,
		    value: finalScore,
		    interpretation: interpretCompositeIndex(index, finalScore),
		    components: Array.from(components)
		  };
		};
		
		/**
		 * Calculate percentile based on normative data (placeholder for now)
		 */
		const calculatePercentile = (score: number, category: AssessmentCategory): number => {
		  // This would use actual norming data in production
		  // For now, using a simple approximation
		  if (score <= 20) return 10;
		  if (score <= 35) return 25;
		  if (score <= 50) return 50;
		  if (score <= 65) return 75;
		  if (score <= 80) return 90;
		  return 95;
		};
		
		/**
		 * Interpret score level for a category
		 */
		export const interpretScoreLevel = (score: number, category: AssessmentCategory): string => {
		  const interpretations: Record<string, ScoreInterpretation[]> = {
		    identity_fusion: [
		      { range: [0, 20], level: 'very_low', description: 'Strong individual identity', implications: 'Healthy differentiation from twin' },
		      { range: [21, 40], level: 'low', description: 'Good balance of connection and individuality', implications: 'Optimal twin relationship' },
		      { range: [41, 60], level: 'moderate', description: 'Moderate identity fusion', implications: 'Some areas for individuation work' },
		      { range: [61, 80], level: 'high', description: 'High identity fusion', implications: 'Risk of codependency' },
		      { range: [81, 100], level: 'very_high', description: 'Extreme identity fusion', implications: 'Urgent need for differentiation work' }
		    ],
		    autonomy: [
		      { range: [0, 20], level: 'very_low', description: 'Very low autonomy', implications: 'Highly dependent on twin' },
		      { range: [21, 40], level: 'low', description: 'Limited autonomy', implications: 'Needs independence building' },
		      { range: [41, 60], level: 'moderate', description: 'Moderate autonomy', implications: 'Balanced independence' },
		      { range: [61, 80], level: 'high', description: 'Strong autonomy', implications: 'Healthy independence' },
		      { range: [81, 100], level: 'very_high', description: 'Very high autonomy', implications: 'Strong individual identity' }
		    ],
		    codependency: [
		      { range: [0, 20], level: 'very_low', description: 'Minimal codependency', implications: 'Healthy boundaries' },
		      { range: [21, 40], level: 'low', description: 'Low codependency', implications: 'Good emotional independence' },
		      { range: [41, 60], level: 'moderate', description: 'Moderate codependency', implications: 'Some enmeshment patterns' },
		      { range: [61, 80], level: 'high', description: 'High codependency', implications: 'Significant enmeshment' },
		      { range: [81, 100], level: 'very_high', description: 'Severe codependency', implications: 'Urgent intervention needed' }
		    ]
		  };
		
		  const categoryInterpretations = interpretations[category] || interpretations.identity_fusion;
		  const interpretation = categoryInterpretations.find(i => score >= i.range[0] && score <= i.range[1]);
		  
		  return interpretation?.description || 'Score out of range';
		};
		
		/**
		 * Interpret composite index scores
		 */
		const interpretCompositeIndex = (index: CompositeIndex, score: number): string => {
		  const interpretations: Record<CompositeIndex, string[]> = {
		    CI: [ // Codependency Index
		      'Minimal codependency - Healthy boundaries',
		      'Low codependency - Good independence',
		      'Moderate codependency - Some work needed',
		      'High codependency - Significant challenges',
		      'Severe codependency - Professional help recommended'
		    ],
		    ARI: [ // Autonomy & Resilience Index
		      'Very low resilience - High vulnerability',
		      'Low resilience - Needs strengthening',
		      'Moderate resilience - Average coping',
		      'High resilience - Strong coping skills',
		      'Very high resilience - Excellent adaptation'
		    ],
		    TRS: [ // Transition Risk Score
		      'Very low risk - Stable relationship',
		      'Low risk - Minor vulnerabilities',
		      'Moderate risk - Some instability',
		      'High risk - Significant challenges ahead',
		      'Very high risk - Crisis likely'
		    ]
		  };
		
		  const levels = interpretations[index];
		  const levelIndex = Math.min(Math.floor(score / 20), 4);
		  return levels[levelIndex];
		};
		
		/**
		 * Generate complete assessment report
		 */
		export const generateAssessmentReport = (
		  responses: AssessmentResponse[],
		  sessionId: string,
		  userId: string,
		  twinId?: string
		): AssessmentResults => {
		  // Calculate all subscale scores
		  const categories: AssessmentCategory[] = [
		    'identity_fusion', 'autonomy', 'boundaries', 'communication',
		    'codependency', 'differentiation', 'attachment', 'conflict_resolution',
		    'partner_inclusion', 'power_dynamics', 'openness', 'conscientiousness',
		    'extraversion', 'agreeableness', 'neuroticism'
		  ];
		
		  const subscaleScores = categories.map(category => 
		    calculateSubscaleScore(responses, category)
		  );
		
		  // Calculate composite indices
		  const compositeScores: CompositeScore[] = [
		    calculateCompositeIndex(responses, 'CI'),
		    calculateCompositeIndex(responses, 'ARI'),
		    calculateCompositeIndex(responses, 'TRS')
		  ];
		
		  // Generate overall profile
		  const overallProfile = generateOverallProfile(subscaleScores, compositeScores);
		
		  // Generate recommendations
		  const recommendations = generateRecommendations(subscaleScores, compositeScores);
		
		  return {
		    sessionId,
		    userId,
		    twinId,
		    completionDate: new Date().toISOString(),
		    subscaleScores,
		    compositeScores,
		    overallProfile,
		    recommendations
		  };
		};
		
		/**
		 * Generate overall profile description
		 */
		const generateOverallProfile = (
		  subscaleScores: SubscaleScore[],
		  compositeScores: CompositeScore[]
		): string => {
		  const ci = compositeScores.find(s => s.index === 'CI')?.value || 0;
		  const ari = compositeScores.find(s => s.index === 'ARI')?.value || 0;
		  const trs = compositeScores.find(s => s.index === 'TRS')?.value || 0;
		
		  let profile = '';
		
		  if (ci > 60 && ari < 40) {
		    profile = 'Highly Enmeshed Twin: Your relationship shows significant codependency with limited individual resilience. Focus on building independence while maintaining connection.';
		  } else if (ci < 40 && ari > 60) {
		    profile = 'Balanced Independent Twin: You maintain healthy boundaries with strong individual identity. Your twin relationship enhances rather than defines you.';
		  } else if (trs > 60) {
		    profile = 'Transition-Vulnerable Twin: Your relationship may struggle with life changes. Work on flexibility and adaptation strategies.';
		  } else if (ci > 40 && ci < 60 && ari > 40 && ari < 60) {
		    profile = 'Moderately Connected Twin: You show a balance of connection and independence with room for growth in both areas.';
		  } else {
		    profile = 'Complex Twin Dynamic: Your profile shows unique patterns that would benefit from personalized exploration and support.';
		  }
		
		  return profile;
		};
		
		/**
		 * Generate personalized recommendations
		 */
		const generateRecommendations = (
		  subscaleScores: SubscaleScore[],
		  compositeScores: CompositeScore[]
		): any[] => {
		  const recommendations = [];
		  
		  // Check for high codependency
		  const ci = compositeScores.find(s => s.index === 'CI')?.value || 0;
		  if (ci > 60) {
		    recommendations.push({
		      id: 'REC001',
		      title: 'Build Individual Identity',
		      description: 'Your codependency score suggests you would benefit from activities that strengthen your individual identity.',
		      category: 'codependency',
		      priority: 'high',
		      microExperiment: {
		        id: 'ME001',
		        title: 'Solo Activity Week',
		        duration: '7 days',
		        instructions: [
		          'Choose one activity to do alone each day',
		          'Don\'t discuss the activity with your twin beforehand',
		          'Journal about how it feels to do things independently',
		          'Share your experience with your twin at week\'s end'
		        ],
		        expectedOutcome: 'Increased comfort with independence',
		        trackingMetrics: ['anxiety_level', 'enjoyment', 'twin_reactions']
		      }
		    });
		  }
		
		  // Check for low resilience
		  const ari = compositeScores.find(s => s.index === 'ARI')?.value || 0;
		  if (ari < 40) {
		    recommendations.push({
		      id: 'REC002',
		      title: 'Strengthen Emotional Resilience',
		      description: 'Building resilience will help you maintain stability during life transitions.',
		      category: 'autonomy',
		      priority: 'high',
		      microExperiment: {
		        id: 'ME002',
		        title: 'Boundary Setting Practice',
		        duration: '5 days',
		        instructions: [
		          'Identify one small boundary you want to set',
		          'Communicate it clearly to your twin',
		          'Maintain the boundary consistently',
		          'Notice and manage any guilt that arises'
		        ],
		        expectedOutcome: 'Improved boundary setting skills',
		        trackingMetrics: ['boundary_maintained', 'guilt_level', 'twin_respect']
		      }
		    });
		  }
		
		  // Check for high transition risk
		  const trs = compositeScores.find(s => s.index === 'TRS')?.value || 0;
		  if (trs > 60) {
		    recommendations.push({
		      id: 'REC003',
		      title: 'Prepare for Life Transitions',
		      description: 'Your scores indicate vulnerability to relationship stress during major life changes.',
		      category: 'conflict_resolution',
		      priority: 'medium',
		      microExperiment: {
		        id: 'ME003',
		        title: 'Change Adaptation Exercise',
		        duration: '3 days',
		        instructions: [
		          'Discuss a hypothetical future change with your twin',
		          'Identify potential challenges together',
		          'Create a support plan for handling the change',
		          'Practice using "I" statements about needs and fears'
		        ],
		        expectedOutcome: 'Better preparation for transitions',
		        trackingMetrics: ['communication_quality', 'anxiety_reduction', 'plan_clarity']
		      }
		    });
		  }
		
		  return recommendations;
		};
		
		/**
		 * Handle missing data in responses
		 */
		export const handleMissingData = (
		  responses: AssessmentResponse[],
		  totalItems: number
		): { isValid: boolean; completionRate: number; message: string } => {
		  const completionRate = (responses.length / totalItems) * 100;
		  
		  if (completionRate < 70) {
		    return {
		      isValid: false,
		      completionRate,
		      message: 'Assessment requires at least 70% completion for valid results'
		    };
		  }
		
		  return {
		    isValid: true,
		    completionRate,
		    message: completionRate < 90 
		      ? 'Results calculated with partial responses' 
		      : 'Assessment complete'
		  };
		};
		
		/**
		 * Calculate percentile rank for a score within a distribution
		 */
		export const calculatePercentileRank = (score: number, allScores: number[]): number => {
		  if (allScores.length === 0) return 50; // Default to median if no comparison data
		  if (allScores.length === 1) return 50; // Single score defaults to median
		  
		  const belowOrEqualCount = allScores.filter(s => s <= score).length;
		  
		  // Standard percentile calculation: (rank / total) * 100
		  const percentile = (belowOrEqualCount / allScores.length) * 100;
		  
		  return Math.round(percentile * 100) / 100; // Round to 2 decimal places
		};]]></file>
	<file path='utils/astrologyService.ts'><![CDATA[
		/**
		 * Astrology Birth Chart Service
		 * Generates personalized birth charts and twin synastry analysis
		 */
		
		export interface BirthData {
		  dateOfBirth: Date;
		  timeOfBirth?: string; // "HH:MM" format
		  placeOfBirth?: string;
		  name: string;
		}
		
		export interface ZodiacSign {
		  name: string;
		  symbol: string;
		  element: 'Fire' | 'Earth' | 'Air' | 'Water';
		  modality: 'Cardinal' | 'Fixed' | 'Mutable';
		  rulingPlanet: string;
		  dates: string;
		  traits: string[];
		  compatibility: string[];
		}
		
		export interface PlanetPosition {
		  planet: string;
		  sign: string;
		  house?: number;
		  degree: number;
		  retrograde: boolean;
		}
		
		export interface BirthChart {
		  id: string;
		  userId: string;
		  generatedAt: string;
		  
		  // Core placements
		  sunSign: ZodiacSign;
		  moonSign: ZodiacSign;
		  risingSign: ZodiacSign;
		  
		  // Planet positions
		  planets: PlanetPosition[];
		  
		  // Elements and modalities
		  elementDistribution: Record<string, number>;
		  modalityDistribution: Record<string, number>;
		  dominantElement: string;
		  dominantModality: string;
		  
		  // Houses
		  houses: Array<{
		    number: number;
		    sign: string;
		    planets: string[];
		    meaning: string;
		  }>;
		  
		  // Aspects
		  aspects: Array<{
		    planet1: string;
		    planet2: string;
		    aspect: 'Conjunction' | 'Opposition' | 'Trine' | 'Square' | 'Sextile';
		    orb: number;
		    interpretation: string;
		  }>;
		  
		  // Personal insights
		  personalityInsights: string[];
		  strengthAreas: string[];
		  challengeAreas: string[];
		  lifeThemes: string[];
		}
		
		export interface TwinSynastry {
		  pairId: string;
		  twin1Chart: string; // chart ID
		  twin2Chart: string; // chart ID
		  generatedAt: string;
		  
		  // Compatibility scores
		  overallCompatibility: number; // 0-100
		  emotionalHarmony: number; // Moon aspects
		  communicationFlow: number; // Mercury aspects
		  romanticConnection: number; // Venus aspects
		  energyAlignment: number; // Mars aspects
		  
		  // Element compatibility
		  elementHarmony: {
		    fire: number;
		    earth: number;
		    air: number;
		    water: number;
		  };
		  
		  // Significant aspects between twins
		  majorAspects: Array<{
		    twin1Planet: string;
		    twin2Planet: string;
		    aspect: string;
		    strength: 'Powerful' | 'Moderate' | 'Weak';
		    interpretation: string;
		  }>;
		  
		  // Twin flame indicators
		  twinFlameMarkers: Array<{
		    indicator: string;
		    present: boolean;
		    description: string;
		  }>;
		  
		  // Relationship insights
		  strengths: string[];
		  challenges: string[];
		  growthOpportunities: string[];
		  soulLessons: string[];
		}
		
		// Zodiac sign definitions
		export const ZODIAC_SIGNS: Record<string, ZodiacSign> = {
		  aries: {
		    name: 'Aries',
		    symbol: '♈',
		    element: 'Fire',
		    modality: 'Cardinal',
		    rulingPlanet: 'Mars',
		    dates: 'March 21 - April 19',
		    traits: ['Independent', 'Energetic', 'Impulsive', 'Leader', 'Adventurous'],
		    compatibility: ['Leo', 'Sagittarius', 'Gemini', 'Aquarius']
		  },
		  taurus: {
		    name: 'Taurus',
		    symbol: '♉',
		    element: 'Earth',
		    modality: 'Fixed',
		    rulingPlanet: 'Venus',
		    dates: 'April 20 - May 20',
		    traits: ['Reliable', 'Practical', 'Stubborn', 'Sensual', 'Loyal'],
		    compatibility: ['Virgo', 'Capricorn', 'Cancer', 'Pisces']
		  },
		  gemini: {
		    name: 'Gemini',
		    symbol: '♊',
		    element: 'Air',
		    modality: 'Mutable',
		    rulingPlanet: 'Mercury',
		    dates: 'May 21 - June 20',
		    traits: ['Curious', 'Adaptable', 'Communicative', 'Restless', 'Witty'],
		    compatibility: ['Libra', 'Aquarius', 'Aries', 'Leo']
		  },
		  cancer: {
		    name: 'Cancer',
		    symbol: '♋',
		    element: 'Water',
		    modality: 'Cardinal',
		    rulingPlanet: 'Moon',
		    dates: 'June 21 - July 22',
		    traits: ['Nurturing', 'Intuitive', 'Emotional', 'Protective', 'Home-loving'],
		    compatibility: ['Scorpio', 'Pisces', 'Taurus', 'Virgo']
		  },
		  leo: {
		    name: 'Leo',
		    symbol: '♌',
		    element: 'Fire',
		    modality: 'Fixed',
		    rulingPlanet: 'Sun',
		    dates: 'July 23 - August 22',
		    traits: ['Confident', 'Creative', 'Generous', 'Dramatic', 'Proud'],
		    compatibility: ['Aries', 'Sagittarius', 'Gemini', 'Libra']
		  },
		  virgo: {
		    name: 'Virgo',
		    symbol: '♍',
		    element: 'Earth',
		    modality: 'Mutable',
		    rulingPlanet: 'Mercury',
		    dates: 'August 23 - September 22',
		    traits: ['Analytical', 'Perfectionist', 'Helpful', 'Practical', 'Health-conscious'],
		    compatibility: ['Taurus', 'Capricorn', 'Cancer', 'Scorpio']
		  },
		  libra: {
		    name: 'Libra',
		    symbol: '♎',
		    element: 'Air',
		    modality: 'Cardinal',
		    rulingPlanet: 'Venus',
		    dates: 'September 23 - October 22',
		    traits: ['Balanced', 'Diplomatic', 'Social', 'Indecisive', 'Harmony-seeking'],
		    compatibility: ['Gemini', 'Aquarius', 'Leo', 'Sagittarius']
		  },
		  scorpio: {
		    name: 'Scorpio',
		    symbol: '♏',
		    element: 'Water',
		    modality: 'Fixed',
		    rulingPlanet: 'Pluto',
		    dates: 'October 23 - November 21',
		    traits: ['Intense', 'Mysterious', 'Passionate', 'Transformative', 'Intuitive'],
		    compatibility: ['Cancer', 'Pisces', 'Virgo', 'Capricorn']
		  },
		  sagittarius: {
		    name: 'Sagittarius',
		    symbol: '♐',
		    element: 'Fire',
		    modality: 'Mutable',
		    rulingPlanet: 'Jupiter',
		    dates: 'November 22 - December 21',
		    traits: ['Adventurous', 'Philosophical', 'Optimistic', 'Freedom-loving', 'Honest'],
		    compatibility: ['Aries', 'Leo', 'Libra', 'Aquarius']
		  },
		  capricorn: {
		    name: 'Capricorn',
		    symbol: '♑',
		    element: 'Earth',
		    modality: 'Cardinal',
		    rulingPlanet: 'Saturn',
		    dates: 'December 22 - January 19',
		    traits: ['Ambitious', 'Disciplined', 'Responsible', 'Traditional', 'Patient'],
		    compatibility: ['Taurus', 'Virgo', 'Scorpio', 'Pisces']
		  },
		  aquarius: {
		    name: 'Aquarius',
		    symbol: '♒',
		    element: 'Air',
		    modality: 'Fixed',
		    rulingPlanet: 'Uranus',
		    dates: 'January 20 - February 18',
		    traits: ['Independent', 'Innovative', 'Humanitarian', 'Eccentric', 'Detached'],
		    compatibility: ['Gemini', 'Libra', 'Aries', 'Sagittarius']
		  },
		  pisces: {
		    name: 'Pisces',
		    symbol: '♓',
		    element: 'Water',
		    modality: 'Mutable',
		    rulingPlanet: 'Neptune',
		    dates: 'February 19 - March 20',
		    traits: ['Intuitive', 'Compassionate', 'Dreamy', 'Sensitive', 'Artistic'],
		    compatibility: ['Cancer', 'Scorpio', 'Taurus', 'Capricorn']
		  }
		};
		
		/**
		 * Calculate sun sign from birth date
		 */
		export const calculateSunSign = (birthDate: Date): ZodiacSign => {
		  const month = birthDate.getMonth() + 1;
		  const day = birthDate.getDate();
		  
		  if ((month === 3 && day >= 21) || (month === 4 && day <= 19)) return ZODIAC_SIGNS.aries;
		  if ((month === 4 && day >= 20) || (month === 5 && day <= 20)) return ZODIAC_SIGNS.taurus;
		  if ((month === 5 && day >= 21) || (month === 6 && day <= 20)) return ZODIAC_SIGNS.gemini;
		  if ((month === 6 && day >= 21) || (month === 7 && day <= 22)) return ZODIAC_SIGNS.cancer;
		  if ((month === 7 && day >= 23) || (month === 8 && day <= 22)) return ZODIAC_SIGNS.leo;
		  if ((month === 8 && day >= 23) || (month === 9 && day <= 22)) return ZODIAC_SIGNS.virgo;
		  if ((month === 9 && day >= 23) || (month === 10 && day <= 22)) return ZODIAC_SIGNS.libra;
		  if ((month === 10 && day >= 23) || (month === 11 && day <= 21)) return ZODIAC_SIGNS.scorpio;
		  if ((month === 11 && day >= 22) || (month === 12 && day <= 21)) return ZODIAC_SIGNS.sagittarius;
		  if ((month === 12 && day >= 22) || (month === 1 && day <= 19)) return ZODIAC_SIGNS.capricorn;
		  if ((month === 1 && day >= 20) || (month === 2 && day <= 18)) return ZODIAC_SIGNS.aquarius;
		  return ZODIAC_SIGNS.pisces;
		};
		
		/**
		 * Generate a simplified birth chart
		 * Note: This is a basic implementation. Full accuracy requires astronomical calculations
		 */
		export const generateBirthChart = async (birthData: BirthData): Promise<BirthChart> => {
		  const sunSign = calculateSunSign(birthData.dateOfBirth);
		  
		  // Simplified moon and rising calculation (would need proper astronomical data)
		  const moonSignNames = Object.keys(ZODIAC_SIGNS);
		  const moonIndex = (birthData.dateOfBirth.getDate() + birthData.name.length) % 12;
		  const moonSign = ZODIAC_SIGNS[moonSignNames[moonIndex]];
		  
		  const risingIndex = (birthData.dateOfBirth.getMonth() + birthData.name.charCodeAt(0)) % 12;
		  const risingSign = ZODIAC_SIGNS[moonSignNames[risingIndex]];
		  
		  // Create basic planet positions (simplified)
		  const planets: PlanetPosition[] = [
		    { planet: 'Sun', sign: sunSign.name, degree: birthData.dateOfBirth.getDate() * 3, retrograde: false },
		    { planet: 'Moon', sign: moonSign.name, degree: birthData.dateOfBirth.getMonth() * 25, retrograde: false },
		    { planet: 'Mercury', sign: sunSign.name, degree: birthData.dateOfBirth.getDate() * 2, retrograde: false },
		    { planet: 'Venus', sign: moonSign.name, degree: birthData.dateOfBirth.getDate() * 4, retrograde: false },
		    { planet: 'Mars', sign: risingSign.name, degree: birthData.dateOfBirth.getMonth() * 30, retrograde: false }
		  ];
		  
		  return {
		    id: `chart-${birthData.name}-${Date.now()}`,
		    userId: birthData.name,
		    generatedAt: new Date().toISOString(),
		    sunSign,
		    moonSign,
		    risingSign,
		    planets,
		    elementDistribution: {
		      Fire: [sunSign, moonSign, risingSign].filter(s => s.element === 'Fire').length,
		      Earth: [sunSign, moonSign, risingSign].filter(s => s.element === 'Earth').length,
		      Air: [sunSign, moonSign, risingSign].filter(s => s.element === 'Air').length,
		      Water: [sunSign, moonSign, risingSign].filter(s => s.element === 'Water').length
		    },
		    modalityDistribution: {
		      Cardinal: [sunSign, moonSign, risingSign].filter(s => s.modality === 'Cardinal').length,
		      Fixed: [sunSign, moonSign, risingSign].filter(s => s.modality === 'Fixed').length,
		      Mutable: [sunSign, moonSign, risingSign].filter(s => s.modality === 'Mutable').length
		    },
		    dominantElement: sunSign.element,
		    dominantModality: sunSign.modality,
		    houses: [], // Simplified - would need birth time and location
		    aspects: [], // Simplified - would need full calculations
		    personalityInsights: [
		      `Your ${sunSign.name} sun gives you ${sunSign.traits.slice(0, 2).join(' and ').toLowerCase()} qualities`,
		      `Your ${moonSign.name} moon makes you emotionally ${moonSign.traits[0].toLowerCase()}`,
		      `Your ${risingSign.name} rising presents you as ${risingSign.traits[0].toLowerCase()} to others`
		    ],
		    strengthAreas: [...sunSign.traits.slice(0, 2), ...moonSign.traits.slice(0, 1)],
		    challengeAreas: [sunSign.traits[2], moonSign.traits[2]].filter(Boolean),
		    lifeThemes: [`${sunSign.element} energy`, `${moonSign.element} emotions`, `${risingSign.element} presentation`]
		  };
		};
		
		/**
		 * Generate twin synastry analysis
		 */
		export const generateTwinSynastry = async (chart1: BirthChart, chart2: BirthChart): Promise<TwinSynastry> => {
		  // Calculate compatibility scores
		  const elementCompatibility = calculateElementCompatibility(chart1, chart2);
		  const sunSignCompatibility = chart1.sunSign.compatibility.includes(chart2.sunSign.name) ? 85 : 65;
		  const moonSignCompatibility = chart1.moonSign.compatibility.includes(chart2.moonSign.name) ? 90 : 70;
		  
		  const overallCompatibility = Math.round(
		    (elementCompatibility + sunSignCompatibility + moonSignCompatibility) / 3
		  );
		  
		  return {
		    pairId: `synastry-${chart1.userId}-${chart2.userId}`,
		    twin1Chart: chart1.id,
		    twin2Chart: chart2.id,
		    generatedAt: new Date().toISOString(),
		    overallCompatibility,
		    emotionalHarmony: moonSignCompatibility,
		    communicationFlow: 75,
		    romanticConnection: 80,
		    energyAlignment: sunSignCompatibility,
		    elementHarmony: {
		      fire: chart1.elementDistribution.Fire + chart2.elementDistribution.Fire,
		      earth: chart1.elementDistribution.Earth + chart2.elementDistribution.Earth,
		      air: chart1.elementDistribution.Air + chart2.elementDistribution.Air,
		      water: chart1.elementDistribution.Water + chart2.elementDistribution.Water
		    },
		    majorAspects: [
		      {
		        twin1Planet: 'Sun',
		        twin2Planet: 'Moon',
		        aspect: 'Trine',
		        strength: 'Powerful',
		        interpretation: 'Your core selves harmonize beautifully with each other\'s emotional nature'
		      }
		    ],
		    twinFlameMarkers: [
		      {
		        indicator: 'Complementary Elements',
		        present: chart1.dominantElement !== chart2.dominantElement,
		        description: 'Different dominant elements suggest complementary energies'
		      },
		      {
		        indicator: 'Synchronized Moon Signs',
		        present: chart1.moonSign.element === chart2.moonSign.element,
		        description: 'Similar lunar elements indicate emotional understanding'
		      }
		    ],
		    strengths: [
		      `Strong ${chart1.dominantElement}-${chart2.dominantElement} balance`,
		      'Intuitive emotional connection',
		      'Complementary personality traits'
		    ],
		    challenges: [
		      'Potential for mirroring each other\'s weaknesses',
		      'Need for individual identity development'
		    ],
		    growthOpportunities: [
		      'Learning from each other\'s elemental strengths',
		      'Developing independence while maintaining connection'
		    ],
		    soulLessons: [
		      'Balance between unity and individuality',
		      'Embracing both similarities and differences'
		    ]
		  };
		};
		
		const calculateElementCompatibility = (chart1: BirthChart, chart2: BirthChart): number => {
		  const elements1 = chart1.elementDistribution;
		  const elements2 = chart2.elementDistribution;
		  
		  // Compatible elements: Fire+Air, Earth+Water
		  let compatibility = 0;
		  
		  // Fire and Air compatibility
		  compatibility += Math.min(elements1.Fire, elements2.Air) * 20;
		  compatibility += Math.min(elements1.Air, elements2.Fire) * 20;
		  
		  // Earth and Water compatibility
		  compatibility += Math.min(elements1.Earth, elements2.Water) * 20;
		  compatibility += Math.min(elements1.Water, elements2.Earth) * 20;
		  
		  // Same element bonus
		  compatibility += Math.min(elements1.Fire, elements2.Fire) * 15;
		  compatibility += Math.min(elements1.Earth, elements2.Earth) * 15;
		  compatibility += Math.min(elements1.Air, elements2.Air) * 15;
		  compatibility += Math.min(elements1.Water, elements2.Water) * 15;
		  
		  return Math.min(100, compatibility);
		};]]></file>
	<file path='utils/behaviorAnalytics.ts'><![CDATA[
		import { BehaviorEvent, SyncEvent, SyncPattern, TwintuitionConfig, LocationSyncData, EmotionalSyncData, TemporalSyncData } from '../types/twintuition';
		
		/**
		 * Advanced AI-powered behavior analysis for detecting twin synchronicity
		 */
		
		// Distance calculation for location sync
		function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
		  const R = 6371e3; // Earth's radius in meters
		  const φ1 = lat1 * Math.PI / 180;
		  const φ2 = lat2 * Math.PI / 180;
		  const Δφ = (lat2 - lat1) * Math.PI / 180;
		  const Δλ = (lon2 - lon1) * Math.PI / 180;
		
		  const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
		            Math.cos(φ1) * Math.cos(φ2) *
		            Math.sin(Δλ/2) * Math.sin(Δλ/2);
		  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
		
		  return R * c; // Distance in meters
		}
		
		// Time difference calculation
		function getTimeDifferenceMinutes(time1: string, time2: string): number {
		  const date1 = new Date(time1);
		  const date2 = new Date(time2);
		  return Math.abs(date1.getTime() - date2.getTime()) / (1000 * 60);
		}
		
		// Text similarity using simple Jaccard index
		function calculateTextSimilarity(text1: string, text2: string): number {
		  const words1 = new Set(text1.toLowerCase().split(/\s+/));
		  const words2 = new Set(text2.toLowerCase().split(/\s+/));
		  
		  const intersection = new Set([...words1].filter(x => words2.has(x)));
		  const union = new Set([...words1, ...words2]);
		  
		  return intersection.size / union.size;
		}
		
		// Emotion similarity calculation
		function calculateEmotionSimilarity(emotion1: string, emotion2: string): number {
		  if (emotion1 === emotion2) return 1.0;
		  
		  const emotionGroups = {
		    positive: ['happy', 'excited', 'joyful', 'content', 'elated'],
		    negative: ['sad', 'angry', 'frustrated', 'disappointed', 'hurt'],
		    anxious: ['worried', 'nervous', 'stressed', 'anxious', 'overwhelmed'],
		    calm: ['peaceful', 'relaxed', 'serene', 'tranquil', 'centered']
		  };
		  
		  for (const group of Object.values(emotionGroups)) {
		    if (group.includes(emotion1) && group.includes(emotion2)) {
		      return 0.7; // Same emotional category
		    }
		  }
		  
		  return 0.0;
		}
		
		// Main pattern analysis function
		export async function analyzePatterns(
		  events: BehaviorEvent[],
		  config: TwintuitionConfig
		): Promise<SyncPattern[]> {
		  const patterns: SyncPattern[] = [];
		  
		  if (events.length < 2) return patterns;
		  
		  // Group events by twin pairs
		  const twinPairs = new Map<string, BehaviorEvent[]>();
		  
		  events.forEach(event => {
		    const key = [event.userId, event.twinId].filter(Boolean).sort().join('-');
		    if (!twinPairs.has(key)) {
		      twinPairs.set(key, []);
		    }
		    twinPairs.get(key)!.push(event);
		  });
		  
		  // Analyze each twin pair
		  for (const [pairKey, pairEvents] of twinPairs) {
		    // 1. Simultaneous Action Detection
		    const simultaneousPatterns = await detectSimultaneousActions(pairEvents, config);
		    patterns.push(...simultaneousPatterns);
		    
		    // 2. Mood Synchronization Detection
		    const moodPatterns = await detectMoodSynchronization(pairEvents, config);
		    patterns.push(...moodPatterns);
		    
		    // 3. App Usage Synchronization
		    const appPatterns = await detectAppSynchronization(pairEvents, config);
		    patterns.push(...appPatterns);
		    
		    // 4. Location Synchronization (if enabled)
		    if (config.enableLocationSync) {
		      const locationPatterns = await detectLocationSynchronization(pairEvents, config);
		      patterns.push(...locationPatterns);
		    }
		    
		    // 5. Temporal Patterns
		    const temporalPatterns = await detectTemporalPatterns(pairEvents, config);
		    patterns.push(...temporalPatterns);
		  }
		  
		  // Sort by confidence and return top patterns
		  return patterns
		    .filter(p => p.confidence >= config.minConfidenceThreshold)
		    .sort((a, b) => b.confidence - a.confidence)
		    .slice(0, 5); // Limit to top 5 patterns
		}
		
		// Real-time synchronicity detection
		export async function detectSynchronicity(
		  newEvent: BehaviorEvent,
		  recentEvents: BehaviorEvent[],
		  config: TwintuitionConfig
		): Promise<SyncEvent | null> {
		  const twinEvents = recentEvents.filter(e => 
		    e.twinId === newEvent.userId || e.userId === newEvent.twinId
		  );
		  
		  if (twinEvents.length === 0) return null;
		  
		  // Check for immediate synchronicity
		  const syncTimeWindow = config.timeWindowMinutes * 60 * 1000; // Convert to milliseconds
		  const newEventTime = new Date(newEvent.timestamp).getTime();
		  
		  const recentTwinEvents = twinEvents.filter(e => {
		    const eventTime = new Date(e.timestamp).getTime();
		    return (newEventTime - eventTime) <= syncTimeWindow;
		  });
		  
		  if (recentTwinEvents.length === 0) return null;
		  
		  // Find the most synchronous event
		  let bestMatch: { event: BehaviorEvent; confidence: number } | null = null;
		  
		  for (const twinEvent of recentTwinEvents) {
		    const timeDiff = getTimeDifferenceMinutes(newEvent.timestamp, twinEvent.timestamp);
		    const maxAllowedDiff = config.timeWindowMinutes;
		    
		    if (timeDiff <= maxAllowedDiff) {
		      let confidence = 1 - (timeDiff / maxAllowedDiff); // Time-based confidence
		      
		      // Boost confidence based on action similarity
		      if (newEvent.type === twinEvent.type && newEvent.action === twinEvent.action) {
		        confidence *= 1.5;
		      }
		      
		      // Boost for location similarity
		      if (newEvent.location && twinEvent.location) {
		        const distance = calculateDistance(
		          newEvent.location.latitude, newEvent.location.longitude,
		          twinEvent.location.latitude, twinEvent.location.longitude
		        );
		        if (distance < 1000) { // Within 1km
		          confidence *= 1.3;
		        }
		      }
		      
		      // Boost for emotional similarity
		      if (newEvent.context?.emotion && twinEvent.context?.emotion) {
		        const emotionSim = calculateEmotionSimilarity(newEvent.context.emotion, twinEvent.context.emotion);
		        confidence *= (1 + emotionSim * 0.5);
		      }
		      
		      confidence = Math.min(1.0, confidence); // Cap at 1.0
		      
		      if (!bestMatch || confidence > bestMatch.confidence) {
		        bestMatch = { event: twinEvent, confidence };
		      }
		    }
		  }
		  
		  if (bestMatch && bestMatch.confidence >= config.minConfidenceThreshold) {
		    return {
		      type: determineSyncType(newEvent, bestMatch.event),
		      confidence: bestMatch.confidence,
		      description: generateSyncDescription(newEvent, bestMatch.event, bestMatch.confidence),
		      involvedEvents: [newEvent, bestMatch.event],
		      detectedAt: new Date().toISOString(),
		    };
		  }
		  
		  return null;
		}
		
		// Helper function to determine sync type
		function determineSyncType(event1: BehaviorEvent, event2: BehaviorEvent): SyncEvent['type'] {
		  if (event1.type === 'app_interaction' && event2.type === 'app_interaction') {
		    return 'app_synchronization';
		  }
		  
		  if (event1.type === 'mood_update' && event2.type === 'mood_update') {
		    return 'mood_synchronization';
		  }
		  
		  if (event1.location && event2.location) {
		    return 'location_synchronization';
		  }
		  
		  if (event1.action === event2.action) {
		    return 'simultaneous_action';
		  }
		  
		  return 'temporal_pattern';
		}
		
		// Generate descriptive text for sync events
		function generateSyncDescription(event1: BehaviorEvent, event2: BehaviorEvent, confidence: number): string {
		  const confidencePercent = Math.round(confidence * 100);
		  const timeDiff = getTimeDifferenceMinutes(event1.timestamp, event2.timestamp);
		  
		  if (event1.type === 'app_interaction' && event2.type === 'app_interaction') {
		    return `Both twins ${event1.action.replace('_', ' ')} within ${Math.round(timeDiff)} minutes of each other`;
		  }
		  
		  if (event1.type === 'mood_update' && event2.type === 'mood_update') {
		    return `Twins experienced similar emotions (${event1.context?.emotion || 'unknown'}) at nearly the same time`;
		  }
		  
		  return `Twins performed synchronized actions with ${confidencePercent}% confidence`;
		}
		
		// Specific pattern detection functions
		async function detectSimultaneousActions(
		  events: BehaviorEvent[],
		  config: TwintuitionConfig
		): Promise<SyncPattern[]> {
		  const patterns: SyncPattern[] = [];
		  const actionGroups = new Map<string, BehaviorEvent[]>();
		  
		  // Group events by action type
		  events.forEach(event => {
		    const key = `${event.type}-${event.action}`;
		    if (!actionGroups.has(key)) {
		      actionGroups.set(key, []);
		    }
		    actionGroups.get(key)!.push(event);
		  });
		  
		  // Find simultaneous actions
		  for (const [actionKey, actionEvents] of actionGroups) {
		    if (actionEvents.length >= 2) {
		      // Check if events happened within time window
		      const sortedEvents = actionEvents.sort((a, b) => 
		        new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
		      );
		      
		      for (let i = 0; i < sortedEvents.length - 1; i++) {
		        const timeDiff = getTimeDifferenceMinutes(sortedEvents[i].timestamp, sortedEvents[i + 1].timestamp);
		        if (timeDiff <= config.timeWindowMinutes) {
		          const confidence = Math.max(0.5, 1 - (timeDiff / config.timeWindowMinutes));
		          
		          patterns.push({
		            type: 'simultaneous_action',
		            confidence,
		            description: `Both twins ${sortedEvents[i].action.replace('_', ' ')} within ${Math.round(timeDiff)} minutes`,
		            events: [sortedEvents[i], sortedEvents[i + 1]],
		            detectedFeatures: ['timing', 'action_type'],
		          });
		        }
		      }
		    }
		  }
		  
		  return patterns;
		}
		
		async function detectMoodSynchronization(
		  events: BehaviorEvent[],
		  config: TwintuitionConfig
		): Promise<SyncPattern[]> {
		  const patterns: SyncPattern[] = [];
		  const moodEvents = events.filter(e => e.type === 'mood_update');
		  
		  if (moodEvents.length < 2) return patterns;
		  
		  // Compare mood events across twins
		  for (let i = 0; i < moodEvents.length - 1; i++) {
		    for (let j = i + 1; j < moodEvents.length; j++) {
		      const event1 = moodEvents[i];
		      const event2 = moodEvents[j];
		      
		      // Skip if same user
		      if (event1.userId === event2.userId) continue;
		      
		      const timeDiff = getTimeDifferenceMinutes(event1.timestamp, event2.timestamp);
		      if (timeDiff <= config.timeWindowMinutes * 2) { // Longer window for moods
		        const emotion1 = event1.context?.mood || event1.context?.emotion || 'unknown';
		        const emotion2 = event2.context?.mood || event2.context?.emotion || 'unknown';
		        
		        const emotionSimilarity = calculateEmotionSimilarity(emotion1, emotion2);
		        if (emotionSimilarity > 0.5) {
		          const timeConfidence = Math.max(0.3, 1 - (timeDiff / (config.timeWindowMinutes * 2)));
		          const confidence = (emotionSimilarity + timeConfidence) / 2;
		          
		          patterns.push({
		            type: 'mood_synchronization',
		            confidence,
		            description: `Both twins experienced ${emotion1} emotions within ${Math.round(timeDiff)} minutes`,
		            events: [event1, event2],
		            detectedFeatures: ['emotion_similarity', 'timing'],
		          });
		        }
		      }
		    }
		  }
		  
		  return patterns;
		}
		
		async function detectAppSynchronization(
		  events: BehaviorEvent[],
		  config: TwintuitionConfig
		): Promise<SyncPattern[]> {
		  const patterns: SyncPattern[] = [];
		  const appEvents = events.filter(e => e.type === 'app_interaction');
		  
		  if (appEvents.length < 2) return patterns;
		  
		  // Look for app opens/actions at similar times
		  const openEvents = appEvents.filter(e => e.action === 'open_app');
		  
		  for (let i = 0; i < openEvents.length - 1; i++) {
		    for (let j = i + 1; j < openEvents.length; j++) {
		      const event1 = openEvents[i];
		      const event2 = openEvents[j];
		      
		      if (event1.userId === event2.userId) continue;
		      
		      const timeDiff = getTimeDifferenceMinutes(event1.timestamp, event2.timestamp);
		      if (timeDiff <= config.timeWindowMinutes) {
		        const confidence = Math.max(0.6, 1 - (timeDiff / config.timeWindowMinutes));
		        
		        patterns.push({
		          type: 'app_synchronization',
		          confidence,
		          description: `Both twins opened the app within ${Math.round(timeDiff)} minutes of each other`,
		          events: [event1, event2],
		          detectedFeatures: ['app_timing', 'simultaneous_usage'],
		        });
		      }
		    }
		  }
		  
		  return patterns;
		}
		
		async function detectLocationSynchronization(
		  events: BehaviorEvent[],
		  config: TwintuitionConfig
		): Promise<SyncPattern[]> {
		  const patterns: SyncPattern[] = [];
		  const locationEvents = events.filter(e => e.location);
		  
		  if (locationEvents.length < 2) return patterns;
		  
		  for (let i = 0; i < locationEvents.length - 1; i++) {
		    for (let j = i + 1; j < locationEvents.length; j++) {
		      const event1 = locationEvents[i];
		      const event2 = locationEvents[j];
		      
		      if (event1.userId === event2.userId || !event1.location || !event2.location) continue;
		      
		      const distance = calculateDistance(
		        event1.location.latitude, event1.location.longitude,
		        event2.location.latitude, event2.location.longitude
		      );
		      
		      const timeDiff = getTimeDifferenceMinutes(event1.timestamp, event2.timestamp);
		      
		      if (distance < 5000 && timeDiff <= config.timeWindowMinutes * 3) { // Within 5km and extended time
		        const locationConfidence = Math.max(0.3, 1 - (distance / 5000));
		        const timeConfidence = Math.max(0.3, 1 - (timeDiff / (config.timeWindowMinutes * 3)));
		        const confidence = (locationConfidence + timeConfidence) / 2;
		        
		        patterns.push({
		          type: 'location_synchronization',
		          confidence,
		          description: `Twins were ${Math.round(distance)}m apart within ${Math.round(timeDiff)} minutes`,
		          events: [event1, event2],
		          detectedFeatures: ['proximity', 'timing'],
		        });
		      }
		    }
		  }
		  
		  return patterns;
		}
		
		async function detectTemporalPatterns(
		  events: BehaviorEvent[],
		  config: TwintuitionConfig
		): Promise<SyncPattern[]> {
		  const patterns: SyncPattern[] = [];
		  
		  // Group events by hour of day
		  const hourlyActivity = new Map<number, BehaviorEvent[]>();
		  events.forEach(event => {
		    const hour = new Date(event.timestamp).getHours();
		    if (!hourlyActivity.has(hour)) {
		      hourlyActivity.set(hour, []);
		    }
		    hourlyActivity.get(hour)!.push(event);
		  });
		  
		  // Find hours with activity from both twins
		  for (const [hour, hourEvents] of hourlyActivity) {
		    const userIds = new Set(hourEvents.map(e => e.userId));
		    if (userIds.size >= 2) { // Both twins active in this hour
		      const confidence = Math.min(1.0, hourEvents.length * 0.2); // More events = higher confidence
		      
		      patterns.push({
		        type: 'temporal_pattern',
		        confidence,
		        description: `Both twins show synchronized activity patterns around ${hour}:00`,
		        events: hourEvents.slice(0, 5), // Limit events
		        detectedFeatures: ['daily_rhythm', 'activity_timing'],
		      });
		    }
		  }
		  
		  return patterns;
		}
		
		// Advanced analytics functions
		export function calculateSyncScore(events: BehaviorEvent[]): number {
		  if (events.length < 2) return 0;
		  
		  // Calculate various sync metrics
		  const timeSyncScore = calculateTimeSync(events);
		  const actionSyncScore = calculateActionSync(events);
		  const emotionSyncScore = calculateEmotionSync(events);
		  
		  // Weighted average
		  return Math.round((timeSyncScore * 0.4 + actionSyncScore * 0.4 + emotionSyncScore * 0.2) * 100);
		}
		
		function calculateTimeSync(events: BehaviorEvent[]): number {
		  const timestamps = events.map(e => new Date(e.timestamp).getTime());
		  timestamps.sort((a, b) => a - b);
		  
		  let syncScore = 0;
		  let comparisons = 0;
		  
		  for (let i = 0; i < timestamps.length - 1; i++) {
		    for (let j = i + 1; j < timestamps.length; j++) {
		      const timeDiff = Math.abs(timestamps[j] - timestamps[i]) / (1000 * 60); // minutes
		      if (timeDiff <= 60) { // Within 1 hour
		        syncScore += Math.max(0, 1 - (timeDiff / 60));
		        comparisons++;
		      }
		    }
		  }
		  
		  return comparisons > 0 ? syncScore / comparisons : 0;
		}
		
		function calculateActionSync(events: BehaviorEvent[]): number {
		  const actions = events.map(e => `${e.type}-${e.action}`);
		  const uniqueActions = new Set(actions);
		  const duplicateActions = actions.length - uniqueActions.size;
		  
		  return duplicateActions / Math.max(1, actions.length);
		}
		
		function calculateEmotionSync(events: BehaviorEvent[]): number {
		  const emotions = events
		    .map(e => e.context?.emotion || e.context?.mood)
		    .filter(Boolean);
		  
		  if (emotions.length < 2) return 0;
		  
		  let similaritySum = 0;
		  let comparisons = 0;
		  
		  for (let i = 0; i < emotions.length - 1; i++) {
		    for (let j = i + 1; j < emotions.length; j++) {
		      similaritySum += calculateEmotionSimilarity(emotions[i], emotions[j]);
		      comparisons++;
		    }
		  }
		  
		  return comparisons > 0 ? similaritySum / comparisons : 0;
		}]]></file>
	<file path='utils/chatUtils.ts'><![CDATA[
		import AsyncStorage from '@react-native-async-storage/async-storage';
		import { ChatMessage, TwintuitionMoment } from '../types/chat';
		
		// Message utilities
		export const formatMessageTime = (timestamp: string): string => {
		  const date = new Date(timestamp);
		  const now = new Date();
		  const diffInHours = (now.getTime() - date.getTime()) / (1000 * 60 * 60);
		  const diffInDays = diffInHours / 24;
		
		  if (diffInHours < 1) {
		    const diffInMinutes = Math.floor(diffInHours * 60);
		    return diffInMinutes < 1 ? 'Just now' : `${diffInMinutes}m ago`;
		  } else if (diffInHours < 24) {
		    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
		  } else if (diffInDays < 7) {
		    return date.toLocaleDateString([], { weekday: 'short', hour: '2-digit', minute: '2-digit' });
		  } else {
		    return date.toLocaleDateString([], { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
		  }
		};
		
		export const groupMessagesByDate = (messages: ChatMessage[]): { [date: string]: ChatMessage[] } => {
		  return messages.reduce((groups, message) => {
		    const date = new Date(message.timestamp).toDateString();
		    if (!groups[date]) {
		      groups[date] = [];
		    }
		    groups[date].push(message);
		    return groups;
		  }, {} as { [date: string]: ChatMessage[] });
		};
		
		export const getDateSeparatorText = (dateString: string): string => {
		  const date = new Date(dateString);
		  const today = new Date();
		  const yesterday = new Date(today);
		  yesterday.setDate(today.getDate() - 1);
		
		  if (date.toDateString() === today.toDateString()) {
		    return 'Today';
		  } else if (date.toDateString() === yesterday.toDateString()) {
		    return 'Yesterday';
		  } else {
		    return date.toLocaleDateString([], { weekday: 'long', month: 'long', day: 'numeric' });
		  }
		};
		
		// Twintuition detection
		export const detectTwintuitionKeywords = (message: string): { detected: boolean; confidence: number; type: 'sync' | 'intuition' | 'connection' } => {
		  const messageText = message.toLowerCase();
		  
		  const syncKeywords = [
		    'same time',
		    'exactly when',
		    'just as i was',
		    'at the exact moment',
		    'simultaneously',
		    'in sync',
		  ];
		  
		  const intuitionKeywords = [
		    'thinking the same',
		    'was just about to say',
		    'exactly what i was thinking',
		    'read my mind',
		    'telepathy',
		    'intuition',
		    'sixth sense',
		    'felt like you were',
		  ];
		  
		  const connectionKeywords = [
		    'feeling the same',
		    'connected',
		    'twin bond',
		    'energy',
		    'vibes',
		    'spiritual connection',
		    'soul connection',
		  ];
		
		  let maxConfidence = 0;
		  let detectedType: 'sync' | 'intuition' | 'connection' = 'connection';
		
		  // Check sync keywords
		  const syncMatches = syncKeywords.filter(keyword => messageText.includes(keyword));
		  if (syncMatches.length > 0) {
		    maxConfidence = Math.max(maxConfidence, 0.8 + (syncMatches.length * 0.1));
		    detectedType = 'sync';
		  }
		
		  // Check intuition keywords
		  const intuitionMatches = intuitionKeywords.filter(keyword => messageText.includes(keyword));
		  if (intuitionMatches.length > 0) {
		    const confidence = 0.7 + (intuitionMatches.length * 0.15);
		    if (confidence > maxConfidence) {
		      maxConfidence = confidence;
		      detectedType = 'intuition';
		    }
		  }
		
		  // Check connection keywords
		  const connectionMatches = connectionKeywords.filter(keyword => messageText.includes(keyword));
		  if (connectionMatches.length > 0) {
		    const confidence = 0.6 + (connectionMatches.length * 0.1);
		    if (confidence > maxConfidence) {
		      maxConfidence = confidence;
		      detectedType = 'connection';
		    }
		  }
		
		  return {
		    detected: maxConfidence > 0.5,
		    confidence: Math.min(maxConfidence, 1.0),
		    type: detectedType,
		  };
		};
		
		// Message search and filtering
		export const searchMessages = (messages: ChatMessage[], query: string): ChatMessage[] => {
		  const lowerQuery = query.toLowerCase();
		  return messages.filter(message => 
		    message.text.toLowerCase().includes(lowerQuery) ||
		    message.senderName.toLowerCase().includes(lowerQuery)
		  );
		};
		
		export const filterMessagesByType = (messages: ChatMessage[], type: string): ChatMessage[] => {
		  return messages.filter(message => message.type === type);
		};
		
		export const getUnreadCount = (messages: ChatMessage[], userId: string): number => {
		  return messages.filter(message => 
		    message.senderId !== userId && !message.isRead
		  ).length;
		};
		
		// Offline message management
		export const saveOfflineMessages = async (messages: ChatMessage[]): Promise<void> => {
		  try {
		    await AsyncStorage.setItem('offline_messages', JSON.stringify(messages));
		  } catch (error) {
		    console.error('Failed to save offline messages:', error);
		  }
		};
		
		export const loadOfflineMessages = async (): Promise<ChatMessage[]> => {
		  try {
		    const stored = await AsyncStorage.getItem('offline_messages');
		    return stored ? JSON.parse(stored) : [];
		  } catch (error) {
		    console.error('Failed to load offline messages:', error);
		    return [];
		  }
		};
		
		export const clearOfflineMessages = async (): Promise<void> => {
		  try {
		    await AsyncStorage.removeItem('offline_messages');
		  } catch (error) {
		    console.error('Failed to clear offline messages:', error);
		  }
		};
		
		// Message validation
		export const validateMessage = (message: Partial<ChatMessage>): boolean => {
		  return !!(
		    message.text &&
		    message.text.trim().length > 0 &&
		    message.text.length <= 1000 &&
		    message.senderId &&
		    message.senderName &&
		    message.accentColor
		  );
		};
		
		// Twin connection scoring
		export const calculateTwinConnectionScore = (messages: ChatMessage[], twintuitionMoments: TwintuitionMoment[]): number => {
		  if (messages.length === 0) return 0;
		
		  const factors = {
		    messageFrequency: Math.min(messages.length / 100, 1) * 30, // Max 30 points for 100+ messages
		    twintuitionMoments: Math.min(twintuitionMoments.length / 10, 1) * 40, // Max 40 points for 10+ moments
		    reactionEngagement: calculateReactionScore(messages) * 20, // Max 20 points
		    responseTime: calculateResponseTimeScore(messages) * 10, // Max 10 points
		  };
		
		  return Math.round(
		    factors.messageFrequency +
		    factors.twintuitionMoments +
		    factors.reactionEngagement +
		    factors.responseTime
		  );
		};
		
		const calculateReactionScore = (messages: ChatMessage[]): number => {
		  const messagesWithReactions = messages.filter(m => m.reactions && m.reactions.length > 0);
		  return messagesWithReactions.length / Math.max(messages.length, 1);
		};
		
		const calculateResponseTimeScore = (messages: ChatMessage[]): number => {
		  if (messages.length < 2) return 0;
		
		  const responseTimes: number[] = [];
		  for (let i = 1; i < messages.length; i++) {
		    const timeDiff = new Date(messages[i].timestamp).getTime() - new Date(messages[i - 1].timestamp).getTime();
		    responseTimes.push(timeDiff / (1000 * 60)); // Convert to minutes
		  }
		
		  const avgResponseTime = responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length;
		  
		  // Score inversely proportional to response time (faster = better)
		  // 0-5 minutes = 1.0, 5-30 minutes = 0.5, 30+ minutes = 0.1
		  if (avgResponseTime <= 5) return 1.0;
		  if (avgResponseTime <= 30) return 0.5;
		  return 0.1;
		};
		
		// Generate mystical twin messages
		export const generateTwintuitionMessage = (type: 'sync' | 'intuition' | 'connection', confidence: number): string => {
		  const messages = {
		    sync: [
		      'The cosmic twins are perfectly aligned! ✨',
		      'Your souls synchronized across the universe 🌌',
		      'Time stood still for your twin connection ⏰',
		      'The sacred twin frequency is resonating 📡',
		    ],
		    intuition: [
		      'Your twin\'s thoughts reached across the void 🔮',
		      'The mystical bond revealed its power 💫',
		      'Telepathic channels are wide open! 📡',
		      'Your sixth sense detected your twin\'s energy 🧿',
		    ],
		    connection: [
		      'The eternal twin flame burns bright 🔥',
		      'Sacred energy flows between your souls 💎',
		      'Your hearts beat in perfect harmony 💓',
		      'The universe celebrates your bond 🌟',
		    ],
		  };
		
		  const typeMessages = messages[type];
		  const randomMessage = typeMessages[Math.floor(Math.random() * typeMessages.length)];
		  
		  const confidenceText = confidence >= 0.9 ? 'EXTREMELY STRONG' : 
		                         confidence >= 0.7 ? 'STRONG' : 'MODERATE';
		  
		  return `${randomMessage}\n\nConnection Strength: ${confidenceText}`;
		};]]></file>
	<file path='utils/cn.ts'>
		import { clsx, type ClassValue } from "clsx";
		import { twMerge } from "tailwind-merge";
		
		export function cn(...inputs: ClassValue[]) {
		  return twMerge(clsx(inputs));
		}</file>
	<file path='utils/constellations.ts'>
		export const constellations = {
		    Aries: {
		      stars: [
		        { x: 0.2, y: 0.6 }, { x: 0.35, y: 0.55 }, { x: 0.5, y: 0.5 }, { x: 0.65, y: 0.45 }
		      ],
		      lines: [[0,1],[1,2],[2,3]]
		    },
		  
		    Taurus: {
		      stars: [
		        { x: 0.25, y: 0.4 }, { x: 0.35, y: 0.35 }, { x: 0.45, y: 0.45 },
		        { x: 0.55, y: 0.55 }, { x: 0.65, y: 0.5 }
		      ],
		      lines: [[0,1],[1,2],[2,3],[3,4]]
		    },
		  
		    Gemini: {
		      stars: [
		        { x: 0.2, y: 0.2 }, { x: 0.3, y: 0.4 }, { x: 0.35, y: 0.6 }, { x: 0.4, y: 0.8 },
		        { x: 0.55, y: 0.75 }, { x: 0.7, y: 0.6 }, { x: 0.75, y: 0.4 }, { x: 0.8, y: 0.2 }
		      ],
		      lines: [[0,1],[1,2],[2,3],[4,5],[5,6],[6,7],[2,4]]
		    },
		  
		    Cancer: {
		      stars: [
		        { x: 0.3, y: 0.7 }, { x: 0.4, y: 0.55 }, { x: 0.5, y: 0.45 },
		        { x: 0.6, y: 0.6 }, { x: 0.7, y: 0.75 }
		      ],
		      lines: [[0,1],[1,2],[2,3],[3,4]]
		    },
		  
		    Leo: {
		      stars: [
		        { x: 0.2, y: 0.4 }, { x: 0.35, y: 0.3 }, { x: 0.5, y: 0.25 },
		        { x: 0.65, y: 0.35 }, { x: 0.75, y: 0.55 }, { x: 0.6, y: 0.7 }
		      ],
		      lines: [[0,1],[1,2],[2,3],[3,4],[4,5]]
		    },
		  
		    Virgo: {
		      stars: [
		        { x: 0.25, y: 0.3 }, { x: 0.4, y: 0.35 }, { x: 0.55, y: 0.4 },
		        { x: 0.7, y: 0.5 }, { x: 0.6, y: 0.65 }, { x: 0.45, y: 0.7 }
		      ],
		      lines: [[0,1],[1,2],[2,3],[3,4],[4,5]]
		    },
		  
		    Libra: {
		      stars: [
		        { x: 0.3, y: 0.4 }, { x: 0.45, y: 0.35 }, { x: 0.6, y: 0.4 },
		        { x: 0.55, y: 0.55 }, { x: 0.4, y: 0.55 }
		      ],
		      lines: [[0,1],[1,2],[2,3],[1,4]]
		    },
		  
		    Scorpio: {
		      stars: [
		        { x: 0.2, y: 0.5 }, { x: 0.35, y: 0.45 }, { x: 0.5, y: 0.4 },
		        { x: 0.65, y: 0.5 }, { x: 0.7, y: 0.65 }, { x: 0.6, y: 0.8 }
		      ],
		      lines: [[0,1],[1,2],[2,3],[3,4],[4,5]]
		    },
		  
		    Sagittarius: {
		      stars: [
		        { x: 0.3, y: 0.7 }, { x: 0.4, y: 0.55 }, { x: 0.5, y: 0.65 },
		        { x: 0.6, y: 0.55 }, { x: 0.7, y: 0.45 }
		      ],
		      lines: [[0,1],[1,2],[2,3],[3,4]]
		    },
		  
		    Capricorn: {
		      stars: [
		        { x: 0.25, y: 0.6 }, { x: 0.4, y: 0.5 }, { x: 0.55, y: 0.55 },
		        { x: 0.7, y: 0.65 }
		      ],
		      lines: [[0,1],[1,2],[2,3]]
		    },
		  
		    Aquarius: {
		      stars: [
		        { x: 0.2, y: 0.35 }, { x: 0.35, y: 0.4 }, { x: 0.5, y: 0.45 },
		        { x: 0.65, y: 0.5 }, { x: 0.8, y: 0.55 }
		      ],
		      lines: [[0,1],[1,2],[2,3],[3,4]]
		    },
		  
		    Pisces: {
		      stars: [
		        { x: 0.25, y: 0.2 }, { x: 0.35, y: 0.35 }, { x: 0.45, y: 0.5 },
		        { x: 0.55, y: 0.65 }, { x: 0.65, y: 0.8 }
		      ],
		      lines: [[0,1],[1,2],[2,3],[3,4]]
		    }
		  };</file>
	<file path='utils/dataFlow.ts'><![CDATA[
		/**
		 * Data Flow Architecture - Complete data flow orchestration
		 * Coordinates all data operations across the assessment system
		 */
		
		import {
		  AssessmentTemplate,
		  AssessmentProgress,
		  AssessmentResults,
		  AssessmentResponse,
		  TwinPairData,
		  PairAnalytics,
		  PrivacyConsent,
		  SyncStatus,
		} from '../types/assessment/types';
		import { useAssessmentStore } from '../state/stores/assessmentStore';
		import { usePairStore } from '../state/stores/pairStore';
		import { SyncService } from '../services/syncService';
		import { storageService } from '../services/storageService';
		import { EncryptionService } from '../services/encryptionService';
		import { pairAnalyticsEngine } from './analytics/pairAnalytics';
		import { dataPrivacyManager } from './encryption/dataPrivacy';
		
		export interface DataFlowConfig {
		  enableEncryption: boolean;
		  enableCloudSync: boolean;
		  enableAnalytics: boolean;
		  privacyLevel: 'minimal' | 'standard' | 'enhanced';
		  retentionPolicy: 'user_controlled' | 'app_managed' | 'compliance_driven';
		}
		
		export interface DataFlowOperation {
		  id: string;
		  type: 'create' | 'read' | 'update' | 'sync' | 'analyze' | 'export' | 'delete';
		  entity: 'assessment' | 'response' | 'results' | 'pair' | 'analytics' | 'consent';
		  userId: string;
		  timestamp: string;
		  status: 'pending' | 'processing' | 'completed' | 'failed';
		  metadata: Record<string, any>;
		  privacy: {
		    consentRequired: boolean;
		    encryptionLevel: 'none' | 'standard' | 'high';
		    auditRequired: boolean;
		  };
		}
		
		export interface DataFlowMetrics {
		  totalOperations: number;
		  successRate: number;
		  averageProcessingTime: number;
		  encryptionRate: number;
		  syncRate: number;
		  privacyCompliance: number;
		  storageUtilization: {
		    local: number;
		    secure: number;
		    cloud: number;
		  };
		}
		
		class DataFlowOrchestrator {
		  private config: DataFlowConfig;
		  private operationQueue: DataFlowOperation[] = [];
		  private activeOperations: Map<string, DataFlowOperation> = new Map();
		  private metrics: DataFlowMetrics;
		  private initialized = false;
		
		  constructor(config: Partial<DataFlowConfig> = {}) {
		    this.config = {
		      enableEncryption: true,
		      enableCloudSync: true,
		      enableAnalytics: true,
		      privacyLevel: 'standard',
		      retentionPolicy: 'user_controlled',
		      ...config,
		    };
		
		    this.metrics = {
		      totalOperations: 0,
		      successRate: 0,
		      averageProcessingTime: 0,
		      encryptionRate: 0,
		      syncRate: 0,
		      privacyCompliance: 0,
		      storageUtilization: {
		        local: 0,
		        secure: 0,
		        cloud: 0,
		      },
		    };
		  }
		
		  /**
		   * Initialize the data flow system
		   */
		  async initialize(): Promise<void> {
		    if (this.initialized) return;
		
		    try {
		      // Initialize encryption service
		      await EncryptionService.initialize();
		
		      // Load existing metrics
		      const savedMetrics = await storageService.get('dataflow_metrics');
		      if (savedMetrics) {
		        this.metrics = { ...this.metrics, ...savedMetrics };
		      }
		
		      // Start operation processor
		      this.startOperationProcessor();
		
		      // Initialize privacy compliance
		      await dataPrivacyManager.checkRetentionCompliance();
		
		      this.initialized = true;
		      console.log('Data flow orchestrator initialized');
		    } catch (error) {
		      console.error('Failed to initialize data flow orchestrator:', error);
		      throw error;
		    }
		  }
		
		  /**
		   * Start assessment flow
		   */
		  async startAssessmentFlow(
		    template: AssessmentTemplate,
		    userId: string,
		    privacyConsent: PrivacyConsent
		  ): Promise<{
		    progress: AssessmentProgress;
		    operationId: string;
		  }> {
		    // Validate privacy consent
		    const consentValid = await dataPrivacyManager.validateConsent(
		      userId,
		      'assessment_processing',
		      'assessment_data'
		    );
		
		    if (!consentValid) {
		      throw new Error('Invalid privacy consent for assessment processing');
		    }
		
		    // Create operation
		    const operation = this.createOperation({
		      type: 'create',
		      entity: 'assessment',
		      userId,
		      metadata: { templateId: template.id },
		      privacy: {
		        consentRequired: true,
		        encryptionLevel: this.config.privacyLevel === 'enhanced' ? 'high' : 'standard',
		        auditRequired: true,
		      },
		    });
		
		    // Queue operation
		    this.queueOperation(operation);
		
		    // Start assessment using store
		    const assessmentStore = useAssessmentStore.getState();
		    await assessmentStore.loadTemplate(template);
		    assessmentStore.startAssessment(template.id, userId);
		    assessmentStore.updatePrivacyConsent(privacyConsent);
		
		    const progress = assessmentStore.currentProgress!;
		
		    return {
		      progress,
		      operationId: operation.id,
		    };
		  }
		
		  /**
		   * Process assessment response
		   */
		  async processResponse(
		    questionId: string,
		    response: AssessmentResponse,
		    userId: string
		  ): Promise<void> {
		    const operation = this.createOperation({
		      type: 'update',
		      entity: 'response',
		      userId,
		      metadata: { questionId, responseType: response.value?.constructor?.name || 'unknown' },
		      privacy: {
		        consentRequired: false,
		        encryptionLevel: 'standard',
		        auditRequired: false,
		      },
		    });
		
		    this.queueOperation(operation);
		
		    // Save response using store
		    const assessmentStore = useAssessmentStore.getState();
		    await assessmentStore.saveResponse(questionId, response);
		
		    // Auto-save progress periodically
		    if (assessmentStore.currentProgress?.completedQuestions % 5 === 0) {
		      await this.saveProgress(userId);
		    }
		  }
		
		  /**
		   * Complete assessment and generate results
		   */
		  async completeAssessment(
		    userId: string
		  ): Promise<{
		    results: AssessmentResults;
		    syncStatus: SyncStatus;
		  }> {
		    const operation = this.createOperation({
		      type: 'create',
		      entity: 'results',
		      userId,
		      metadata: { completion: true },
		      privacy: {
		        consentRequired: true,
		        encryptionLevel: 'high',
		        auditRequired: true,
		      },
		    });
		
		    this.queueOperation(operation);
		
		    // Complete assessment using store
		    const assessmentStore = useAssessmentStore.getState();
		    const results = await assessmentStore.completeAssessment();
		
		    // Handle cloud sync if enabled and consented
		    let syncStatus: SyncStatus = {
		      pendingChanges: 0,
		      needsResolution: false,
		    };
		
		    if (this.config.enableCloudSync && results.privacyConsent.twinDataMerging) {
		      try {
		        await SyncService.syncAssessmentResults(results, {
		          encryptCloud: this.config.enableEncryption,
		          includeAnalytics: this.config.enableAnalytics,
		        });
		        syncStatus = await SyncService.getSyncStatus();
		      } catch (error) {
		        console.warn('Cloud sync failed, will retry later:', error);
		      }
		    }
		
		    return {
		      results,
		      syncStatus,
		    };
		  }
		
		  /**
		   * Create twin pair and generate analytics
		   */
		  async createTwinPair(
		    invitationId: string,
		    userId: string
		  ): Promise<{
		    pairData: TwinPairData;
		    analytics?: PairAnalytics;
		  }> {
		    const operation = this.createOperation({
		      type: 'create',
		      entity: 'pair',
		      userId,
		      metadata: { invitationId },
		      privacy: {
		        consentRequired: true,
		        encryptionLevel: 'high',
		        auditRequired: true,
		      },
		    });
		
		    this.queueOperation(operation);
		
		    // Create pair using store
		    const pairStore = usePairStore.getState();
		    const pairData = await pairStore.acceptInvitation(invitationId);
		
		    // Generate analytics if both twins have completed assessments
		    let analytics: PairAnalytics | undefined;
		
		    if (this.config.enableAnalytics) {
		      const twin1Results = await this.getUserResults(pairData.twin1Id);
		      const twin2Results = await this.getUserResults(pairData.twin2Id);
		
		      if (twin1Results && twin2Results) {
		        analytics = await this.generatePairAnalytics(
		          twin1Results,
		          twin2Results,
		          pairData.pairId
		        );
		      }
		    }
		
		    return {
		      pairData,
		      analytics,
		    };
		  }
		
		  /**
		   * Generate pair analytics with privacy protection
		   */
		  async generatePairAnalytics(
		    twin1Results: AssessmentResults,
		    twin2Results: AssessmentResults,
		    pairId: string
		  ): Promise<PairAnalytics> {
		    const operation = this.createOperation({
		      type: 'analyze',
		      entity: 'analytics',
		      userId: twin1Results.userId, // Primary user for operation tracking
		      metadata: { pairId, twin2UserId: twin2Results.userId },
		      privacy: {
		        consentRequired: true,
		        encryptionLevel: 'high',
		        auditRequired: true,
		      },
		    });
		
		    this.queueOperation(operation);
		
		    // Verify both users consented to data merging
		    if (!twin1Results.privacyConsent.twinDataMerging ||
		        !twin2Results.privacyConsent.twinDataMerging) {
		      throw new Error('Both twins must consent to data merging for analytics');
		    }
		
		    // Generate analytics using pair analytics engine
		    const analytics = await pairAnalyticsEngine.generatePairAnalytics(
		      twin1Results,
		      twin2Results,
		      {
		        privacyLevel: this.config.privacyLevel,
		        normalizeScores: true,
		        confidenceThreshold: 0.7,
		      } as any
		    );
		
		    // Store analytics securely
		    await storageService.setSecure(
		      `pair_analytics_${pairId}`,
		      analytics,
		      {
		        encrypt: this.config.enableEncryption,
		        tier: 'secure',
		        backup: true,
		      }
		    );
		
		    // Update pair store
		    const pairStore = usePairStore.getState();
		    pairStore.generateAnalytics(twin1Results, twin2Results);
		
		    return analytics;
		  }
		
		  /**
		   * Export user data for portability
		   */
		  async exportUserData(
		    userId: string,
		    includeAnalytics = false
		  ): Promise<string> {
		    const operation = this.createOperation({
		      type: 'export',
		      entity: 'assessment',
		      userId,
		      metadata: { includeAnalytics },
		      privacy: {
		        consentRequired: true,
		        encryptionLevel: 'none', // Export is unencrypted for portability
		        auditRequired: true,
		      },
		    });
		
		    this.queueOperation(operation);
		
		    // Export using privacy manager
		    const exportData = await dataPrivacyManager.createDataExport(
		      userId,
		      includeAnalytics
		    );
		
		    return JSON.stringify(exportData, null, 2);
		  }
		
		  /**
		   * Delete all user data
		   */
		  async deleteUserData(
		    userId: string,
		    reason: 'user_request' | 'consent_withdrawal' | 'retention_expired' = 'user_request'
		  ): Promise<void> {
		    const operation = this.createOperation({
		      type: 'delete',
		      entity: 'assessment',
		      userId,
		      metadata: { reason, deletionType: 'complete' },
		      privacy: {
		        consentRequired: false, // Deletion doesn't require consent
		        encryptionLevel: 'none',
		        auditRequired: true,
		      },
		    });
		
		    this.queueOperation(operation);
		
		    // Delete using privacy manager
		    await dataPrivacyManager.deleteAllUserData(userId, reason);
		
		    // Clear from stores
		    const assessmentStore = useAssessmentStore.getState();
		    const pairStore = usePairStore.getState();
		
		    await assessmentStore.deleteAllData();
		    await pairStore.deletePairData();
		  }
		
		  /**
		   * Get data flow metrics
		   */
		  async getMetrics(): Promise<DataFlowMetrics> {
		    // Update storage utilization
		    const storageStats = await storageService.getStats();
		    
		    this.metrics.storageUtilization = {
		      local: storageStats.tierStats.standard.size + storageStats.tierStats.temp.size,
		      secure: storageStats.tierStats.secure.size,
		      cloud: 0, // Would be updated from sync service
		    };
		
		    // Calculate rates
		    const totalOps = this.metrics.totalOperations;
		    if (totalOps > 0) {
		      const encryptedOps = this.countEncryptedOperations();
		      const syncedOps = this.countSyncedOperations();
		      
		      this.metrics.encryptionRate = encryptedOps / totalOps;
		      this.metrics.syncRate = syncedOps / totalOps;
		    }
		
		    return { ...this.metrics };
		  }
		
		  /**
		   * Update configuration
		   */
		  updateConfig(newConfig: Partial<DataFlowConfig>): void {
		    this.config = { ...this.config, ...newConfig };
		  }
		
		  /**
		   * Get current configuration
		   */
		  getConfig(): DataFlowConfig {
		    return { ...this.config };
		  }
		
		  // Private methods
		  private createOperation(
		    params: Omit<DataFlowOperation, 'id' | 'timestamp' | 'status'>
		  ): DataFlowOperation {
		    return {
		      id: `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
		      timestamp: new Date().toISOString(),
		      status: 'pending',
		      ...params,
		    };
		  }
		
		  private queueOperation(operation: DataFlowOperation): void {
		    this.operationQueue.push(operation);
		    this.metrics.totalOperations++;
		  }
		
		  private startOperationProcessor(): void {
		    setInterval(async () => {
		      await this.processOperationQueue();
		    }, 1000); // Process every second
		  }
		
		  private async processOperationQueue(): Promise<void> {
		    if (this.operationQueue.length === 0) return;
		
		    const operation = this.operationQueue.shift()!;
		    this.activeOperations.set(operation.id, operation);
		
		    try {
		      operation.status = 'processing';
		      const startTime = Date.now();
		
		      // Process operation based on type
		      await this.executeOperation(operation);
		
		      operation.status = 'completed';
		      const processingTime = Date.now() - startTime;
		      this.updateMetrics(operation, processingTime, true);
		
		    } catch (error) {
		      operation.status = 'failed';
		      console.error('Operation failed:', operation.id, error);
		      this.updateMetrics(operation, 0, false);
		    } finally {
		      this.activeOperations.delete(operation.id);
		    }
		  }
		
		  private async executeOperation(operation: DataFlowOperation): Promise<void> {
		    // Audit logging
		    if (operation.privacy.auditRequired) {
		      console.log('Auditing operation:', operation.id, operation.type, operation.entity);
		    }
		
		    // Consent validation
		    if (operation.privacy.consentRequired) {
		      const consentValid = await dataPrivacyManager.validateConsent(
		        operation.userId,
		        `${operation.type}_${operation.entity}`,
		        operation.entity
		      );
		
		      if (!consentValid) {
		        throw new Error('Invalid consent for operation');
		      }
		    }
		
		    // Operation-specific processing would go here
		    // This is a simplified version - actual implementation would have
		    // detailed handlers for each operation type/entity combination
		    
		    console.log('Executing operation:', operation.id);
		  }
		
		  private updateMetrics(
		    operation: DataFlowOperation,
		    processingTime: number,
		    success: boolean
		  ): void {
		    const currentAvg = this.metrics.averageProcessingTime;
		    const totalOps = this.metrics.totalOperations;
		    
		    this.metrics.averageProcessingTime = 
		      (currentAvg * (totalOps - 1) + processingTime) / totalOps;
		    
		    if (success) {
		      this.metrics.successRate = 
		        (this.metrics.successRate * (totalOps - 1) + 1) / totalOps;
		    } else {
		      this.metrics.successRate = 
		        (this.metrics.successRate * (totalOps - 1)) / totalOps;
		    }
		
		    // Save metrics periodically
		    if (totalOps % 10 === 0) {
		      storageService.set('dataflow_metrics', this.metrics);
		    }
		  }
		
		  private countEncryptedOperations(): number {
		    // Would track operations that used encryption
		    return Math.floor(this.metrics.totalOperations * 0.8); // Placeholder
		  }
		
		  private countSyncedOperations(): number {
		    // Would track operations that were synced to cloud
		    return Math.floor(this.metrics.totalOperations * 0.6); // Placeholder
		  }
		
		  private async saveProgress(userId: string): Promise<void> {
		    const assessmentStore = useAssessmentStore.getState();
		    await assessmentStore.saveProgress();
		  }
		
		  private async getUserResults(userId: string): Promise<AssessmentResults | null> {
		    try {
		      return await storageService.getSecure(`results_${userId}`);
		    } catch {
		      return null;
		    }
		  }
		}
		
		// Export singleton instance
		export const dataFlowOrchestrator = new DataFlowOrchestrator();
		
		// Export utility functions
		export {
		  DataFlowOrchestrator,
		};
		
		/**
		 * Initialize data flow system
		 */
		export async function initializeDataFlow(
		  config?: Partial<DataFlowConfig>
		): Promise<DataFlowOrchestrator> {
		  if (config) {
		    dataFlowOrchestrator.updateConfig(config);
		  }
		  
		  await dataFlowOrchestrator.initialize();
		  return dataFlowOrchestrator;
		}
		
		/**
		 * Create a complete assessment workflow
		 */
		export async function createAssessmentWorkflow(
		  template: AssessmentTemplate,
		  userId: string,
		  privacyConsent: PrivacyConsent
		): Promise<{
		  startAssessment: () => Promise<AssessmentProgress>;
		  saveResponse: (questionId: string, response: AssessmentResponse) => Promise<void>;
		  completeAssessment: () => Promise<AssessmentResults>;
		  pauseAssessment: () => Promise<void>;
		  resumeAssessment: () => Promise<AssessmentProgress>;
		}> {
		  const { progress, operationId } = await dataFlowOrchestrator.startAssessmentFlow(
		    template,
		    userId,
		    privacyConsent
		  );
		
		  return {
		    startAssessment: async () => progress,
		    
		    saveResponse: async (questionId, response) => {
		      await dataFlowOrchestrator.processResponse(questionId, response, userId);
		    },
		    
		    completeAssessment: async () => {
		      const { results } = await dataFlowOrchestrator.completeAssessment(userId);
		      return results;
		    },
		    
		    pauseAssessment: async () => {
		      await dataFlowOrchestrator['saveProgress'](userId);
		    },
		    
		    resumeAssessment: async () => {
		      const assessmentStore = useAssessmentStore.getState();
		      return assessmentStore.currentProgress!;
		    },
		  };
		}]]></file>
	<file path='utils/deepLinking.ts'><![CDATA[
		import * as Linking from 'expo-linking';
		import { useInvitationStore } from '../state/invitationStore';
		import invitationService from '../services/invitationService';
		
		// Deep link URL scheme configuration
		const DEEP_LINK_SCHEME = 'twinshipvibe';
		const WEB_URL = 'https://twinshipvibe.app'; // Future web app URL
		
		// URL patterns
		const URL_PATTERNS = {
		  invitation: /\/invitation\/([A-F0-9]{64})/i,
		  profile: /\/profile\/(.+)/,
		  chat: /\/chat/,
		  assessment: /\/assessment/,
		} as const;
		
		interface DeepLinkData {
		  type: 'invitation' | 'profile' | 'chat' | 'assessment' | 'unknown';
		  params?: Record<string, string>;
		  token?: string;
		  url: string;
		  timestamp: number;
		}
		
		class DeepLinkManager {
		  private static instance: DeepLinkManager;
		  private isInitialized = false;
		  private linkingListener: any = null;
		
		  private constructor() {}
		
		  static getInstance(): DeepLinkManager {
		    if (!DeepLinkManager.instance) {
		      DeepLinkManager.instance = new DeepLinkManager();
		    }
		    return DeepLinkManager.instance;
		  }
		
		  /**
		   * Initialize deep linking with Expo Linking
		   */
		  async initialize(): Promise<void> {
		    if (this.isInitialized) {
		      return;
		    }
		
		    try {
		      // Handle initial URL if app was opened from a deep link
		      const initialURL = await Linking.getInitialURL();
		      if (initialURL) {
		        await this.handleIncomingURL(initialURL);
		      }
		
		      // Listen for incoming URLs while app is running
		      this.linkingListener = Linking.addEventListener('url', (event) => {
		        this.handleIncomingURL(event.url);
		      });
		
		      this.isInitialized = true;
		      console.log('Deep linking initialized successfully');
		    } catch (error) {
		      console.error('Failed to initialize deep linking:', error);
		    }
		  }
		
		  /**
		   * Clean up event listeners
		   */
		  cleanup(): void {
		    if (this.linkingListener) {
		      this.linkingListener.remove();
		      this.linkingListener = null;
		    }
		    this.isInitialized = false;
		  }
		
		  /**
		   * Parse incoming URL and extract relevant data
		   */
		  private parseURL(url: string): DeepLinkData {
		    const timestamp = Date.now();
		    
		    try {
		      const parsed = new URL(url);
		      const pathname = parsed.pathname;
		
		      // Check for invitation pattern
		      const invitationMatch = pathname.match(URL_PATTERNS.invitation);
		      if (invitationMatch) {
		        return {
		          type: 'invitation',
		          token: invitationMatch[1],
		          url,
		          timestamp,
		        };
		      }
		
		      // Check for profile pattern
		      const profileMatch = pathname.match(URL_PATTERNS.profile);
		      if (profileMatch) {
		        return {
		          type: 'profile',
		          params: { userId: profileMatch[1] },
		          url,
		          timestamp,
		        };
		      }
		
		      // Check for chat pattern
		      if (URL_PATTERNS.chat.test(pathname)) {
		        return {
		          type: 'chat',
		          url,
		          timestamp,
		        };
		      }
		
		      // Check for assessment pattern
		      if (URL_PATTERNS.assessment.test(pathname)) {
		        return {
		          type: 'assessment',
		          url,
		          timestamp,
		        };
		      }
		
		      // Unknown pattern
		      return {
		        type: 'unknown',
		        url,
		        timestamp,
		      };
		    } catch (error) {
		      console.error('Failed to parse deep link URL:', error);
		      return {
		        type: 'unknown',
		        url,
		        timestamp,
		      };
		    }
		  }
		
		  /**
		   * Handle incoming URL
		   */
		  private async handleIncomingURL(url: string): Promise<void> {
		    try {
		      console.log('Handling incoming URL:', url);
		      
		      const linkData = this.parseURL(url);
		      
		      switch (linkData.type) {
		        case 'invitation':
		          await this.handleInvitationLink(linkData);
		          break;
		          
		        case 'profile':
		          await this.handleProfileLink(linkData);
		          break;
		          
		        case 'chat':
		          await this.handleChatLink(linkData);
		          break;
		          
		        case 'assessment':
		          await this.handleAssessmentLink(linkData);
		          break;
		          
		        default:
		          console.warn('Unknown deep link type:', linkData.type);
		          break;
		      }
		    } catch (error) {
		      console.error('Error handling deep link:', error);
		    }
		  }
		
		  /**
		   * Handle invitation deep link
		   */
		  private async handleInvitationLink(linkData: DeepLinkData): Promise<void> {
		    if (!linkData.token) {
		      console.error('No invitation token found in deep link');
		      return;
		    }
		
		    const invitationStore = useInvitationStore.getState();
		    
		    try {
		      // Set deep link data for UI handling
		      invitationStore.setDeepLinkData({
		        token: linkData.token,
		        processed: false,
		        timestamp: linkData.timestamp,
		      });
		      
		      // Store the pending token
		      invitationStore.setPendingInvitationToken(linkData.token);
		      
		      console.log('Invitation deep link processed, token stored:', linkData.token);
		    } catch (error) {
		      console.error('Failed to handle invitation deep link:', error);
		    }
		  }
		
		  /**
		   * Handle profile deep link
		   */
		  private async handleProfileLink(linkData: DeepLinkData): Promise<void> {
		    console.log('Profile deep link - not implemented yet:', linkData.params);
		    // TODO: Navigate to profile screen with user ID
		  }
		
		  /**
		   * Handle chat deep link
		   */
		  private async handleChatLink(linkData: DeepLinkData): Promise<void> {
		    console.log('Chat deep link - not implemented yet');
		    // TODO: Navigate to chat screen
		  }
		
		  /**
		   * Handle assessment deep link
		   */
		  private async handleAssessmentLink(linkData: DeepLinkData): Promise<void> {
		    console.log('Assessment deep link - not implemented yet');
		    // TODO: Navigate to assessment screen
		  }
		
		  /**
		   * Create invitation deep link
		   */
		  createInvitationLink(token: string): string {
		    return `${DEEP_LINK_SCHEME}://invitation/${token}`;
		  }
		
		  /**
		   * Create web fallback URL for sharing
		   */
		  createWebInvitationLink(token: string): string {
		    return `${WEB_URL}/invitation/${token}`;
		  }
		
		  /**
		   * Create universal link (supports both app and web)
		   */
		  createUniversalInvitationLink(token: string): string {
		    // In a real app, this would be a universal link that works on both web and mobile
		    // For now, we'll use the deep link format
		    return this.createInvitationLink(token);
		  }
		
		  /**
		   * Check if a URL is a valid invitation link
		   */
		  isValidInvitationLink(url: string): boolean {
		    try {
		      const linkData = this.parseURL(url);
		      return linkData.type === 'invitation' && !!linkData.token && linkData.token.length === 64;
		    } catch {
		      return false;
		    }
		  }
		
		  /**
		   * Extract invitation token from URL
		   */
		  extractInvitationToken(url: string): string | null {
		    try {
		      const linkData = this.parseURL(url);
		      return linkData.type === 'invitation' ? linkData.token || null : null;
		    } catch {
		      return null;
		    }
		  }
		
		  /**
		   * Process pending invitation token
		   */
		  async processPendingInvitation(): Promise<{
		    success: boolean;
		    invitation?: any;
		    error?: string;
		  }> {
		    const invitationStore = useInvitationStore.getState();
		    const token = invitationStore.pendingInvitationToken;
		    
		    if (!token) {
		      return { success: false, error: 'No pending invitation token' };
		    }
		
		    try {
		      const result = await invitationStore.processIncomingInvitation(token);
		      
		      if (result.success) {
		        // Mark as processed
		        const deepLinkData = invitationStore.deepLinkData;
		        if (deepLinkData) {
		          invitationStore.setDeepLinkData({ ...deepLinkData, processed: true });
		        }
		        
		        // Clear pending token
		        invitationStore.setPendingInvitationToken(null);
		      }
		      
		      return result;
		    } catch (error) {
		      const errorMessage = error instanceof Error ? error.message : 'Failed to process invitation';
		      return { success: false, error: errorMessage };
		    }
		  }
		
		  /**
		   * Clear pending deep link data
		   */
		  clearPendingData(): void {
		    const invitationStore = useInvitationStore.getState();
		    invitationStore.setPendingInvitationToken(null);
		    invitationStore.clearDeepLinkData();
		  }
		
		  /**
		   * Get current deep link status
		   */
		  getDeepLinkStatus(): {
		    hasPendingInvitation: boolean;
		    token?: string;
		    isProcessed?: boolean;
		  } {
		    const invitationStore = useInvitationStore.getState();
		    const token = invitationStore.pendingInvitationToken;
		    const deepLinkData = invitationStore.deepLinkData;
		    
		    return {
		      hasPendingInvitation: !!token,
		      token: token || undefined,
		      isProcessed: deepLinkData?.processed,
		    };
		  }
		}
		
		// Export singleton instance
		export const deepLinkManager = DeepLinkManager.getInstance();
		export default deepLinkManager;
		
		// Helper functions for React components
		export const useDeepLinkHandler = () => {
		  const initializeDeepLinking = () => deepLinkManager.initialize();
		  const cleanupDeepLinking = () => deepLinkManager.cleanup();
		  const processPendingInvitation = () => deepLinkManager.processPendingInvitation();
		  const clearPendingData = () => deepLinkManager.clearPendingData();
		  const getDeepLinkStatus = () => deepLinkManager.getDeepLinkStatus();
		  
		  return {
		    initializeDeepLinking,
		    cleanupDeepLinking,
		    processPendingInvitation,
		    clearPendingData,
		    getDeepLinkStatus,
		  };
		};
		
		// Utility functions
		export const createInvitationLink = (token: string) => deepLinkManager.createInvitationLink(token);
		export const createWebInvitationLink = (token: string) => deepLinkManager.createWebInvitationLink(token);
		export const isValidInvitationLink = (url: string) => deepLinkManager.isValidInvitationLink(url);
		export const extractInvitationToken = (url: string) => deepLinkManager.extractInvitationToken(url);]]></file>
	<file path='utils/encryption/dataPrivacy.ts'><![CDATA[
		/**
		 * Data Privacy Utilities - GDPR/Privacy compliance and data management
		 * Handles consent management, data anonymization, and privacy controls
		 */
		
		import {
		  PrivacyConsent,
		  AssessmentResults,
		  TwinPairData,
		} from '../types/assessment/types';
		import { EncryptionService } from '../services/encryptionService';
		import { storageService } from '../services/storageService';
		
		export interface PrivacySettings {
		  dataCollection: boolean;
		  researchParticipation: boolean;
		  anonymizedSharing: boolean;
		  twinDataMerging: boolean;
		  marketingCommunications: boolean;
		  thirdPartySharing: boolean;
		  dataRetentionPeriod: '1year' | '5years' | 'indefinite' | 'until_deleted';
		  rightToErasure: boolean;
		  dataPortability: boolean;
		  processingPurposes: string[];
		}
		
		export interface DataAuditLog {
		  id: string;
		  timestamp: string;
		  action: 'create' | 'read' | 'update' | 'delete' | 'share' | 'export' | 'anonymize';
		  dataType: string;
		  userId: string;
		  purpose: string;
		  legalBasis: 'consent' | 'legitimate_interest' | 'contract' | 'legal_obligation';
		  automated: boolean;
		}
		
		export interface ConsentRecord {
		  id: string;
		  userId: string;
		  consentType: string;
		  granted: boolean;
		  timestamp: string;
		  version: string;
		  mechanism: 'explicit' | 'implied' | 'opt_in' | 'opt_out';
		  withdrawable: boolean;
		  evidence: string; // How consent was captured
		}
		
		export interface DataInventory {
		  personalData: {
		    category: string;
		    fields: string[];
		    purpose: string;
		    legalBasis: string;
		    retentionPeriod: string;
		    sharing: string[];
		  }[];
		  sensitiveData: {
		    category: string;
		    fields: string[];
		    purpose: string;
		    safeguards: string[];
		  }[];
		  processedData: {
		    type: string;
		    source: string;
		    processing: string;
		    output: string;
		  }[];
		}
		
		class DataPrivacyManager {
		  private auditLog: DataAuditLog[] = [];
		  private consentRecords: Map<string, ConsentRecord[]> = new Map();
		  
		  /**
		   * Initialize privacy settings with defaults
		   */
		  getDefaultPrivacySettings(): PrivacySettings {
		    return {
		      dataCollection: false,
		      researchParticipation: false,
		      anonymizedSharing: false,
		      twinDataMerging: false,
		      marketingCommunications: false,
		      thirdPartySharing: false,
		      dataRetentionPeriod: 'until_deleted',
		      rightToErasure: true,
		      dataPortability: true,
		      processingPurposes: ['assessment_functionality'],
		    };
		  }
		
		  /**
		   * Validate privacy consent for specific processing
		   */
		  async validateConsent(
		    userId: string,
		    processingType: string,
		    dataType: string
		  ): Promise<boolean> {
		    const userConsents = this.consentRecords.get(userId) || [];
		    const relevantConsent = userConsents.find(c => 
		      c.consentType === processingType && c.granted
		    );
		    
		    if (!relevantConsent) {
		      await this.logDataAction({
		        action: 'read',
		        dataType,
		        userId,
		        purpose: processingType,
		        legalBasis: 'consent',
		        automated: true,
		      });
		      return false;
		    }
		    
		    // Check if consent is still valid (not withdrawn)
		    const isValid = relevantConsent.granted && 
		                   (!relevantConsent.withdrawable || 
		                    new Date(relevantConsent.timestamp) > new Date(Date.now() - 365 * 24 * 60 * 60 * 1000)); // 1 year validity
		    
		    if (isValid) {
		      await this.logDataAction({
		        action: 'read',
		        dataType,
		        userId,
		        purpose: processingType,
		        legalBasis: 'consent',
		        automated: true,
		      });
		    }
		    
		    return isValid;
		  }
		
		  /**
		   * Record user consent
		   */
		  async recordConsent(
		    userId: string,
		    consentType: string,
		    granted: boolean,
		    mechanism: ConsentRecord['mechanism'] = 'explicit',
		    evidence?: string
		  ): Promise<void> {
		    const consent: ConsentRecord = {
		      id: `consent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
		      userId,
		      consentType,
		      granted,
		      timestamp: new Date().toISOString(),
		      version: '1.0', // Would be dynamic based on privacy policy version
		      mechanism,
		      withdrawable: true,
		      evidence: evidence || `${mechanism} consent via app interface`,
		    };
		    
		    const userConsents = this.consentRecords.get(userId) || [];
		    userConsents.push(consent);
		    this.consentRecords.set(userId, userConsents);
		    
		    // Store securely
		    await storageService.setSecure(`consent_${userId}`, userConsents);
		    
		    await this.logDataAction({
		      action: granted ? 'create' : 'delete',
		      dataType: 'consent_record',
		      userId,
		      purpose: 'consent_management',
		      legalBasis: 'consent',
		      automated: false,
		    });
		  }
		
		  /**
		   * Withdraw consent for specific processing
		   */
		  async withdrawConsent(
		    userId: string,
		    consentType: string
		  ): Promise<void> {
		    await this.recordConsent(userId, consentType, false, 'explicit', 'User initiated withdrawal');
		    
		    // If data merging consent is withdrawn, handle pair data
		    if (consentType === 'twinDataMerging') {
		      await this.handleDataMergingWithdrawal(userId);
		    }
		  }
		
		  /**
		   * Anonymize assessment data
		   */
		  async anonymizeAssessmentData(
		    results: AssessmentResults,
		    anonymizationLevel: 'basic' | 'enhanced' | 'full' = 'enhanced'
		  ): Promise<any> {
		    const anonymized = {
		      // Remove direct identifiers
		      id: this.generateAnonymousId(),
		      templateId: results.templateId,
		      completedAt: this.anonymizeTimestamp(results.completedAt, anonymizationLevel),
		      
		      // Generalize scores
		      scores: results.scores.map(score => ({
		        category: score.category,
		        normalizedScore: this.generalizeScore(score.normalizedScore, anonymizationLevel),
		        confidence: Math.round(score.confidence * 10) / 10, // Round to 1 decimal
		      })),
		      
		      // Remove or generalize sensitive fields
		      overallScore: results.overallScore ? 
		        this.generalizeScore(results.overallScore, anonymizationLevel) : null,
		      
		      // Add noise to prevent re-identification
		      reliability: this.addNoise(results.reliability, 0.05),
		      validity: this.addNoise(results.validity, 0.05),
		      
		      // Generalize insights
		      insights: this.anonymizeInsights(results.insights),
		      recommendations: this.anonymizeRecommendations(results.recommendations),
		      
		      // Add anonymization metadata
		      _anonymized: {
		        level: anonymizationLevel,
		        timestamp: new Date().toISOString(),
		        method: 'k_anonymity_differential_privacy',
		      },
		    };
		    
		    await this.logDataAction({
		      action: 'anonymize',
		      dataType: 'assessment_results',
		      userId: results.userId,
		      purpose: 'data_protection',
		      legalBasis: 'consent',
		      automated: true,
		    });
		    
		    return anonymized;
		  }
		
		  /**
		   * Create data export package for user (GDPR Article 20)
		   */
		  async createDataExport(
		    userId: string,
		    includeAnalytics = false
		  ): Promise<{
		    personalData: any;
		    assessmentData: any;
		    pairData: any;
		    consentHistory: ConsentRecord[];
		    auditLog: DataAuditLog[];
		    metadata: {
		      exportedAt: string;
		      format: string;
		      completeness: string;
		    };
		  }> {
		    // Validate user consent for data export
		    const canExport = await this.validateConsent(userId, 'dataPortability', 'all_user_data');
		    if (!canExport) {
		      throw new Error('No valid consent for data export');
		    }
		    
		    const exportData = {
		      personalData: await this.getUserPersonalData(userId),
		      assessmentData: await this.getUserAssessmentData(userId),
		      pairData: includeAnalytics ? await this.getUserPairData(userId) : null,
		      consentHistory: this.consentRecords.get(userId) || [],
		      auditLog: this.auditLog.filter(log => log.userId === userId),
		      metadata: {
		        exportedAt: new Date().toISOString(),
		        format: 'JSON',
		        completeness: 'complete',
		      },
		    };
		    
		    await this.logDataAction({
		      action: 'export',
		      dataType: 'complete_user_data',
		      userId,
		      purpose: 'data_portability',
		      legalBasis: 'consent',
		      automated: false,
		    });
		    
		    return exportData;
		  }
		
		  /**
		   * Delete all user data (GDPR Article 17 - Right to Erasure)
		   */
		  async deleteAllUserData(
		    userId: string,
		    reason: 'user_request' | 'consent_withdrawal' | 'retention_expired'
		  ): Promise<void> {
		    try {
		      // Delete assessment data
		      await storageService.removeSecure(`assessment_results_${userId}`);
		      await storageService.removeSecure(`assessment_progress_${userId}`);
		      
		      // Delete pair data
		      await storageService.removeSecure(`pair_data_${userId}`);
		      await storageService.removeSecure(`pair_analytics_${userId}`);
		      
		      // Delete consent records
		      await storageService.removeSecure(`consent_${userId}`);
		      this.consentRecords.delete(userId);
		      
		      // Handle shared pair data
		      await this.handleSharedDataDeletion(userId);
		      
		      await this.logDataAction({
		        action: 'delete',
		        dataType: 'complete_user_data',
		        userId,
		        purpose: `data_erasure_${reason}`,
		        legalBasis: 'consent',
		        automated: reason === 'retention_expired',
		      });
		      
		    } catch (error) {
		      console.error('Failed to delete user data:', error);
		      throw new Error('Data deletion failed');
		    }
		  }
		
		  /**
		   * Check data retention compliance
		   */
		  async checkRetentionCompliance(): Promise<{
		    expiredData: Array<{
		      userId: string;
		      dataType: string;
		      retentionExpiry: string;
		    }>;
		    actionRequired: boolean;
		  }> {
		    const expiredData: any[] = [];
		    const currentDate = new Date();
		    
		    // Check assessment data retention
		    const assessmentKeys = await this.getAllStorageKeys('assessment_');
		    
		    for (const key of assessmentKeys) {
		      const data = await storageService.getSecure(key);
		      if (data && data.createdAt) {
		        const retentionPeriod = this.getRetentionPeriod(data.userId, 'assessment_data');
		        const expiryDate = this.calculateExpiryDate(data.createdAt, retentionPeriod);
		        
		        if (currentDate > expiryDate) {
		          expiredData.push({
		            userId: data.userId,
		            dataType: 'assessment_data',
		            retentionExpiry: expiryDate.toISOString(),
		          });
		        }
		      }
		    }
		    
		    return {
		      expiredData,
		      actionRequired: expiredData.length > 0,
		    };
		  }
		
		  /**
		   * Generate data processing impact assessment
		   */
		  async generateDPIA(): Promise<{
		    riskLevel: 'low' | 'medium' | 'high';
		    risks: Array<{
		      category: string;
		      description: string;
		      likelihood: number;
		      impact: number;
		      mitigations: string[];
		    }>;
		    recommendations: string[];
		    lastUpdated: string;
		  }> {
		    const risks = [
		      {
		        category: 'Data Breach',
		        description: 'Unauthorized access to assessment data',
		        likelihood: 0.2,
		        impact: 0.8,
		        mitigations: [
		          'End-to-end encryption',
		          'Secure storage tiers',
		          'Access logging',
		          'Regular security audits',
		        ],
		      },
		      {
		        category: 'Re-identification',
		        description: 'Identifying users from anonymized data',
		        likelihood: 0.3,
		        impact: 0.6,
		        mitigations: [
		          'K-anonymity algorithms',
		          'Differential privacy',
		          'Data generalization',
		          'Regular anonymization review',
		        ],
		      },
		      {
		        category: 'Consent Violations',
		        description: 'Processing data without valid consent',
		        likelihood: 0.1,
		        impact: 0.9,
		        mitigations: [
		          'Consent validation checks',
		          'Automated consent monitoring',
		          'Regular consent audits',
		          'Clear consent mechanisms',
		        ],
		      },
		    ];
		    
		    const riskScores = risks.map(risk => risk.likelihood * risk.impact);
		    const maxRisk = Math.max(...riskScores);
		    
		    let riskLevel: 'low' | 'medium' | 'high' = 'low';
		    if (maxRisk > 0.6) riskLevel = 'high';
		    else if (maxRisk > 0.3) riskLevel = 'medium';
		    
		    const recommendations = [
		      'Implement regular privacy training',
		      'Conduct quarterly privacy audits',
		      'Update privacy notices annually',
		      'Monitor data processing activities',
		      'Implement privacy by design principles',
		    ];
		    
		    return {
		      riskLevel,
		      risks,
		      recommendations,
		      lastUpdated: new Date().toISOString(),
		    };
		  }
		
		  /**
		   * Get data inventory for compliance reporting
		   */
		  async getDataInventory(): Promise<DataInventory> {
		    return {
		      personalData: [
		        {
		          category: 'User Profile',
		          fields: ['name', 'email', 'phone', 'dateOfBirth', 'location'],
		          purpose: 'User identification and twin pairing',
		          legalBasis: 'consent',
		          retentionPeriod: '5 years or until deletion request',
		          sharing: ['Twin pair only'],
		        },
		        {
		          category: 'Assessment Responses',
		          fields: ['questionResponses', 'scores', 'timestamps'],
		          purpose: 'Personality assessment and twin analytics',
		          legalBasis: 'consent',
		          retentionPeriod: 'User-defined or until deletion request',
		          sharing: ['Research (anonymized)', 'Twin pair (with consent)'],
		        },
		      ],
		      sensitiveData: [
		        {
		          category: 'Psychological Data',
		          fields: ['personalityScores', 'behavioralPatterns', 'emotionalProfiles'],
		          purpose: 'Twin compatibility analysis',
		          safeguards: ['End-to-end encryption', 'Access controls', 'Audit logging'],
		        },
		      ],
		      processedData: [
		        {
		          type: 'Pair Analytics',
		          source: 'Twin assessment data',
		          processing: 'Similarity and complementarity algorithms',
		          output: 'Compatibility scores and insights',
		        },
		        {
		          type: 'Anonymized Research Data',
		          source: 'User assessment data',
		          processing: 'Anonymization and aggregation',
		          output: 'Research insights and trends',
		        },
		      ],
		    };
		  }
		
		  // Private helper methods
		  private async logDataAction(
		    action: Omit<DataAuditLog, 'id' | 'timestamp'>
		  ): Promise<void> {
		    const logEntry: DataAuditLog = {
		      id: `log_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
		      timestamp: new Date().toISOString(),
		      ...action,
		    };
		    
		    this.auditLog.push(logEntry);
		    
		    // Keep only recent entries to prevent memory issues
		    if (this.auditLog.length > 10000) {
		      this.auditLog = this.auditLog.slice(-5000);
		    }
		    
		    // Persist audit log
		    await storageService.set('privacy_audit_log', this.auditLog);
		  }
		
		  private generateAnonymousId(): string {
		    return `anon_${Date.now().toString(36)}_${Math.random().toString(36).substr(2, 8)}`;
		  }
		
		  private anonymizeTimestamp(
		    timestamp: string,
		    level: 'basic' | 'enhanced' | 'full'
		  ): string {
		    const date = new Date(timestamp);
		    
		    switch (level) {
		      case 'basic':
		        // Round to nearest day
		        return new Date(date.getFullYear(), date.getMonth(), date.getDate()).toISOString();
		      case 'enhanced':
		        // Round to nearest month
		        return new Date(date.getFullYear(), date.getMonth(), 1).toISOString();
		      case 'full':
		        // Round to nearest year
		        return new Date(date.getFullYear(), 0, 1).toISOString();
		    }
		  }
		
		  private generalizeScore(
		    score: number,
		    level: 'basic' | 'enhanced' | 'full'
		  ): number {
		    switch (level) {
		      case 'basic':
		        return Math.round(score / 5) * 5; // Round to nearest 5
		      case 'enhanced':
		        return Math.round(score / 10) * 10; // Round to nearest 10
		      case 'full':
		        return Math.round(score / 25) * 25; // Round to nearest 25
		    }
		  }
		
		  private addNoise(value: number, noiseLevel: number): number {
		    const noise = (Math.random() - 0.5) * 2 * noiseLevel;
		    return Math.max(0, Math.min(1, value + noise));
		  }
		
		  private anonymizeInsights(insights: string[]): string[] {
		    return insights.map(insight => 
		      insight.replace(/\b(high|low|strong|weak)\s+/gi, 'notable ')
		            .replace(/\b(very|extremely|significantly)\s+/gi, '')
		            .replace(/\b\d+\.?\d*%/g, 'X%')
		    );
		  }
		
		  private anonymizeRecommendations(recommendations: string[]): string[] {
		    return recommendations.map(rec => 
		      rec.replace(/\b(you|your)\b/gi, 'users')
		         .replace(/\b(twin|sibling)\b/gi, 'pair member')
		    );
		  }
		
		  private async handleDataMergingWithdrawal(userId: string): Promise<void> {
		    // Remove user from any existing pairs
		    const pairKeys = await this.getAllStorageKeys('pair_');
		    
		    for (const key of pairKeys) {
		      const pairData = await storageService.getSecure(key);
		      if (pairData && (pairData.twin1Id === userId || pairData.twin2Id === userId)) {
		        // Mark pair as consent-withdrawn
		        pairData.bothConsented = false;
		        pairData.withdrawnAt = new Date().toISOString();
		        await storageService.setSecure(key, pairData);
		        
		        // Delete merged analytics
		        await storageService.removeSecure(`pair_analytics_${pairData.pairId}`);
		      }
		    }
		  }
		
		  private async handleSharedDataDeletion(userId: string): Promise<void> {
		    // Handle deletion when user data is part of pair analytics
		    const pairKeys = await this.getAllStorageKeys('pair_analytics_');
		    
		    for (const key of pairKeys) {
		      const analytics = await storageService.getSecure(key);
		      if (analytics && analytics.involvedUsers && analytics.involvedUsers.includes(userId)) {
		        // Anonymize the remaining data or delete if both users are gone
		        const remainingUsers = analytics.involvedUsers.filter((id: string) => id !== userId);
		        
		        if (remainingUsers.length === 0) {
		          await storageService.removeSecure(key);
		        } else {
		          // Anonymize the data for remaining user
		          const anonymizedAnalytics = await this.anonymizeAssessmentData(analytics, 'full');
		          await storageService.setSecure(key, anonymizedAnalytics);
		        }
		      }
		    }
		  }
		
		  private async getUserPersonalData(userId: string): Promise<any> {
		    // Retrieve all personal data for the user
		    const keys = await this.getAllStorageKeys(`user_${userId}`);
		    const personalData: any = {};
		    
		    for (const key of keys) {
		      const data = await storageService.getSecure(key);
		      if (data) {
		        personalData[key] = data;
		      }
		    }
		    
		    return personalData;
		  }
		
		  private async getUserAssessmentData(userId: string): Promise<any> {
		    // Retrieve assessment data for the user
		    return await storageService.getSecure(`assessment_results_${userId}`);
		  }
		
		  private async getUserPairData(userId: string): Promise<any> {
		    // Retrieve pair data for the user
		    return await storageService.getSecure(`pair_data_${userId}`);
		  }
		
		  private async getAllStorageKeys(prefix: string): Promise<string[]> {
		    // Mock implementation - would use actual storage key enumeration
		    return [];
		  }
		
		  private getRetentionPeriod(userId: string, dataType: string): string {
		    // Get user-specific retention period or default
		    return '5years'; // Default
		  }
		
		  private calculateExpiryDate(createdAt: string, retention: string): Date {
		    const created = new Date(createdAt);
		    
		    switch (retention) {
		      case '1year':
		        return new Date(created.getTime() + 365 * 24 * 60 * 60 * 1000);
		      case '5years':
		        return new Date(created.getTime() + 5 * 365 * 24 * 60 * 60 * 1000);
		      case 'indefinite':
		        return new Date('9999-12-31');
		      default:
		        return new Date('9999-12-31');
		    }
		  }
		}
		
		// Export singleton instance
		export const dataPrivacyManager = new DataPrivacyManager();
		
		// Export utility functions
		export {
		  DataPrivacyManager,
		};
		
		/**
		 * Initialize privacy compliance checks
		 */
		export async function initializePrivacyCompliance(): Promise<void> {
		  // Run retention compliance check
		  const compliance = await dataPrivacyManager.checkRetentionCompliance();
		  
		  if (compliance.actionRequired) {
		    console.log('Privacy compliance action required:', compliance.expiredData.length, 'expired items');
		    // Handle expired data according to policy
		  }
		  
		  // Schedule regular compliance checks
		  setInterval(async () => {
		    await dataPrivacyManager.checkRetentionCompliance();
		  }, 24 * 60 * 60 * 1000); // Daily check
		}
		
		/**
		 * Validate data processing legality
		 */
		export async function validateProcessingLegality(
		  userId: string,
		  processingType: string,
		  dataTypes: string[]
		): Promise<{
		  legal: boolean;
		  basis: string;
		  restrictions: string[];
		}> {
		  const legal = await dataPrivacyManager.validateConsent(userId, processingType, dataTypes.join(','));
		  
		  return {
		    legal,
		    basis: legal ? 'consent' : 'no_legal_basis',
		    restrictions: legal ? [] : ['Obtain valid consent before processing'],
		  };
		}]]></file>
	<file path='utils/neonColors.ts'>
		import { ThemeColor } from "../state/twinStore";
		
		export const getNeonAccentColor = (theme: ThemeColor): string => {
		  switch (theme) {
		    case "neon-pink":
		      return "#ff1493";
		    case "neon-blue":
		      return "#00bfff";
		    case "neon-green":
		      return "#00ff7f";
		    case "neon-yellow":
		      return "#ffff00";
		    case "neon-purple":
		      return "#8a2be2";
		    case "neon-orange":
		      return "#ff4500";
		    case "neon-cyan":
		      return "#00ffff";
		    case "neon-red":
		      return "#ff0000";
		    default:
		      return "#8a2be2";
		  }
		};
		
		export const getNeonAccentColorWithOpacity = (theme: ThemeColor, opacity: number = 0.3): string => {
		  const color = getNeonAccentColor(theme);
		  // Convert hex to rgba
		  const r = parseInt(color.slice(1, 3), 16);
		  const g = parseInt(color.slice(3, 5), 16);
		  const b = parseInt(color.slice(5, 7), 16);
		  return `rgba(${r}, ${g}, ${b}, ${opacity})`;
		};
		
		export const getNeonGradientColors = (theme: ThemeColor): [string, string, string] => {
		  switch (theme) {
		    case "neon-pink":
		      return ["#ff1493", "#ff69b4", "#ffb6c1"];
		    case "neon-blue":
		      return ["#00bfff", "#1e90ff", "#87cefa"];
		    case "neon-green":
		      return ["#00ff7f", "#32cd32", "#90ee90"];
		    case "neon-yellow":
		      return ["#ffff00", "#ffd700", "#ffffe0"];
		    case "neon-purple":
		      return ["#8a2be2", "#9370db", "#dda0dd"];
		    case "neon-orange":
		      return ["#ff4500", "#ff8c00", "#ffa500"];
		    case "neon-cyan":
		      return ["#00ffff", "#40e0d0", "#afeeee"];
		    case "neon-red":
		      return ["#ff0000", "#dc143c", "#ffa07a"];
		    default:
		      return ["#8a2be2", "#9370db", "#dda0dd"];
		  }
		};</file>
	<file path='utils/numerologyService.ts'><![CDATA[
		/**
		 * Numerology Reading Service
		 * Generates personalized numerology profiles and twin number connections
		 */
		
		export interface NumerologyData {
		  fullName: string;
		  dateOfBirth: Date;
		}
		
		export interface LifePathNumber {
		  number: number;
		  isMasterNumber: boolean;
		  title: string;
		  description: string;
		  traits: string[];
		  challenges: string[];
		  purpose: string;
		  compatibility: number[];
		}
		
		export interface NumerologyProfile {
		  id: string;
		  userId: string;
		  generatedAt: string;
		  
		  // Core numbers
		  lifePath: LifePathNumber;
		  expression: LifePathNumber;
		  soulUrge: LifePathNumber;
		  personality: LifePathNumber;
		  birthday: LifePathNumber;
		  
		  // Name analysis
		  cornerstone: {
		    letter: string;
		    meaning: string;
		  };
		  capstone: {
		    letter: string;
		    meaning: string;
		  };
		  
		  // Special numbers
		  karmic: number[];
		  hidden: number[];
		  
		  // Personal insights
		  strengths: string[];
		  challenges: string[];
		  opportunities: string[];
		  lifeThemes: string[];
		}
		
		export interface TwinNumerology {
		  pairId: string;
		  twin1Profile: string;
		  twin2Profile: string;
		  generatedAt: string;
		  
		  // Compatibility analysis
		  lifePathCompatibility: number; // 0-100
		  expressionHarmony: number;
		  soulConnection: number;
		  personalityBalance: number;
		  overallSynergy: number;
		  
		  // Special twin connections
		  masterNumberConnections: Array<{
		    type: 'shared' | 'complementary' | 'mirror';
		    numbers: number[];
		    meaning: string;
		  }>;
		  
		  // Karmic connections
		  karmicBonds: Array<{
		    description: string;
		    strength: 'Strong' | 'Moderate' | 'Subtle';
		  }>;
		  
		  // Twin flame indicators
		  numerologyMarkers: Array<{
		    indicator: string;
		    present: boolean;
		    significance: string;
		  }>;
		  
		  // Relationship insights
		  strengths: string[];
		  challenges: string[];
		  guidance: string[];
		  soulPurpose: string[];
		}
		
		// Life Path Number definitions
		export const LIFE_PATH_MEANINGS: Record<number, LifePathNumber> = {
		  1: {
		    number: 1,
		    isMasterNumber: false,
		    title: "The Leader",
		    description: "Independent pioneer with natural leadership abilities and strong drive for success",
		    traits: ["Independent", "Ambitious", "Creative", "Strong-willed", "Original"],
		    challenges: ["Impatience", "Stubbornness", "Self-centeredness"],
		    purpose: "To lead and inspire others while developing self-reliance",
		    compatibility: [1, 5, 7]
		  },
		  2: {
		    number: 2,
		    isMasterNumber: false,
		    title: "The Diplomat",
		    description: "Natural peacemaker with intuitive understanding of relationships and cooperation",
		    traits: ["Cooperative", "Diplomatic", "Intuitive", "Gentle", "Supportive"],
		    challenges: ["Over-sensitivity", "Indecisiveness", "Self-doubt"],
		    purpose: "To bring harmony and balance to relationships and situations",
		    compatibility: [2, 4, 8]
		  },
		  3: {
		    number: 3,
		    isMasterNumber: false,
		    title: "The Creative Communicator",
		    description: "Artistic and expressive soul with natural gifts for communication and creativity",
		    traits: ["Creative", "Expressive", "Optimistic", "Social", "Inspiring"],
		    challenges: ["Scattered energy", "Superficiality", "Criticism sensitivity"],
		    purpose: "To inspire and uplift others through creative expression",
		    compatibility: [3, 6, 9]
		  },
		  4: {
		    number: 4,
		    isMasterNumber: false,
		    title: "The Builder",
		    description: "Practical and hardworking individual who creates stable foundations",
		    traits: ["Reliable", "Organized", "Patient", "Loyal", "Systematic"],
		    challenges: ["Rigidity", "Narrow-mindedness", "Workaholism"],
		    purpose: "To create lasting structures and systems that benefit others",
		    compatibility: [2, 4, 8]
		  },
		  5: {
		    number: 5,
		    isMasterNumber: false,
		    title: "The Adventurer",
		    description: "Freedom-loving spirit with insatiable curiosity and need for variety",
		    traits: ["Adventurous", "Curious", "Versatile", "Progressive", "Dynamic"],
		    challenges: ["Restlessness", "Irresponsibility", "Lack of focus"],
		    purpose: "To experience freedom and help others break limiting boundaries",
		    compatibility: [1, 5, 7]
		  },
		  6: {
		    number: 6,
		    isMasterNumber: false,
		    title: "The Nurturer",
		    description: "Caring and responsible soul dedicated to family, home, and community service",
		    traits: ["Nurturing", "Responsible", "Compassionate", "Healing", "Protective"],
		    challenges: ["Over-responsibility", "Martyrdom", "Perfectionism"],
		    purpose: "To nurture and heal others while creating harmonious environments",
		    compatibility: [3, 6, 9]
		  },
		  7: {
		    number: 7,
		    isMasterNumber: false,
		    title: "The Seeker",
		    description: "Spiritual and analytical mind seeking truth, wisdom, and deeper understanding",
		    traits: ["Analytical", "Intuitive", "Spiritual", "Reserved", "Perfectionist"],
		    challenges: ["Isolation", "Skepticism", "Overthinking"],
		    purpose: "To seek truth and share wisdom with the world",
		    compatibility: [1, 5, 7]
		  },
		  8: {
		    number: 8,
		    isMasterNumber: false,
		    title: "The Achiever",
		    description: "Ambitious and material-focused individual with strong business acumen",
		    traits: ["Ambitious", "Authoritative", "Material", "Efficient", "Organized"],
		    challenges: ["Materialism", "Impatience", "Workaholism"],
		    purpose: "To achieve material success while maintaining spiritual balance",
		    compatibility: [2, 4, 8]
		  },
		  9: {
		    number: 9,
		    isMasterNumber: false,
		    title: "The Humanitarian",
		    description: "Compassionate and generous soul dedicated to serving humanity",
		    traits: ["Humanitarian", "Generous", "Compassionate", "Artistic", "Wise"],
		    challenges: ["Emotional extremes", "Self-pity", "Aimlessness"],
		    purpose: "To serve humanity and contribute to global healing",
		    compatibility: [3, 6, 9]
		  },
		  11: {
		    number: 11,
		    isMasterNumber: true,
		    title: "The Illuminator",
		    description: "Highly intuitive and inspirational soul with psychic abilities and spiritual mission",
		    traits: ["Intuitive", "Inspirational", "Psychic", "Charismatic", "Visionary"],
		    challenges: ["Nervous energy", "Self-doubt", "Emotional intensity"],
		    purpose: "To illuminate and inspire others toward spiritual awakening",
		    compatibility: [11, 22, 33]
		  },
		  22: {
		    number: 22,
		    isMasterNumber: true,
		    title: "The Master Builder",
		    description: "Powerful manifestor capable of turning dreams into concrete reality",
		    traits: ["Visionary", "Practical", "Powerful", "Organized", "Inspirational"],
		    challenges: ["Pressure", "Self-doubt", "Overwhelming responsibility"],
		    purpose: "To build something of lasting value that benefits humanity",
		    compatibility: [11, 22, 33]
		  },
		  33: {
		    number: 33,
		    isMasterNumber: true,
		    title: "The Master Teacher",
		    description: "Highly evolved soul dedicated to uplifting and healing others",
		    traits: ["Compassionate", "Healing", "Teaching", "Selfless", "Inspiring"],
		    challenges: ["Martyrdom", "Emotional overwhelm", "Self-sacrifice"],
		    purpose: "To heal and teach others with unconditional love",
		    compatibility: [11, 22, 33]
		  }
		};
		
		/**
		 * Calculate digit root (reduce to single digit or master number)
		 */
		export const calculateDigitRoot = (num: number): number => {
		  while (num > 9 && num !== 11 && num !== 22 && num !== 33) {
		    num = num.toString().split('').reduce((sum, digit) => sum + parseInt(digit), 0);
		  }
		  return num;
		};
		
		/**
		 * Calculate Life Path Number from birth date
		 */
		export const calculateLifePathNumber = (birthDate: Date): number => {
		  const year = birthDate.getFullYear();
		  const month = birthDate.getMonth() + 1;
		  const day = birthDate.getDate();
		  
		  const total = year + month + day;
		  return calculateDigitRoot(total);
		};
		
		/**
		 * Calculate Expression Number from full name
		 */
		export const calculateExpressionNumber = (fullName: string): number => {
		  const letterValues: Record<string, number> = {
		    A: 1, B: 2, C: 3, D: 4, E: 5, F: 6, G: 7, H: 8, I: 9,
		    J: 1, K: 2, L: 3, M: 4, N: 5, O: 6, P: 7, Q: 8, R: 9,
		    S: 1, T: 2, U: 3, V: 4, W: 5, X: 6, Y: 7, Z: 8
		  };
		  
		  const total = fullName
		    .toUpperCase()
		    .replace(/[^A-Z]/g, '')
		    .split('')
		    .reduce((sum, letter) => sum + (letterValues[letter] || 0), 0);
		  
		  return calculateDigitRoot(total);
		};
		
		/**
		 * Calculate Soul Urge Number from vowels in name
		 */
		export const calculateSoulUrgeNumber = (fullName: string): number => {
		  const vowelValues: Record<string, number> = {
		    A: 1, E: 5, I: 9, O: 6, U: 3, Y: 7
		  };
		  
		  const total = fullName
		    .toUpperCase()
		    .split('')
		    .reduce((sum, letter) => sum + (vowelValues[letter] || 0), 0);
		  
		  return calculateDigitRoot(total);
		};
		
		/**
		 * Calculate Personality Number from consonants in name
		 */
		export const calculatePersonalityNumber = (fullName: string): number => {
		  const consonantValues: Record<string, number> = {
		    B: 2, C: 3, D: 4, F: 6, G: 7, H: 8,
		    J: 1, K: 2, L: 3, M: 4, N: 5, P: 7, Q: 8, R: 9,
		    S: 1, T: 2, V: 4, W: 5, X: 6, Z: 8
		  };
		  
		  const total = fullName
		    .toUpperCase()
		    .split('')
		    .reduce((sum, letter) => sum + (consonantValues[letter] || 0), 0);
		  
		  return calculateDigitRoot(total);
		};
		
		/**
		 * Generate complete numerology profile
		 */
		export const generateNumerologyProfile = async (data: NumerologyData): Promise<NumerologyProfile> => {
		  const lifePathNum = calculateLifePathNumber(data.dateOfBirth);
		  const expressionNum = calculateExpressionNumber(data.fullName);
		  const soulUrgeNum = calculateSoulUrgeNumber(data.fullName);
		  const personalityNum = calculatePersonalityNumber(data.fullName);
		  const birthdayNum = calculateDigitRoot(data.dateOfBirth.getDate());
		  
		  const cleanName = data.fullName.toUpperCase().replace(/[^A-Z]/g, '');
		  
		  return {
		    id: `numerology-${data.fullName}-${Date.now()}`,
		    userId: data.fullName,
		    generatedAt: new Date().toISOString(),
		    lifePath: LIFE_PATH_MEANINGS[lifePathNum],
		    expression: LIFE_PATH_MEANINGS[expressionNum] || LIFE_PATH_MEANINGS[1],
		    soulUrge: LIFE_PATH_MEANINGS[soulUrgeNum] || LIFE_PATH_MEANINGS[1],
		    personality: LIFE_PATH_MEANINGS[personalityNum] || LIFE_PATH_MEANINGS[1],
		    birthday: LIFE_PATH_MEANINGS[birthdayNum] || LIFE_PATH_MEANINGS[1],
		    cornerstone: {
		      letter: cleanName[0] || 'A',
		      meaning: 'Your approach to new experiences and challenges'
		    },
		    capstone: {
		      letter: cleanName[cleanName.length - 1] || 'A',
		      meaning: 'How you complete projects and handle endings'
		    },
		    karmic: [], // Could add karmic debt calculations
		    hidden: [], // Could add hidden passion numbers
		    strengths: [
		      ...LIFE_PATH_MEANINGS[lifePathNum].traits.slice(0, 3),
		      ...LIFE_PATH_MEANINGS[expressionNum]?.traits.slice(0, 2) || []
		    ],
		    challenges: [
		      ...LIFE_PATH_MEANINGS[lifePathNum].challenges,
		      ...LIFE_PATH_MEANINGS[soulUrgeNum]?.challenges.slice(0, 1) || []
		    ],
		    opportunities: [
		      `Develop your ${LIFE_PATH_MEANINGS[lifePathNum].title.toLowerCase()} qualities`,
		      `Express your ${LIFE_PATH_MEANINGS[expressionNum]?.title.toLowerCase() || 'creative'} nature`,
		      `Honor your ${LIFE_PATH_MEANINGS[soulUrgeNum]?.title.toLowerCase() || 'inner'} desires`
		    ],
		    lifeThemes: [
		      LIFE_PATH_MEANINGS[lifePathNum].purpose,
		      `Personal expression through ${LIFE_PATH_MEANINGS[expressionNum]?.title.toLowerCase() || 'leadership'}`,
		      `Soul fulfillment via ${LIFE_PATH_MEANINGS[soulUrgeNum]?.title.toLowerCase() || 'service'}`
		    ]
		  };
		};
		
		/**
		 * Calculate numerology compatibility between twins
		 */
		export const generateTwinNumerology = async (profile1: NumerologyProfile, profile2: NumerologyProfile): Promise<TwinNumerology> => {
		  // Calculate compatibility scores
		  const lifePathComp = calculateNumberCompatibility(profile1.lifePath.number, profile2.lifePath.number);
		  const expressionComp = calculateNumberCompatibility(profile1.expression.number, profile2.expression.number);
		  const soulComp = calculateNumberCompatibility(profile1.soulUrge.number, profile2.soulUrge.number);
		  const personalityComp = calculateNumberCompatibility(profile1.personality.number, profile2.personality.number);
		  
		  const overallSynergy = Math.round((lifePathComp + expressionComp + soulComp + personalityComp) / 4);
		  
		  // Check for master number connections
		  const masterConnections = [];
		  if (profile1.lifePath.isMasterNumber || profile2.lifePath.isMasterNumber) {
		    masterConnections.push({
		      type: 'shared' as const,
		      numbers: [profile1.lifePath.number, profile2.lifePath.number],
		      meaning: 'Elevated spiritual connection and shared higher purpose'
		    });
		  }
		  
		  return {
		    pairId: `twin-numerology-${profile1.userId}-${profile2.userId}`,
		    twin1Profile: profile1.id,
		    twin2Profile: profile2.id,
		    generatedAt: new Date().toISOString(),
		    lifePathCompatibility: lifePathComp,
		    expressionHarmony: expressionComp,
		    soulConnection: soulComp,
		    personalityBalance: personalityComp,
		    overallSynergy,
		    masterNumberConnections: masterConnections,
		    karmicBonds: [
		      {
		        description: 'Past-life connection indicated by complementary life path numbers',
		        strength: 'Strong'
		      },
		      {
		        description: 'Soul contract to grow together spiritually',
		        strength: 'Moderate'
		      }
		    ],
		    numerologyMarkers: [
		      {
		        indicator: 'Mirror Numbers',
		        present: profile1.lifePath.number + profile2.lifePath.number === 11,
		        significance: 'Numbers that add to 11 suggest twin flame connection'
		      },
		      {
		        indicator: 'Master Number Presence',
		        present: profile1.lifePath.isMasterNumber || profile2.lifePath.isMasterNumber,
		        significance: 'Master numbers indicate advanced soul development'
		      },
		      {
		        indicator: 'Complementary Expression',
		        present: Math.abs(profile1.expression.number - profile2.expression.number) <= 3,
		        significance: 'Similar expression numbers suggest harmonious life purpose'
		      }
		    ],
		    strengths: [
		      `Combined ${profile1.lifePath.title} and ${profile2.lifePath.title} energy`,
		      'Balanced approach to life challenges',
		      'Mutual support for individual purposes'
		    ],
		    challenges: [
		      'Potential for mirroring each other\'s numerical weaknesses',
		      'Need to maintain individual identity despite strong connection'
		    ],
		    guidance: [
		      'Embrace your individual life path purposes while supporting each other',
		      'Use your combined numerical strengths to overcome shared challenges',
		      'Honor both unity and independence in your twin journey'
		    ],
		    soulPurpose: [
		      'Learn to balance togetherness with individual growth',
		      'Develop spiritual consciousness through your twin connection',
		      'Serve as an example of harmonious twin relationship'
		    ]
		  };
		};
		
		/**
		 * Calculate compatibility between two numbers
		 */
		const calculateNumberCompatibility = (num1: number, num2: number): number => {
		  // Same numbers have high compatibility
		  if (num1 === num2) return 95;
		  
		  // Master numbers are compatible with each other
		  if ([11, 22, 33].includes(num1) && [11, 22, 33].includes(num2)) return 90;
		  
		  // Check traditional compatibility
		  const compatibilityMap: Record<number, number[]> = {
		    1: [1, 5, 7], 2: [2, 4, 8], 3: [3, 6, 9], 4: [2, 4, 8],
		    5: [1, 5, 7], 6: [3, 6, 9], 7: [1, 5, 7], 8: [2, 4, 8], 9: [3, 6, 9]
		  };
		  
		  if (compatibilityMap[num1]?.includes(num2)) return 85;
		  
		  // Complementary numbers (add to 10)
		  if (num1 + num2 === 10) return 80;
		  
		  // Default moderate compatibility
		  return 65;
		};]]></file>
	<file path='utils/pairAnalytics.ts'><![CDATA[
		import {
		  AssessmentResults,
		  PairAnalytics,
		  AssessmentCategory,
		  SubscaleScore,
		  CompositeScore,
		  Recommendation
		} from '../types/assessment';
		
		/**
		 * Compare twin scores and generate pair analytics
		 */
		export const compareTwinScores = (
		  user1Results: AssessmentResults,
		  user2Results: AssessmentResults
		): PairAnalytics => {
		  const compatibilityScore = calculateCompatibilityScore(user1Results, user2Results);
		  const strengthAreas = identifyStrengthAreas(user1Results, user2Results);
		  const growthAreas = identifyGrowthAreas(user1Results, user2Results);
		  const riskFactors = identifyRiskFactors(user1Results, user2Results);
		  const recommendations = generatePairRecommendations(
		    user1Results,
		    user2Results,
		    growthAreas,
		    riskFactors
		  );
		
		  return {
		    user1Id: user1Results.userId,
		    user2Id: user2Results.userId,
		    compatibilityScore,
		    strengthAreas,
		    growthAreas,
		    riskFactors,
		    recommendations
		  };
		};
		
		/**
		 * Calculate overall compatibility score between twins
		 */
		const calculateCompatibilityScore = (
		  user1Results: AssessmentResults,
		  user2Results: AssessmentResults
		): number => {
		  let totalDifference = 0;
		  let categoryCount = 0;
		
		  // Compare subscale scores
		  user1Results.subscaleScores.forEach(score1 => {
		    const score2 = user2Results.subscaleScores.find(
		      s => s.category === score1.category
		    );
		    if (score2) {
		      // Weight certain categories more heavily
		      const weight = getCategoryWeight(score1.category);
		      const difference = Math.abs(score1.scaledScore - score2.scaledScore);
		      
		      // Invert difference for compatibility (smaller difference = higher compatibility)
		      const categoryCompatibility = 100 - difference;
		      totalDifference += categoryCompatibility * weight;
		      categoryCount += weight;
		    }
		  });
		
		  // Factor in composite indices
		  const ciDiff = Math.abs(
		    (user1Results.compositeScores.find(s => s.index === 'CI')?.value || 0) -
		    (user2Results.compositeScores.find(s => s.index === 'CI')?.value || 0)
		  );
		  
		  const ariDiff = Math.abs(
		    (user1Results.compositeScores.find(s => s.index === 'ARI')?.value || 0) -
		    (user2Results.compositeScores.find(s => s.index === 'ARI')?.value || 0)
		  );
		
		  // Penalize large differences in codependency and resilience
		  const indexPenalty = (ciDiff > 30 || ariDiff > 30) ? 10 : 0;
		
		  const baseCompatibility = categoryCount > 0 ? totalDifference / categoryCount : 50;
		  return Math.max(0, Math.min(100, baseCompatibility - indexPenalty));
		};
		
		/**
		 * Get category weight for compatibility calculation
		 */
		const getCategoryWeight = (category: AssessmentCategory): number => {
		  const weights: Partial<Record<AssessmentCategory, number>> = {
		    communication: 2.0,
		    conflict_resolution: 2.0,
		    boundaries: 1.8,
		    autonomy: 1.5,
		    codependency: 1.8,
		    partner_inclusion: 1.5,
		    attachment: 1.3,
		    identity_fusion: 1.5,
		    differentiation: 1.3,
		    power_dynamics: 1.5,
		    // Big Five traits have lower weights
		    openness: 0.8,
		    conscientiousness: 0.8,
		    extraversion: 0.7,
		    agreeableness: 0.9,
		    neuroticism: 1.0
		  };
		  
		  return weights[category] || 1.0;
		};
		
		/**
		 * Identify areas where both twins score well
		 */
		const identifyStrengthAreas = (
		  user1Results: AssessmentResults,
		  user2Results: AssessmentResults
		): AssessmentCategory[] => {
		  const strengths: AssessmentCategory[] = [];
		
		  user1Results.subscaleScores.forEach(score1 => {
		    const score2 = user2Results.subscaleScores.find(
		      s => s.category === score1.category
		    );
		    
		    if (score2) {
		      const isPositiveCategory = [
		        'autonomy', 'boundaries', 'communication', 'differentiation',
		        'conflict_resolution', 'openness', 'conscientiousness', 'agreeableness'
		      ].includes(score1.category);
		      
		      const isNegativeCategory = [
		        'codependency', 'identity_fusion', 'neuroticism'
		      ].includes(score1.category);
		
		      if (isPositiveCategory && score1.scaledScore > 60 && score2.scaledScore > 60) {
		        strengths.push(score1.category);
		      } else if (isNegativeCategory && score1.scaledScore < 40 && score2.scaledScore < 40) {
		        strengths.push(score1.category);
		      }
		    }
		  });
		
		  return strengths;
		};
		
		/**
		 * Identify areas needing improvement for both twins
		 */
		const identifyGrowthAreas = (
		  user1Results: AssessmentResults,
		  user2Results: AssessmentResults
		): AssessmentCategory[] => {
		  const growthAreas: AssessmentCategory[] = [];
		
		  user1Results.subscaleScores.forEach(score1 => {
		    const score2 = user2Results.subscaleScores.find(
		      s => s.category === score1.category
		    );
		    
		    if (score2) {
		      const isPositiveCategory = [
		        'autonomy', 'boundaries', 'communication', 'differentiation',
		        'conflict_resolution', 'openness', 'conscientiousness', 'agreeableness'
		      ].includes(score1.category);
		      
		      const isNegativeCategory = [
		        'codependency', 'identity_fusion', 'neuroticism'
		      ].includes(score1.category);
		
		      // Both twins struggle in positive areas
		      if (isPositiveCategory && score1.scaledScore < 40 && score2.scaledScore < 40) {
		        growthAreas.push(score1.category);
		      } 
		      // Both twins score high in negative areas
		      else if (isNegativeCategory && score1.scaledScore > 60 && score2.scaledScore > 60) {
		        growthAreas.push(score1.category);
		      }
		      // Large discrepancy between twins (>30 points)
		      else if (Math.abs(score1.scaledScore - score2.scaledScore) > 30) {
		        growthAreas.push(score1.category);
		      }
		    }
		  });
		
		  return growthAreas;
		};
		
		/**
		 * Identify risk factors in the twin relationship
		 */
		const identifyRiskFactors = (
		  user1Results: AssessmentResults,
		  user2Results: AssessmentResults
		): string[] => {
		  const risks: string[] = [];
		
		  // Check composite indices
		  const ci1 = user1Results.compositeScores.find(s => s.index === 'CI')?.value || 0;
		  const ci2 = user2Results.compositeScores.find(s => s.index === 'CI')?.value || 0;
		  const ari1 = user1Results.compositeScores.find(s => s.index === 'ARI')?.value || 0;
		  const ari2 = user2Results.compositeScores.find(s => s.index === 'ARI')?.value || 0;
		  const trs1 = user1Results.compositeScores.find(s => s.index === 'TRS')?.value || 0;
		  const trs2 = user2Results.compositeScores.find(s => s.index === 'TRS')?.value || 0;
		
		  // Both highly codependent
		  if (ci1 > 70 && ci2 > 70) {
		    risks.push('Severe mutual codependency requiring professional support');
		  }
		
		  // Both low resilience
		  if (ari1 < 30 && ari2 < 30) {
		    risks.push('Very low collective resilience - vulnerable to stress');
		  }
		
		  // Both high transition risk
		  if (trs1 > 70 && trs2 > 70) {
		    risks.push('Extreme vulnerability to life changes');
		  }
		
		  // Power imbalance
		  const powerDynamics1 = user1Results.subscaleScores.find(
		    s => s.category === 'power_dynamics'
		  )?.scaledScore || 50;
		  const powerDynamics2 = user2Results.subscaleScores.find(
		    s => s.category === 'power_dynamics'
		  )?.scaledScore || 50;
		  
		  if (Math.abs(powerDynamics1 - powerDynamics2) > 40) {
		    risks.push('Significant power imbalance in relationship');
		  }
		
		  // Communication breakdown
		  const comm1 = user1Results.subscaleScores.find(
		    s => s.category === 'communication'
		  )?.scaledScore || 50;
		  const comm2 = user2Results.subscaleScores.find(
		    s => s.category === 'communication'
		  )?.scaledScore || 50;
		  
		  if (comm1 < 30 && comm2 < 30) {
		    risks.push('Critical communication breakdown');
		  }
		
		  // Partner inclusion issues
		  const partner1 = user1Results.subscaleScores.find(
		    s => s.category === 'partner_inclusion'
		  )?.scaledScore || 50;
		  const partner2 = user2Results.subscaleScores.find(
		    s => s.category === 'partner_inclusion'
		  )?.scaledScore || 50;
		  
		  if (partner1 < 30 || partner2 < 30) {
		    risks.push('Romantic relationships likely to cause conflict');
		  }
		
		  return risks;
		};
		
		/**
		 * Generate recommendations for the twin pair
		 */
		const generatePairRecommendations = (
		  user1Results: AssessmentResults,
		  user2Results: AssessmentResults,
		  growthAreas: AssessmentCategory[],
		  riskFactors: string[]
		): Recommendation[] => {
		  const recommendations: Recommendation[] = [];
		
		  // Address critical risk factors first
		  if (riskFactors.includes('Severe mutual codependency requiring professional support')) {
		    recommendations.push({
		      id: 'PAIR001',
		      title: 'Seek Professional Twin Therapy',
		      description: 'Your mutual codependency levels indicate you would both benefit from specialized twin therapy to develop healthier patterns.',
		      category: 'codependency',
		      priority: 'high',
		      microExperiment: {
		        id: 'ME_PAIR001',
		        title: 'Therapy Preparation Exercise',
		        duration: '1 week',
		        instructions: [
		          'Each twin writes down 3 things they love about being twins',
		          'Each twin writes down 3 things that feel difficult about being twins',
		          'Share lists with each other without judgment',
		          'Identify one pattern you both want to change',
		          'Research twin-aware therapists in your area'
		        ],
		        expectedOutcome: 'Readiness for therapeutic intervention',
		        trackingMetrics: ['openness_to_change', 'mutual_understanding', 'commitment_level']
		      }
		    });
		  }
		
		  // Address communication issues
		  if (growthAreas.includes('communication')) {
		    recommendations.push({
		      id: 'PAIR002',
		      title: 'Daily Check-In Ritual',
		      description: 'Establish a structured communication practice to improve your connection.',
		      category: 'communication',
		      priority: 'high',
		      microExperiment: {
		        id: 'ME_PAIR002',
		        title: '5-Minute Daily Check-In',
		        duration: '2 weeks',
		        instructions: [
		          'Set a daily 5-minute timer for check-ins',
		          'Each twin shares for 2 minutes without interruption',
		          'Use "I feel..." statements only',
		          'No advice giving - just listening',
		          'End with one appreciation for each other'
		        ],
		        expectedOutcome: 'Improved emotional attunement',
		        trackingMetrics: ['consistency', 'emotional_expression', 'listening_quality']
		      }
		    });
		  }
		
		  // Address boundary issues
		  if (growthAreas.includes('boundaries')) {
		    recommendations.push({
		      id: 'PAIR003',
		      title: 'Boundary Negotiation Workshop',
		      description: 'Work together to establish mutually respectful boundaries.',
		      category: 'boundaries',
		      priority: 'medium',
		      microExperiment: {
		        id: 'ME_PAIR003',
		        title: 'Weekly Boundary Meeting',
		        duration: '4 weeks',
		        instructions: [
		          'Meet weekly to discuss one boundary topic',
		          'Week 1: Privacy boundaries',
		          'Week 2: Social boundaries',
		          'Week 3: Time boundaries',
		          'Week 4: Emotional boundaries',
		          'Create written agreements for each area'
		        ],
		        expectedOutcome: 'Clear, mutually agreed boundaries',
		        trackingMetrics: ['agreement_clarity', 'boundary_respect', 'conflict_reduction']
		      }
		    });
		  }
		
		  // Address autonomy development
		  if (growthAreas.includes('autonomy')) {
		    recommendations.push({
		      id: 'PAIR004',
		      title: 'Independence Challenge',
		      description: 'Support each other in developing individual interests and identities.',
		      category: 'autonomy',
		      priority: 'medium',
		      microExperiment: {
		        id: 'ME_PAIR004',
		        title: 'Solo Adventure Month',
		        duration: '30 days',
		        instructions: [
		          'Each twin chooses a new solo activity or hobby',
		          'Dedicate 3 hours per week to this activity',
		          'Keep a journal about the experience',
		          'Share highlights weekly without seeking approval',
		          'Celebrate each other\'s individual growth'
		        ],
		        expectedOutcome: 'Increased comfort with independence',
		        trackingMetrics: ['individual_confidence', 'twin_support', 'identity_development']
		      }
		    });
		  }
		
		  return recommendations;
		};
		
		/**
		 * Calculate compatibility metrics for specific areas
		 */
		export const calculateCompatibilityMetrics = (
		  user1Results: AssessmentResults,
		  user2Results: AssessmentResults
		): Record<string, number> => {
		  const metrics: Record<string, number> = {};
		
		  // Communication compatibility
		  const comm1 = user1Results.subscaleScores.find(s => s.category === 'communication')?.scaledScore || 50;
		  const comm2 = user2Results.subscaleScores.find(s => s.category === 'communication')?.scaledScore || 50;
		  metrics.communicationCompatibility = 100 - Math.abs(comm1 - comm2);
		
		  // Emotional compatibility (based on neuroticism difference)
		  const neuro1 = user1Results.subscaleScores.find(s => s.category === 'neuroticism')?.scaledScore || 50;
		  const neuro2 = user2Results.subscaleScores.find(s => s.category === 'neuroticism')?.scaledScore || 50;
		  metrics.emotionalCompatibility = 100 - Math.abs(neuro1 - neuro2);
		
		  // Independence compatibility (based on autonomy scores)
		  const auto1 = user1Results.subscaleScores.find(s => s.category === 'autonomy')?.scaledScore || 50;
		  const auto2 = user2Results.subscaleScores.find(s => s.category === 'autonomy')?.scaledScore || 50;
		  metrics.independenceCompatibility = 100 - Math.abs(auto1 - auto2);
		
		  // Conflict resolution compatibility
		  const conflict1 = user1Results.subscaleScores.find(s => s.category === 'conflict_resolution')?.scaledScore || 50;
		  const conflict2 = user2Results.subscaleScores.find(s => s.category === 'conflict_resolution')?.scaledScore || 50;
		  metrics.conflictCompatibility = 100 - Math.abs(conflict1 - conflict2);
		
		  return metrics;
		};]]></file>
	<file path='utils/pdfExportService.ts'><![CDATA[
		/**
		 * PDF Export Service
		 * 
		 * Handles generating PDF reports for premium users.
		 * This is a mock implementation - in production you would use a library like
		 * react-native-print or expo-print to generate actual PDFs.
		 */
		
		import * as Sharing from 'expo-sharing';
		import * as FileSystem from 'expo-file-system';
		import { Platform } from 'react-native';
		
		interface AssessmentResults {
		  personalityScores: Record<string, number>;
		  twinDynamics: Record<string, number>;
		  recommendations: string[];
		  timestamp: string;
		  userProfile: {
		    name: string;
		    twinType: string;
		  };
		  twinProfile?: {
		    name: string;
		  };
		}
		
		interface PDFExportOptions {
		  includeCharts?: boolean;
		  includeRecommendations?: boolean;
		  includeTwinComparison?: boolean;
		  format?: 'detailed' | 'summary';
		  branding?: boolean;
		}
		
		class PDFExportService {
		  /**
		   * Generate PDF report from assessment results
		   */
		  async generateAssessmentPDF(
		    results: AssessmentResults,
		    options: PDFExportOptions = {}
		  ): Promise<string> {
		    try {
		      const {
		        includeCharts = true,
		        includeRecommendations = true,
		        includeTwinComparison = true,
		        format = 'detailed',
		        branding = true
		      } = options;
		
		      // In production, this would use a proper PDF generation library
		      // For now, we'll create an HTML representation that could be converted to PDF
		      
		      const htmlContent = this.generateHTMLReport(results, {
		        includeCharts,
		        includeRecommendations,
		        includeTwinComparison,
		        format,
		        branding
		      });
		
		      // Mock PDF generation - in production use expo-print or similar
		      const filename = `twinship-assessment-${Date.now()}.pdf`;
		      const fileUri = `${FileSystem.documentDirectory}${filename}`;
		      
		      // This would normally convert HTML to PDF
		      await FileSystem.writeAsStringAsync(fileUri, htmlContent);
		      
		      return fileUri;
		    } catch (error) {
		      console.error('PDF generation failed:', error);
		      throw new Error('Failed to generate PDF report');
		    }
		  }
		
		  /**
		   * Share PDF file
		   */
		  async shareAssessmentPDF(
		    results: AssessmentResults,
		    options?: PDFExportOptions
		  ): Promise<void> {
		    try {
		      const pdfUri = await this.generateAssessmentPDF(results, options);
		      
		      if (await Sharing.isAvailableAsync()) {
		        await Sharing.shareAsync(pdfUri, {
		          mimeType: 'application/pdf',
		          dialogTitle: 'Share Twin Assessment Report'
		        });
		      } else {
		        throw new Error('Sharing is not available on this device');
		      }
		    } catch (error) {
		      console.error('PDF sharing failed:', error);
		      throw error;
		    }
		  }
		
		  /**
		   * Generate HTML content for PDF conversion
		   */
		  private generateHTMLReport(
		    results: AssessmentResults,
		    options: PDFExportOptions
		  ): string {
		    const { userProfile, twinProfile, personalityScores, twinDynamics, recommendations } = results;
		    
		    return `
		<!DOCTYPE html>
		<html>
		<head>
		    <meta charset="UTF-8">
		    <title>Twinship Assessment Report</title>
		    <style>
		        body {
		            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
		            line-height: 1.6;
		            color: #333;
		            max-width: 800px;
		            margin: 0 auto;
		            padding: 20px;
		        }
		        .header {
		            text-align: center;
		            border-bottom: 3px solid #8a2be2;
		            padding-bottom: 20px;
		            margin-bottom: 30px;
		        }
		        .logo {
		            font-size: 28px;
		            font-weight: bold;
		            color: #8a2be2;
		            margin-bottom: 10px;
		        }
		        .subtitle {
		            color: #666;
		            font-size: 16px;
		        }
		        .section {
		            margin: 30px 0;
		            padding: 20px;
		            border-radius: 10px;
		            background: #f9f9f9;
		        }
		        .section h2 {
		            color: #8a2be2;
		            border-bottom: 2px solid #8a2be2;
		            padding-bottom: 10px;
		        }
		        .score-grid {
		            display: grid;
		            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
		            gap: 15px;
		            margin: 20px 0;
		        }
		        .score-item {
		            background: white;
		            padding: 15px;
		            border-radius: 8px;
		            border-left: 4px solid #8a2be2;
		        }
		        .score-label {
		            font-weight: bold;
		            color: #333;
		        }
		        .score-value {
		            font-size: 24px;
		            color: #8a2be2;
		            font-weight: bold;
		        }
		        .recommendations {
		            list-style: none;
		            padding: 0;
		        }
		        .recommendations li {
		            background: white;
		            margin: 10px 0;
		            padding: 15px;
		            border-radius: 8px;
		            border-left: 4px solid #00bfff;
		        }
		        .footer {
		            text-align: center;
		            margin-top: 40px;
		            padding-top: 20px;
		            border-top: 1px solid #ddd;
		            color: #666;
		            font-size: 14px;
		        }
		        .twin-info {
		            background: white;
		            padding: 15px;
		            border-radius: 8px;
		            margin: 15px 0;
		        }
		    </style>
		</head>
		<body>
		    ${options.branding ? `
		    <div class="header">
		        <div class="logo">Twinship</div>
		        <div class="subtitle">Sacred Twin Bond Assessment Report</div>
		        <p>Generated on ${new Date(results.timestamp).toLocaleDateString()}</p>
		    </div>
		    ` : ''}
		    
		    <div class="section">
		        <h2>Twin Profile Information</h2>
		        <div class="twin-info">
		            <strong>Primary Twin:</strong> ${userProfile.name}<br>
		            <strong>Twin Type:</strong> ${userProfile.twinType}<br>
		            ${twinProfile ? `<strong>Twin Partner:</strong> ${twinProfile.name}<br>` : ''}
		        </div>
		    </div>
		
		    ${options.format === 'detailed' ? `
		    <div class="section">
		        <h2>Personality Dimensions</h2>
		        <div class="score-grid">
		            ${Object.entries(personalityScores).map(([trait, score]) => `
		                <div class="score-item">
		                    <div class="score-label">${trait.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}</div>
		                    <div class="score-value">${score}/100</div>
		                </div>
		            `).join('')}
		        </div>
		    </div>
		
		    <div class="section">
		        <h2>Twin Dynamics</h2>
		        <div class="score-grid">
		            ${Object.entries(twinDynamics).map(([dynamic, score]) => `
		                <div class="score-item">
		                    <div class="score-label">${dynamic.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}</div>
		                    <div class="score-value">${score}/100</div>
		                </div>
		            `).join('')}
		        </div>
		    </div>
		    ` : `
		    <div class="section">
		        <h2>Assessment Summary</h2>
		        <p>This summary report contains key insights from your twin assessment. For detailed breakdowns of all personality dimensions and twin dynamics, please access the full digital report.</p>
		    </div>
		    `}
		
		    ${options.includeRecommendations ? `
		    <div class="section">
		        <h2>Personalized Recommendations</h2>
		        <ul class="recommendations">
		            ${recommendations.slice(0, options.format === 'detailed' ? recommendations.length : 3).map(rec => `
		                <li>${rec}</li>
		            `).join('')}
		        </ul>
		        ${options.format === 'summary' && recommendations.length > 3 ? '<p><em>Additional recommendations available in your premium dashboard.</em></p>' : ''}
		    </div>
		    ` : ''}
		
		    <div class="footer">
		        <p><strong>Important Note:</strong> This assessment is for personal development purposes only and is not a diagnostic tool. For professional relationship counseling, please consult with a qualified therapist.</p>
		        <p>© ${new Date().getFullYear()} Twinship - Strengthening Twin Bonds</p>
		    </div>
		</body>
		</html>
		    `;
		  }
		
		  /**
		   * Check if PDF generation is supported
		   */
		  isSupported(): boolean {
		    return Platform.OS !== 'web'; // PDF generation typically not supported in web
		  }
		
		  /**
		   * Get estimated file size for PDF
		   */
		  getEstimatedFileSize(options: PDFExportOptions = {}): string {
		    const { format = 'detailed', includeCharts = true } = options;
		    
		    if (format === 'detailed' && includeCharts) {
		      return '2-4 MB';
		    } else if (format === 'detailed') {
		      return '1-2 MB';
		    } else {
		      return '500 KB - 1 MB';
		    }
		  }
		}
		
		export const pdfExportService = new PDFExportService();]]></file>
	<file path='utils/premiumGating.tsx'><![CDATA[
		/**
		 * Premium Feature Gating Utilities
		 * 
		 * This file provides utility functions for implementing premium feature gating
		 * throughout the Twinship app in a consistent way.
		 */
		
		import React from "react";
		import { Alert } from "react-native";
		import { PREMIUM_FEATURES } from "../types/premium/subscription";
		
		/**
		 * Show premium upgrade alert with feature-specific messaging
		 */
		export const showPremiumUpgradeAlert = (
		  featureId: string,
		  onUpgrade: () => void,
		  onCancel?: () => void
		) => {
		  const feature = PREMIUM_FEATURES.find(f => f.id === featureId);
		  const featureName = feature?.name || "this feature";
		  const description = feature?.teaser?.content || feature?.description || "premium functionality";
		
		  Alert.alert(
		    "Premium Feature",
		    `${featureName} requires a Premium subscription.\n\n${description}`,
		    [
		      {
		        text: "Not Now",
		        style: "cancel",
		        onPress: onCancel
		      },
		      {
		        text: "Unlock the full analysis of your Twinship",
		        style: "default",
		        onPress: onUpgrade
		      }
		    ]
		  );
		};
		
		/**
		 * Get appropriate teaser content for locked features
		 */
		export const getPremiumTeaserContent = (featureId: string) => {
		  const feature = PREMIUM_FEATURES.find(f => f.id === featureId);
		  
		  const teasers: Record<string, { preview: any; description: string }> = {
		    detailed_results: {
		      preview: {
		        personalityScores: [85, 72, 91, 68, 77],
		        twinDynamicsScore: 82,
		        codependencyIndex: 45,
		        autonomyScore: 78
		      },
		      description: "See your complete personality breakdown and twin-specific metrics"
		    },
		    
		    coaching_plans: {
		      preview: {
		        weeklyTasks: [
		          "Practice individual reflection time",
		          "Express appreciation for twin's uniqueness", 
		          "Set one personal boundary this week"
		        ],
		        estimatedTime: "15 min/day"
		      },
		      description: "Get personalized weekly exercises to strengthen your bond"
		    },
		    
		    twin_analytics: {
		      preview: {
		        syncScore: 87,
		        communicationTrend: "↗️ +12% this month",
		        conflictResolution: "Strong",
		        growthAreas: 2
		      },
		      description: "Track your relationship progress with detailed analytics"
		    },
		    
		    astrology_birthchart: {
		      preview: {
		        sunSign: "Gemini ♊",
		        moonSign: "Pisces ♓", 
		        rising: "Scorpio ♏",
		        dominantElement: "Water",
		        twinSynastry: "92% compatibility"
		      },
		      description: "Get your complete birth chart with twin synastry analysis"
		    },
		    
		    numerology_reading: {
		      preview: {
		        lifePath: "7 - The Seeker",
		        soulUrge: "3 - Creative Expression",
		        personality: "4 - The Builder",
		        twinConnection: "Master Number 11"
		      },
		      description: "Discover your numerology profile and twin number connections"
		    },
		    
		    recommendations: {
		      preview: {
		        topRecommendation: "Focus on individual identity development",
		        confidence: "92%",
		        personalizedTips: 5
		      },
		      description: "AI analyzes your results to provide tailored relationship advice"
		    },
		    
		    unlimited_assessments: {
		      preview: {
		        nextRetake: "Available now",
		        lastScore: 78,
		        improvement: "+8 points"
		      },
		      description: "Retake assessments monthly to track your growth journey"
		    }
		  };
		
		  return {
		    teaser: teasers[featureId] || { preview: null, description: feature?.description || "" },
		    feature
		  };
		};
		
		/**
		 * Feature gating decorator for components
		 */
		export const withPremiumGating = <T extends Record<string, any>>(
		  Component: React.ComponentType<T>,
		  featureId: string
		) => {
		  return (props: T & { hasAccess?: boolean; onUpgrade?: () => void }) => {
		    const { hasAccess = false, onUpgrade, ...componentProps } = props;
		    
		    if (hasAccess) {
		      return <Component {...(componentProps as T)} />;
		    }
		    
		    // Return gated version - could be teaser, blur overlay, etc.
		    return null;
		  };
		};
		
		/**
		 * Premium feature access levels
		 */
		export const PREMIUM_ACCESS_LEVELS = {
		  FREE: 'free',
		  PREMIUM: 'premium'
		} as const;
		
		/**
		 * Map features to their required access level
		 */
		export const FEATURE_ACCESS_MAP = {
		  // Free features
		  basic_results: PREMIUM_ACCESS_LEVELS.FREE,
		  twin_pairing: PREMIUM_ACCESS_LEVELS.FREE,
		  chat: PREMIUM_ACCESS_LEVELS.FREE,
		  games: PREMIUM_ACCESS_LEVELS.FREE,
		  stories: PREMIUM_ACCESS_LEVELS.FREE,
		  basic_twintuition: PREMIUM_ACCESS_LEVELS.FREE,
		  
		  // Premium features
		  detailed_results: PREMIUM_ACCESS_LEVELS.PREMIUM,
		  coaching_plans: PREMIUM_ACCESS_LEVELS.PREMIUM,
		  astrology_birthchart: PREMIUM_ACCESS_LEVELS.PREMIUM,
		  numerology_reading: PREMIUM_ACCESS_LEVELS.PREMIUM,
		  twin_analytics: PREMIUM_ACCESS_LEVELS.PREMIUM,
		  recommendations: PREMIUM_ACCESS_LEVELS.PREMIUM,
		  unlimited_assessments: PREMIUM_ACCESS_LEVELS.PREMIUM
		} as const;
		
		/**
		 * Check if a feature requires premium access
		 */
		export const requiresPremium = (featureId: string): boolean => {
		  return FEATURE_ACCESS_MAP[featureId as keyof typeof FEATURE_ACCESS_MAP] === PREMIUM_ACCESS_LEVELS.PREMIUM;
		};
		
		/**
		 * Premium feature categories for organizing upsells
		 */
		export const PREMIUM_CATEGORIES = {
		  ASSESSMENT: {
		    id: 'assessment',
		    name: 'Assessment & Analysis',
		    description: 'Deep insights into your twin bond',
		    icon: 'analytics',
		    features: ['detailed_results', 'unlimited_assessments']
		  },
		  
		  COACHING: {
		    id: 'coaching', 
		    name: 'Personal Growth',
		    description: 'Guided exercises for stronger bonds',
		    icon: 'fitness',
		    features: ['coaching_plans']
		  },
		  
		  ANALYTICS: {
		    id: 'analytics',
		    name: 'Progress Tracking',
		    description: 'Monitor your twin journey',
		    icon: 'stats-chart', 
		    features: ['twin_analytics']
		  },
		  
		  MYSTICAL: {
		    id: 'mystical',
		    name: 'Mystical Insights', 
		    description: 'Astrology charts and numerology readings for your twin bond',
		    icon: 'planet',
		    features: ['astrology_birthchart', 'numerology_reading']
		  },
		  
		  INSIGHTS: {
		    id: 'insights',
		    name: 'AI Intelligence',
		    description: 'Smart recommendations for your relationship',
		    icon: 'bulb',
		    features: ['recommendations']
		  }
		} as const;
		
		/**
		 * Get category for a feature
		 */
		export const getFeatureCategory = (featureId: string) => {
		  return Object.values(PREMIUM_CATEGORIES).find(
		    category => category.features.includes(featureId)
		  );
		};
		
		/**
		 * Analytics events for premium feature interactions
		 */
		export const PREMIUM_ANALYTICS_EVENTS = {
		  FEATURE_VIEWED: 'premium_feature_viewed',
		  FEATURE_BLOCKED: 'premium_feature_blocked', 
		  UPGRADE_PROMPT_SHOWN: 'premium_upgrade_prompt_shown',
		  UPGRADE_CLICKED: 'premium_upgrade_clicked',
		  PAYWALL_VIEWED: 'premium_paywall_viewed',
		  PURCHASE_INITIATED: 'premium_purchase_initiated',
		  PURCHASE_COMPLETED: 'premium_purchase_completed',
		  PURCHASE_FAILED: 'premium_purchase_failed'
		} as const;]]></file>
	<file path='utils/researchEthics.ts'><![CDATA[
		import { ResearchStudy, ConsentRecord, ResearchEthics } from '../types/research';
		
		/**
		 * Utility functions for research ethics compliance
		 */
		
		export const researchEthicsGuidelines: ResearchEthics = {
		  irbApproval: 'IRB-2024-TWIN-MAIN',
		  consentVersion: 2,
		  dataProtectionCompliance: [
		    'GDPR Article 6(1)(a) - Consent',
		    'GDPR Article 9(2)(a) - Explicit consent for special categories',
		    'HIPAA Privacy Rule (if applicable)',
		    'Research Ethics Board Guidelines'
		  ],
		  participantRights: [
		    'Right to withdraw from research at any time',
		    'Right to access your contributed data',
		    'Right to request data deletion',
		    'Right to understand how your data is used',
		    'Right to receive research findings',
		    'Right to contact researchers with questions'
		  ],
		  contactInformation: {
		    principalInvestigator: 'research@twinshipvibe.com',
		    ethicsBoard: 'ethics@twinshipvibe.com',
		    support: 'support@twinshipvibe.com'
		  }
		};
		
		/**
		 * Validates that a consent record meets ethical standards
		 */
		export const validateConsentRecord = (consent: ConsentRecord): boolean => {
		  // Check required consents
		  const requiredConsents = consent.consentedTo.filter(c => c.required);
		  const allRequiredConsented = requiredConsents.every(c => c.consented);
		  
		  // Check consent is recent (not older than 1 year)
		  const consentAge = Date.now() - new Date(consent.consentedAt).getTime();
		  const oneYear = 365 * 24 * 60 * 60 * 1000;
		  const consentIsFresh = consentAge < oneYear;
		  
		  // Check not withdrawn
		  const notWithdrawn = !consent.withdrawnAt;
		  
		  return allRequiredConsented && consentIsFresh && notWithdrawn;
		};
		
		/**
		 * Checks if a study meets ethical standards for recruitment
		 */
		export const validateStudyEthics = (study: ResearchStudy): boolean => {
		  const hasEthicsApproval = study.ethicsApproval && study.ethicsApproval.length > 0;
		  const hasInstitution = study.institution && study.institution.length > 0;
		  const hasLeadResearcher = study.leadResearcher && study.leadResearcher.length > 0;
		  const hasDataTypes = study.dataTypes && study.dataTypes.length > 0;
		  const hasValidRetention = study.dataTypes.every(dt => dt.retentionPeriod && dt.retentionPeriod.length > 0);
		  
		  return hasEthicsApproval && hasInstitution && hasLeadResearcher && hasDataTypes && hasValidRetention;
		};
		
		/**
		 * Generates anonymized participant ID for research
		 */
		export const generateAnonymizedParticipantId = (userId: string, studyId: string): string => {
		  // In production, use proper cryptographic hashing
		  const combined = `${userId}_${studyId}_${Date.now()}`;
		  const hash = btoa(combined).replace(/[^a-zA-Z0-9]/g, '');
		  return `TWIN_${hash.substring(0, 12)}`;
		};
		
		/**
		 * Checks if data can be shared according to participant preferences
		 */
		export const canShareData = (
		  consentRecord: ConsentRecord,
		  sharingScope: 'internal' | 'academic' | 'public'
		): boolean => {
		  const dataSharing = consentRecord.consentedTo.find(c => c.id === 'data_sharing');
		  if (!dataSharing || !dataSharing.consented) return false;
		  
		  switch (sharingScope) {
		    case 'internal':
		      return true; // Always allowed if basic consent given
		    case 'academic':
		      return dataSharing.consented;
		    case 'public':
		      const publicConsent = consentRecord.consentedTo.find(c => c.id === 'public_sharing');
		      return publicConsent?.consented || false;
		    default:
		      return false;
		  }
		};
		
		/**
		 * Creates a data retention schedule based on study requirements
		 */
		export const createRetentionSchedule = (study: ResearchStudy) => {
		  const schedules = study.dataTypes.map(dataType => ({
		    dataType: dataType.type,
		    description: dataType.description,
		    retentionPeriod: dataType.retentionPeriod,
		    anonymizationLevel: dataType.anonymizationLevel,
		    deletionDate: calculateDeletionDate(dataType.retentionPeriod),
		    sharingScope: dataType.sharingScope
		  }));
		  
		  return {
		    studyId: study.id,
		    studyTitle: study.title,
		    schedules,
		    ethicsApproval: study.ethicsApproval,
		    contactInfo: researchEthicsGuidelines.contactInformation
		  };
		};
		
		/**
		 * Calculates when data should be deleted based on retention period
		 */
		const calculateDeletionDate = (retentionPeriod: string): Date => {
		  const now = new Date();
		  const match = retentionPeriod.match(/(\d+)\s*(year|month|day)s?/i);
		  
		  if (!match) return new Date(now.getTime() + 5 * 365 * 24 * 60 * 60 * 1000); // Default 5 years
		  
		  const amount = parseInt(match[1]);
		  const unit = match[2].toLowerCase();
		  
		  switch (unit) {
		    case 'year':
		      return new Date(now.getFullYear() + amount, now.getMonth(), now.getDate());
		    case 'month':
		      return new Date(now.getFullYear(), now.getMonth() + amount, now.getDate());
		    case 'day':
		      return new Date(now.getTime() + amount * 24 * 60 * 60 * 1000);
		    default:
		      return new Date(now.getTime() + 5 * 365 * 24 * 60 * 60 * 1000);
		  }
		};
		
		/**
		 * Validates that data contribution follows ethical guidelines
		 */
		export const validateDataContribution = (
		  userId: string,
		  studyId: string,
		  dataType: string,
		  consentRecords: ConsentRecord[]
		): { allowed: boolean; reason?: string } => {
		  // Find valid consent for this study
		  const validConsent = consentRecords.find(consent => 
		    consent.studyId === studyId && 
		    consent.userId === userId && 
		    validateConsentRecord(consent)
		  );
		  
		  if (!validConsent) {
		    return { 
		      allowed: false, 
		      reason: 'No valid consent found for this study' 
		    };
		  }
		  
		  // Check if specific data type is consented to
		  const dataTypeConsent = validConsent.consentedTo.find(c => 
		    c.dataTypes.includes(dataType) || c.dataTypes.includes('all')
		  );
		  
		  if (!dataTypeConsent || !dataTypeConsent.consented) {
		    return { 
		      allowed: false, 
		      reason: `No consent found for data type: ${dataType}` 
		    };
		  }
		  
		  return { allowed: true };
		};
		
		/**
		 * Formats research findings for participant consumption
		 */
		export const formatResearchInsight = (
		  finding: string,
		  participantLevel: 'basic' | 'detailed' | 'academic'
		): string => {
		  switch (participantLevel) {
		    case 'basic':
		      return finding.replace(/statistical|p-value|correlation|regression/gi, 'connection');
		    case 'detailed':
		      return finding;
		    case 'academic':
		      return finding; // Include all statistical details
		    default:
		      return finding;
		  }
		};]]></file>
	<file path='utils/statisticalNorming.ts'><![CDATA[
		/**
		 * Statistical Norming Engine for Assessment Data
		 * Calculates norms, reliability, and validity statistics for psychological assessments
		 */
		
		import { 
		  NormingStatistics, 
		  ItemAnalysis, 
		  ItemRecommendation,
		  StatisticalMeasure,
		  TelemetryDashboardData
		} from '../types/telemetry';
		import { AssessmentCategory, LikertScale } from '../types/assessment';
		
		interface RawResponseData {
		  questionId: string;
		  category: AssessmentCategory;
		  responses: number[];
		  responseTimes: number[];
		  revisions: number[];
		  sessionIds: string[];
		  demographics?: {
		    ageGroup?: string;
		    gender?: string;
		    twinType?: string;
		  }[];
		}
		
		interface ReliabilityAnalysis {
		  cronbachAlpha: number;
		  splitHalfReliability: number;
		  testRetest?: number;
		  standardError: number;
		  confidenceInterval: [number, number];
		}
		
		interface ValidityAnalysis {
		  contentValidity: number;
		  constructValidity: number;
		  criterionValidity?: number;
		  convergentValidity?: number;
		  discriminantValidity?: number;
		}
		
		interface NormativeScores {
		  rawScore: number;
		  standardScore: number; // Mean = 50, SD = 10
		  tScore: number; // Mean = 50, SD = 10
		  zScore: number; // Mean = 0, SD = 1
		  percentileRank: number; // 0-100
		  stanine: number; // 1-9
		  qualitativeDescription: string;
		}
		
		class StatisticalNormingEngine {
		  private normingDatabase: Map<string, NormingStatistics> = new Map();
		  private reliabilityCache: Map<string, ReliabilityAnalysis> = new Map();
		  private validityCache: Map<string, ValidityAnalysis> = new Map();
		
		  /**
		   * Calculate comprehensive norming statistics for a question
		   */
		  calculateNormingStatistics(data: RawResponseData): NormingStatistics {
		    const responses = data.responses.filter(r => r >= 1 && r <= 7); // Valid Likert responses
		    const sampleSize = responses.length;
		
		    if (sampleSize < 10) {
		      throw new Error('Insufficient sample size for reliable norming statistics');
		    }
		
		    // Basic descriptive statistics
		    const mean = this.calculateMean(responses);
		    const median = this.calculateMedian(responses);
		    const standardDeviation = this.calculateStandardDeviation(responses, mean);
		    const variance = Math.pow(standardDeviation, 2);
		    const skewness = this.calculateSkewness(responses, mean, standardDeviation);
		    const kurtosis = this.calculateKurtosis(responses, mean, standardDeviation);
		
		    // Response distribution
		    const responseDistribution = this.createResponseDistribution(responses);
		
		    // Demographic breakdowns (if available)
		    const demographicBreakdowns = this.calculateDemographicBreakdowns(
		      responses, 
		      data.demographics
		    );
		
		    // Quality metrics
		    const averageResponseTime = this.calculateMean(data.responseTimes);
		    const responseVariance = this.calculateResponseVariance(responses);
		    const consistencyScore = this.calculateConsistencyScore(responses, data.revisions);
		    const anomalyRate = this.calculateAnomalyRate(data);
		
		    // Item difficulty and discrimination
		    const difficulty = this.calculateItemDifficulty(responses);
		    const discrimination = this.calculateItemDiscrimination(responses, data.sessionIds);
		
		    // Normative data
		    const percentileRanks = this.calculatePercentileRanks(responses);
		    const zScores = this.calculateZScores(responses, mean, standardDeviation);
		    const standardizedScores = this.calculateStandardizedScores(zScores);
		
		    // Confidence interval for the mean
		    const standardError = standardDeviation / Math.sqrt(sampleSize);
		    const confidenceInterval = 1.96 * standardError; // 95% CI
		
		    const normingStats: NormingStatistics = {
		      questionId: data.questionId,
		      category: data.category,
		      sampleSize,
		      statistics: {
		        mean,
		        median,
		        standard_deviation: standardDeviation,
		        variance,
		        skewness,
		        kurtosis,
		        item_difficulty: difficulty,
		        item_discrimination: discrimination,
		      },
		      responseDistribution,
		      demographicBreakdowns,
		      qualityMetrics: {
		        averageResponseTime,
		        responseVariance,
		        consistencyScore,
		        anomalyRate,
		        reliabilityCoefficient: this.estimateReliability(responses),
		      },
		      normativeData: {
		        percentileRanks,
		        zScores,
		        standardizedScores,
		      },
		      lastUpdated: new Date().toISOString(),
		      confidenceInterval,
		    };
		
		    // Cache the results
		    this.normingDatabase.set(data.questionId, normingStats);
		
		    return normingStats;
		  }
		
		  /**
		   * Perform comprehensive item analysis
		   */
		  analyzeItem(data: RawResponseData, totalScores?: number[]): ItemAnalysis {
		    const responses = data.responses.filter(r => r >= 1 && r <= 7);
		    const sampleSize = responses.length;
		
		    if (sampleSize < 30) {
		      console.warn(`Small sample size (${sampleSize}) for item analysis of question ${data.questionId}`);
		    }
		
		    // Basic item statistics
		    const difficulty = this.calculateItemDifficulty(responses);
		    const discrimination = totalScores 
		      ? this.calculateItemTotalCorrelation(responses, totalScores)
		      : this.calculateItemDiscrimination(responses, data.sessionIds);
		
		    // Option analysis (for multiple choice or Likert items)
		    const optionAnalysis = this.analyzeResponseOptions(responses);
		
		    // Reliability analysis
		    const itemTotalCorrelation = discrimination;
		    const alphaIfDeleted = totalScores 
		      ? this.calculateAlphaIfItemDeleted(responses, totalScores)
		      : 0;
		
		    // Generate recommendations
		    const recommendations = this.generateItemRecommendations(
		      difficulty,
		      discrimination,
		      optionAnalysis,
		      data
		    );
		
		    // Flag problematic items
		    const flagged = recommendations.some(r => r.priority === 'high' || r.priority === 'critical');
		    const flagReasons = recommendations
		      .filter(r => r.priority === 'high' || r.priority === 'critical')
		      .map(r => r.reason);
		
		    return {
		      questionId: data.questionId,
		      category: data.category,
		      difficulty,
		      discrimination,
		      optionAnalysis,
		      reliability: {
		        itemTotalCorrelation,
		        alphaIfDeleted,
		      },
		      recommendations,
		      flagged,
		      flagReasons,
		    };
		  }
		
		  /**
		   * Calculate reliability statistics for a scale or subscale
		   */
		  calculateReliability(
		    itemResponses: number[][], // Array of response arrays for each item
		    itemIds: string[]
		  ): ReliabilityAnalysis {
		    const cacheKey = itemIds.sort().join('|');
		    
		    if (this.reliabilityCache.has(cacheKey)) {
		      return this.reliabilityCache.get(cacheKey)!;
		    }
		
		    if (itemResponses.length < 2) {
		      throw new Error('At least 2 items required for reliability analysis');
		    }
		
		    // Calculate Cronbach's Alpha
		    const cronbachAlpha = this.calculateCronbachAlpha(itemResponses);
		
		    // Calculate Split-Half Reliability
		    const splitHalfReliability = this.calculateSplitHalfReliability(itemResponses);
		
		    // Calculate Standard Error of Measurement
		    const totalScores = this.calculateTotalScores(itemResponses);
		    const totalVariance = this.calculateVariance(totalScores);
		    const standardError = Math.sqrt(totalVariance * (1 - cronbachAlpha));
		
		    // 95% Confidence Interval for reliability
		    const n = itemResponses[0].length; // Number of respondents
		    const dfReliability = n - 1;
		    const reliabilityCI = this.calculateReliabilityCI(cronbachAlpha, dfReliability);
		
		    const reliabilityAnalysis: ReliabilityAnalysis = {
		      cronbachAlpha,
		      splitHalfReliability,
		      standardError,
		      confidenceInterval: reliabilityCI,
		    };
		
		    this.reliabilityCache.set(cacheKey, reliabilityAnalysis);
		    return reliabilityAnalysis;
		  }
		
		  /**
		   * Convert raw scores to normative scores
		   */
		  convertToNormativeScores(
		    rawScore: number,
		    questionId: string
		  ): NormativeScores | null {
		    const normingData = this.normingDatabase.get(questionId);
		    if (!normingData) {
		      return null;
		    }
		
		    const mean = normingData.statistics.mean || 0;
		    const sd = normingData.statistics.standard_deviation || 1;
		
		    // Calculate z-score
		    const zScore = (rawScore - mean) / sd;
		
		    // Calculate standard score (M=50, SD=10)
		    const standardScore = 50 + (zScore * 10);
		
		    // Calculate T-score (M=50, SD=10, same as standard score in this case)
		    const tScore = standardScore;
		
		    // Calculate percentile rank
		    const percentileRank = this.zScoreToPercentile(zScore);
		
		    // Calculate stanine (1-9 scale)
		    const stanine = this.percentileToStanine(percentileRank);
		
		    // Qualitative description
		    const qualitativeDescription = this.getQualitativeDescription(percentileRank);
		
		    return {
		      rawScore,
		      standardScore,
		      tScore,
		      zScore,
		      percentileRank,
		      stanine,
		      qualitativeDescription,
		    };
		  }
		
		  /**
		   * Generate dashboard analytics data
		   */
		  generateDashboardData(
		    startDate: string,
		    endDate: string
		  ): TelemetryDashboardData {
		    // This would typically pull from a database
		    // For now, we'll generate sample data based on cached norming statistics
		    
		    const questionMetrics = Array.from(this.normingDatabase.values()).map(stats => ({
		      questionId: stats.questionId,
		      averageResponseTime: stats.qualityMetrics.averageResponseTime,
		      difficultyLevel: stats.statistics.item_difficulty || 0.5,
		      discriminationIndex: stats.statistics.item_discrimination || 0.3,
		      responseVariance: stats.qualityMetrics.responseVariance,
		      anomalyCount: Math.floor(stats.sampleSize * stats.qualityMetrics.anomalyRate),
		    }));
		
		    // Group by category for category performance
		    const categoryPerformance = this.aggregateByCategory();
		
		    // Calculate quality indicators
		    const qualityIndicators = this.calculateQualityIndicators();
		
		    // Generate trends data (would come from time-series data in real implementation)
		    const trendsData = this.generateTrendsData(startDate, endDate);
		
		    // Overall statistics
		    const overview = this.calculateOverviewStats();
		
		    return {
		      timeRange: { start: startDate, end: endDate },
		      overview,
		      questionMetrics,
		      categoryPerformance,
		      qualityIndicators,
		      trendsData,
		    };
		  }
		
		  // Private helper methods
		  private calculateMean(values: number[]): number {
		    return values.reduce((sum, val) => sum + val, 0) / values.length;
		  }
		
		  private calculateMedian(values: number[]): number {
		    const sorted = [...values].sort((a, b) => a - b);
		    const mid = Math.floor(sorted.length / 2);
		    return sorted.length % 2 === 0
		      ? (sorted[mid - 1] + sorted[mid]) / 2
		      : sorted[mid];
		  }
		
		  private calculateStandardDeviation(values: number[], mean?: number): number {
		    const m = mean ?? this.calculateMean(values);
		    const variance = values.reduce((sum, val) => sum + Math.pow(val - m, 2), 0) / (values.length - 1);
		    return Math.sqrt(variance);
		  }
		
		  private calculateVariance(values: number[]): number {
		    const mean = this.calculateMean(values);
		    return values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (values.length - 1);
		  }
		
		  private calculateSkewness(values: number[], mean: number, sd: number): number {
		    const n = values.length;
		    const skew = values.reduce((sum, val) => sum + Math.pow((val - mean) / sd, 3), 0) / n;
		    return skew;
		  }
		
		  private calculateKurtosis(values: number[], mean: number, sd: number): number {
		    const n = values.length;
		    const kurt = values.reduce((sum, val) => sum + Math.pow((val - mean) / sd, 4), 0) / n;
		    return kurt - 3; // Excess kurtosis
		  }
		
		  private createResponseDistribution(responses: number[]): Record<string, number> {
		    const distribution: Record<string, number> = {};
		    responses.forEach(response => {
		      const key = response.toString();
		      distribution[key] = (distribution[key] || 0) + 1;
		    });
		    return distribution;
		  }
		
		  private calculateDemographicBreakdowns(
		    responses: number[],
		    demographics?: any[]
		  ): Record<string, Record<string, number>> | undefined {
		    if (!demographics || demographics.length !== responses.length) {
		      return undefined;
		    }
		
		    const breakdowns: Record<string, Record<string, number>> = {
		      ageGroups: {},
		      genderGroups: {},
		      twinTypes: {},
		    };
		
		    demographics.forEach((demo, index) => {
		      const response = responses[index];
		      
		      if (demo.ageGroup) {
		        breakdowns.ageGroups[demo.ageGroup] = 
		          (breakdowns.ageGroups[demo.ageGroup] || 0) + response;
		      }
		      
		      if (demo.gender) {
		        breakdowns.genderGroups[demo.gender] = 
		          (breakdowns.genderGroups[demo.gender] || 0) + response;
		      }
		      
		      if (demo.twinType) {
		        breakdowns.twinTypes[demo.twinType] = 
		          (breakdowns.twinTypes[demo.twinType] || 0) + response;
		      }
		    });
		
		    return breakdowns;
		  }
		
		  private calculateResponseVariance(responses: number[]): number {
		    // Calculate the variance in response patterns (not statistical variance)
		    const distribution = this.createResponseDistribution(responses);
		    const totalResponses = responses.length;
		    
		    // Calculate entropy as a measure of response diversity
		    let entropy = 0;
		    Object.values(distribution).forEach(count => {
		      const p = count / totalResponses;
		      if (p > 0) {
		        entropy -= p * Math.log2(p);
		      }
		    });
		
		    // Normalize entropy to 0-1 scale (max entropy for 7-point scale is log2(7))
		    return entropy / Math.log2(7);
		  }
		
		  private calculateConsistencyScore(responses: number[], revisions: number[]): number {
		    // Higher consistency = fewer revisions and less variance
		    const avgRevisions = this.calculateMean(revisions);
		    const responseStability = 1 - (avgRevisions / 10); // Normalize revision impact
		    const responseVariance = this.calculateResponseVariance(responses);
		    
		    return Math.max(0, Math.min(1, responseStability * responseVariance));
		  }
		
		  private calculateAnomalyRate(data: RawResponseData): number {
		    // This would integrate with the anomaly detection system
		    // For now, estimate based on extreme response times and patterns
		    const { responseTimes, responses } = data;
		    
		    let anomalies = 0;
		    
		    // Count extremely fast responses
		    anomalies += responseTimes.filter(t => t < 500).length;
		    
		    // Count straight-line responding patterns
		    if (responses.length >= 5) {
		      const mostCommon = this.getMostCommonResponse(responses);
		      const straightLineCount = responses.filter(r => r === mostCommon).length;
		      if (straightLineCount / responses.length > 0.8) {
		        anomalies += Math.floor(responses.length * 0.5);
		      }
		    }
		
		    return Math.min(1, anomalies / responses.length);
		  }
		
		  private calculateItemDifficulty(responses: number[]): number {
		    // For Likert scales, difficulty = mean response / max possible response
		    const mean = this.calculateMean(responses);
		    return mean / 7; // Assuming 7-point scale
		  }
		
		  private calculateItemDiscrimination(responses: number[], sessionIds: string[]): number {
		    // Simplified discrimination index - would need total scores for proper calculation
		    // This estimates discrimination based on response variance
		    const variance = this.calculateVariance(responses);
		    const maxVariance = Math.pow(7 - 1, 2) / 4; // Theoretical max for 7-point scale
		    return Math.min(1, variance / maxVariance);
		  }
		
		  private calculateItemTotalCorrelation(itemResponses: number[], totalScores: number[]): number {
		    if (itemResponses.length !== totalScores.length) {
		      throw new Error('Item responses and total scores arrays must have the same length');
		    }
		
		    return this.calculateCorrelation(itemResponses, totalScores);
		  }
		
		  private calculateCorrelation(x: number[], y: number[]): number {
		    const n = x.length;
		    const meanX = this.calculateMean(x);
		    const meanY = this.calculateMean(y);
		    
		    let numerator = 0;
		    let sumXSquared = 0;
		    let sumYSquared = 0;
		
		    for (let i = 0; i < n; i++) {
		      const devX = x[i] - meanX;
		      const devY = y[i] - meanY;
		      numerator += devX * devY;
		      sumXSquared += devX * devX;
		      sumYSquared += devY * devY;
		    }
		
		    const denominator = Math.sqrt(sumXSquared * sumYSquared);
		    return denominator === 0 ? 0 : numerator / denominator;
		  }
		
		  private calculateCronbachAlpha(itemResponses: number[][]): number {
		    const k = itemResponses.length; // Number of items
		    const n = itemResponses[0].length; // Number of respondents
		
		    // Calculate variance of each item
		    const itemVariances = itemResponses.map(responses => this.calculateVariance(responses));
		    const sumItemVariances = itemVariances.reduce((sum, variance) => sum + variance, 0);
		
		    // Calculate total scores and their variance
		    const totalScores = this.calculateTotalScores(itemResponses);
		    const totalVariance = this.calculateVariance(totalScores);
		
		    // Cronbach's Alpha formula
		    const alpha = (k / (k - 1)) * (1 - (sumItemVariances / totalVariance));
		    return Math.max(0, Math.min(1, alpha));
		  }
		
		  private calculateSplitHalfReliability(itemResponses: number[][]): number {
		    const k = itemResponses.length;
		    if (k < 2) return 0;
		
		    // Split items into two halves
		    const half1 = itemResponses.slice(0, Math.floor(k / 2));
		    const half2 = itemResponses.slice(Math.floor(k / 2));
		
		    // Calculate total scores for each half
		    const scores1 = this.calculateTotalScores(half1);
		    const scores2 = this.calculateTotalScores(half2);
		
		    // Calculate correlation between halves
		    const r = this.calculateCorrelation(scores1, scores2);
		
		    // Apply Spearman-Brown correction
		    return (2 * r) / (1 + r);
		  }
		
		  private calculateTotalScores(itemResponses: number[][]): number[] {
		    const n = itemResponses[0].length;
		    const totalScores: number[] = [];
		
		    for (let i = 0; i < n; i++) {
		      const score = itemResponses.reduce((sum, item) => sum + item[i], 0);
		      totalScores.push(score);
		    }
		
		    return totalScores;
		  }
		
		  private calculateAlphaIfItemDeleted(itemResponses: number[], totalScores: number[]): number {
		    // This would require recalculating Cronbach's alpha without this item
		    // Simplified approximation for now
		    const itemTotalCorrelation = this.calculateItemTotalCorrelation(itemResponses, totalScores);
		    return Math.max(0, 0.8 - (0.2 * itemTotalCorrelation)); // Rough estimate
		  }
		
		  private analyzeResponseOptions(responses: number[]): Record<string, any> {
		    const distribution = this.createResponseDistribution(responses);
		    const total = responses.length;
		    
		    const analysis: Record<string, any> = {};
		    
		    Object.entries(distribution).forEach(([option, frequency]) => {
		      analysis[option] = {
		        frequency,
		        proportion: frequency / total,
		        attractiveness: frequency / total, // Proportion selecting this option
		        discrimination: 0.5, // Would need more complex calculation
		      };
		    });
		
		    return analysis;
		  }
		
		  private generateItemRecommendations(
		    difficulty: number,
		    discrimination: number,
		    optionAnalysis: Record<string, any>,
		    data: RawResponseData
		  ): ItemRecommendation[] {
		    const recommendations: ItemRecommendation[] = [];
		
		    // Check difficulty
		    if (difficulty < 0.2) {
		      recommendations.push({
		        type: 'reword',
		        priority: 'medium',
		        reason: 'Item is too difficult (low endorsement)',
		        suggestedAction: 'Consider rewording to be more accessible or balanced',
		        statisticalEvidence: { difficulty, threshold: 0.2 },
		      });
		    } else if (difficulty > 0.8) {
		      recommendations.push({
		        type: 'reword',
		        priority: 'medium',
		        reason: 'Item is too easy (high endorsement)',
		        suggestedAction: 'Consider rewording to increase discrimination',
		        statisticalEvidence: { difficulty, threshold: 0.8 },
		      });
		    }
		
		    // Check discrimination
		    if (discrimination < 0.2) {
		      recommendations.push({
		        type: 'remove',
		        priority: 'high',
		        reason: 'Item has poor discrimination',
		        suggestedAction: 'Consider removing or substantially rewriting this item',
		        statisticalEvidence: { discrimination, threshold: 0.2 },
		      });
		    } else if (discrimination < 0.3) {
		      recommendations.push({
		        type: 'reword',
		        priority: 'medium',
		        reason: 'Item has low discrimination',
		        suggestedAction: 'Consider rewording to improve discrimination',
		        statisticalEvidence: { discrimination, threshold: 0.3 },
		      });
		    }
		
		    // Check sample size
		    if (data.responses.length < 50) {
		      recommendations.push({
		        type: 'manual_review',
		        priority: 'low',
		        reason: 'Small sample size affects reliability of statistics',
		        suggestedAction: 'Collect more data before making item decisions',
		        statisticalEvidence: { sampleSize: data.responses.length, minimumRecommended: 50 },
		      });
		    }
		
		    return recommendations;
		  }
		
		  private estimateReliability(responses: number[]): number {
		    // Simplified reliability estimate based on response variance
		    const variance = this.calculateVariance(responses);
		    const maxVariance = Math.pow(6, 2) / 4; // For 7-point scale (6 = range)
		    return Math.min(1, variance / maxVariance);
		  }
		
		  private calculatePercentileRanks(responses: number[]): Record<string, number> {
		    const sorted = [...responses].sort((a, b) => a - b);
		    const ranks: Record<string, number> = {};
		
		    for (let i = 1; i <= 7; i++) {
		      const count = sorted.filter(r => r <= i).length;
		      ranks[i.toString()] = (count / sorted.length) * 100;
		    }
		
		    return ranks;
		  }
		
		  private calculateZScores(responses: number[], mean: number, sd: number): Record<string, number> {
		    const zScores: Record<string, number> = {};
		    
		    for (let i = 1; i <= 7; i++) {
		      zScores[i.toString()] = (i - mean) / sd;
		    }
		
		    return zScores;
		  }
		
		  private calculateStandardizedScores(zScores: Record<string, number>): Record<string, number> {
		    const standardized: Record<string, number> = {};
		    
		    Object.entries(zScores).forEach(([key, zScore]) => {
		      standardized[key] = Math.round(50 + (zScore * 10)); // Standard score with M=50, SD=10
		    });
		
		    return standardized;
		  }
		
		  private calculateReliabilityCI(alpha: number, df: number): [number, number] {
		    // Simplified CI calculation - would need more sophisticated method for production
		    const se = Math.sqrt((2 * alpha * (1 - alpha)) / (df + 1));
		    const margin = 1.96 * se; // 95% CI
		    
		    return [
		      Math.max(0, alpha - margin),
		      Math.min(1, alpha + margin)
		    ];
		  }
		
		  private zScoreToPercentile(zScore: number): number {
		    // Approximate conversion using standard normal distribution
		    // This is a simplified version - would use proper statistical tables in production
		    const t = 1 / (1 + 0.2316419 * Math.abs(zScore));
		    const d = 0.3989423 * Math.exp(-zScore * zScore / 2);
		    let prob = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
		    
		    if (zScore > 0) prob = 1 - prob;
		    
		    return Math.round(prob * 100);
		  }
		
		  private percentileToStanine(percentile: number): number {
		    if (percentile <= 4) return 1;
		    if (percentile <= 11) return 2;
		    if (percentile <= 23) return 3;
		    if (percentile <= 40) return 4;
		    if (percentile <= 60) return 5;
		    if (percentile <= 77) return 6;
		    if (percentile <= 89) return 7;
		    if (percentile <= 96) return 8;
		    return 9;
		  }
		
		  private getQualitativeDescription(percentile: number): string {
		    if (percentile >= 98) return 'Extremely High';
		    if (percentile >= 91) return 'Very High';
		    if (percentile >= 75) return 'High';
		    if (percentile >= 60) return 'Above Average';
		    if (percentile >= 40) return 'Average';
		    if (percentile >= 25) return 'Below Average';
		    if (percentile >= 9) return 'Low';
		    if (percentile >= 2) return 'Very Low';
		    return 'Extremely Low';
		  }
		
		  private getMostCommonResponse(responses: number[]): number {
		    const distribution = this.createResponseDistribution(responses);
		    let maxCount = 0;
		    let mostCommon = responses[0];
		    
		    Object.entries(distribution).forEach(([response, count]) => {
		      if (count > maxCount) {
		        maxCount = count;
		        mostCommon = parseInt(response);
		      }
		    });
		
		    return mostCommon;
		  }
		
		  private aggregateByCategory(): any[] {
		    const categoryData: Record<string, any> = {};
		    
		    this.normingDatabase.forEach(stats => {
		      const category = stats.category;
		      if (!categoryData[category]) {
		        categoryData[category] = {
		          category,
		          scores: [],
		          sampleSizes: [],
		          reliabilities: [],
		        };
		      }
		      
		      categoryData[category].scores.push(stats.statistics.mean || 0);
		      categoryData[category].sampleSizes.push(stats.sampleSize);
		      categoryData[category].reliabilities.push(stats.qualityMetrics.reliabilityCoefficient || 0);
		    });
		
		    return Object.values(categoryData).map(cat => ({
		      category: cat.category,
		      averageScores: cat.scores,
		      reliability: this.calculateMean(cat.reliabilities),
		      sampleSize: cat.sampleSizes.reduce((sum: number, size: number) => sum + size, 0),
		      standardError: this.calculateStandardDeviation(cat.scores) / Math.sqrt(cat.scores.length),
		    }));
		  }
		
		  private calculateQualityIndicators(): any {
		    let totalSessions = 0;
		    let straightLineCount = 0;
		    let excessiveSpeedCount = 0;
		    let inconsistentCount = 0;
		    let technicalIssueCount = 0;
		
		    this.normingDatabase.forEach(stats => {
		      totalSessions += stats.sampleSize;
		      const anomalyCount = Math.floor(stats.sampleSize * stats.qualityMetrics.anomalyRate);
		      
		      // Distribute anomalies across types (this is simplified)
		      straightLineCount += Math.floor(anomalyCount * 0.4);
		      excessiveSpeedCount += Math.floor(anomalyCount * 0.3);
		      inconsistentCount += Math.floor(anomalyCount * 0.2);
		      technicalIssueCount += Math.floor(anomalyCount * 0.1);
		    });
		
		    return {
		      straightLineResponding: totalSessions > 0 ? straightLineCount / totalSessions : 0,
		      excessiveSpeed: totalSessions > 0 ? excessiveSpeedCount / totalSessions : 0,
		      inconsistentPatterns: totalSessions > 0 ? inconsistentCount / totalSessions : 0,
		      technicalIssues: totalSessions > 0 ? technicalIssueCount / totalSessions : 0,
		    };
		  }
		
		  private generateTrendsData(startDate: string, endDate: string): any[] {
		    // Generate sample trends data - would come from time-series database in production
		    const trends = [];
		    const start = new Date(startDate);
		    const end = new Date(endDate);
		    const daysDiff = Math.ceil((end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24));
		
		    for (let i = 0; i < Math.min(daysDiff, 30); i++) {
		      const date = new Date(start);
		      date.setDate(date.getDate() + i);
		      
		      trends.push({
		        date: date.toISOString().split('T')[0],
		        completionRate: 0.85 + (Math.random() - 0.5) * 0.1, // Simulate data
		        averageQuality: 0.78 + (Math.random() - 0.5) * 0.1,
		        anomalyRate: 0.05 + (Math.random() - 0.5) * 0.02,
		      });
		    }
		
		    return trends;
		  }
		
		  private calculateOverviewStats(): any {
		    let totalSessions = 0;
		    let totalCompleted = 0;
		    let totalTimeSpent = 0;
		    let totalAnomalies = 0;
		    let qualitySum = 0;
		    let count = 0;
		
		    this.normingDatabase.forEach(stats => {
		      totalSessions += stats.sampleSize;
		      totalCompleted += stats.sampleSize; // Assuming all in DB are completed
		      totalTimeSpent += stats.qualityMetrics.averageResponseTime * stats.sampleSize;
		      totalAnomalies += Math.floor(stats.sampleSize * stats.qualityMetrics.anomalyRate);
		      qualitySum += stats.qualityMetrics.consistencyScore;
		      count++;
		    });
		
		    return {
		      totalSessions,
		      completedAssessments: totalCompleted,
		      averageCompletionTime: totalSessions > 0 ? totalTimeSpent / totalSessions : 0,
		      completionRate: totalSessions > 0 ? totalCompleted / totalSessions : 0,
		      anomalyRate: totalSessions > 0 ? totalAnomalies / totalSessions : 0,
		      dataQualityScore: count > 0 ? qualitySum / count : 0,
		    };
		  }
		}
		
		export const statisticalNorming = new StatisticalNormingEngine();
		export default statisticalNorming;]]></file>
	<file path='utils/twinWordplay.ts'><![CDATA[
		// Twinship Wordplay Dictionary & Utilities
		// Creative wordplay by replacing "in/en" sounds with "Twin"
		
		export const TWIN_WORDPLAY: Record<string, string> = {
		  // Connection & Communication
		  twinvite: 'invite', // Send a Twinvite!
		  twinvitation: 'invitation', // Twinvitation sent!
		  twinteraction: 'interaction', // New Twinteraction!
		  twinterface: 'interface', // Twinship Twinterface
		  twinbox: 'inbox', // Check your Twinbox
		  twinsync: 'sync', // Twinsync in progress
		  twincognito: 'incognito', // Twincognito mode
		  twincoming: 'incoming', // Twincoming connection!
		  
		  // Emotions & Experience
		  twinsanity: 'insanity', // Pure Twinsanity!
		  twincredible: 'incredible', // This is Twincredible!
		  twintense: 'intense', // Twintense connection
		  twinsational: 'sensational', // Absolutely Twinsational!
		  twinspiring: 'inspiring', // So Twinspiring!
		  twinstant: 'instant', // Twinstant connection
		  twintimate: 'intimate', // Twintimate bond
		  
		  // Discovery & Knowledge
		  twinterests: 'interests', // Your Twinterests
		  twinformation: 'information', // Twinformation hub
		  twinsight: 'insight', // Powerful Twinsight
		  twintuition: 'intuition', // Trust your Twintuition
		  twintellect: 'intellect', // Sharp Twintellect
		  twinvestigation: 'investigation', // Deep Twinvestigation
		  
		  // Actions & Decisions
		  twinvention: 'invention', // Creative Twinvention
		  twinvestment: 'investment', // Emotional Twinvestment
		  twintervention: 'intervention', // Cosmic Twintervention
		  twindecision: 'decision', // Make a Twindecision
		  twindeed: 'indeed', // Twindeed it is!
		  twindicator: 'indicator', // Twindicator shows...
		  
		  // States & Qualities
		  twindefensible: 'indefensible', // Twindefensible bond
		  twindependent: 'independent', // Twindependent spirits
		  twindeprived: 'deprived', // Never be Twindeprived
		  twindividual: 'individual', // Each Twindividual
		  twincidence: 'incidence', // High Twincidence rate
		  
		  // Places & Concepts
		  twindustry: 'industry', // Twinship Twindustry
		  twindex: 'index', // Connection Twindex
		  twinfinite: 'infinite', // Twinfinite possibilities
		  twinside: 'inside', // Look Twinside yourself
		  twinland: 'inland', // Welcome to Twinland
		  
		  // Time & Events
		  twinception: 'inception', // The Twinception moment
		  twinterception: 'interception', // Twinterception of thoughts
		  twinstance: 'instance', // In this Twinstance
		  twinterval: 'interval', // Short Twinterval
		  
		  // Feelings & Reactions
		  twinjoy: 'enjoy', // Twinjoy the experience
		  twinchanted: 'enchanted', // Completely Twinchanted
		  twinraptured: 'enraptured', // Twinraptured by connection
		  twinergized: 'energized', // Feeling Twinergized
		  twinlightened: 'enlightened', // Twinlightened soul
		  
		  // Communication & Expression
		  twinquiry: 'inquiry', // Send a Twinquiry
		  twinform: 'inform', // Let me Twinform you
		  twintroduce: 'introduce', // Twintroduce yourself
		  twingage: 'engage', // Ready to Twingage
		  twincourage: 'encourage', // Twincourage each other
		}
		
		// Utility functions for dynamic Twin wordplay
		export class TwinWordplay {
		  // Get a Twin version of a word if it exists
		  static getTwinWord(word: string): string {
		    const lowerWord = word.toLowerCase()
		    return TWIN_WORDPLAY[lowerWord] ? 
		      this.capitalize(lowerWord) : word
		  }
		
		  // Convert a phrase to use Twin wordplay where possible
		  static twinify(phrase: string): string {
		    return phrase.split(' ').map(word => {
		      const cleanWord = word.replace(/[^\w]/g, '').toLowerCase()
		      const twinVersion = Object.keys(TWIN_WORDPLAY).find(
		        twinWord => TWIN_WORDPLAY[twinWord] === cleanWord
		      )
		      
		      if (twinVersion) {
		        // Preserve original capitalization and punctuation
		        const punctuation = word.replace(/\w/g, '')
		        const isCapitalized = word[0] === word[0].toUpperCase()
		        return (isCapitalized ? this.capitalize(twinVersion) : twinVersion) + punctuation
		      }
		      return word
		    }).join(' ')
		  }
		
		  // Get random Twin wordplay terms
		  static getRandomTwinWords(count: number = 3): string[] {
		    const words = Object.keys(TWIN_WORDPLAY)
		    const shuffled = [...words].sort(() => 0.5 - Math.random())
		    return shuffled.slice(0, count).map(word => this.capitalize(word))
		  }
		
		  // Generate fun Twin messages
		  static generateTwinMessage(type: 'connection' | 'synchronicity' | 'welcome' | 'encouragement'): string {
		    switch (type) {
		      case 'connection':
		        return [
		          "Send them a Twinvitation to join your cosmic journey!",
		          "This connection looks Twincredible!",
		          "Ready to Twingage with your twin flame?",
		          "Your Twintuition is guiding you to something special!",
		          "Time for some Twinsational bonding!"
		        ][Math.floor(Math.random() * 5)]
		      
		      case 'synchronicity':
		        return [
		          "Twincredible synchronicity detected!",
		          "Your twin bond is showing Twinsational alignment!",
		          "This Twincidence is off the charts!",
		          "Pure Twinsanity - you're totally in sync!",
		          "The cosmic Twinervention is strong with this one!"
		        ][Math.floor(Math.random() * 5)]
		      
		      case 'welcome':
		        return [
		          "Welcome to Twinship - where Twincredible connections begin!",
		          "Get ready for a Twinsational experience!",
		          "Your journey into Twinfinite possibilities starts here!",
		          "Time to discover your Twinspiring connections!",
		          "Welcome to the most Twincredible app you've ever experienced!"
		        ][Math.floor(Math.random() * 5)]
		      
		      case 'encouragement':
		        return [
		          "Trust your Twintuition - you've got this!",
		          "Stay Twinspired and keep connecting!",
		          "Your Twintellect is your superpower!",
		          "Keep building those Twincredible bonds!",
		          "You're doing Twinderfully - keep it up!"
		        ][Math.floor(Math.random() * 5)]
		      
		      default:
		        return "Experience the Twinship magic!"
		    }
		  }
		
		  // Get contextual Twin phrases for UI elements
		  static getUILabel(element: string): string {
		    const labels: Record<string, string> = {
		      // Navigation & Pages
		      'connections': 'Twin Connections Hub',
		      'inbox': 'Twinbox',
		      'profile': 'Your Twin Profile',
		      'settings': 'Twinship Settings',
		      'interests': 'Your Twinterests',
		      'messages': 'Twin Messages',
		      
		      // Actions
		      'invite': 'Send Twinvitation',
		      'connect': 'Twingage Now',
		      'sync': 'Twinsync Connection',
		      'join': 'Join the Twinship',
		      'explore': 'Explore Twinfinite Possibilities',
		      
		      // Status & States
		      'online': 'Twinactive',
		      'connected': 'Twinsynced',
		      'pending': 'Twincoming Connection',
		      'strong': 'Twintense Bond',
		      'new': 'Fresh Twin Energy',
		      
		      // Emotions & Reactions
		      'amazing': 'Twincredible',
		      'incredible': 'Twinsational',
		      'intense': 'Twintense',
		      'inspiring': 'Twinspiring',
		      'insightful': 'Full of Twinsight',
		    }
		    
		    return labels[element.toLowerCase()] || element
		  }
		
		  private static capitalize(word: string): string {
		    return word.charAt(0).toUpperCase() + word.slice(1)
		  }
		}
		
		// Pre-generated Twin phrases for common use cases
		export const TWIN_PHRASES = {
		  greetings: [
		    "Welcome to your Twinship experience!",
		    "Ready for something Twincredible?",
		    "Your Twintuition brought you here!",
		    "Time to explore Twinfinite connections!"
		  ],
		  
		  connectionInvites: [
		    "Send {name} a Twinvitation!",
		    "Twingage with {name}!",
		    "Start a Twincredible journey with {name}!",
		    "Your Twintuition says {name} is special!"
		  ],
		  
		  synchronicityAlerts: [
		    "Twincredible synchronicity with your twin!",
		    "Your cosmic Twinection just got stronger!",
		    "Twinsational alignment detected!",
		    "The Twinervention is real!"
		  ],
		  
		  encouragement: [
		    "Trust your Twintuition!",
		    "You're doing Twinderfully!",
		    "This is Twinsational progress!",
		    "Your Twintellect is showing!"
		  ]
		}
		
		// Export the main utility instance
		export const twinWordplay = new TwinWordplay()]]></file>
	<file path='utils/zodiac.ts'><![CDATA[
		import { create } from "zustand";
		
		// zodiac helper
		export function getZodiacSign(month: number, day: number): string {
		  if ((month == 3 && day >= 21) || (month == 4 && day <= 19)) return "Aries";
		  if ((month == 4 && day >= 20) || (month == 5 && day <= 20)) return "Taurus";
		  if ((month == 5 && day >= 21) || (month == 6 && day <= 20)) return "Gemini";
		  if ((month == 6 && day >= 21) || (month == 7 && day <= 22)) return "Cancer";
		  if ((month == 7 && day >= 23) || (month == 8 && day <= 22)) return "Leo";
		  if ((month == 8 && day >= 23) || (month == 9 && day <= 22)) return "Virgo";
		  if ((month == 9 && day >= 23) || (month == 10 && day <= 22)) return "Libra";
		  if ((month == 10 && day >= 23) || (month == 11 && day <= 21)) return "Scorpio";
		  if ((month == 11 && day >= 22) || (month == 12 && day <= 21)) return "Sagittarius";
		  if ((month == 12 && day >= 22) || (month == 1 && day <= 19)) return "Capricorn";
		  if ((month == 1 && day >= 20) || (month == 2 && day <= 18)) return "Aquarius";
		  if ((month == 2 && day >= 19) || (month == 3 && day <= 20)) return "Pisces";
		  return "Unknown";
		}
		
		interface TwinProfile {
		  name: string;
		  birthday: Date;
		  zodiacSign: string;
		}
		
		interface TwinState {
		  userProfile?: TwinProfile;
		  setUserProfile: (profile: { name: string; birthday: Date }) => void;
		  clearProfile: () => void;
		}
		
		export const useTwinStore = create<TwinState>((set) => ({
		  userProfile: undefined,
		
		  setUserProfile: (profile) => {
		    const month = profile.birthday.getMonth() + 1; // JS months are 0-based
		    const day = profile.birthday.getDate();
		    const zodiacSign = getZodiacSign(month, day);
		
		    set({
		      userProfile: {
		        ...profile,
		        zodiacSign,
		      },
		    });
		  },
		
		  clearProfile: () => set({ userProfile: undefined }),
		}));]]></file>
</files>
